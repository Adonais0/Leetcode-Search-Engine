Is this Algorithm optimal or what? Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.   Medium Linked List Math [c++] Sharing my 11-line c++ solution, can someone make it even more concise? Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.   Medium Linked List Math Clear python code, straight forward Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.   Medium Linked List Math My accepted Java solution Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.   Medium Linked List Math Python concise solution. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.   Medium Linked List Math 11-line simple Java solution, O(n) with explanation Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.      Medium Hash Table Two Pointers String C++ code in 9 lines. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.      Medium Hash Table Two Pointers String Share my Java solution using HashSet Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.      Medium Hash Table Two Pointers String A Python solution - 85ms - O(n) Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.      Medium Hash Table Two Pointers String Shortest O(n) DP solution with explanations Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.      Medium Hash Table Two Pointers String Share my O(log(min(m,n)) solution with explanation Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5   Hard Array Binary Search Divide and Conquer Very concise O(log(min(M,N))) iterative solution with detailed explanation Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5   Hard Array Binary Search Divide and Conquer Share my simple O(log(m+n)) solution for your reference Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5   Hard Array Binary Search Divide and Conquer Concise JAVA solution based on Binary Search Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5   Hard Array Binary Search Divide and Conquer Share my iterative solution with O(log(min(n, m))) Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5   Hard Array Binary Search Divide and Conquer Very simple clean java solution Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"   Medium String Dynamic Programming Simple C++ solution (8ms, 13 lines) Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"   Medium String Dynamic Programming Share my Java solution using dynamic programming Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"   Medium String Dynamic Programming (AC) relatively short and very clear Java solution Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"   Medium String Dynamic Programming Python easy to understand solution with comments (from middle to two ends). Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"   Medium String Dynamic Programming Easy to understand Java solution ZigZag Conversion The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I  Medium String If you are confused with zigzag pattern,come and see! ZigZag Conversion The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I  Medium String Python O(n) Solution in 96ms (99.43%) ZigZag Conversion The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I  Medium String Share simple C++ solution ZigZag Conversion The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I  Medium String JAVA solution--easy and clear ( interesting approach ) ZigZag Conversion The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I  Medium String My accepted 15 lines of code for Java Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  Easy Math Very Short (7 lines) and Elegant Solution Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  Easy Math Golfing in Python Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  Easy Math Shortest code possible in c++ Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  Easy Math 8 ms simple C++ solution which checks overflow Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  Easy Math Such a shitty problem String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.  Medium Math String My simple solution String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.  Medium Math String Java Solution with 4 steps explanations String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.  Medium Math String JAVA-------Easy  Version To Understand!!!!!!!!!! String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.  Medium Math String 8ms C++ solution, easy to understand String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.  Medium Math String Easy DP Java Solution with detailed Explanation Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false   Hard String Dynamic Programming Backtracking My concise recursive and DP solutions with full explanation in C++ Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false   Hard String Dynamic Programming Backtracking In the given examples, the last one isMatch("aab", "c*a*b") \u2192 true; don't understand why it is true? Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false   Hard String Dynamic Programming Backtracking 9-lines 16ms C++ DP Solutions with Explanations Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false   Hard String Dynamic Programming Backtracking My DP approach in Python with comments and unittest Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false   Hard String Dynamic Programming Backtracking Yet another way to see what happens in the O(n) algorithm Container With Most Water Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.    The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.    Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49  Medium Array Two Pointers Simple and fast C++/C with explanation Container With Most Water Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.    The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.    Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49  Medium Array Two Pointers Simple and clear proof/explanation Container With Most Water Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.    The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.    Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49  Medium Array Two Pointers Easy Concise Java O(N) Solution with Proof and Explanation Container With Most Water Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.    The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.    Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49  Medium Array Two Pointers Very simple O(n) solution Container With Most Water Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.    The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.    Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49  Medium Array Two Pointers Simple Solution Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Medium Math String My java solution easy to understand Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Medium Math String Two lines can do the job Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Medium Math String Share My Python Solution 96ms Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Medium Math String Simple JAVA solution Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Medium Math String My solution for this question but I don't know is there any easier way? Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Easy Math String Clean O(n) c++ solution Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Easy Math String My Straightforward Python Solution Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Easy Math String I strongly suggest leetcode explains the conversion rule clearer. Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Easy Math String 7ms solution in Java. easy to understand Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.  Easy Math String Java code with 13 lines Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.  Easy String What does Longest Common Prefix mean ? Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.  Easy String Sorted the array, Java solution, 2 ms Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.  Easy String Simple Python solution Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.  Easy String Short Python Solution Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.  Easy String Concise O(N^2) Java solution 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]   Medium Array Two Pointers Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]   Medium Array Two Pointers Python easy to understand solution (O(n*n) time). 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]   Medium Array Two Pointers Easiest Java Solution 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]   Medium Array Two Pointers Share my simple java solution 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]   Medium Array Two Pointers Java solution with O(n2) for reference 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).   Medium Array Two Pointers A n^2 Solution, Can we do better ? 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).   Medium Array Two Pointers C++ solution O(n^2) using sort 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).   Medium Array Two Pointers Python O(N^2) solution 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).   Medium Array Two Pointers 12 lines concise and easy understand c++ solultion 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).   Medium Array Two Pointers 7ms java code win over 100% 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]   Medium Array Hash Table Two Pointers Python 140ms beats 100%, and works for N-sum (N>=2) 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]   Medium Array Hash Table Two Pointers My 16ms c++ code 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]   Medium Array Hash Table Two Pointers Clean accepted java O(n^3) solution based on 3sum 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]   Medium Array Hash Table Two Pointers My solution generalized for kSums in JAVA 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]   Medium Array Hash Table Two Pointers Simple Java solution in one pass Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?  Medium Linked List Two Pointers My short C++ solution Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?  Medium Linked List Two Pointers 3 short Python solutions Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?  Medium Linked List Two Pointers My one pass solution Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?  Medium Linked List Two Pointers C++ solution, easy to understand with explanations. Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?  Medium Linked List Two Pointers Short java solution Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true   Easy String Stack Simple Python solution with stack Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true   Easy String Stack My easy to understand Java Solution with one stack Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true   Easy String Stack [Python] is this a cheating method? accepted with 40ms, easy to understand, but Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true   Easy String Stack 2ms C++ sloution Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true   Easy String Stack Easy to understand Java backtracking solution Generate Parentheses  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]  Medium String Backtracking Concise recursive C++ solution Generate Parentheses  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]  Medium String Backtracking An iterative method. Generate Parentheses  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]  Medium String Backtracking 4-7 lines Python Generate Parentheses  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]  Medium String Backtracking Simple Python DFS solution with explanation Generate Parentheses  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]  Medium String Backtracking A java solution based on Priority Queue Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6   Hard Linked List Divide and Conquer Heap My simple java Solution use recursion Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6   Hard Linked List Divide and Conquer Heap Sharing my straightforward C++ solution without data structure other than vector Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6   Hard Linked List Divide and Conquer Heap Difference between Priority-Queue and Heap, and C++ implementation Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6   Hard Linked List Divide and Conquer Heap 10-line python solution with priority queue Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6   Hard Linked List Divide and Conquer Heap My accepted java code. used recursion. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note:  Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed.   Medium Linked List My simple JAVA solution for share Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note:  Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed.   Medium Linked List 7-8 lines C++ / Python / Ruby Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note:  Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed.   Medium Linked List Java simple recursive solution Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note:  Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed.   Medium Linked List Simple implementation with C++ Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note:  Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed.   Medium Linked List Short but recursive Java code with comments Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.   Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note:  Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed.   Hard Linked List Share my Java Solution with comments in line Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.   Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note:  Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed.   Hard Linked List Non-recursive Java solution and idea Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.   Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note:  Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed.   Hard Linked List 20-line iterative C++ solution Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.   Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note:  Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed.   Hard Linked List Succinct iterative Python, O(n) time O(1) space Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.   Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note:  Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed.   Hard Linked List My Solution : Time O(n), Space O(1) Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }  Easy Array Two Pointers Share my clean C++ code Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }  Easy Array Two Pointers 5 lines C++/Java, nicer loops Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }  Easy Array Two Pointers Simple Python solution - O(n) Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }  Easy Array Two Pointers 5 lines Java solution Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }  Easy Array Two Pointers Elegant Java solution Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().  Easy Two Pointers String Share my accepted java solution Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().  Easy Two Pointers String C++ Brute-Force and KMP Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().  Easy Two Pointers String My answer by Python Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().  Easy Two Pointers String A very clean solution, brute-force Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().  Easy Two Pointers String Detailed Explained 8ms C++ solution Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.   Medium Math Binary Search Clean Java solution with some comment. Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.   Medium Math Binary Search Clear python code Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.   Medium Math Binary Search Simple O((log N) ^ 2) C++ solution Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.   Medium Math Binary Search No Use of Long Java Solution Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.   Medium Math Binary Search Easy Two-Map Solution (C++/Java) Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodstudentgoodword",   words = ["word","student"] Output: []   Hard Hash Table Two Pointers String An O(N) solution with detailed explanation Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodstudentgoodword",   words = ["word","student"] Output: []   Hard Hash Table Two Pointers String Accepted Java solution 12ms with explanation Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodstudentgoodword",   words = ["word","student"] Output: []   Hard Hash Table Two Pointers String Simple Java Solution with Two Pointers and Map Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodstudentgoodword",   words = ["word","student"] Output: []   Hard Hash Table Two Pointers String Why does the second example have words with different length? Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodstudentgoodword",   words = ["word","student"] Output: []   Hard Hash Table Two Pointers String Share my O(n) time solution Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Medium Array C++ from Wikipedia Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Medium Array Sharing my clean and easy-understand java code with explanation Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Medium Array Easiest JAVA Solution Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Medium Array 1, 4, 11 lines C++ Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Medium Array My O(n) solution using a stack Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"   Hard String Dynamic Programming My DP, O(n) solution without using stack Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"   Hard String Dynamic Programming Simple JAVA solution, O(n) time, one stack Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"   Hard String Dynamic Programming My simple 8ms C++ code Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"   Hard String Dynamic Programming My solution using one stack in one pass Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"   Hard String Dynamic Programming Concise O(log N) Binary search solution Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Medium Array Binary Search Clever idea making it simple Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Medium Array Binary Search Revised Binary Search Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Medium Array Binary Search Java AC Solution using once binary search Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Medium Array Binary Search Python binary search solution - O(logn) - 48ms Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Medium Array Binary Search Clean iterative solution with two binary searches (with explanation) Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Medium Array Binary Search A very simple Java solution, with only one binary search algorithm Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Medium Array Binary Search 9-11 lines O(log n) Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Medium Array Binary Search Easy java O(logn) solution Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Medium Array Binary Search Simple and strict O(logn) solution in Java using recursion Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Medium Array Binary Search Short+Simple Java using Strings Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.   Medium Hash Table Shared my concise Java code Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.   Medium Hash Table My short solution by C++. O(n2) Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.   Medium Hash Table Sharing my easy-understand java solution using set Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.   Medium Hash Table A readable Python solution Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.   Medium Hash Table Please change the misleading description Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"  Easy String Examples of nth sequence Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"  Easy String Show an Answer in Java Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"  Easy String 4-5 lines Python solutions Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"  Easy String C++ solution easy-understand Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"  Easy String A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]   Medium Array Backtracking Accepted 16ms c++ solution use backtracking, easy understand. Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]   Medium Array Backtracking Python dfs solution. Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]   Medium Array Backtracking Java solution using recursive Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]   Medium Array Backtracking Iterative Java DP solution Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]   Medium Array Backtracking Java solution using dfs, easy understand Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]   Medium Array Backtracking Combination Sum I, II and III Java solution (see the similarities yourself) Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]   Medium Array Backtracking C++ backtracking solution with detailed explanation Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]   Medium Array Backtracking Beating 98%  Python solution using recursion with comments Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]   Medium Array Backtracking DP solution in Python Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]   Medium Array Backtracking My short c++ solution, O(1) space, and O(n) time First Missing Positive Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.  Hard Array Share my O(n) time, O(1) space solution First Missing Positive Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.  Hard Array O(1) space Java Solution First Missing Positive Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.  Hard Array Python O(1) space,  O(n) time solution with explanation First Missing Positive Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.  Hard Array A very nice solution (from Ants Aasma @stackoverflow) First Missing Positive Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.  Hard Array Sharing my simple c++ code: O(n) time, O(1) space Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Hard Array Two Pointers Stack Share my short solution. Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Hard Array Two Pointers Stack 7 lines C / C++ Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Hard Array Two Pointers Stack A stack based solution for reference, inspired by Histogram Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Hard Array Two Pointers Stack Sharing my Java code: O(n) time, O(1) space Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Hard Array Two Pointers Stack Easiest JAVA Solution with Graph Explanation Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.   Medium Math String Brief C++ solution using only strings and without reversal Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.   Medium Math String AC solution in Java with explanation Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.   Medium Math String One Easy solution with C++ Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.   Medium Math String Clear JAVA solution without reversal Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.   Medium Math String Linear runtime and constant space solution Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false   Hard String Dynamic Programming Backtracking Greedy My java DP solution using 2D table Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false   Hard String Dynamic Programming Backtracking Greedy Accepted C++ DP Solution with a Trick Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false   Hard String Dynamic Programming Backtracking Greedy Python DP solution Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false   Hard String Dynamic Programming Backtracking Greedy My three C++ solutions (iterative (16ms) & DP (180ms) & modified recursion (88ms)) Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false   Hard String Dynamic Programming Backtracking Greedy O(n), BFS solution Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.  Hard Array Greedy Concise O(n) one loop JAVA solution based on Greedy Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.  Hard Array Greedy Single loop simple java solution Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.  Hard Array Greedy 10-lines C++ (16ms) / Python BFS Solutions with Explanations Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.  Hard Array Greedy Sharing My AC Java Solution Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.  Hard Array Greedy A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning) Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]   Medium Backtracking My elegant recursive C++ solution with inline explanation Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]   Medium Backtracking My AC simple iterative java/python solution Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]   Medium Backtracking One-Liners in Python Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]   Medium Backtracking Simple Python solution (DFS). Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]   Medium Backtracking Really easy Java solution, much easier than the solutions with very high vote Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]   Medium Backtracking A simple C++ solution in only 20 lines Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]   Medium Backtracking Share my Java code with detailed explanantion Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]   Medium Backtracking 9-line python solution with 1 line to handle duplication, beat 99% of others :-) Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]   Medium Backtracking A non-recursive C++ implementation with O(1) space cost Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]   Medium Backtracking A common method to rotate the image Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]   Medium Array AC Java in place solution with explanation Easy to understand. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]   Medium Array Seven Short Solutions (1 to 7 lines) Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]   Medium Array 4ms few lines C++ code Rotate Image 90 degree for O(1) space Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]   Medium Array Clear Java solution Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]   Medium Array Share my short JAVA solution Group Anagrams Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.   Medium Hash Table String Java beat 100%!!! use prime number Group Anagrams Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.   Medium Hash Table String 10-lines 76ms Easy C++ Solution (Updated Function Signature) Group Anagrams Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.   Medium Hash Table String What does it mean "return all groups"? But the return result is vector<string>? How can we return all groups? Group Anagrams Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.   Medium Hash Table String O(M * N) algorithm using hash, without sort() Group Anagrams Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.   Medium Hash Table String Short and easy to understand solution Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]   Medium Math Binary Search 5 different choices when talk with interviewers Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]   Medium Math Binary Search Iterative Log(N) solution with Clear Explanation Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]   Medium Math Binary Search Shortest Python - Guaranteed Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]   Medium Math Binary Search O (logn) solution in Java Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]   Medium Math Binary Search Accepted 4ms c++ solution use backtracking and bitmask, easy understand. N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.   Hard Backtracking My easy understanding Java Solution N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.   Hard Backtracking Fast, short, and easy-to-understand python solution, 11 lines, 76ms N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.   Hard Backtracking The description should give a clear explanation of the problem of "n-queens" N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.   Hard Backtracking Comparably concise Java code N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.   Hard Backtracking Accepted Java Solution N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ]   Hard Backtracking Easiest Java Solution (1ms, 98.22%) N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ]   Hard Backtracking Share my Java code (beats 97.83% run times) N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ]   Hard Backtracking C++ solution - DFS - easy understanding N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ]   Hard Backtracking Python recursive dfs solution. N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.  Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [".Q..",  // Solution 1   "...Q",   "Q...",   "..Q."],   ["..Q.",  // Solution 2   "Q...",   "...Q",   ".Q.."] ]   Hard Backtracking DP solution & some thoughts Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Easy Array Divide and Conquer Dynamic Programming Accepted O(n) solution in java Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Easy Array Divide and Conquer Dynamic Programming A Python solution Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Easy Array Divide and Conquer Dynamic Programming Easy Python Way Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Easy Array Divide and Conquer Dynamic Programming Simplest and fastest O(n) C++ solution Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Easy Array Divide and Conquer Dynamic Programming Super Simple and Easy to Understand Solution Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Medium Array 1-liner in Python + Ruby Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Medium Array A concise C++ implementation based on Directions Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Medium Array 0ms Clear C++ Solution Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Medium Array Clean Java, readable, human friendly code Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Medium Array Linear and simple solution in C++ Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.   Medium Array Greedy Simplest O(N) solution with constant space Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.   Medium Array Greedy Java Solution easy to understand Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.   Medium Array Greedy 6 line java solution in O(n) Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.   Medium Array Greedy 1-6 lines, O(n) time, O(1) space Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.   Medium Array Greedy A simple Java solution Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Medium Array Sort 7 lines, easy, Python Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Medium Array Sort C++ 10 line solution. easing understanding Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Medium Array Sort Beat 98% Java. Sort start & end respectively. Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Medium Array Sort A clean java solution Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Medium Array Sort Short and straight-forward Java solution Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Hard Array Sort 7+ lines, 3 easy solutions Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Hard Array Sort Short java code Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Hard Array Sort Elegant C++ STL solution, using "equal_range" to find overlapped intervals. Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Hard Array Sort Easy and clean O(n) C++ solution Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Hard Array Sort 7-lines 4ms C++ Solution Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5   Easy String My simple solution in C++ Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5   Easy String A single line of Code in Java Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5   Easy String This problem is not fun at all. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5   Easy String One line Python solution Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5   Easy String 4-9 lines Python solutions Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]   Medium Array My Super Simple Solution. Can be used for both Spiral Matrix I and II Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]   Medium Array Simple C++ solution(with explaination) Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]   Medium Array Share my java solution Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]   Medium Array My AC solution with using direction variable Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]   Medium Array "Explain-like-I'm-five" Java Solution in O(n) Permutation Sequence The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"   Medium Math Backtracking An iterative solution for reference Permutation Sequence The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"   Medium Math Backtracking Most concise C++ solution, minimal memory required Permutation Sequence The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"   Medium Math Backtracking Share my Python solution with detailed explanation Permutation Sequence The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"   Medium Math Backtracking Sharing my straightforward C++ solution with explanation Permutation Sequence The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"   Medium Math Backtracking My clean C++ code, quite standard (find tail and reconnect the list) Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL  Medium Linked List Two Pointers Share my java solution with explanation Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL  Medium Linked List Two Pointers Anyone solve the problem without counting the length of List? Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL  Medium Linked List Two Pointers Clean Java Solution with Brief Explanation Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL  Medium Linked List Two Pointers I think the description of this problem is misleading. Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL  Medium Linked List Two Pointers 0ms, 5-lines DP Solution in C++ with Explanations Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28  Medium Array Dynamic Programming My AC solution using formula Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28  Medium Array Dynamic Programming Math solution, O(1) space Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28  Medium Array Dynamic Programming Java DP solution with complexity O(n*m) Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28  Medium Array Dynamic Programming Accpeted simple Python DP solution. Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28  Medium Array Dynamic Programming Short JAVA solution Unique Paths II A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right   Medium Array Dynamic Programming My C++ Dp solution , very simple! Unique Paths II A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right   Medium Array Dynamic Programming 4ms O(n) DP Solution in C++ with Explanations Unique Paths II A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right   Medium Array Dynamic Programming Java Solution using Dynamic Programming, O(1) space Unique Paths II A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right   Medium Array Dynamic Programming Easy Java solution, in-place, DP Unique Paths II A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right   Medium Array Dynamic Programming 10-lines 28ms O(n)-space DP solution in C++ with Explanations Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Medium Array Dynamic Programming My java solution using DP and no extra space Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Medium Array Dynamic Programming Simple python dp 70ms Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Medium Array Dynamic Programming DP Solution, Linear space Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Medium Array Dynamic Programming My 8 lines simple solution Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Medium Array Dynamic Programming The worst problem i have ever met in this oj Valid Number Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.  Hard Math String Clear Java solution with ifs Valid Number Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.  Hard Math String A simple solution in Python based on DFA Valid Number Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.  Hard Math String A simple solution in cpp Valid Number Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.  Hard Math String A clean design solution By using design pattern Valid Number Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.  Hard Math String My Simple Java Solution Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.   Easy Array Math Is it a simple code(C++)? Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.   Easy Array Math I cannot fully understand the meaning of question 'Plus One' Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.   Easy Array Math Simple java solution Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.   Easy Array Math Simple Python solution with explanation (Plus One) Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.   Easy Array Math Short code by c++ Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"  Easy Math String Short AC solution in Java with explanation Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"  Easy Math String Simple accepted java solution Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"  Easy Math String An accepted concise Python recursive solution 10 lines Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"  Easy Math String Very concise C++ solution without calculating longest string Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"  Easy Math String Share my concise c++ solution - less than 20 lines Text Justification Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]   Hard String Concise python solution, 10 lines. Text Justification Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]   Hard String Simple Java Solution Text Justification Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]   Hard String What does this question aim to teach? Text Justification Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]   Hard String Easy understanding solution Text Justification Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]   Hard String C++ 10-lines solution Simplify Path Given an absolute path for a file (Unix-style), simplify it.  For example, path = "/home/", => "/home" path = "/a/./b/../../c/", => "/c" path = "/a/../../b/../c//.//", => "/c" path = "/a//b////c/d//././/..", => "/a/b/c" In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases:  Did you consider the case where path = "/../"? 	In this case, you should return "/". Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/". 	In this case, you should ignore redundant slashes and return "/home/foo".   Medium String Stack Java 10-lines solution with stack Simplify Path Given an absolute path for a file (Unix-style), simplify it.  For example, path = "/home/", => "/home" path = "/a/./b/../../c/", => "/c" path = "/a/../../b/../c//.//", => "/c" path = "/a//b////c/d//././/..", => "/a/b/c" In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases:  Did you consider the case where path = "/../"? 	In this case, you should return "/". Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/". 	In this case, you should ignore redundant slashes and return "/home/foo".   Medium String Stack Can someone please explain what does simplify means in this context? Simplify Path Given an absolute path for a file (Unix-style), simplify it.  For example, path = "/home/", => "/home" path = "/a/./b/../../c/", => "/c" path = "/a/../../b/../c//.//", => "/c" path = "/a//b////c/d//././/..", => "/a/b/c" In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases:  Did you consider the case where path = "/../"? 	In this case, you should return "/". Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/". 	In this case, you should ignore redundant slashes and return "/home/foo".   Medium String Stack 9 lines of Python code Simplify Path Given an absolute path for a file (Unix-style), simplify it.  For example, path = "/home/", => "/home" path = "/a/./b/../../c/", => "/c" path = "/a/../../b/../c//.//", => "/c" path = "/a//b////c/d//././/..", => "/a/b/c" In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases:  Did you consider the case where path = "/../"? 	In this case, you should return "/". Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/". 	In this case, you should ignore redundant slashes and return "/home/foo".   Medium String Stack My O(n) AC code . just need to handle two special cases. Simplify Path Given an absolute path for a file (Unix-style), simplify it.  For example, path = "/home/", => "/home" path = "/a/./b/../../c/", => "/c" path = "/a/../../b/../c//.//", => "/c" path = "/a//b////c/d//././/..", => "/a/b/c" In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases:  Did you consider the case where path = "/../"? 	In this case, you should return "/". Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/". 	In this case, you should ignore redundant slashes and return "/home/foo".   Medium String Stack 20ms Detailed Explained C++ Solutions (O(n) Space) Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')   Hard String Dynamic Programming Java DP solution - O(nm) Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')   Hard String Dynamic Programming My O(mn) time and O(n) space solution using DP with explanation Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')   Hard String Dynamic Programming Good pdf on edit distance problem. May be helpful. Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')   Hard String Dynamic Programming Python solutions and intuition Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')   Hard String Dynamic Programming Any shorter O(1) space solution? Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?   Medium Array My AC java O(1) solution (easy to read) Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?   Medium Array My C++ O(1) yoooooo Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?   Medium Array My java O(1) solution (easy to understand) Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?   Medium Array 21 lines concise and easy understand C++ solution, O(1) space, three steps Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?   Medium Array Don't treat it as a 2D matrix, just treat it as a sorted list Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false  Medium Array Binary Search Binary search on an ordered matrix Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false  Medium Array Binary Search Java clear solution Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false  Medium Array Binary Search A Python binary search solution - O(logn) Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false  Medium Array Binary Search C++ 12ms, O(log(mn)), no library functions, treat matrix as an array Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false  Medium Array Binary Search Share my at most two-pass constant space 10-line solution Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?   Medium Array Two Pointers Sort Four different solutions Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?   Medium Array Two Pointers Sort AC Python in place one pass solution O(n) time O(1) space, no swap no count Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?   Medium Array Two Pointers Sort Sharing C++ solution with Good Explanation Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?   Medium Array Two Pointers Sort Java solution, both 2-pass and 1-pass Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?   Medium Array Two Pointers Sort Here is a 10-line template that can solve most 'substring' problems Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.   Hard Hash Table Two Pointers String 12 lines Python Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.   Hard Hash Table Two Pointers String Accepted O(n) solution Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.   Hard Hash Table Two Pointers String Java solution. using two pointers + HashMap Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.   Hard Hash Table Two Pointers String Can T have characters repeating ? Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.   Hard Hash Table Two Pointers String Short Iterative C++ Answer 8ms Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]   Medium Backtracking Backtracking Solution Java Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]   Medium Backtracking A short recursive Java solution based on C(n,k)=C(n-1,k-1)+C(n-1,k) Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]   Medium Backtracking 1-liner, 3-liner, 4-liner Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]   Medium Backtracking My shortest c++ solution,using dfs Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]   Medium Backtracking A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]  Medium Array Backtracking Bit Manipulation My solution using bit manipulation Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]  Medium Array Backtracking Bit Manipulation C++ Recursive/Iterative/Bit-Manipulation Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]  Medium Array Backtracking Bit Manipulation Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively). Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]  Medium Array Backtracking Bit Manipulation 3ms, easiest solution, no backtracking, no bit manipulation, no dfs, no bullshit Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]  Medium Array Backtracking Bit Manipulation Accepted very short Java solution. No additional space. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.   Medium Array Backtracking My Java solution Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.   Medium Array Backtracking Python dfs solution with comments. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.   Medium Array Backtracking My 19ms accepted C++ code Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.   Medium Array Backtracking Simple solution Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.   Medium Array Backtracking 3-6 easy lines, C++, Java, Python, Ruby Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }   Medium Array Two Pointers Share my O(N) time and O(1) solution when duplicates are allowed at most K times Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }   Medium Array Two Pointers Short and Simple Java solution (easy to understand) Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }   Medium Array Two Pointers My C++ solution. 16ms, 5 lines Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }   Medium Array Two Pointers O(N) Time and O(1) Java Solution When Allowed at Most K times of Duplicates Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }   Medium Array Two Pointers My 8ms C++ solution (o(logn) on average, o(n) worst case) Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?   Medium Array Binary Search C++ concise log(n) solution Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?   Medium Array Binary Search Neat JAVA solution using binary search Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?   Medium Array Binary Search Python easy to understand solution (with comments). Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?   Medium Array Binary Search When there are duplicates, the worst case is O(n). Could we do better? Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?   Medium Array Binary Search My accepted Java code Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5  Example 2: Input: 1->1->1->2->3 Output: 2->3   Medium Linked List My Recursive Java Solution Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5  Example 2: Input: 1->1->1->2->3 Output: 2->3   Medium Linked List Java simple and clean code with comment Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5  Example 2: Input: 1->1->1->2->3 Output: 2->3   Medium Linked List Simple and clear c++ recursive solution Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5  Example 2: Input: 1->1->1->2->3 Output: 2->3   Medium Linked List Python in-place solution with dummy head node. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5  Example 2: Input: 1->1->1->2->3 Output: 2->3   Medium Linked List 3 Line JAVA recursive solution Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2  Example 2: Input: 1->1->2->3->3 Output: 1->2->3   Easy Linked List My pretty solution. Java. Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2  Example 2: Input: 1->1->2->3->3 Output: 1->2->3   Easy Linked List Concise solution and memory freeing Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2  Example 2: Input: 1->1->2->3->3 Output: 1->2->3   Easy Linked List Simple iterative Python 6 lines, 60 ms Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2  Example 2: Input: 1->1->2->3->3 Output: 1->2->3   Easy Linked List Clean Java solution Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2  Example 2: Input: 1->1->2->3->3 Output: 1->2->3   Easy Linked List My concise C++ solution, AC 90 ms Largest Rectangle in Histogram Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10   Hard Array Stack O(n) stack based JAVA solution Largest Rectangle in Histogram Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10   Hard Array Stack 5ms O(n) Java solution explained (beats 96%) Largest Rectangle in Histogram Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10   Hard Array Stack AC Python clean solution using stack 76ms Largest Rectangle in Histogram Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10   Hard Array Stack Simple Divide and Conquer AC solution without Segment Tree Largest Rectangle in Histogram Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10   Hard Array Stack Share my DP solution Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6   Hard Array Hash Table Dynamic Programming Stack A O(n^2) solution based on Largest Rectangle in Histogram Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6   Hard Array Hash Table Dynamic Programming Stack My java solution based on Maximum Rectangle in Histogram with explanation Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6   Hard Array Hash Table Dynamic Programming Stack AC Python DP solutioin 120ms based on largest rectangle in histogram Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6   Hard Array Hash Table Dynamic Programming Stack Sharing my straightforward C++ solution with O(n^2) time with explanation Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6   Hard Array Hash Table Dynamic Programming Stack Very concise one pass solution Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5   Medium Linked List Two Pointers Concise java code with explanation, one pass Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5   Medium Linked List Two Pointers Python concise solution with dummy nodes. Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5   Medium Linked List Two Pointers 10 lines concise C++ Solution Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5   Medium Linked List Two Pointers My accepted solution. Any improvement? Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5   Medium Linked List Two Pointers Share my 4ms c++ recursive solution Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false  Hard String Dynamic Programming Accepted Java solution Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false  Hard String Dynamic Programming My C++ solutions (recursion with cache , DP, recursion with cache and pruning) with explanation (4ms) Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false  Hard String Dynamic Programming Simple iterative DP Java solution with explanation Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false  Hard String Dynamic Programming Can you partition a string at ANY index at ANY time in producing a scramble? Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false  Hard String Dynamic Programming This is my AC code, may help you Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]   Easy Array Two Pointers Beautiful Python Solution Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]   Easy Array Two Pointers 4ms C++ solution with single loop Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]   Easy Array Two Pointers 3 line Java Solution Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]   Easy Array Two Pointers 1 Line Solution Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]   Easy Array Two Pointers An accepted three line solution in JAVA Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1  Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0].   Medium Backtracking Share my solution Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1  Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0].   Medium Backtracking One-liner Python solution (with demo in comments) Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1  Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0].   Medium Backtracking What is the best solution for Gray Code problem? No extra space used and no recursion? Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1  Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0].   Medium Backtracking Backtracking C++ solution Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1  Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0].   Medium Backtracking C++ solution and explanation Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]   Medium Array Backtracking Simple iterative solution Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]   Medium Array Backtracking Simple python solution without extra space. Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]   Medium Array Backtracking Accepted 10ms c++ solution use backtracking, only 10 lines, easy understand. Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]   Medium Array Backtracking Very simple and fast java solution Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]   Medium Array Backtracking DP Solution (Java) for reference Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).  Medium String Dynamic Programming Java clean DP solution with explanation Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).  Medium String Dynamic Programming A concise dp solution Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).  Medium String Dynamic Programming Evolve from recursion to dp Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).  Medium String Dynamic Programming Java 2ms DP solution with detailed explanation and inline comments Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).  Medium String Dynamic Programming Simple Java solution with clear explanation Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL   Medium Linked List 12-lines 4ms C++ Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL   Medium Linked List Share my 14 lines C++ solution Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL   Medium Linked List Talk is cheap, show me the code (and DRAWING) Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL   Medium Linked List Python one pass iterative solution Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL   Medium Linked List My code in Java Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]   Medium String Backtracking WHO CAN BEAT THIS CODE ? Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]   Medium String Backtracking Very simple DFS solution Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]   Medium String Backtracking What is the definition of a valid IP address? Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]   Medium String Backtracking My concise AC java code Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]   Medium String Backtracking Iterative solution in Java - simple and readable Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Hash Table Stack Tree Three Methods to Solve (C++) Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Hash Table Stack Tree Python recursive and iterative solutions. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Hash Table Stack Tree C++ Ierative, Recursive and Morris Traversal Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Hash Table Stack Tree Concise JAVA solution based on Stack Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Hash Table Stack Tree A simple recursive solution Unique Binary Search Trees II Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Java Solution with DP Unique Binary Search Trees II Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Divide-and-conquer.  F(i) = G(i-1) * G(n-i) Unique Binary Search Trees II Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Should-be-6-Liner Unique Binary Search Trees II Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Share a C++ DP solution with O(1) space Unique Binary Search Trees II Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i) Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Fantastic Clean Java DP Solution with Detail Explaination Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Dp problem. 10+ lines with comments Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree A very simple and straight ans based on Math,Catalan Number ,O(N) times,O(1)space Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree Simple solution with easy explaination Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3   Medium Dynamic Programming Tree My DP solution in C++ Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false   Hard String Dynamic Programming 8ms C++ solution using BFS, with explanation Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false   Hard String Dynamic Programming DP Solution in Java Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false   Hard String Dynamic Programming 1ms tiny DFS beats 94.57% Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false   Hard String Dynamic Programming Python DP solutions (O(m*n), O(n) space), BFS, DFS. Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false   Hard String Dynamic Programming Learn one iterative inorder traversal, apply it to multiple tree questions (Java Solution) Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input:     2    / \   1   3 Output: true  Example 2:     5    / \   1   4      / \     3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value              is 5 but its right child's value is 4.   Medium Tree Depth-first Search My simple Java solution in 3 lines Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input:     2    / \   1   3 Output: true  Example 2:     5    / \   1   4      / \     3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value              is 5 but its right child's value is 4.   Medium Tree Depth-first Search C++ in-order traversal, and please do not rely on buggy INT_MAX, INT_MIN solutions any more Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input:     2    / \   1   3 Output: true  Example 2:     5    / \   1   4      / \     3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value              is 5 but its right child's value is 4.   Medium Tree Depth-first Search C++ simple recursive solution Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input:     2    / \   1   3 Output: true  Example 2:     5    / \   1   4      / \     3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value              is 5 but its right child's value is 4.   Medium Tree Depth-first Search My java inorder iteration solution Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input:     2    / \   1   3 Output: true  Example 2:     5    / \   1   4      / \     3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value              is 5 but its right child's value is 4.   Medium Tree Depth-first Search No Fancy Algorithm, just Simple and Powerful In-Order Traversal Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?   Hard Tree Depth-first Search Detail Explain about How Morris Traversal Finds two Incorrect Pointer Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?   Hard Tree Depth-first Search Tree Deserializer and Visualizer for Python Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?   Hard Tree Depth-first Search Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?   Hard Tree Depth-first Search [recommend for beginners]clean C++ implementation with detailed explaination Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?   Hard Tree Depth-first Search Five line Java solution with recursion Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false   Easy Tree Depth-first Search Here's a C++ recursion solution in minimal lines of code Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false   Easy Tree Depth-first Search My non-recursive method Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false   Easy Tree Depth-first Search Shortest+simplest Python Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false   Easy Tree Depth-first Search Python Recursive solution and DFS Iterative solution with stack and BFS Iterative solution with queue Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false   Easy Tree Depth-first Search Recursive and non-recursive solutions in Java Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).  For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3]  is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.  Easy Tree Depth-first Search Breadth-first Search 1ms recursive Java Solution, easy to understand Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).  For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3]  is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.  Easy Tree Depth-first Search Breadth-first Search My C++ Accepted code in 16ms with iteration solution Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).  For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3]  is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.  Easy Tree Depth-first Search Breadth-first Search Recursively and iteratively solution in Python Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).  For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3]  is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.  Easy Tree Depth-first Search Breadth-first Search Short and clean java iterative solution Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).  For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3]  is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.  Easy Tree Depth-first Search Breadth-first Search Java solution with a queue used Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]   Medium Tree Breadth-first Search Java Solution using DFS Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]   Medium Tree Breadth-first Search One of C++ solutions (preorder) Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]   Medium Tree Breadth-first Search C++ solution using only one queue / use a marker NULL Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]   Medium Tree Breadth-first Search 5-6 lines fast python solution (48 ms) Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]   Medium Tree Breadth-first Search My accepted JAVA solution Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]   Medium Stack Tree Breadth-first Search [c++] 5ms version: one queue and without reverse operation by using size of each level Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]   Medium Stack Tree Breadth-first Search A concise and easy understanding Java solution Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]   Medium Stack Tree Breadth-first Search JAVA Double Stack Solution Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]   Medium Stack Tree Breadth-first Search Python simple BFS Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]   Medium Stack Tree Breadth-first Search Can leetcode share top performing solution(s) of problems for each supported language ? Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.  Easy Tree Depth-first Search Simple solution using Java Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.  Easy Tree Depth-first Search My code of C++, Depth-first-search and Breadth-first-search Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.  Easy Tree Depth-first Search Two Java Iterative solution DFS and BFS Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.  Easy Tree Depth-first Search 1 line Ruby and Python Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.  Easy Tree Depth-first Search My Accepted Java Solution Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7  Medium Array Tree Depth-first Search Python short recursive solution. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7  Medium Array Tree Depth-first Search The iterative solution is easier than you think! Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7  Medium Array Tree Depth-first Search Sharing my straightforward recursive solution Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7  Medium Array Tree Depth-first Search 5ms Java Clean Solution with Caching Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7  Medium Array Tree Depth-first Search My recursive Java code with O(n) time and O(n) space Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7   Medium Array Tree Depth-first Search A Python recursive solution Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7   Medium Array Tree Depth-first Search Sharing my straightforward recursive solution Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7   Medium Array Tree Depth-first Search Java iterative solution with explanation Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7   Medium Array Tree Depth-first Search My comprehension of O(n) solution from @hongzhi Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7   Medium Array Tree Depth-first Search My DFS and BFS java solution Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]   Easy Tree Breadth-first Search Is there any better idea than doing regular level order traversal and reverse the result? Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]   Easy Tree Breadth-first Search Python solutions (dfs recursively, dfs+stack, bfs+queue). Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]   Easy Tree Breadth-first Search Java Solution. Using Queue Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]   Easy Tree Breadth-first Search My Neat Solution in C++ Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]   Easy Tree Breadth-first Search My Accepted Java Solution Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Easy Tree Depth-first Search Java Iterative Solution Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Easy Tree Depth-first Search An easy Python solution Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Easy Tree Depth-first Search Accepted C++ recursive solution within a single method Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Easy Tree Depth-first Search Python optimal solution Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Easy Tree Depth-first Search Share my JAVA solution, 1ms, very short and concise. Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Medium Linked List Depth-first Search Share my O(1) space and O(n) time Java code Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Medium Linked List Depth-first Search Share my code with O(n) time and O(1) space Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Medium Linked List Depth-first Search My Accepted C++ solution Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Medium Linked List Depth-first Search Recursive BST construction using slow-fast traversal on linked list Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5   Medium Linked List Depth-first Search The bottom up O(N) solution would be better Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.  Easy Tree Depth-first Search Java solution based on height, check left and right node in every recursion to avoid further useless search Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.  Easy Tree Depth-first Search VERY SIMPLE Python solutions (iterative and recursive), both beat 90% Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.  Easy Tree Depth-first Search Two different definitions of balanced binary tree result in two different judgments Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.  Easy Tree Depth-first Search JAVA O(n) solution based on Maximum Depth of Binary Tree Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.  Easy Tree Depth-first Search My 4 Line java solution Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.  Easy Tree Depth-first Search Breadth-first Search My concise c++ solution Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.  Easy Tree Depth-first Search Breadth-first Search 3 lines in Every Language Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.  Easy Tree Depth-first Search Breadth-first Search Why expected result for input of {1,2}  is 2? Shouldn't it be 1? Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.  Easy Tree Depth-first Search Breadth-first Search BFS, C++, 8ms, Beats 99.94% submissions Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.  Easy Tree Depth-first Search Breadth-first Search [Accepted]My recursive solution in Java Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.  Easy Tree Depth-first Search 3 lines of  c++ solution Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.  Easy Tree Depth-first Search Short Python recursive solution - O(n) Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.  Easy Tree Depth-first Search [Accepted] By using postorder traversal Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.  Easy Tree Depth-first Search My java no-recursive method Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.  Easy Tree Depth-first Search DFS with one LinkedList , accepted java solution Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]   Medium Tree Depth-first Search 12ms 11-lines C++ Solution Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]   Medium Tree Depth-first Search Python solutions (Recursively, BFS+queue, DFS+stack) Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]   Medium Tree Depth-first Search Simple DFS Java Solution Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]   Medium Tree Depth-first Search Java Solution: iterative and recursive Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]   Medium Tree Depth-first Search My short post order traversal Java solution for share Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6   Medium Tree Depth-first Search Share my simple NON-recursive solution, O(1) space complexity! Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6   Medium Tree Depth-first Search Straightforward Java Solution Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6   Medium Tree Depth-first Search Accepted simple Java solution , iterative Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6   Medium Tree Depth-first Search 8ms, Non-recursive, No stack, C++ solution Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6   Medium Tree Depth-first Search Easy to understand DP in Java Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^   Hard String Dynamic Programming Any better solution that takes less than O(n^2) space while in O(n^2) time? Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^   Hard String Dynamic Programming Task clarification Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^   Hard String Dynamic Programming 7-10 lines C++ Solutions with Detailed Explanations (O(m*n) time and O(m) space) Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^   Hard String Dynamic Programming The question should be reworded. Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^   Hard String Dynamic Programming A simple accepted solution Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).  Example: Given the following perfect binary tree,      1    /  \   2    3  / \  / \ 4  5  6  7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \  / \ 4->5->6->7 -> NULL   Medium Tree Depth-first Search Java solution with O(1) memory+ O(n) time Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).  Example: Given the following perfect binary tree,      1    /  \   2    3  / \  / \ 4  5  6  7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \  / \ 4->5->6->7 -> NULL   Medium Tree Depth-first Search My recursive solution(Java) Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).  Example: Given the following perfect binary tree,      1    /  \   2    3  / \  / \ 4  5  6  7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \  / \ 4->5->6->7 -> NULL   Medium Tree Depth-first Search My simple non-iterative C++ code with O(1) memory Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).  Example: Given the following perfect binary tree,      1    /  \   2    3  / \  / \ 4  5  6  7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \  / \ 4->5->6->7 -> NULL   Medium Tree Depth-first Search 7 lines, iterative, real O(1) space Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).  Example: Given the following perfect binary tree,      1    /  \   2    3  / \  / \ 4  5  6  7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \  / \ 4->5->6->7 -> NULL   Medium Tree Depth-first Search O(1) space O(n) complexity Iterative Solution Populating Next Right Pointers in Each Node II Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.  Example: Given the following binary tree,      1    /  \   2    3  / \    \ 4   5    7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \    \ 4-> 5 -> 7 -> NULL   Medium Tree Depth-first Search Simple solution using constant space Populating Next Right Pointers in Each Node II Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.  Example: Given the following binary tree,      1    /  \   2    3  / \    \ 4   5    7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \    \ 4-> 5 -> 7 -> NULL   Medium Tree Depth-first Search Java solution with constant space Populating Next Right Pointers in Each Node II Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.  Example: Given the following binary tree,      1    /  \   2    3  / \    \ 4   5    7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \    \ 4-> 5 -> 7 -> NULL   Medium Tree Depth-first Search AC Python O(1) space solution 12 lines and easy to understand Populating Next Right Pointers in Each Node II Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.  Example: Given the following binary tree,      1    /  \   2    3  / \    \ 4   5    7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \    \ 4-> 5 -> 7 -> NULL   Medium Tree Depth-first Search Simple 40ms c++ o(n) ,o(1) solution with only one while loop Populating Next Right Pointers in Each Node II Given a binary tree struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.  Example: Given the following binary tree,      1    /  \   2    3  / \    \ 4   5    7  After calling your function, the tree should look like:      1 -> NULL    /  \   2 -> 3 -> NULL  / \    \ 4-> 5 -> 7 -> NULL   Medium Tree Depth-first Search My concise solution in Java Pascal's Triangle Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]   Easy Array Python 4 lines short solution using map. Pascal's Triangle Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]   Easy Array Solution in Java Pascal's Triangle Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]   Easy Array Maybe shortest c++ solution Pascal's Triangle Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]   Easy Array Simple Python 4 lines Pascal's Triangle Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]   Easy Array Here is my brief O(k) solution Pascal's Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?  Easy Array Very simple Python solution Pascal's Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?  Easy Array My accepted java solution, any better code? Pascal's Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?  Easy Array My 8 lines java solution use ArrayList Pascal's Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?  Easy Array Sharing my c++ code, very simple Pascal's Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?  Easy Array DP Solution for Triangle Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  Medium Array Dynamic Programming 7 lines neat Java Solution Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  Medium Array Dynamic Programming My 8 line DP Java code(4 meaningful lines) with O(1) space Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  Medium Array Dynamic Programming Python easy to understand solutions (top-down, bottom-up). Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  Medium Array Dynamic Programming Bottom Up 5 line C++ Solution Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  Medium Array Dynamic Programming Kadane's Algorithm - Since no one has mentioned about this so far :) (In case if interviewer twists the input) Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.   Easy Array Dynamic Programming Sharing my simple and clear C++ solution Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.   Easy Array Dynamic Programming Please explain the problem more clearly!!! Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.   Easy Array Dynamic Programming My jave accepted solution with O(N) time and O(1) space Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.   Easy Array Dynamic Programming Easy O(n) Python solution Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.   Easy Array Dynamic Programming Is this question a joke? Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Easy Array Greedy Three lines in C++, with explanation Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Easy Array Greedy Java O(n) solution if we're not greedy Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Easy Array Greedy Clear 1-line Python Solution Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Easy Array Greedy Shortest and fastest solution with explanation. You can never beat this. Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Easy Array Greedy Is it Best Solution with O(n), O(1). Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Hard Array Dynamic Programming A clean DP solution which generalizes to k transactions Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Hard Array Dynamic Programming Detail explanation of DP solution Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Hard Array Dynamic Programming My explanation for O(N) solution! Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Hard Array Dynamic Programming My C++ solution (O(N) time, O(1) space, 8ms) Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  Hard Array Dynamic Programming Accepted short solution in Java Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42   Hard Tree Depth-first Search Simple O(n) algorithm with one traversal through the tree Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42   Hard Tree Depth-first Search Elegant Java solution Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42   Hard Tree Depth-first Search A very concise recursive solution Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42   Hard Tree Depth-first Search What is the meaning of path in this problem? Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42   Hard Tree Depth-first Search Accepted pretty Java solution(271ms) Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false   Easy Two Pointers String My three line java solution Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false   Easy Two Pointers String Here's a clean C++ solution Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false   Easy Two Pointers String Python in-place two-pointer solution. Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false   Easy Two Pointers String Passed clean c++ code Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false   Easy Two Pointers String My concise JAVA solution based on BFS and DFS Word Ladder II Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Hard Array String Backtracking Breadth-first Search Share two similar Java solution that Accpted by OJ. Word Ladder II Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Hard Array String Backtracking Breadth-first Search C++ solution using standard BFS method, no DFS or backtracking Word Ladder II Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Hard Array String Backtracking Breadth-first Search Super fast Java solution (two-end BFS) Word Ladder II Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Hard Array String Backtracking Breadth-first Search Use defaultdict for traceback and easy writing, 20 lines python code Word Ladder II Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Hard Array String Backtracking Breadth-first Search Easy 76ms C++ Solution using BFS Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:  Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: 5  Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: 0  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Medium Breadth-first Search Two-end BFS in Java 31ms. Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:  Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: 5  Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: 0  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Medium Breadth-first Search Java Solution using BFS, with explanation Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:  Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: 5  Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: 0  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Medium Breadth-first Search Share my two Python solutions: a very concise one (12 lines, ~160ms) and an optimized solution(~100ms) Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:  Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: 5  Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: 0  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Medium Breadth-first Search Another accepted Java solution (BFS) Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:  Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: 5  Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: 0  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.     Medium Breadth-first Search My really simple Java O(n) solution - Accepted Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Hard Array Union Find Simple O(n) with Explanation - Just walk each streak Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Hard Array Union Find Possibly shortest cpp solution, only 6 lines. Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Hard Array Union Find Simple fast Java solution using Set Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Hard Array Union Find A simple C++,solution using unordered_set.And simple consideration about this problem Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Hard Array Union Find Short Java solution. Recursion. Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.  Medium Tree Depth-first Search Can you improve this algorithm? Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.  Medium Tree Depth-first Search Python solutions (dfs+stack, bfs+queue, dfs recursively). Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.  Medium Tree Depth-first Search Clean Java DFS solution (preorder traversal) Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.  Medium Tree Depth-first Search One of the easier solution using preorder traversal (recursion) Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.  Medium Tree Depth-first Search A really simple and readable C++ solution\uff0conly cost 12ms Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.  Medium Depth-first Search Breadth-first Search Union Find Solve it using Union Find Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.  Medium Depth-first Search Breadth-first Search Union Find 9 lines, Python 148 ms Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.  Medium Depth-first Search Breadth-first Search Union Find Java DFS + boundary cell turning solution, simple and clean code, commented. Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.  Medium Depth-first Search Breadth-first Search Union Find My BFS solution (C++ 28ms) Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.  Medium Depth-first Search Breadth-first Search Union Find Java: Backtracking solution. Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: "aab" Output: [   ["aa","b"],   ["a","a","b"] ]   Medium Backtracking My Java DP only solution without recursion. O(n^2) Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: "aab" Output: [   ["aa","b"],   ["a","a","b"] ]   Medium Backtracking Clean C++ backtracking solution Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: "aab" Output: [   ["aa","b"],   ["a","a","b"] ]   Medium Backtracking Java DP + DFS solution Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: "aab" Output: [   ["aa","b"],   ["a","a","b"] ]   Medium Backtracking Python recursive/iterative backtracking solution Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: "aab" Output: [   ["aa","b"],   ["a","a","b"] ]   Medium Backtracking My solution does not need a table for palindrome, is it right ? It uses only O(n) space. Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.   Hard Dynamic Programming Easiest Java DP Solution (97.36%) Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.   Hard Dynamic Programming My DP Solution ( explanation and code) Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.   Hard Dynamic Programming Two C++ versions given (one DP 28ms, one Manancher-like algorithm 10 ms) Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.   Hard Dynamic Programming DP solution & some thoughts Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.   Hard Dynamic Programming Depth First Simple Java Solution Clone Graph Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.  OJ's undirected graph serialization (so you can understand error output): Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #.  First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    Visually, the graph looks like the following:        1       / \      /   \     0 --- 2          / \          \_/  Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.   Medium Depth-first Search Breadth-first Search Graph 7-17 lines C++ BFS/DFS Solutions Clone Graph Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.  OJ's undirected graph serialization (so you can understand error output): Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #.  First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    Visually, the graph looks like the following:        1       / \      /   \     0 --- 2          / \          \_/  Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.   Medium Depth-first Search Breadth-first Search Graph Simple Java iterative BFS solution with HashMap and queue Clone Graph Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.  OJ's undirected graph serialization (so you can understand error output): Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #.  First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    Visually, the graph looks like the following:        1       / \      /   \     0 --- 2          / \          \_/  Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.   Medium Depth-first Search Breadth-first Search Graph 9 line c++ DFS Solution Clone Graph Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.  OJ's undirected graph serialization (so you can understand error output): Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #.  First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    Visually, the graph looks like the following:        1       / \      /   \     0 --- 2          / \          \_/  Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.   Medium Depth-first Search Breadth-first Search Graph Java BFS solution Clone Graph Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.  OJ's undirected graph serialization (so you can understand error output): Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #.  First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    Visually, the graph looks like the following:        1       / \      /   \     0 --- 2          / \          \_/  Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.   Medium Depth-first Search Breadth-first Search Graph Share some of my ideas. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.   Medium Greedy My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.   Medium Greedy Proof of "if total gas is greater than total cost, there is a solution". C++ Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.   Medium Greedy My one pass solution. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.   Medium Greedy Fully-commented O(n) C++ solution enabled by a single observation of mine Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.   Medium Greedy A simple solution Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.   Hard Greedy One-pass constant space Java solution Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.   Hard Greedy Simple O(n) Java solution with comments Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.   Hard Greedy Very Simple Java Solution with detail explanation Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.   Hard Greedy Two C++ solutions given with explanation (both with O(N) time, one with O(1) space, the other with O(N) space) Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.   Hard Greedy My O(n) solution using XOR Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4   Easy Hash Table Bit Manipulation Easiest way to solve by using bit manipulation. Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4   Easy Hash Table Bit Manipulation Easy Java solution (tell you why using bitwise XOR) Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4   Easy Hash Table Bit Manipulation Python different solutions. Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4   Easy Hash Table Bit Manipulation My very simple solution (linear time, no extra memory) Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4   Easy Hash Table Bit Manipulation Challenge me , thx Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3  Example 2: Input: [0,1,0,1,0,1,99] Output: 99  Medium Bit Manipulation Detailed explanation and generalization of the bitwise operation method for single numbers Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3  Example 2: Input: [0,1,0,1,0,1,99] Output: 99  Medium Bit Manipulation An General Way to Handle All this sort of questions. Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3  Example 2: Input: [0,1,0,1,0,1,99] Output: 99  Medium Bit Manipulation Java O(n) easy to understand solution, easily extended to any times of occurance Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3  Example 2: Input: [0,1,0,1,0,1,99] Output: 99  Medium Bit Manipulation Accepted code with proper Explaination. Does anyone have a better idea? Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3  Example 2: Input: [0,1,0,1,0,1,99] Output: 99  Medium Bit Manipulation A solution with constant space complexity O(1) and linear time complexity O(N) Copy List with Random Pointer  A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.   Return a deep copy of the list.  Medium Hash Table Linked List Java O(n) solution Copy List with Random Pointer  A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.   Return a deep copy of the list.  Medium Hash Table Linked List 2 clean C++ algorithms without using extra array/hash table.  Algorithms are explained step by step. Copy List with Random Pointer  A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.   Return a deep copy of the list.  Medium Hash Table Linked List Clear and short python O(2n) and O(n) solution Copy List with Random Pointer  A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.   Return a deep copy of the list.  Medium Hash Table Linked List My accepted Java code. O(n) but need to iterate the list 3 times Copy List with Random Pointer  A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.   Return a deep copy of the list.  Medium Hash Table Linked List Java implementation using DP in two ways Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false   Medium Dynamic Programming C++ Dynamic Programming simple and fast solution (4ms) with optimization Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false   Medium Dynamic Programming A solution using BFS Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false   Medium Dynamic Programming Simple DP solution in Python with description Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false   Medium Dynamic Programming 4 lines in Python Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false   Medium Dynamic Programming My concise JAVA solution based on memorized DFS Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []  Hard Dynamic Programming Backtracking 11ms C++ solution (concise) Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []  Hard Dynamic Programming Backtracking Getting rid of TLE Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []  Hard Dynamic Programming Backtracking 9 lines Python, 10 lines C++ Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []  Hard Dynamic Programming Backtracking Python easy-to-understand solution Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []  Hard Dynamic Programming Backtracking O(1) Space Solution Linked List Cycle  Given a linked list, determine if it has a cycle in it.   Follow up: Can you solve it without using extra space?  Easy Linked List Two Pointers Except-ionally fast Python Linked List Cycle  Given a linked list, determine if it has a cycle in it.   Follow up: Can you solve it without using extra space?  Easy Linked List Two Pointers My faster and slower runner solution Linked List Cycle  Given a linked list, determine if it has a cycle in it.   Follow up: Can you solve it without using extra space?  Easy Linked List Two Pointers Simple and easy understanding java solution, Time  o(n) ,Space O(1) Linked List Cycle  Given a linked list, determine if it has a cycle in it.   Follow up: Can you solve it without using extra space?  Easy Linked List Two Pointers By saying using no extra space, does it mean O(0) in space? Linked List Cycle  Given a linked list, determine if it has a cycle in it.   Follow up: Can you solve it without using extra space?  Easy Linked List Two Pointers O(n) solution by using two pointers without change anything Linked List Cycle II  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.   Note: Do not modify the linked list.  Follow up: Can you solve it without using extra space?  Medium Linked List Two Pointers Concise O(n) solution by using C++ with Detailed Alogrithm Description Linked List Cycle II  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.   Note: Do not modify the linked list.  Follow up: Can you solve it without using extra space?  Medium Linked List Two Pointers Java O(1) space solution with detailed explanation. Linked List Cycle II  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.   Note: Do not modify the linked list.  Follow up: Can you solve it without using extra space?  Medium Linked List Two Pointers Concise JAVA solution based on slow fast pointers Linked List Cycle II  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.   Note: Do not modify the linked list.  Follow up: Can you solve it without using extra space?  Medium Linked List Two Pointers Share my python solution with detailed explanation Linked List Cycle II  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.   Note: Do not modify the linked list.  Follow up: Can you solve it without using extra space?  Medium Linked List Two Pointers Java solution with 3 steps Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3.   Medium Linked List A concise O(n) time, O(1) in place solution Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3.   Medium Linked List Java solution with 3 steps Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3.   Medium Linked List A python solution O(n) time, O(1) space Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3.   Medium Linked List My O(n) C++ Method, accepted Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3.   Medium Linked List Accepted iterative solution in Java using stack. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Stack Tree 3 Different Solutions Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Stack Tree Accepted code. Explaination with Algo. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Stack Tree Very simple iterative Python solution Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Stack Tree Easy C++ solution using Stack Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?  Medium Stack Tree Preorder, Inorder, and Postorder Iteratively Summarization Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?  Hard Stack Tree My Accepted code with explaination. Does anyone have a better idea? Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?  Hard Stack Tree Java simple and clean Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?  Hard Stack Tree C++ Iterative, Recursive and Morris Traversal Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?  Hard Stack Tree A very concise solution Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?  Hard Stack Tree [Java] Hashtable + Double linked list (with a touch of pseudo nodes) LRU Cache  Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Python Dict + Double LinkedList LRU Cache  Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Laziest implementation: Java's LinkedHashMap takes care of everything LRU Cache  Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design C++11 code 74ms - Hash table + List LRU Cache  Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design JAVA-----------Easy Version To Understand!!!! LRU Cache  Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design An easy and clear way to sort ( O(1) space ) Insertion Sort List Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list     Algorithm of Insertion Sort:  Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.   Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5   Medium Linked List Sort Thoughts from a Google interviewer Insertion Sort List Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list     Algorithm of Insertion Sort:  Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.   Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5   Medium Linked List Sort Explained C++ solution (24ms) Insertion Sort List Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list     Algorithm of Insertion Sort:  Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.   Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5   Medium Linked List Sort Accepted Solution using JAVA Insertion Sort List Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list     Algorithm of Insertion Sort:  Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.   Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5   Medium Linked List Sort Clean Java solution using a fake head Insertion Sort List Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list     Algorithm of Insertion Sort:  Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.   Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5   Medium Linked List Sort Java merge sort solution Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5  Medium Linked List Sort Bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5  Medium Linked List Sort I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage? Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5  Medium Linked List Sort Basically, it seems like merge sort problem(Really easy understand) Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5  Medium Linked List Sort Clean python code Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4  Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5  Medium Linked List Sort A java solution with notes Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6   Hard Hash Table Math Sharing my simple solution with explanation Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6   Hard Hash Table Math Accepted Java solution, easy to understand. Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6   Hard Hash Table Math C++ O(n^2) solution for your reference Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6   Hard Hash Table Math 16ms/28ms C++ Solutions with Explanations Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6   Hard Hash Table Math 6/\uff08-132\uff09= 0 or -1 Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:  Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.  Example 1: Input: ["2", "1", "+", "3", "*"] Output: 9 Explanation: ((2 + 1) * 3) = 9  Example 2: Input: ["4", "13", "5", "/", "+"] Output: 6 Explanation: (4 + (13 / 5)) = 6  Example 3: Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22   Medium Stack [Java] Accepted Code: Stack implementation. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:  Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.  Example 1: Input: ["2", "1", "+", "3", "*"] Output: 9 Explanation: ((2 + 1) * 3) = 9  Example 2: Input: ["4", "13", "5", "/", "+"] Output: 6 Explanation: (4 + (13 / 5)) = 6  Example 3: Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22   Medium Stack Accepted clean Java solution Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:  Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.  Example 1: Input: ["2", "1", "+", "3", "*"] Output: 9 Explanation: ((2 + 1) * 3) = 9  Example 2: Input: ["4", "13", "5", "/", "+"] Output: 6 Explanation: (4 + (13 / 5)) = 6  Example 3: Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22   Medium Stack Fancy C++ lambda expression solution Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:  Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.  Example 1: Input: ["2", "1", "+", "3", "*"] Output: 9 Explanation: ((2 + 1) * 3) = 9  Example 2: Input: ["4", "13", "5", "/", "+"] Output: 6 Explanation: (4 + (13 / 5)) = 6  Example 3: Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22   Medium Stack Python solution with comments (don't use eval() function). Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:  Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.  Example 1: Input: ["2", "1", "+", "3", "*"] Output: 9 Explanation: ((2 + 1) * 3) = 9  Example 2: Input: ["4", "13", "5", "/", "+"] Output: 6 Explanation: (4 + (13 / 5)) = 6  Example 3: Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22   Medium Stack Clean Java two-pointers solution (no trim( ), no split( ), no StringBuilder) Reverse Words in a String Given an input string, reverse the string word by word. Example:   Input: "the sky is blue", Output: "blue is sky the".  Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up: For C programmers, try to solve it in-place in O(1) space.  Medium String In place simple solution Reverse Words in a String Given an input string, reverse the string word by word. Example:   Input: "the sky is blue", Output: "blue is sky the".  Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up: For C programmers, try to solve it in-place in O(1) space.  Medium String My accepted Java solution Reverse Words in a String Given an input string, reverse the string word by word. Example:   Input: "the sky is blue", Output: "blue is sky the".  Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up: For C programmers, try to solve it in-place in O(1) space.  Medium String Java 3-line builtin solution Reverse Words in a String Given an input string, reverse the string word by word. Example:   Input: "the sky is blue", Output: "blue is sky the".  Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up: For C programmers, try to solve it in-place in O(1) space.  Medium String C++ solution, in place: runtime O(n), memory O(1) Reverse Words in a String Given an input string, reverse the string word by word. Example:   Input: "the sky is blue", Output: "blue is sky the".  Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up: For C programmers, try to solve it in-place in O(1) space.  Medium String Possibly simplest solution with O(n) time complexity Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Medium Array Dynamic Programming Sharing my solution: O(1) space, O(n) running time Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Medium Array Dynamic Programming Simple Java code Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Medium Array Dynamic Programming Share my C++ solution, maybe is the simplest solution Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Medium Array Dynamic Programming In Python, can it be more concise? Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Medium Array Dynamic Programming Compact and clean C++ solution Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0   Medium Array Binary Search 4ms simple C++ code with explanation Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0   Medium Array Binary Search A concise solution with proof in the comment Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0   Medium Array Binary Search Simplest and fastest C++ solution O(lg N), you can't beat this! Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0   Medium Array Binary Search Java solution with binary search Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0   Medium Array Binary Search My pretty simple code to solve it Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?   Hard Array Binary Search One simple and clear method with O(1) space and worst O(n) time Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?   Hard Array Binary Search Super simple and clean Java, binary search. Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?   Hard Array Binary Search Stop wasting your time. It most likely has to be O(n). Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?   Hard Array Binary Search Only two more lines code on top of the solution for Part I Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?   Hard Array Binary Search Share my Java solution with ONLY ONE stack Min Stack  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.    Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.   Easy Stack Design Java accepted solution using one stack Min Stack  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.    Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.   Easy Stack Design Clean 6ms Java solution Min Stack  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.    Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.   Easy Stack Design C++ using two stacks, quite short and easy to understand Min Stack  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.    Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.   Easy Stack Design My Python solution Min Stack  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.    Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.   Easy Stack Design Java solution without knowing the difference in len! Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:  A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗             B:     b1 → b2 → b3  begin to intersect at node c1.  Notes:  If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.  You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Credits:Special thanks to @stellari for adding this problem and creating all test cases. Easy Linked List My accepted simple and shortest C++ code with comments explaining the algorithm.  Any comments or improvements? Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:  A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗             B:     b1 → b2 → b3  begin to intersect at node c1.  Notes:  If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.  You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Credits:Special thanks to @stellari for adding this problem and creating all test cases. Easy Linked List Concise python code with comments Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:  A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗             B:     b1 → b2 → b3  begin to intersect at node c1.  Notes:  If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.  You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Credits:Special thanks to @stellari for adding this problem and creating all test cases. Easy Linked List Concise JAVA solution, O(1) memory O(n) time Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:  A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗             B:     b1 → b2 → b3  begin to intersect at node c1.  Notes:  If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.  You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Credits:Special thanks to @stellari for adding this problem and creating all test cases. Easy Linked List Simple C++ solution (5 lines) Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:  A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗             B:     b1 → b2 → b3  begin to intersect at node c1.  Notes:  If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.  You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Credits:Special thanks to @stellari for adding this problem and creating all test cases. Easy Linked List Find the maximum by binary search (recursion and iteration) Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.  Medium Array Binary Search O(logN) Solution JavaCode Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.  Medium Array Binary Search Java solution and explanation using invariants Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.  Medium Array Binary Search My clean and readable python solution Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.  Medium Array Binary Search A concise standard binary search solution Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.  Medium Array Binary Search [bucket sort] JAVA solution with explanation, O(N) time and space Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either              (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:  You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.   Hard Sort Radix sort solution in Java with explanation Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either              (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:  You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.   Hard Sort Pigeon hole principle Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either              (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:  You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.   Hard Sort My C++ code (12 ms, "bucket sort", O(n) time and space) Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either              (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:  You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.   Hard Sort I solved it using radix sort Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either              (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:  You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.   Hard Sort Accepted small Java solution. Compare Version Numbers Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1  Medium String My 2ms easy solution with C/C++ Compare Version Numbers Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1  Medium String Cudos on who invent such a boring question Compare Version Numbers Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1  Medium String My JAVA solution without split Compare Version Numbers Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1  Medium String Java solution with fewer if logic Compare Version Numbers Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1  Medium String My clean Java solution Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"   Medium Hash Table Math Accepted cpp solution, with explainations Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"   Medium Hash Table Math 0ms C++ Solution with Detailed Explanations Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"   Medium Hash Table Math Short Java solution Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"   Medium Hash Table Math Accepted Clean Java Solution Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"   Medium Hash Table Math My 1 lines code in Java, C++, and Python Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"  Easy Math Accepted Java solution Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"  Easy Math Python solution with explanation Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"  Easy Math Share my simple solution, just a little trick to handle corner case 26 Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"  Easy Math My easy to understand JAVA solution Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"  Easy Math O(n) time O(1) space fastest solution Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2   Easy Array Divide and Conquer Bit Manipulation 6 Suggested Solutions in C++ with Explanations Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2   Easy Array Divide and Conquer Bit Manipulation Java solutions (sorting, hashmap, moore voting, bit manipulation). Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2   Easy Array Divide and Conquer Bit Manipulation One line solution in Python Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2   Easy Array Divide and Conquer Bit Manipulation Share my solution [Java] - Count bits Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2   Easy Array Divide and Conquer Bit Manipulation My solutions in 3 languages, does any one have one line solution in Java or C++? Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701  Easy Math Asked this question on an interview Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701  Easy Math Here is my java solution Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701  Easy Math My 2ms JAVA solution Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701  Easy Math Explanation in Python Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701  Easy Math My one-line solutions in 3 languages Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  Easy Math Simple C/C++ Solution (with detailed explaination) Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  Easy Math My explanation of the Log(n) solution Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  Easy Math O(log_5(N)) solution, java Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  Easy Math 4-lines 4ms C++ Solution with Explanations Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  Easy Math My solutions in 3 languages with Stack Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  Credits:Special thanks to @ts for adding this problem and creating all test cases. Medium Stack Tree Design Ideal Solution using Stack (Java) Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  Credits:Special thanks to @ts for adding this problem and creating all test cases. Medium Stack Tree Design My java accepted solution Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  Credits:Special thanks to @ts for adding this problem and creating all test cases. Medium Stack Tree Design My Solution in C++, in average O(1) time and uses O(h) memory Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  Credits:Special thanks to @ts for adding this problem and creating all test cases. Medium Stack Tree Design Two Python solutions, stack and generator Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  Credits:Special thanks to @ts for adding this problem and creating all test cases. Medium Stack Tree Design C++ DP solution Dungeon Game table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.   Hard Binary Search Dynamic Programming My AC Java Version, Suggestions are welcome Dungeon Game table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.   Hard Binary Search Dynamic Programming Best solution I have found with explanations Dungeon Game table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.   Hard Binary Search Dynamic Programming My java solution with explanation in detail Dungeon Game table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.   Hard Binary Search Dynamic Programming Sharing my solution with O(n) space, O(mn) runtime Dungeon Game table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.   Hard Binary Search Dynamic Programming Its a simple question of Left Join. My solution attached Combine Two Tables SQL SchemaTable: Person +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.    Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State   Easy Comparative solution between LEFT JOIN, LEFT JOIN USING and NATURAL LEFT JOIN Combine Two Tables SQL SchemaTable: Person +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.    Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State   Easy Why cannot using where Combine Two Tables SQL SchemaTable: Person +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.    Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State   Easy My Solution And Question With Union Combine Two Tables SQL SchemaTable: Person +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.    Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State   Easy So watch your capitalization carefully\uff01 Combine Two Tables SQL SchemaTable: Person +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.    Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State   Easy Simple query which handles the NULL situation Second Highest Salary SQL SchemaWrite a SQL query to get the second highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. +---------------------+ | SecondHighestSalary | +---------------------+ | 200                 | +---------------------+   Easy A Simple Answer Second Highest Salary SQL SchemaWrite a SQL query to get the second highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. +---------------------+ | SecondHighestSalary | +---------------------+ | 200                 | +---------------------+   Easy Accepted solution Second Highest Salary SQL SchemaWrite a SQL query to get the second highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. +---------------------+ | SecondHighestSalary | +---------------------+ | 200                 | +---------------------+   Easy My tidy soution Second Highest Salary SQL SchemaWrite a SQL query to get the second highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. +---------------------+ | SecondHighestSalary | +---------------------+ | 200                 | +---------------------+   Easy Simple Solution Second Highest Salary SQL SchemaWrite a SQL query to get the second highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. +---------------------+ | SecondHighestSalary | +---------------------+ | 200                 | +---------------------+   Easy Accpted Solution for the Nth Highest Salary Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. +------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200                    | +------------------------+   Medium My accepted simply solution.Any advising? Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. +------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200                    | +------------------------+   Medium No Variable, No Limit X,1, Just one query, 808ms Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. +------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200                    | +------------------------+   Medium Why using LIMIT N-1,1 will cause error? Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. +------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200                    | +------------------------+   Medium Accepted Solution of Nth Highest Salary Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. +----+--------+ | Id | Salary | +----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    | +----+--------+  For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. +------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200                    | +------------------------+   Medium Simple, Short, Fast Rank Scores SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1  | 3.50  | | 2  | 3.65  | | 3  | 4.00  | | 4  | 3.85  | | 5  | 4.00  | | 6  | 3.65  | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00  | 1    | | 4.00  | 1    | | 3.85  | 2    | | 3.65  | 3    | | 3.65  | 3    | | 3.50  | 4    | +-------+------+   Medium Accepted solution using InnerJoin and GroupBy Rank Scores SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1  | 3.50  | | 2  | 3.65  | | 3  | 4.00  | | 4  | 3.85  | | 5  | 4.00  | | 6  | 3.65  | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00  | 1    | | 4.00  | 1    | | 3.85  | 2    | | 3.65  | 3    | | 3.65  | 3    | | 3.50  | 4    | +-------+------+   Medium Maybe the Simpest Solution Rank Scores SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1  | 3.50  | | 2  | 3.65  | | 3  | 4.00  | | 4  | 3.85  | | 5  | 4.00  | | 6  | 3.65  | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00  | 1    | | 4.00  | 1    | | 3.85  | 2    | | 3.65  | 3    | | 3.65  | 3    | | 3.50  | 4    | +-------+------+   Medium Accepted Solution with subqueries and group by Rank Scores SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1  | 3.50  | | 2  | 3.65  | | 3  | 4.00  | | 4  | 3.85  | | 5  | 4.00  | | 6  | 3.65  | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00  | 1    | | 4.00  | 1    | | 3.85  | 2    | | 3.65  | 3    | | 3.65  | 3    | | 3.50  | 4    | +-------+------+   Medium Accepted solution with subquery for rank Rank Scores SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1  | 3.50  | | 2  | 3.65  | | 3  | 4.00  | | 4  | 3.85  | | 5  | 4.00  | | 6  | 3.65  | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00  | 1    | | 4.00  | 1    | | 3.85  | 2    | | 3.65  | 3    | | 3.65  | 3    | | 3.50  | 4    | +-------+------+   Medium My Java Solution to share Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: "210" Example 2: Input: [3,30,34,5,9] Output: "9534330"  Note: The result may be very large, so you need to return a string instead of an integer.  Medium Sort A simple C++ solution Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: "210" Example 2: Input: [3,30,34,5,9] Output: "9534330"  Note: The result may be very large, so you need to return a string instead of an integer.  Medium Sort My 3-lines code in Java and Python Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: "210" Example 2: Input: [3,30,34,5,9] Output: "9534330"  Note: The result may be very large, so you need to return a string instead of an integer.  Medium Sort Share a short code in c++ Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: "210" Example 2: Input: [3,30,34,5,9] Output: "9534330"  Note: The result may be very large, so you need to return a string instead of an integer.  Medium Sort Python simple solution in 4 lines Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: "210" Example 2: Input: [3,30,34,5,9] Output: "9534330"  Note: The result may be very large, so you need to return a string instead of an integer.  Medium Sort Simple solution Consecutive Numbers SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively. +----+-----+ | Id | Num | +----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  | +----+-----+  For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. +-----------------+ | ConsecutiveNums | +-----------------+ | 1               | +-----------------+   Medium Solution with user defined variables Consecutive Numbers SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively. +----+-----+ | Id | Num | +----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  | +----+-----+  For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. +-----------------+ | ConsecutiveNums | +-----------------+ | 1               | +-----------------+   Medium An ugly solution Consecutive Numbers SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively. +----+-----+ | Id | Num | +----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  | +----+-----+  For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. +-----------------+ | ConsecutiveNums | +-----------------+ | 1               | +-----------------+   Medium Accepted solution without joins (works in n-consecutive cases with slight modification) Consecutive Numbers SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively. +----+-----+ | Id | Num | +----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  | +----+-----+  For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. +-----------------+ | ConsecutiveNums | +-----------------+ | 1               | +-----------------+   Medium Simple sql with join, 1484 ms Consecutive Numbers SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively. +----+-----+ | Id | Num | +----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  | +----+-----+  For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. +-----------------+ | ConsecutiveNums | +-----------------+ | 1               | +-----------------+   Medium A straightforward method Employees Earning More Than Their Managers SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +----+-------+--------+-----------+ | Id | Name  | Salary | ManagerId | +----+-------+--------+-----------+ | 1  | Joe   | 70000  | 3         | | 2  | Henry | 80000  | 4         | | 3  | Sam   | 60000  | NULL      | | 4  | Max   | 90000  | NULL      | +----+-------+--------+-----------+  Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. +----------+ | Employee | +----------+ | Joe      | +----------+   Easy Sharing my solution~   simple and easy to understand Employees Earning More Than Their Managers SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +----+-------+--------+-----------+ | Id | Name  | Salary | ManagerId | +----+-------+--------+-----------+ | 1  | Joe   | 70000  | 3         | | 2  | Henry | 80000  | 4         | | 3  | Sam   | 60000  | NULL      | | 4  | Max   | 90000  | NULL      | +----+-------+--------+-----------+  Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. +----------+ | Employee | +----------+ | Joe      | +----------+   Easy Sharing my solution Employees Earning More Than Their Managers SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +----+-------+--------+-----------+ | Id | Name  | Salary | ManagerId | +----+-------+--------+-----------+ | 1  | Joe   | 70000  | 3         | | 2  | Henry | 80000  | 4         | | 3  | Sam   | 60000  | NULL      | | 4  | Max   | 90000  | NULL      | +----+-------+--------+-----------+  Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. +----------+ | Employee | +----------+ | Joe      | +----------+   Easy An easy solution to this question. Employees Earning More Than Their Managers SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +----+-------+--------+-----------+ | Id | Name  | Salary | ManagerId | +----+-------+--------+-----------+ | 1  | Joe   | 70000  | 3         | | 2  | Henry | 80000  | 4         | | 3  | Sam   | 60000  | NULL      | | 4  | Max   | 90000  | NULL      | +----+-------+--------+-----------+  Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. +----------+ | Employee | +----------+ | Joe      | +----------+   Easy Two Straightforward way, using 'where' and 'join' Employees Earning More Than Their Managers SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +----+-------+--------+-----------+ | Id | Name  | Salary | ManagerId | +----+-------+--------+-----------+ | 1  | Joe   | 70000  | 3         | | 2  | Henry | 80000  | 4         | | 3  | Sam   | 60000  | NULL      | | 4  | Max   | 90000  | NULL      | +----+-------+--------+-----------+  Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager. +----------+ | Employee | +----------+ | Joe      | +----------+   Easy I have this Simple Approach, anybody has some other way Duplicate Emails SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person. +----+---------+ | Id | Email   | +----+---------+ | 1  | a@b.com | | 2  | c@d.com | | 3  | a@b.com | +----+---------+  For example, your query should return the following for the above table: +---------+ | Email   | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase.  Easy My simple accepted solution Duplicate Emails SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person. +----+---------+ | Id | Email   | +----+---------+ | 1  | a@b.com | | 2  | c@d.com | | 3  | a@b.com | +----+---------+  For example, your query should return the following for the above table: +---------+ | Email   | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase.  Easy A solution using a GROUP BY and another one using a self join Duplicate Emails SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person. +----+---------+ | Id | Email   | +----+---------+ | 1  | a@b.com | | 2  | c@d.com | | 3  | a@b.com | +----+---------+  For example, your query should return the following for the above table: +---------+ | Email   | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase.  Easy Share my solution Duplicate Emails SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person. +----+---------+ | Id | Email   | +----+---------+ | 1  | a@b.com | | 2  | c@d.com | | 3  | a@b.com | +----+---------+  For example, your query should return the following for the above table: +---------+ | Email   | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase.  Easy Simple solution use Group By Duplicate Emails SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person. +----+---------+ | Id | Email   | +----+---------+ | 1  | a@b.com | | 2  | c@d.com | | 3  | a@b.com | +----+---------+  For example, your query should return the following for the above table: +---------+ | Email   | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase.  Easy Three accepted solutions Customers Who Never Order SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. +----+-------+ | Id | Name  | +----+-------+ | 1  | Joe   | | 2  | Henry | | 3  | Sam   | | 4  | Max   | +----+-------+  Table: Orders. +----+------------+ | Id | CustomerId | +----+------------+ | 1  | 3          | | 2  | 1          | +----+------------+  Using the above tables as example, return the following: +-----------+ | Customers | +-----------+ | Henry     | | Max       | +-----------+   Easy A solution using NOT IN and another one using LEFT JOIN Customers Who Never Order SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. +----+-------+ | Id | Name  | +----+-------+ | 1  | Joe   | | 2  | Henry | | 3  | Sam   | | 4  | Max   | +----+-------+  Table: Orders. +----+------------+ | Id | CustomerId | +----+------------+ | 1  | 3          | | 2  | 1          | +----+------------+  Using the above tables as example, return the following: +-----------+ | Customers | +-----------+ | Henry     | | Max       | +-----------+   Easy Here are 3 solutions Customers Who Never Order SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. +----+-------+ | Id | Name  | +----+-------+ | 1  | Joe   | | 2  | Henry | | 3  | Sam   | | 4  | Max   | +----+-------+  Table: Orders. +----+------------+ | Id | CustomerId | +----+------------+ | 1  | 3          | | 2  | 1          | +----+------------+  Using the above tables as example, return the following: +-----------+ | Customers | +-----------+ | Henry     | | Max       | +-----------+   Easy Share My first DB Answer Customers Who Never Order SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. +----+-------+ | Id | Name  | +----+-------+ | 1  | Joe   | | 2  | Henry | | 3  | Sam   | | 4  | Max   | +----+-------+  Table: Orders. +----+------------+ | Id | CustomerId | +----+------------+ | 1  | 3          | | 2  | 1          | +----+------------+  Using the above tables as example, return the following: +-----------+ | Customers | +-----------+ | Henry     | | Max       | +-----------+   Easy MySql Solution using not in Customers Who Never Order SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Table: Customers. +----+-------+ | Id | Name  | +----+-------+ | 1  | Joe   | | 2  | Henry | | 3  | Sam   | | 4  | Max   | +----+-------+  Table: Orders. +----+------------+ | Id | CustomerId | +----+------------+ | 1  | 3          | | 2  | 1          | +----+------------+  Using the above tables as example, return the following: +-----------+ | Customers | +-----------+ | Henry     | | Max       | +-----------+   Easy Three accpeted solutions Department Highest Salary SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | Sales      | Henry    | 80000  | +------------+----------+--------+   Medium Simple solution, easy to understand Department Highest Salary SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | Sales      | Henry    | 80000  | +------------+----------+--------+   Medium Sharing my simple solution Department Highest Salary SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | Sales      | Henry    | 80000  | +------------+----------+--------+   Medium GROUP BY HAVING not working for multiple highest salary, why? Department Highest Salary SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | Sales      | Henry    | 80000  | +------------+----------+--------+   Medium Why cannot we just use max() with group by? Department Highest Salary SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | Sales      | Henry    | 80000  | +------------+----------+--------+   Medium Accepted solution without group by or order by Department Top Three Salaries SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | | 5  | Janet | 69000  | 1            | | 6  | Randy | 85000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | IT         | Randy    | 85000  | | IT         | Joe      | 70000  | | Sales      | Henry    | 80000  | | Sales      | Sam      | 60000  | +------------+----------+--------+   Hard My tidy solution Department Top Three Salaries SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | | 5  | Janet | 69000  | 1            | | 6  | Randy | 85000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | IT         | Randy    | 85000  | | IT         | Joe      | 70000  | | Sales      | Henry    | 80000  | | Sales      | Sam      | 60000  | +------------+----------+--------+   Hard Simple solution, easy to understand Department Top Three Salaries SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | | 5  | Janet | 69000  | 1            | | 6  | Randy | 85000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | IT         | Randy    | 85000  | | IT         | Joe      | 70000  | | Sales      | Henry    | 80000  | | Sales      | Sam      | 60000  | +------------+----------+--------+   Hard Best solution, clean, easy, no subquery Department Top Three Salaries SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | | 5  | Janet | 69000  | 1            | | 6  | Randy | 85000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | IT         | Randy    | 85000  | | IT         | Joe      | 70000  | | Sales      | Henry    | 80000  | | Sales      | Sam      | 60000  | +------------+----------+--------+   Hard Simple Solution for 1112 ms Department Top Three Salaries SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name  | Salary | DepartmentId | +----+-------+--------+--------------+ | 1  | Joe   | 70000  | 1            | | 2  | Henry | 80000  | 2            | | 3  | Sam   | 60000  | 2            | | 4  | Max   | 90000  | 1            | | 5  | Janet | 69000  | 1            | | 6  | Randy | 85000  | 1            | +----+-------+--------+--------------+  The Department table holds all departments of the company. +----+----------+ | Id | Name     | +----+----------+ | 1  | IT       | | 2  | Sales    | +----+----------+  Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT         | Max      | 90000  | | IT         | Randy    | 85000  | | IT         | Joe      | 70000  | | Sales      | Henry    | 80000  | | Sales      | Sam      | 60000  | +------------+----------+--------+   Hard 7 lines simple Java, O(n) Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]   Medium Hash Table Bit Manipulation Clean Java solution (hashmap + bits manipulation) Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]   Medium Hash Table Bit Manipulation I did it in 10 lines of C++ Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]   Medium Hash Table Bit Manipulation Short Java "rolling-hash" solution Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]   Medium Hash Table Bit Manipulation 20 ms solution (C++) with explanation Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]   Medium Hash Table Bit Manipulation A Concise DP Solution in Java Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Hard Dynamic Programming Clean Java DP solution with comment Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Hard Dynamic Programming C++ Solution with O(n + klgn) time using Max Heap and Stack Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Hard Dynamic Programming Share my C++ DP solution with O(kn) time O(k) space, 10ms Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Hard Dynamic Programming Easy understanding and can be easily modified to different situations Java Solution Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Hard Dynamic Programming Easy to read Java solution Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?  Easy Array Summary of C++ solutions Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?  Easy Array Java O(1) space solution of Rotate Array. Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?  Easy Array 3-line using reverse Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?  Easy Array My solution by using Python Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?  Easy Array O(1) bit operation C++ solution (8ms) Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example: Input: 43261596 Output: 964176192 Explanation: 43261596 represented in binary as 00000010100101000001111010011100,               return 964176192 represented in binary as 00111001011110000010100101000000.  Follow up: If this function is called many times, how would you optimize it? Easy Bit Manipulation Java Solution and Optimization Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example: Input: 43261596 Output: 964176192 Explanation: 43261596 represented in binary as 00000010100101000001111010011100,               return 964176192 represented in binary as 00111001011110000010100101000000.  Follow up: If this function is called many times, how would you optimize it? Easy Bit Manipulation Sharing my 2ms Java Solution with Explanation Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example: Input: 43261596 Output: 964176192 Explanation: 43261596 represented in binary as 00000010100101000001111010011100,               return 964176192 represented in binary as 00111001011110000010100101000000.  Follow up: If this function is called many times, how would you optimize it? Easy Bit Manipulation My 3ms pure C solution Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example: Input: 43261596 Output: 964176192 Explanation: 43261596 represented in binary as 00000010100101000001111010011100,               return 964176192 represented in binary as 00111001011110000010100101000000.  Follow up: If this function is called many times, how would you optimize it? Easy Bit Manipulation The concise C++ solution(9ms) Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example: Input: 43261596 Output: 964176192 Explanation: 43261596 represented in binary as 00000010100101000001111010011100,               return 964176192 represented in binary as 00111001011110000010100101000000.  Follow up: If this function is called many times, how would you optimize it? Easy Bit Manipulation Simple Java Solution, Bit Shifting Number of 1 Bits Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Example 1: Input: 11 Output: 3 Explanation: Integer 11 has binary representation 00000000000000000000000000001011   Example 2: Input: 128 Output: 1 Explanation: Integer 128 has binary representation 00000000000000000000000010000000   Easy Bit Manipulation Short code of C++, O(m) by time, m is the count of 1's,  and another several method of O(1) time Number of 1 Bits Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Example 1: Input: 11 Output: 3 Explanation: Integer 11 has binary representation 00000000000000000000000000001011   Example 2: Input: 128 Output: 1 Explanation: Integer 128 has binary representation 00000000000000000000000010000000   Easy Bit Manipulation C++ Solution: n & (n - 1) Number of 1 Bits Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Example 1: Input: 11 Output: 3 Explanation: Integer 11 has binary representation 00000000000000000000000000001011   Example 2: Input: 128 Output: 1 Explanation: Integer 128 has binary representation 00000000000000000000000010000000   Easy Bit Manipulation Readable simple JAVA solution O(1) Number of 1 Bits Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Example 1: Input: 11 Output: 3 Explanation: Integer 11 has binary representation 00000000000000000000000000001011   Example 2: Input: 128 Output: 1 Explanation: Integer 128 has binary representation 00000000000000000000000010000000   Easy Bit Manipulation Use n=n&(n-1) trick to clear the least bit Number of 1 Bits Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Example 1: Input: 11 Output: 3 Explanation: Integer 11 has binary representation 00000000000000000000000000001011   Example 2: Input: 128 Output: 1 Explanation: Integer 128 has binary representation 00000000000000000000000010000000   Easy Bit Manipulation My simple solution (one line with pipe) Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume:  words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters.  Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is  Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1  Note:  Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?   Medium Solution using awk and pipes with explaination Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume:  words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters.  Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is  Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1  Note:  Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?   Medium My accepted answer using tr, sort, uniq and awk Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume:  words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters.  Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is  Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1  Note:  Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?   Medium Share my accepted solution, using awk and sort! Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume:  words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters.  Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is  Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1  Note:  Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?   Medium My 16ms unix-pipe cat+tr+awk+sort+(hash) solution Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume:  words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters.  Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is  Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1  Note:  Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?   Medium Three different solutions using grep, sed, and awk Valid Phone Numbers Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890  Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890   Easy Grep -e solution with detailed explanation, good for those new to regex Valid Phone Numbers Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890  Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890   Easy Simple solution using awk Valid Phone Numbers Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890  Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890   Easy My "grep -E" solution Valid Phone Numbers Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890  Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890   Easy My easy understand grep -e solution Valid Phone Numbers Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890  Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890   Easy AC solution using awk and statement just like C. Transpose File Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30  Output the following: name alice ryan age 21 30     Medium Simple BASH solution that OJ hates Transpose File Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30  Output the following: name alice ryan age 21 30     Medium Solution using AWK with explanations Transpose File Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30  Output the following: name alice ryan age 21 30     Medium My 28ms awk solution Transpose File Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30  Output the following: name alice ryan age 21 30     Medium Memory Limit Exceeded Transpose File Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30  Output the following: name alice ryan age 21 30     Medium Share four different solutions Tenth Line Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10  Your script should output the tenth line, which is: Line 10  Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.  Easy Super simple solution Tenth Line Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10  Your script should output the tenth line, which is: Line 10  Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.  Easy My three simple solutions Tenth Line Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10  Your script should output the tenth line, which is: Line 10  Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.  Easy A generalized approach with head/tail Tenth Line Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10  Your script should output the tenth line, which is: Line 10  Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.  Easy Simple Solution using AWK Tenth Line Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10  Your script should output the tenth line, which is: Line 10  Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.  Easy Simple Solution Delete Duplicate Emails Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | | 3  | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | +----+------------------+  Note: Your output is the whole Person table after executing your sql. Use delete statement.  Easy A skillful mysql solution  avoid " select and update conflict" Delete Duplicate Emails Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | | 3  | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | +----+------------------+  Note: Your output is the whole Person table after executing your sql. Use delete statement.  Easy Solution in a Single query without any conflicts Delete Duplicate Emails Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | | 3  | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | +----+------------------+  Note: Your output is the whole Person table after executing your sql. Use delete statement.  Easy I can't believe I get it wrong! What's wrong with my code? Delete Duplicate Emails Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | | 3  | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | +----+------------------+  Note: Your output is the whole Person table after executing your sql. Use delete statement.  Easy A simple AC solution. Delete Duplicate Emails Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | | 3  | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email            | +----+------------------+ | 1  | john@example.com | | 2  | bob@example.com  | +----+------------------+  Note: Your output is the whole Person table after executing your sql. Use delete statement.  Easy Simple Solution Rising Temperature SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates. +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ |       1 |       2015-01-01 |               10 | |       2 |       2015-01-02 |               25 | |       3 |       2015-01-03 |               20 | |       4 |       2015-01-04 |               30 | +---------+------------------+------------------+  For example, return the following Ids for the above Weather table: +----+ | Id | +----+ |  2 | |  4 | +----+   Easy My simple solution using inner join Rising Temperature SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates. +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ |       1 |       2015-01-01 |               10 | |       2 |       2015-01-02 |               25 | |       3 |       2015-01-03 |               20 | |       4 |       2015-01-04 |               30 | +---------+------------------+------------------+  For example, return the following Ids for the above Weather table: +----+ | Id | +----+ |  2 | |  4 | +----+   Easy Two Solutions.......... Rising Temperature SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates. +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ |       1 |       2015-01-01 |               10 | |       2 |       2015-01-02 |               25 | |       3 |       2015-01-03 |               20 | |       4 |       2015-01-04 |               30 | +---------+------------------+------------------+  For example, return the following Ids for the above Weather table: +----+ | Id | +----+ |  2 | |  4 | +----+   Easy My simple solution Rising Temperature SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates. +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ |       1 |       2015-01-01 |               10 | |       2 |       2015-01-02 |               25 | |       3 |       2015-01-03 |               20 | |       4 |       2015-01-04 |               30 | +---------+------------------+------------------+  For example, return the following Ids for the above Weather table: +----+ | Id | +----+ |  2 | |  4 | +----+   Easy Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works? Rising Temperature SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates. +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ |       1 |       2015-01-01 |               10 | |       2 |       2015-01-02 |               25 | |       3 |       2015-01-03 |               20 | |       4 |       2015-01-04 |               30 | +---------+------------------+------------------+  For example, return the following Ids for the above Weather table: +----+ | Id | +----+ |  2 | |  4 | +----+   Easy From good to great. How to approach most of DP problems. House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.   Easy Dynamic Programming C 1ms, O(1)space,  very simple solution House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.   Easy Dynamic Programming Java O(n) solution, space O(1) House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.   Easy Dynamic Programming Python solution, 3 lines. House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.   Easy Dynamic Programming JAVA DP Solution, O(n) runtime and O(1) space, with inline comment House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.   Easy Dynamic Programming My simple accepted solution(JAVA) Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---  Medium Tree Depth-first Search Breadth-first Search My C++ solution, modified preorder traversal Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---  Medium Tree Depth-first Search Breadth-first Search Reverse Level Order Traversal, java Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---  Medium Tree Depth-first Search Breadth-first Search 5-9 Lines Python, 48+ ms Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---  Medium Tree Depth-first Search Breadth-first Search Simple C++ solution (BTW: I like clean codes) Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---  Medium Tree Depth-first Search Breadth-first Search Very concise Java AC solution Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3  Medium Depth-first Search Breadth-first Search Union Find 7 lines Python, ~14 lines Java Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3  Medium Depth-first Search Breadth-first Search Union Find 1D Union Find Java solution, easily generalized to other problems Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3  Medium Depth-first Search Breadth-first Search Union Find Python Simple DFS Solution Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3  Medium Depth-first Search Breadth-first Search Union Find Simple Java Solution Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3  Medium Depth-first Search Breadth-first Search Union Find Bit operation solution(JAVA) Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4  Example 2: Input: [0,1] Output: 0 Medium Bit Manipulation One line C++ solution Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4  Example 2: Input: [0,1] Output: 0 Medium Bit Manipulation 2 line Solution with detailed explanation Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4  Example 2: Input: [0,1] Output: 0 Medium Bit Manipulation Java/Python easy solution with explanation Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4  Example 2: Input: [0,1] Output: 0 Medium Bit Manipulation My simple java solution(3 lines) Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4  Example 2: Input: [0,1] Output: 0 Medium Bit Manipulation 3 line recursive solution Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5   Easy Linked List AC Java solution Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5   Easy Linked List Iterative short Java solution Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5   Easy Linked List Accepted 7 line clean java solution Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5   Easy Linked List Simple and elegant solution in C++ Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5   Easy Linked List My simple Java solution Count Primes Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  Easy Hash Table Math Fast Python Solution Count Primes Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  Easy Hash Table Math My easy one round c++ code Count Primes Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  Easy Hash Table Math 12 ms Java solution modified from the hint method, beats 99.95% Count Primes Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  Easy Hash Table Math Short C++ Sieve of Eratosthenes solution Count Primes Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  Easy Hash Table Math My 6 lines solution Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.  Easy Hash Table Python different solutions (dictionary, etc). Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.  Easy Hash Table Short Java solution without maps Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.  Easy Hash Table Java solution using HashMap Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.  Easy Hash Table Java solution with 1 line core code Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.  Easy Hash Table In-place iterative and recursive Java solution Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL  Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  Easy Linked List C++ Iterative and Recursive Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL  Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  Easy Linked List Python Iterative and Recursive Solution Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL  Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  Easy Linked List My Java recursive solution Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL  Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  Easy Linked List Accepted C Solutions both iteratively and recursively Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL  Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  Easy Linked List 18-22 lines C++ BFS/DFS Solutions Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Easy BFS Topological sort, Java Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Java DFS and BFS solution Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Python 20 lines DFS solution sharing with explanation Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort JAVA---------Easy Version To UnderStand!!!!!!!!!!!!!!!!! Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort AC JAVA solution simple using single array Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();  trie.insert("apple"); trie.search("apple");   // returns true trie.search("app");     // returns false trie.startsWith("app"); // returns true trie.insert("app");    trie.search("app");     // returns true  Note:  You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.   Medium Design Trie Maybe the code is not too much by using "next[26]", C++ Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();  trie.insert("apple"); trie.search("apple");   // returns true trie.search("app");     // returns false trie.startsWith("app"); // returns true trie.insert("app");    trie.search("app");     // returns true  Note:  You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.   Medium Design Trie AC Python Solution Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();  trie.insert("apple"); trie.search("apple");   // returns true trie.search("app");     // returns false trie.startsWith("app"); // returns true trie.insert("app");    trie.search("app");     // returns true  Note:  You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.   Medium Design Trie My python solution Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();  trie.insert("apple"); trie.search("apple");   // returns true trie.search("app");     // returns false trie.startsWith("app"); // returns true trie.insert("app");    trie.search("app");     // returns true  Note:  You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.   Medium Design Trie C++, My solution,  easy to understand:) Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();  trie.insert("apple"); trie.search("apple");   // returns true trie.search("app");     // returns false trie.startsWith("app"); // returns true trie.insert("app");    trie.search("app");     // returns true  Note:  You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.   Medium Design Trie Accepted clean Java O(n) solution (two pointers) Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).   Medium Array Two Pointers Binary Search Two AC solutions in Java with time complexity of N and NLogN with explanation Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).   Medium Array Two Pointers Binary Search 4ms O(n) / 8ms O(nlogn) C++ Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).   Medium Array Two Pointers Binary Search O(N),O(NLogN) solutions, both O(1) space Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).   Medium Array Two Pointers Binary Search O(N)  template for Minimum Size Subarray Sum & Minimum Window Substring & Longest Substring Without Repeating Characters Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).   Medium Array Two Pointers Binary Search Two AC solution in Java using BFS and DFS with explanation Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort 20+ lines C++ BFS/DFS Solutions Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Concise JAVA solution based on BFS with comments Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Python dfs, bfs solutions with comments. Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort Java DFS double cache visiting each vertex once 433ms Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.   Medium Depth-first Search Breadth-first Search Graph Topological Sort My simple and clean Java code Add and Search Word - Data structure design Design a data structure that supports the following two operations: void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord("bad") addWord("dad") addWord("mad") search("pad") -> false search("bad") -> true search(".ad") -> true search("b..") -> true  Note: You may assume that all words are consist of lowercase letters a-z.  Medium Backtracking Design Trie 80ms Clear C++ Code with Detailed Explanations Add and Search Word - Data structure design Design a data structure that supports the following two operations: void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord("bad") addWord("dad") addWord("mad") search("pad") -> false search("bad") -> true search(".ad") -> true search("b..") -> true  Note: You may assume that all words are consist of lowercase letters a-z.  Medium Backtracking Design Trie Python 168ms-beat-100% solution Add and Search Word - Data structure design Design a data structure that supports the following two operations: void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord("bad") addWord("dad") addWord("mad") search("pad") -> false search("bad") -> true search(".ad") -> true search("b..") -> true  Note: You may assume that all words are consist of lowercase letters a-z.  Medium Backtracking Design Trie Tree solutions, 18-20 lines Add and Search Word - Data structure design Design a data structure that supports the following two operations: void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord("bad") addWord("dad") addWord("mad") search("pad") -> false search("bad") -> true search(".ad") -> true search("b..") -> true  Note: You may assume that all words are consist of lowercase letters a-z.  Medium Backtracking Design Trie My JAVA Trie based solution Add and Search Word - Data structure design Design a data structure that supports the following two operations: void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord("bad") addWord("dad") addWord("mad") search("pad") -> false search("bad") -> true search(".ad") -> true search("b..") -> true  Note: You may assume that all words are consist of lowercase letters a-z.  Medium Backtracking Design Trie Java 15ms Easiest Solution (100.00%) Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input:  words = ["oath","pea","eat","rain"] and board = [   ['o','a','a','n'],   ['e','t','a','e'],   ['i','h','k','r'],   ['i','f','l','v'] ]  Output: ["eat","oath"]  Note: You may assume that all inputs are consist of lowercase letters a-z. Hard Backtracking Trie My simple and clean Java code using DFS and Trie Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input:  words = ["oath","pea","eat","rain"] and board = [   ['o','a','a','n'],   ['e','t','a','e'],   ['i','h','k','r'],   ['i','f','l','v'] ]  Output: ["eat","oath"]  Note: You may assume that all inputs are consist of lowercase letters a-z. Hard Backtracking Trie Test Case [a], [a, a] doesn't make sense? Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input:  words = ["oath","pea","eat","rain"] and board = [   ['o','a','a','n'],   ['e','t','a','e'],   ['i','h','k','r'],   ['i','f','l','v'] ]  Output: ["eat","oath"]  Note: You may assume that all inputs are consist of lowercase letters a-z. Hard Backtracking Trie Python code use trie and dfs 380ms Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input:  words = ["oath","pea","eat","rain"] and board = [   ['o','a','a','n'],   ['e','t','a','e'],   ['i','h','k','r'],   ['i','f','l','v'] ]  Output: ["eat","oath"]  Note: You may assume that all inputs are consist of lowercase letters a-z. Hard Backtracking Trie 27 lines, uses complex numbers Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input:  words = ["oath","pea","eat","rain"] and board = [   ['o','a','a','n'],   ['e','t','a','e'],   ['i','h','k','r'],   ['i','f','l','v'] ]  Output: ["eat","oath"]  Note: You may assume that all inputs are consist of lowercase letters a-z. Hard Backtracking Trie Simple AC solution in Java in O(n) with explanation House Robber II You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.  Medium Dynamic Programming 9-lines 0ms O(1)-Space C++ solution House Robber II You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.  Medium Dynamic Programming Twice pass solution, C++ House Robber II You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.  Medium Dynamic Programming [C++] Super Simple 0ms solution with explanation House Robber II You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.  Medium Dynamic Programming Good performance DP solution using Java House Robber II You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.  Medium Dynamic Programming Clean KMP solution with super detailed explanation Shortest Palindrome Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd" Hard String My 7-lines recursive Java solution Shortest Palindrome Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd" Hard String C++ 8 ms KMP-based O(n) time & O(n) memory solution Shortest Palindrome Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd" Hard String AC in 288 ms, simple brute force Shortest Palindrome Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd" Hard String My 9-lines three pointers Java solution with explanation Shortest Palindrome Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd" Hard String Solution explained Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:  You may assume k is always valid, 1 ≤ k ≤ array's length.  Medium Divide and Conquer Heap C++ Partition/Max-Heap/priority_queue/multiset Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:  You may assume k is always valid, 1 ≤ k ≤ array's length.  Medium Divide and Conquer Heap AC Clean QuickSelect Java solution avg. O(n) time Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:  You may assume k is always valid, 1 ≤ k ≤ array's length.  Medium Divide and Conquer Heap Python different solutions with comments (bubble sort, selection sort, heap sort and quick sort). Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:  You may assume k is always valid, 1 ≤ k ≤ array's length.  Medium Divide and Conquer Heap Concise JAVA solution based on Quick Select Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:  You may assume k is always valid, 1 ≤ k ≤ array's length.  Medium Divide and Conquer Heap Simple and clean Java code, backtracking. Combination Sum III  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]   Medium Array Backtracking My C++ solution, backtracking. Combination Sum III  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]   Medium Array Backtracking Fast, easy Java code, with explanation! Combination Sum III  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]   Medium Array Backtracking Use backtrack c++ solution, easy to understand. Combination Sum III  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]   Medium Array Backtracking Clean 1/6/7-liners (AC) Combination Sum III  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]   Medium Array Backtracking Possible solutions. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Easy Array Hash Table Single line C++ solution 60ms Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Easy Array Hash Table One line solution in python Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Easy Array Hash Table 5 lines in Java Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Easy Array Hash Table C++ solution. simply one line. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Easy Array Hash Table (Guaranteed) Really Detailed and Good (Perfect) Explanation of The Skyline Problem The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).      The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes:  The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]   Hard Divide and Conquer Heap Binary Indexed Tree Segment Tree Short Java solution The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).      The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes:  The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]   Hard Divide and Conquer Heap Binary Indexed Tree Segment Tree Once for all, explanation with clean Java code(O(n^2)time, O(n) space) The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).      The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes:  The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]   Hard Divide and Conquer Heap Binary Indexed Tree Segment Tree My C++ code using one priority queue (812 ms) The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).      The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes:  The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]   Hard Divide and Conquer Heap Binary Indexed Tree Segment Tree Share my divide and conquer java solution, 464 ms The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).      The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes:  The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]   Hard Divide and Conquer Heap Binary Indexed Tree Segment Tree Simple Java solution Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false      Easy Array Hash Table C++ solution with unordered_set Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false      Easy Array Hash Table Short AC JAVA solution Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false      Easy Array Hash Table Python concise solution with dictionary. Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false      Easy Array Hash Table C++ 6 line solution. simple code and easy understanding Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false      Easy Array Hash Table AC O(N) solution in Java using buckets with explanation Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true   Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false      Medium Binary Search Tree Java O(N lg K) solution Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true   Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false      Medium Binary Search Tree Java/Python one pass solution, O(n) time O(n) space using buckets Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true   Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false      Medium Binary Search Tree C++ using set (less 10 lines), with simple explanation. Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true   Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false      Medium Binary Search Tree O(n) Python using buckets with explanation, 10 lines. Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true   Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false      Medium Binary Search Tree C++ Dynamic Programming Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4  Medium Dynamic Programming Extremely Simple Java Solution :) Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4  Medium Dynamic Programming Accepted clean Java DP solution Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4  Medium Dynamic Programming 6 lines, Visual Explanation, O(mn) Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4  Medium Dynamic Programming Clear C++ solution, no extra space, 12 ms. Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4  Medium Dynamic Programming Concise Java solutions O(log(n)^2) Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6  Medium Binary Search Tree Easy short c++ recursive solution Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6  Medium Binary Search Tree Accepted Easy Understand Java Solution Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6  Medium Binary Search Tree My JAVA solution with explanation which beats 99% Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6  Medium Binary Search Tree A very clear recursive solution, isn't it? Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6  Medium Binary Search Tree If you want to laugh, look at my solution Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.  Medium Math Just another short way Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.  Medium Math My Java solution [Sum of areas - Overlapped area] Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.  Medium Math Python concise solution. Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.  Medium Math An explanation in plain language Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.  Medium Math Iterative Java solution with stack Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.   Hard Math Stack JAVA-----------Easy Version To Understand!!!!! Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.   Hard Math Stack 16 ms solution in C++ with stacks Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.   Hard Math Stack Easy 18 lines C++, 16 lines Python Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.   Hard Math Stack Java solution/Stack Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.   Hard Math Stack A simple C++ solution Implement Stack using Queues Implement the following operations of a stack using queues.  push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty.  Example: MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false Notes:  You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Easy Stack Design Only push is O(n), others are O(1). Using one queue. Combination of two shared solutions Implement Stack using Queues Implement the following operations of a stack using queues.  push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty.  Example: MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false Notes:  You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Easy Stack Design Java solutions about three ways one of which utilizes one queue, and the others utilize two queues Implement Stack using Queues Implement the following operations of a stack using queues.  push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty.  Example: MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false Notes:  You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Easy Stack Design Concise 1 Queue - Java, C++, Python Implement Stack using Queues Implement the following operations of a stack using queues.  push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty.  Example: MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false Notes:  You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Easy Stack Design O(1) purely with queues Implement Stack using Queues Implement the following operations of a stack using queues.  push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty.  Example: MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false Notes:  You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Easy Stack Design Straightforward DFS recursive, iterative, BFS solutions Invert Binary Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.  Easy Tree 3-4 lines Python Invert Binary Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.  Easy Tree Recursive and non-recursive C++ both 4ms Invert Binary Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.  Easy Tree Python solutions (recursively, dfs, bfs). Invert Binary Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.  Easy Tree My simple recursion java solution Invert Binary Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.  Easy Tree Share my  java solution Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.  Medium String 17 lines C++, easy, 20 ms Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.  Medium String Java straight forward iteration Solution with comments, No Stack, O(N) & O(1) Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.  Medium String My 16 ms No stack One pass short C++ solution Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.  Medium String Python short solution with stack. Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.  Medium String Accepted JAVA solution--easy to understand Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.   Medium Array 6 lines in Python Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.   Medium Array 10 line c++ easy understand Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.   Medium Array My concise Java solution Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.   Medium Array Idea + 1-Liner: Group by number-index Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.   Medium Array Boyer-Moore Majority Vote algorithm and my elaboration Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]  Medium Array JAVA-------------------Easy Version To Understand!!!!!!!!!!!! Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]  Medium Array 6 lines, general case O(N) time and O(k) space Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]  Medium Array Boyer-Moore Majority Vote algorithm generalization Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]  Medium Array My C++ Solution Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]  Medium Array 3 ways implemented in JAVA (Python): Binary Search, in-order iterative & recursive Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?  Medium Binary Search Tree What if you could modify the BST node's structure? Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?  Medium Binary Search Tree Two Easiest In Order Traverse (Java) Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?  Medium Binary Search Tree 4 Lines in C++. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?  Medium Binary Search Tree Python Easy Iterative and Recursive Solution Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?  Medium Binary Search Tree Using n&(n-1) trick Power of Two Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  Easy Math Bit Manipulation 4 different ways to solve -- Iterative / Recursive / Bit operation / Math Power of Two Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  Easy Math Bit Manipulation One line java solution using bitCount Power of Two Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  Easy Math Bit Manipulation One line of C++ Power of Two Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  Easy Math Bit Manipulation Python one line solution Power of Two Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  Easy Math Bit Manipulation Short O(1) amortized, C++ / Java / Ruby Implement Queue using Stacks Implement the following operations of a queue using stacks.  push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty.  Example: MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false Notes:  You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Easy Stack Design Easy Java solution, just edit push() method Implement Queue using Stacks Implement the following operations of a queue using stacks.  push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty.  Example: MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false Notes:  You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Easy Stack Design 0 ms C++ solution using one Stack w/ explanation. Implement Queue using Stacks Implement the following operations of a queue using stacks.  push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty.  Example: MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false Notes:  You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Easy Stack Design Share my python solution (32ms) Implement Queue using Stacks Implement the following operations of a queue using stacks.  push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty.  Example: MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false Notes:  You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Easy Stack Design Do you know when we should use two stacks to implement a queue? Implement Queue using Stacks Implement the following operations of a queue using stacks.  push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty.  Example: MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false Notes:  You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Easy Stack Design 4+ lines, O(log n), C++/Java/Python Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   Hard Math AC short Java solution Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   Hard Math Java/Python one pass solution easy to understand Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   Hard Math 0ms o(lgn) accepted c++ solution using counting principle with explanation Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   Hard Math 0 ms recursive solution Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   Hard Math Reversing a list is not considered "O(1) space" Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  Easy Linked List Two Pointers Java, easy to understand Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  Easy Linked List Two Pointers 11 lines, 12 with restore, O(n) time, O(1) space Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  Easy Linked List Two Pointers Share my C++ solution, O(n) time and O(1) memory Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  Easy Linked List Two Pointers My easy understand C++ solution Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  Easy Linked List Two Pointers 3 lines with O(1) space, 1-Liners, Alternatives Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]         _______6______        /              \     ___2__          ___8__    /      \        /      \    0      _4       7       9          /  \          3   5  Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself               according to the LCA definition.  Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.   Easy Tree My Java Solution Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]         _______6______        /              \     ___2__          ___8__    /      \        /      \    0      _4       7       9          /  \          3   5  Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself               according to the LCA definition.  Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.   Easy Tree C++ Recursive and Iterative Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]         _______6______        /              \     ___2__          ___8__    /      \        /      \    0      _4       7       9          /  \          3   5  Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself               according to the LCA definition.  Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.   Easy Tree Python Iterative Solution Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]         _______6______        /              \     ___2__          ___8__    /      \        /      \    0      _4       7       9          /  \          3   5  Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself               according to the LCA definition.  Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.   Easy Tree 11ms java solution, 3 lines Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]         _______6______        /              \     ___2__          ___8__    /      \        /      \    0      _4       7       9          /  \          3   5  Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself               according to the LCA definition.  Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.   Easy Tree Why LeetCode accepted such stupid question? Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:     4 -> 5 -> 1 -> 9  Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list              should become 4 -> 1 -> 9 after calling your function.  Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list              should become 4 -> 5 -> 9 after calling your function.  Note:  The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.   Easy Linked List 1-3 lines, C++/Java/Python/C/C#/JavaScript/Ruby Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:     4 -> 5 -> 1 -> 9  Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list              should become 4 -> 1 -> 9 after calling your function.  Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list              should become 4 -> 5 -> 9 after calling your function.  Note:  The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.   Easy Linked List Easy solution in java Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:     4 -> 5 -> 1 -> 9  Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list              should become 4 -> 1 -> 9 after calling your function.  Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list              should become 4 -> 5 -> 9 after calling your function.  Note:  The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.   Easy Linked List This question is wrong.You cannot delete the node Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:     4 -> 5 -> 1 -> 9  Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list              should become 4 -> 1 -> 9 after calling your function.  Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list              should become 4 -> 5 -> 9 after calling your function.  Note:  The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.   Easy Linked List Easy question, Easy solution(JAVA) Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:     4 -> 5 -> 1 -> 9  Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list              should become 4 -> 1 -> 9 after calling your function.  Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list              should become 4 -> 5 -> 9 after calling your function.  Note:  The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.   Easy Linked List Simple Java solution in O(n) without extra space Product of Array Except Self Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)  Medium Array Python solution (Accepted), O(n) time, O(1) space Product of Array Except Self Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)  Medium Array My simple Java solution Product of Array Except Self Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)  Medium Array O(n) time and O(1) space C++ solution with explanation Product of Array Except Self Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)  Medium Array My solution beats 100% java solutions Product of Array Except Self Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)  Medium Array Java O(n) solution using deque with explanation Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7  Note:  You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Hard Heap O(n) solution in Java with two simple pass in the array Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7  Note:  You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Hard Heap This is a typical monotonic queue problem Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7  Note:  You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Hard Heap Clean C++ O(n) solution using a deque Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7  Note:  You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Hard Heap My C++ O(n) deque based solution with explanation Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7  Note:  You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Hard Heap My concise O(m+n) Java solution Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.  Medium Binary Search Divide and Conquer C++ with O(m+n) complexity Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.  Medium Binary Search Divide and Conquer *Java* an easy-to-understand divide and conquer method Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.  Medium Binary Search Divide and Conquer 6-9 lines C++/Python Solutions with Explanations Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.  Medium Binary Search Divide and Conquer Java short code, O(m+n) Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.  Medium Binary Search Divide and Conquer A recursive Java solution (284 ms) Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: "2-1-1" Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input: "2*3-4*5" Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10  Medium Divide and Conquer C++ 4ms Recursive & DP solution with brief explanation Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: "2-1-1" Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input: "2*3-4*5" Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10  Medium Divide and Conquer 1-11 lines Python, 9 lines C++ Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: "2-1-1" Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input: "2*3-4*5" Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10  Medium Divide and Conquer Python easy to understand solution (divide and conquer). Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: "2-1-1" Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input: "2*3-4*5" Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10  Medium Divide and Conquer Share a clean and short JAVA solution Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: "2-1-1" Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input: "2*3-4*5" Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10  Medium Divide and Conquer Accepted Java O(n) solution in 5 lines Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?  Easy Hash Table Sort 2 C++ Solutions with Explanations Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?  Easy Hash Table Sort Python solutions (sort and dictionary). Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?  Easy Hash Table Sort Share my java solution Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?  Easy Hash Table Sort Simple fast java solution (beats 97%) Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?  Easy Hash Table Sort Accepted Java simple solution in 8 lines Binary Tree Paths Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3  Easy Tree Depth-first Search Python solutions (dfs+stack, bfs+queue, dfs recursively). Binary Tree Paths Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3  Easy Tree Depth-first Search Clean Java solution (Accepted) without any helper recursive function Binary Tree Paths Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3  Easy Tree Depth-first Search C++ simple 4ms recursive solution Binary Tree Paths Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3  Easy Tree Depth-first Search My Java solution in DFS, BFS, recursion Binary Tree Paths Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3  Easy Tree Depth-first Search Accepted C++ O(1)-time O(1)-space 1-Line Solution with Detail Explanations Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime? Easy Math 3 methods for python with explains Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime? Easy Math Two lines C code, with explanation Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime? Easy Math Simple Java Solution No recursion/ loop Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime? Easy Math 1 line Java Solution Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime? Easy Math Accepted C++/Java O(n)-time O(1)-space Easy Solution with Detail Explanations Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input:  [1,2,1,3,2,5] Output: [3,5] Note:  The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  Medium Bit Manipulation Sharing explanation of the solution Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input:  [1,2,1,3,2,5] Output: [3,5] Note:  The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  Medium Bit Manipulation C++ solution O(n) time and O(1) space, easy-understaning with simple explanation Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input:  [1,2,1,3,2,5] Output: [3,5] Note:  The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  Medium Bit Manipulation Bit manipulation beats 99.62% Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input:  [1,2,1,3,2,5] Output: [3,5] Note:  The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  Medium Bit Manipulation Share my C++ solution, Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input:  [1,2,1,3,2,5] Output: [3,5] Note:  The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  Medium Bit Manipulation Solution without join Trips and Users SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1  |     1     |    10     |    1    |     completed      |2013-10-01| | 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01| | 3  |     3     |    12     |    6    |     completed      |2013-10-01| | 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01| | 5  |     1     |    10     |    1    |     completed      |2013-10-02| | 6  |     2     |    11     |    6    |     completed      |2013-10-02| | 7  |     3     |    12     |    6    |     completed      |2013-10-02| | 8  |     2     |    12     |    12   |     completed      |2013-10-03| | 9  |     3     |    10     |    12   |     completed      |2013-10-03|  | 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+  The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). +----------+--------+--------+ | Users_Id | Banned |  Role  | +----------+--------+--------+ |    1     |   No   | client | |    2     |   Yes  | client | |    3     |   No   | client | |    4     |   No   | client | |    10    |   No   | driver | |    11    |   No   | driver | |    12    |   No   | driver | |    13    |   No   | driver | +----------+--------+--------+  Write a SQL query to find the cancellation rate of requests made by unbanned users between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ |     Day    | Cancellation Rate | +------------+-------------------+ | 2013-10-01 |       0.33        | | 2013-10-02 |       0.00        | | 2013-10-03 |       0.50        | +------------+-------------------+  Credits: Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.  Hard Sharing my solution, Trips and Users SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1  |     1     |    10     |    1    |     completed      |2013-10-01| | 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01| | 3  |     3     |    12     |    6    |     completed      |2013-10-01| | 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01| | 5  |     1     |    10     |    1    |     completed      |2013-10-02| | 6  |     2     |    11     |    6    |     completed      |2013-10-02| | 7  |     3     |    12     |    6    |     completed      |2013-10-02| | 8  |     2     |    12     |    12   |     completed      |2013-10-03| | 9  |     3     |    10     |    12   |     completed      |2013-10-03|  | 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+  The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). +----------+--------+--------+ | Users_Id | Banned |  Role  | +----------+--------+--------+ |    1     |   No   | client | |    2     |   Yes  | client | |    3     |   No   | client | |    4     |   No   | client | |    10    |   No   | driver | |    11    |   No   | driver | |    12    |   No   | driver | |    13    |   No   | driver | +----------+--------+--------+  Write a SQL query to find the cancellation rate of requests made by unbanned users between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ |     Day    | Cancellation Rate | +------------+-------------------+ | 2013-10-01 |       0.33        | | 2013-10-02 |       0.00        | | 2013-10-03 |       0.50        | +------------+-------------------+  Credits: Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.  Hard Question towards problem description Trips and Users SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1  |     1     |    10     |    1    |     completed      |2013-10-01| | 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01| | 3  |     3     |    12     |    6    |     completed      |2013-10-01| | 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01| | 5  |     1     |    10     |    1    |     completed      |2013-10-02| | 6  |     2     |    11     |    6    |     completed      |2013-10-02| | 7  |     3     |    12     |    6    |     completed      |2013-10-02| | 8  |     2     |    12     |    12   |     completed      |2013-10-03| | 9  |     3     |    10     |    12   |     completed      |2013-10-03|  | 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+  The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). +----------+--------+--------+ | Users_Id | Banned |  Role  | +----------+--------+--------+ |    1     |   No   | client | |    2     |   Yes  | client | |    3     |   No   | client | |    4     |   No   | client | |    10    |   No   | driver | |    11    |   No   | driver | |    12    |   No   | driver | |    13    |   No   | driver | +----------+--------+--------+  Write a SQL query to find the cancellation rate of requests made by unbanned users between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ |     Day    | Cancellation Rate | +------------+-------------------+ | 2013-10-01 |       0.33        | | 2013-10-02 |       0.00        | | 2013-10-03 |       0.50        | +------------+-------------------+  Credits: Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.  Hard Sharing my solution Trips and Users SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1  |     1     |    10     |    1    |     completed      |2013-10-01| | 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01| | 3  |     3     |    12     |    6    |     completed      |2013-10-01| | 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01| | 5  |     1     |    10     |    1    |     completed      |2013-10-02| | 6  |     2     |    11     |    6    |     completed      |2013-10-02| | 7  |     3     |    12     |    6    |     completed      |2013-10-02| | 8  |     2     |    12     |    12   |     completed      |2013-10-03| | 9  |     3     |    10     |    12   |     completed      |2013-10-03|  | 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+  The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). +----------+--------+--------+ | Users_Id | Banned |  Role  | +----------+--------+--------+ |    1     |   No   | client | |    2     |   Yes  | client | |    3     |   No   | client | |    4     |   No   | client | |    10    |   No   | driver | |    11    |   No   | driver | |    12    |   No   | driver | |    13    |   No   | driver | +----------+--------+--------+  Write a SQL query to find the cancellation rate of requests made by unbanned users between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ |     Day    | Cancellation Rate | +------------+-------------------+ | 2013-10-01 |       0.33        | | 2013-10-02 |       0.00        | | 2013-10-03 |       0.50        | +------------+-------------------+  Credits: Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.  Hard My solution share Trips and Users SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1  |     1     |    10     |    1    |     completed      |2013-10-01| | 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01| | 3  |     3     |    12     |    6    |     completed      |2013-10-01| | 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01| | 5  |     1     |    10     |    1    |     completed      |2013-10-02| | 6  |     2     |    11     |    6    |     completed      |2013-10-02| | 7  |     3     |    12     |    6    |     completed      |2013-10-02| | 8  |     2     |    12     |    12   |     completed      |2013-10-03| | 9  |     3     |    10     |    12   |     completed      |2013-10-03|  | 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+  The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). +----------+--------+--------+ | Users_Id | Banned |  Role  | +----------+--------+--------+ |    1     |   No   | client | |    2     |   Yes  | client | |    3     |   No   | client | |    4     |   No   | client | |    10    |   No   | driver | |    11    |   No   | driver | |    12    |   No   | driver | |    13    |   No   | driver | +----------+--------+--------+  Write a SQL query to find the cancellation rate of requests made by unbanned users between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ |     Day    | Cancellation Rate | +------------+-------------------+ | 2013-10-01 |       0.33        | | 2013-10-02 |       0.00        | | 2013-10-03 |       0.50        | +------------+-------------------+  Credits: Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.  Hard 2-4 lines, every language Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].  Easy Math My 2ms java solution Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].  Easy Math Simple java solution with explanation Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].  Easy Math My python solution Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].  Easy Math Java solution, greatest divide by 2, 3, 5 Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].  Easy Math My 16ms C++ DP solution with short explanation Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.  Medium Math Dynamic Programming Heap O(n) Java solution Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.  Medium Math Dynamic Programming Heap Elegant C++ Solution O(N) space time with detailed explanation. Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.  Medium Math Dynamic Programming Heap My expressive Python solution Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.  Medium Math Dynamic Programming Heap Java solution -- using PriorityQueue Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.  Medium Math Dynamic Programming Heap 4 Line Simple Java Bit Manipulate Solution with Explaination Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Easy Array Math Bit Manipulation 3 different ideas: XOR, SUM, Binary Search. Java code Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Easy Array Math Bit Manipulation C++ solution using bit manipulation Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Easy Array Math Bit Manipulation 1+ lines Ruby, Python, Java, C++ Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Easy Array Math Bit Manipulation Java solution O(1) space and O(n) in time Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Easy Array Math Bit Manipulation My clean Java solution, very easy to understand Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"   Hard Math String Short clean Java solution Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"   Hard Math String Fairly Clear 4ms C++ solution Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"   Hard Math String Recursive Python Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"   Hard Math String Python Clean Solution Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"   Hard Math String My O(n) time solution use Java H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.  Medium Hash Table Sort Java bucket sort O(n) solution with detail explanation H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.  Medium Hash Table Sort A Clean O(N) Solution in Java H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.  Medium Hash Table Sort Java, O(n) time, with easy explanation. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.  Medium Hash Table Sort My easy solution H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.  Medium Hash Table Sort Standard binary search H-Index II Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?   Medium Binary Search Java binary search, simple and clean H-Index II Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?   Medium Binary Search O(logN)-time O(1)-space Easy Solution with Detailed Explanations (C++/Java/Python) H-Index II Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?   Medium Binary Search Very standard binary search using (start + 1 < end) H-Index II Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?   Medium Binary Search Share my C O(logN) solution with explanation. H-Index II Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?   Medium Binary Search O(lgN) simple Java solution First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.   Easy Binary Search A good warning to me to use  start+(end-start)/2 to avoid overflow First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.   Easy Binary Search Time limit exceed First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.   Easy Binary Search Short C++ answer and minimize API calls First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.   Easy Binary Search 1-liner in Ruby / Python First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.   Easy Binary Search Summary of 4 different solutions (BFS, DP, static DP and mathematics) Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Medium Math Dynamic Programming Breadth-first Search An easy understanding DP solution in Java Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Medium Math Dynamic Programming Breadth-first Search Short Python solution using BFS Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Medium Math Dynamic Programming Breadth-first Search Static DP, C++ 12 ms, Python 172 ms, Ruby 384 ms Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Medium Math Dynamic Programming Breadth-first Search O(sqrt(n)) in Ruby, C++, C Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Medium Math Dynamic Programming Breadth-first Search Java Standard Backtrace AC Solutoin, short and clear Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: Input: num = "123", target = 6 Output: ["1+2+3", "1*2*3"]   Example 2: Input: num = "232", target = 8 Output: ["2*3+2", "2+3*2"] Example 3: Input: num = "105", target = 5 Output: ["1*0+5","10-5"] Example 4: Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]  Example 5: Input: num = "3456237490", target = 9191 Output: []  Hard Divide and Conquer 17 lines solution, dfs (C++) Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: Input: num = "123", target = 6 Output: ["1+2+3", "1*2*3"]   Example 2: Input: num = "232", target = 8 Output: ["2*3+2", "2+3*2"] Example 3: Input: num = "105", target = 5 Output: ["1*0+5","10-5"] Example 4: Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]  Example 5: Input: num = "3456237490", target = 9191 Output: []  Hard Divide and Conquer Java AC solution, 19ms, beat 100.00%. Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: Input: num = "123", target = 6 Output: ["1+2+3", "1*2*3"]   Example 2: Input: num = "232", target = 8 Output: ["2*3+2", "2+3*2"] Example 3: Input: num = "105", target = 5 Output: ["1*0+5","10-5"] Example 4: Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]  Example 5: Input: num = "3456237490", target = 9191 Output: []  Hard Divide and Conquer Clean Python DFS with comments Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: Input: num = "123", target = 6 Output: ["1+2+3", "1*2*3"]   Example 2: Input: num = "232", target = 8 Output: ["2*3+2", "2+3*2"] Example 3: Input: num = "105", target = 5 Output: ["1*0+5","10-5"] Example 4: Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]  Example 5: Input: num = "3456237490", target = 9191 Output: []  Hard Divide and Conquer Accepted C++ Solution Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: Input: num = "123", target = 6 Output: ["1+2+3", "1*2*3"]   Example 2: Input: num = "232", target = 8 Output: ["2*3+2", "2+3*2"] Example 3: Input: num = "105", target = 5 Output: ["1*0+5","10-5"] Example 4: Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]  Example 5: Input: num = "3456237490", target = 9191 Output: []  Hard Divide and Conquer Simple O(N) Java Solution Using Insert Index Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.  Easy Array Two Pointers My simple C++ solution Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.  Easy Array Two Pointers 1ms Java solution Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.  Easy Array Two Pointers Python short in-place solution with comments. Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.  Easy Array Two Pointers C++ Accepted Code Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.  Easy Array Two Pointers Concise Java Solution Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.  Follow up: How would you extend your design to be generic and work with all types, not just integer?  Medium Design Simple C++ solution (1 line per method) without extra member variables Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.  Follow up: How would you extend your design to be generic and work with all types, not just integer?  Medium Design Simple Python Solution Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.  Follow up: How would you extend your design to be generic and work with all types, not just integer?  Medium Design Another C++ solution with one line in peek() and hasNext(), AC Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.  Follow up: How would you extend your design to be generic and work with all types, not just integer?  Medium Design Simple Java solution by caching next element Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.  Follow up: How would you extend your design to be generic and work with all types, not just integer?  Medium Design My easy understood solution with O(n) time and O(1) space without modifying the array. With clear explanation. Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.   Medium Array Two Pointers Binary Search Two Solutions (with explanation): O(nlog(n)) and O(n) time , O(1) space, without changing the input array Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.   Medium Array Two Pointers Binary Search Java O(n) time and O(1) space solution. Similar to find loop in linkedlist. Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.   Medium Array Two Pointers Binary Search Simple C++ code with O(1) space and O(nlogn) time complexity Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.   Medium Array Two Pointers Binary Search Java O(1)space using Binary-Search Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.   Medium Array Two Pointers Binary Search Easiest JAVA solution with explanation Game of Life According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?   Medium Array C++ O(1) space, O(mn) time Game of Life According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?   Medium Array Infinite board solution Game of Life According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?   Medium Array C++ AC Code  O(1) space, O(mn) time Game of Life According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?   Medium Array Clean O(1) space O(mn) time Java Solution Game of Life According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?   Medium Array 8 lines simple Java Word Pattern Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Easy Hash Table Short C++, read words on the fly Word Pattern Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Easy Hash Table Very fast (3ms) Java Solution using HashMap Word Pattern Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Easy Hash Table Short in Python Word Pattern Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Easy Hash Table 0ms C++ solution using istringstream and double maps Word Pattern Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Easy Hash Table Theorem: all 4s shall be false Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;              No matter 1, 2, or 3 stones you remove, the last stone will always be               removed by your friend. Easy Brainteaser One line O(1) solution and explanation Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;              No matter 1, 2, or 3 stones you remove, the last stone will always be               removed by your friend. Easy Brainteaser O(1) Efficient Single-line Java using Bit Checking Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;              No matter 1, 2, or 3 stones you remove, the last stone will always be               removed by your friend. Easy Brainteaser Two Java Solution. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;              No matter 1, 2, or 3 stones you remove, the last stone will always be               removed by your friend. Easy Brainteaser 1 line 0 ms C++ solution with explanation Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;              No matter 1, 2, or 3 stones you remove, the last stone will always be               removed by your friend. Easy Brainteaser Short simple Java/C++/Python, O(log n) + O(1) Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:  void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.    Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2    Follow up:  If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?   Hard Heap Design Share my java solution logn to insert, O(1) to query Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:  void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.    Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2    Follow up:  If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?   Hard Heap Design Java/Python two heap solution, O(log n) add, O(1) find Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:  void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.    Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2    Follow up:  If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?   Hard Heap Design Easy to understand double-heap solution in Java Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:  void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.    Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2    Follow up:  If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?   Hard Heap Design Very Short, O(log n) + O(1) Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:  void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.    Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2    Follow up:  If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?   Hard Heap Design Easy to understand Java Solution Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Hard Tree Design Recursive preorder, Python and C++, O(n) Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Hard Tree Design Short and straight forward BFS Java code with a queue Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Hard Tree Design Clean C++ solution Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Hard Tree Design Recursive DFS, Iterative DFS and BFS Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Hard Tree Design One pass Java solution Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. Medium Hash Table [C++] 4ms Straight forward solution two pass O(N) time Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. Medium Hash Table My 3ms Java solution may help u Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. Medium Hash Table Python 3 lines solution Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. Medium Hash Table 3 lines in Python Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. Medium Hash Table Java/Python Binary search O(nlogn) time with explanation Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?  Medium Binary Search Dynamic Programming Short Java solution using DP O(n log n) Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?  Medium Binary Search Dynamic Programming 9 lines C++ code with O(NlogN) complexity Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?  Medium Binary Search Dynamic Programming My easy to understand O(n^2) solution using DP with video explanation Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?  Medium Binary Search Dynamic Programming [C++] Typical DP N^2 solution and NLogN solution from GeekForGeek Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?  Medium Binary Search Dynamic Programming Easy, Short, Concise and Fast Java DFS 3 ms solution Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]  Hard Depth-first Search Breadth-first Search Share my Java BFS solution Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]  Hard Depth-first Search Breadth-first Search Easiest 9ms Java Solution Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]  Hard Depth-first Search Breadth-first Search Short Python BFS Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]  Hard Depth-first Search Breadth-first Search My C++ DFS Solution - 16ms Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]  Hard Depth-first Search Breadth-first Search Java simple O(n) init and O(1) query solution Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.   Easy Dynamic Programming 5-lines C++, 4-lines Python Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.   Easy Dynamic Programming C++ O(1) queries - just 2 extra lines of code Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.   Easy Dynamic Programming A very short Python solution Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.   Easy Dynamic Programming My java 3ms solution Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.   Easy Dynamic Programming Clean C++ Solution and Explaination - O(mn) space with O(1) time Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.   Medium Dynamic Programming Clean and easy to understand java solution Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.   Medium Dynamic Programming Sharing My Python solution Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.   Medium Dynamic Programming C++ with helper Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.   Medium Dynamic Programming Very clean and fast java solution Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.   Medium Dynamic Programming Java Recursive and Iterative Solutions Additive Number Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: "112358" Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.               1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2: Input: "199100199" Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.               1 + 99 = 100, 99 + 100 = 199 Follow up: How would you handle overflow for very large input integers? Medium Backtracking 0ms concise C++ solution (perfectly handles the follow-up and leading 0s) Additive Number Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: "112358" Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.               1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2: Input: "199100199" Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.               1 + 99 = 100, 99 + 100 = 199 Follow up: How would you handle overflow for very large input integers? Medium Backtracking *Java* very straightforward solution with detailed explanation Additive Number Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: "112358" Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.               1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2: Input: "199100199" Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.               1 + 99 = 100, 99 + 100 = 199 Follow up: How would you handle overflow for very large input integers? Medium Backtracking Python solution Additive Number Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: "112358" Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.               1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2: Input: "199100199" Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.               1 + 99 = 100, 99 + 100 = 199 Follow up: How would you handle overflow for very large input integers? Medium Backtracking Java Easy Understand DFS Additive Number Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: "112358" Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.               1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2: Input: "199100199" Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.               1 + 99 = 100, 99 + 100 = 199 Follow up: How would you handle overflow for very large input integers? Medium Backtracking 17 ms Java solution with segment tree Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8  Note:  The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.   Medium Binary Indexed Tree Segment Tree Java using Binary Indexed Tree with clear explanation Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8  Note:  The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.   Medium Binary Indexed Tree Segment Tree "0 lines" Python Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8  Note:  The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.   Medium Binary Indexed Tree Segment Tree C++ solution using "buckets". O(1) for updating and O(n^0.5) for query in the worst case (not the fast). Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8  Note:  The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.   Medium Binary Indexed Tree Segment Tree Python: Well commented solution using Segment Trees Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8  Note:  The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.   Medium Binary Indexed Tree Segment Tree Share my thinking process Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]  Medium Dynamic Programming Share my DP solution (By State Machine Thinking) Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]  Medium Dynamic Programming Easiest JAVA solution with explanations Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]  Medium Dynamic Programming 7-line Java: only consider sell and cooldown Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]  Medium Dynamic Programming Very Easy to Understand One Pass O(n) Solution with No Extra Space Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]  Medium Dynamic Programming Share some thoughts Minimum Height Trees For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \       2   3   Output: [1]  Example 2 : Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \ | /         3         |         4         |         5   Output: [3, 4] Note:  According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Medium Breadth-first Search Graph Two O(n) solutions Minimum Height Trees For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \       2   3   Output: [1]  Example 2 : Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \ | /         3         |         4         |         5   Output: [3, 4] Note:  According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Medium Breadth-first Search Graph C++ Solution. O(n)-Time, O(n)-Space Minimum Height Trees For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \       2   3   Output: [1]  Example 2 : Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \ | /         3         |         4         |         5   Output: [3, 4] Note:  According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Medium Breadth-first Search Graph C++ BFS short clean solution with explanation Minimum Height Trees For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \       2   3   Output: [1]  Example 2 : Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \ | /         3         |         4         |         5   Output: [3, 4] Note:  According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Medium Breadth-first Search Graph Share my BFS JAVA code using degree with explanation, which beats more than 95% Minimum Height Trees For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \       2   3   Output: [1]  Example 2 : Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \ | /         3         |         4         |         5   Output: [3, 4] Note:  According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Medium Breadth-first Search Graph Share some analysis and explanations Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167  Hard Divide and Conquer Dynamic Programming C++ dynamic programming, O(N^3), 32 ms, with comments Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167  Hard Divide and Conquer Dynamic Programming For anyone that is still confused after reading all kinds of explanations... Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167  Hard Divide and Conquer Dynamic Programming Java DP solution with detailed explanation, O(n^3) Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167  Hard Divide and Conquer Dynamic Programming Easiest Java Solution Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167  Hard Divide and Conquer Dynamic Programming Java three methods, 23ms, 36 ms, 58ms(with heap), performance explained Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   Medium Math Heap 7 line consice O(kn) c++ solution Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   Medium Math Heap 108ms easy to understand java solution Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   Medium Math Heap Python, generators on a heap Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   Medium Math Heap Java solution\uff0c21ms\uff0c\u8be6\u7ec6\u7684\u4e2d\u6587\u89e3\u91ca Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   Medium Math Heap 9ms  short Java BST solution get answer when building BST Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree Mergesort solution Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree 11ms JAVA solution using merge sort with explanation Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree My simple AC Java Binary Search code Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree C++ O(nlogn)-Time O(n)-Space MergeSort Solution with Detail Explanation Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree A short O(n) recursive greedy solution Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"  Hard Stack Greedy Java solution using Stack with comments Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"  Hard Stack Greedy Easy to understand iterative Java solution Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"  Hard Stack Greedy C++ simple solution easy understanding Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"  Hard Stack Greedy Java O(n) solution using stack with detail explanation Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"  Hard Stack Greedy JAVA----------Easy Version To Understand!!!!!!!!!!!!!!!!! Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: ["abcw","baz","foo","bar","xtfn","abcdef"] Output: 16  Explanation: The two words can be "abcw", "xtfn". Example 2: Input: ["a","ab","abc","d","cd","bcd","abcd"] Output: 4  Explanation: The two words can be "ab", "cd". Example 3: Input: ["a","aa","aaa","aaaa"] Output: 0  Explanation: No such pair of words.  Medium Bit Manipulation 32ms Java AC solution Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: ["abcw","baz","foo","bar","xtfn","abcdef"] Output: 16  Explanation: The two words can be "abcw", "xtfn". Example 2: Input: ["a","ab","abc","d","cd","bcd","abcd"] Output: 4  Explanation: The two words can be "ab", "cd". Example 3: Input: ["a","aa","aaa","aaaa"] Output: 0  Explanation: No such pair of words.  Medium Bit Manipulation Bit shorter C++ Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: ["abcw","baz","foo","bar","xtfn","abcdef"] Output: 16  Explanation: The two words can be "abcw", "xtfn". Example 2: Input: ["a","ab","abc","d","cd","bcd","abcd"] Output: 4  Explanation: The two words can be "ab", "cd". Example 3: Input: ["a","aa","aaa","aaaa"] Output: 0  Explanation: No such pair of words.  Medium Bit Manipulation Python solution, beats 99.67% Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: ["abcw","baz","foo","bar","xtfn","abcdef"] Output: 16  Explanation: The two words can be "abcw", "xtfn". Example 2: Input: ["a","ab","abc","d","cd","bcd","abcd"] Output: 4  Explanation: The two words can be "ab", "cd". Example 3: Input: ["a","aa","aaa","aaaa"] Output: 0  Explanation: No such pair of words.  Medium Bit Manipulation Java Solution with comments Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: ["abcw","baz","foo","bar","xtfn","abcdef"] Output: 16  Explanation: The two words can be "abcw", "xtfn". Example 2: Input: ["a","ab","abc","d","cd","bcd","abcd"] Output: 4  Explanation: The two words can be "ab", "cd". Example 3: Input: ["a","aa","aaa","aaaa"] Output: 0  Explanation: No such pair of words.  Medium Bit Manipulation Math solution.. Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.   Medium Math Brainteaser Share my o(1) solution with explanation Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.   Medium Math Brainteaser My 0 ms C++ solution with explanation Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.   Medium Math Brainteaser The simplest and most efficient solution well-explained Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.   Medium Math Brainteaser One line java with explanation Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.   Medium Math Brainteaser Share my greedy solution Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]  Hard Dynamic Programming Greedy C++ 16ms, FASTEST, beats 97%. Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]  Hard Dynamic Programming Greedy Short Python / Ruby / C++ Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]  Hard Dynamic Programming Greedy Share my 21ms java solution with comments Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]  Hard Dynamic Programming Greedy Share my Python solution with explanation Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]  Hard Dynamic Programming Greedy [C++] O(n*amount) time O(amount) space DP solution Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.  Medium Dynamic Programming *Java* Both iterative and recursive solutions with explanations Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.  Medium Dynamic Programming Easy-To-Understand Recursive DP solution using Java (with explanations) Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.  Medium Dynamic Programming Clean dp python code Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.  Medium Dynamic Programming Fast Python BFS Solution Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.  Medium Dynamic Programming O(n)+O(1) after median --- Virtual Indexing Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Medium Sort Step by step explanation of index mapping in Java Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Medium Sort 3 lines Python, with Explanation / Proof Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Medium Sort Summary of the various solutions to Wiggle Sort for your reference Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Medium Sort O(n)-time O(1)-space solution with detail explanations Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Medium Sort 1 line java solution without loop / recursion Power of Three Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Easy Math ** A summary of `all` solutions (new method included at 15:30pm Jan-8th) Power of Three Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Easy Math Without log and O(1). Power of Three Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Easy Math 1 line C++ no recursion/loop Power of Three Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Easy Math One line (cheating) Power of Three Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Easy Math Share my solution Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  Hard Divide and Conquer Binary Search Tree Summary of the Divide and Conquer based and Binary Indexed Tree based solutions Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  Hard Divide and Conquer Binary Search Tree Short & simple O(n log n) Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  Hard Divide and Conquer Binary Search Tree Java SegmentTree Solution, 36ms Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  Hard Divide and Conquer Binary Search Tree C++ merge sort solution, very short Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  Hard Divide and Conquer Binary Search Tree Simple O(N) time, O(1), space Java solution. Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL  Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL  Note:  The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...   Medium Linked List Straigntforward Java solution, O(1) space, O(n) time Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL  Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL  Note:  The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...   Medium Linked List Simple C++ solution, O(n) time, O(1) space Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL  Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL  Note:  The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...   Medium Linked List Clear Python Solution Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL  Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL  Note:  The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...   Medium Linked List 1ms Java Solution Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL  Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL  Note:  The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...   Medium Linked List 15ms Concise Java Solution Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  Hard Depth-first Search Topological Sort Memoization Python solution, memoization dp, 288ms Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  Hard Depth-first Search Topological Sort Memoization Graph theory, Java solution, O(v^2), no DFS Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  Hard Depth-first Search Topological Sort Memoization Java 14ms relative short & easy to code solution with explanation. O(mn) time O(mn) space. DFS + DP Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  Hard Depth-first Search Topological Sort Memoization C++ DP / DFS solution sharing Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  Hard Depth-first Search Topological Sort Memoization Solution + explanation Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0  Hard Greedy Share my thinking process Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0  Hard Greedy C++, 8ms, greedy solution with explanation Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0  Hard Greedy Share my greedy solution by Java with simple explanation (time: 1 ms) Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0  Hard Greedy My simple accepted C++ solution Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0  Hard Greedy 7 lines Easy Java Solution Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.      _9_     /   \    3     2   / \   / \  4   1  #  6 / \ / \   / \ # # # #   # #  For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3". Example 1: Input: "9,3,4,#,#,1,#,#,2,#,6,#,#" Output: true Example 2: Input: "1,#" Output: false  Example 3: Input: "9,#,#,1" Output: false Medium Stack Java intuitive 22ms solution with stack Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.      _9_     /   \    3     2   / \   / \  4   1  #  6 / \ / \   / \ # # # #   # #  For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3". Example 1: Input: "9,3,4,#,#,1,#,#,2,#,6,#,#" Output: true Example 2: Input: "1,#" Output: false  Example 3: Input: "9,#,#,1" Output: false Medium Stack The simplest python solution with explanation (no stack, no recursion) Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.      _9_     /   \    3     2   / \   / \  4   1  #  6 / \ / \   / \ # # # #   # #  For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3". Example 1: Input: "9,3,4,#,#,1,#,#,2,#,6,#,#" Output: true Example 2: Input: "1,#" Output: false  Example 3: Input: "9,#,#,1" Output: false Medium Stack JAVA, Counting Indegree and Outdegree, SIMPLE & CLEAR! Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.      _9_     /   \    3     2   / \   / \  4   1  #  6 / \ / \   / \ # # # #   # #  For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3". Example 1: Input: "9,3,4,#,#,1,#,#,2,#,6,#,#" Output: true Example 2: Input: "1,#" Output: false  Example 3: Input: "9,#,#,1" Output: false Medium Stack Simple Python solution using stack. With Explanation. Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.      _9_     /   \    3     2   / \   / \  4   1  #  6 / \ / \   / \ # # # #   # #  For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3". Example 1: Input: "9,3,4,#,#,1,#,#,2,#,6,#,#" Output: true Example 2: Input: "1,#" Output: false  Example 3: Input: "9,#,#,1" Output: false Medium Stack Short Ruby / Python / Java / C++ Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.   Medium Depth-first Search Graph Share my solution Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.   Medium Depth-first Search Graph Short C++ DFS iterative 44ms solution with explanation.  No recursive calls, no backtracking. Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.   Medium Depth-first Search Graph [Share Solution] Java, Greedy, Stack, 15ms with explanation Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.   Medium Depth-first Search Graph Very Straightforward DFS Solution with Detailed Explanations Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.   Medium Depth-first Search Graph Concise Java solution with comments. Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.  Example 1: Input: [1,2,3,4,5] Output: true   Example 2: Input: [5,4,3,2,1] Output: false    Medium Clean and short, with comments, C++ Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.  Example 1: Input: [1,2,3,4,5] Output: true   Example 2: Input: [5,4,3,2,1] Output: false    Medium Python Easy O(n) Solution Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.  Example 1: Input: [1,2,3,4,5] Output: true   Example 2: Input: [5,4,3,2,1] Output: false    Medium My accepted JAVA solution for this question, only 7-lines, clear and concise. Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.  Example 1: Input: [1,2,3,4,5] Output: true   Example 2: Input: [5,4,3,2,1] Output: false    Medium Simple Java Solution...Easy to understand!!!! Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.  Example 1: Input: [1,2,3,4,5] Output: true   Example 2: Input: [5,4,3,2,1] Output: false    Medium Java Oms with explanation Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Input: [2,1,1,2]  ????? ?   ? ???????>     ?  Input: true  Explanation: self crossing  Example 2: Input: [1,2,3,4]  ???????? ?      ? ? ? ?????????????>  Output: false  Explanation: not self crossing  Example 3: Input: [1,1,1,1]  ????? ?   ? ?????>  Output: true  Explanation: self crossing  Hard Math Another python... Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Input: [2,1,1,2]  ????? ?   ? ???????>     ?  Input: true  Explanation: self crossing  Example 2: Input: [1,2,3,4]  ???????? ?      ? ? ? ?????????????>  Output: false  Explanation: not self crossing  Example 3: Input: [1,1,1,1]  ????? ?   ? ?????>  Output: true  Explanation: self crossing  Hard Math Simple Java Solution Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Input: [2,1,1,2]  ????? ?   ? ???????>     ?  Input: true  Explanation: self crossing  Example 2: Input: [1,2,3,4]  ???????? ?      ? ? ? ?????????????>  Output: false  Explanation: not self crossing  Example 3: Input: [1,1,1,1]  ????? ?   ? ?????>  Output: true  Explanation: self crossing  Hard Math The best submission in C searching for the crossing patterns is the key Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Input: [2,1,1,2]  ????? ?   ? ???????>     ?  Input: true  Explanation: self crossing  Example 2: Input: [1,2,3,4]  ???????? ?      ? ? ? ?????????????>  Output: false  Explanation: not self crossing  Example 3: Input: [1,1,1,1]  ????? ?   ? ?????>  Output: true  Explanation: self crossing  Hard Math C++ simple solution Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Input: [2,1,1,2]  ????? ?   ? ???????>     ?  Input: true  Explanation: self crossing  Example 2: Input: [1,2,3,4]  ???????? ?      ? ? ? ?????????????>  Output: false  Explanation: not self crossing  Example 3: Input: [1,1,1,1]  ????? ?   ? ?????>  Output: true  Explanation: self crossing  Hard Math O(n * k^2) java solution with Trie structure Palindrome Pairs Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]    Hard Hash Table String Trie 150 ms 45 lines JAVA solution Palindrome Pairs Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]    Hard Hash Table String Trie The Easy-to-unserstand JAVA Solution Palindrome Pairs Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]    Hard Hash Table String Trie Accepted Python Solution With Explanation Palindrome Pairs Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]    Hard Hash Table String Trie Easy to understand AC C++ solution O(n*k^2) using map Palindrome Pairs Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]    Hard Hash Table String Trie Step by step tackling of the problem House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.  Medium Tree Depth-first Search Easy understanding solution with dfs House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.  Medium Tree Depth-first Search Simple C++ solution House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.  Medium Tree Depth-first Search Easy to understand(java) House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.  Medium Tree Depth-first Search C++, JAVA, PYTHON &  explanation House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.  Medium Tree Depth-first Search Three-Line Java Solution Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  Medium Dynamic Programming Bit Manipulation Four lines, C++, time O(n), space O(n) Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  Medium Dynamic Programming Bit Manipulation How we handle this question on interview [Thinking process + DP solution] Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  Medium Dynamic Programming Bit Manipulation Simple Java O(n) solution using two pointers Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  Medium Dynamic Programming Bit Manipulation Simple Java Dynamic Programming without any bitwise operation Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  Medium Dynamic Programming Bit Manipulation Simple Java solution using a stack with explanation Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1:  Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,1,2,1,1].  Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,4,6].     Medium Stack Design Real iterator in Python, Java, C++ Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1:  Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,1,2,1,1].  Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,4,6].     Medium Stack Design Share my Java neat solution, 8ms Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1:  Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,1,2,1,1].  Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,4,6].     Medium Stack Design 8-line Python Solution Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1:  Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,1,2,1,1].  Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,4,6].     Medium Stack Design Concise C++ without storing all values at initialization Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1:  Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,1,2,1,1].  Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,               the order of elements returned by next should be: [1,4,6].     Medium Stack Design Java 1-line (cheating for the purpose of not using loops) Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true   Example 2: Input: 5 Output: false  Follow up: Could you solve it without loops/recursion? Easy Bit Manipulation 1 line C++ solution without confusing bit manipulations Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true   Example 2: Input: 5 Output: false  Follow up: Could you solve it without loops/recursion? Easy Bit Manipulation O(1) one-line solution without loops Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true   Example 2: Input: 5 Output: false  Follow up: Could you solve it without loops/recursion? Easy Bit Manipulation Python one line solution with explanations Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true   Example 2: Input: 5 Output: false  Follow up: Could you solve it without loops/recursion? Easy Bit Manipulation Simple C++ O(1) solution without 0x55555555 Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true   Example 2: Input: 5 Output: false  Follow up: Could you solve it without loops/recursion? Easy Bit Manipulation Why factor 2 or 3? The math behind this problem. Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.   Medium Math Dynamic Programming A simple explanation of the math part and a O(n) solution Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.   Medium Math Dynamic Programming Java DP solution Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.   Medium Math Dynamic Programming O(log(n)) Time solution with explanation Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.   Medium Math Dynamic Programming Easy to understand C++ with explanation Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.   Medium Math Dynamic Programming [JAVA] Simple and Clean with Explanations [6 Solutions] Reverse String Write a function that takes a string as input and returns the string reversed. Example 1:  Input: "hello" Output: "olleh"   Example 2: Input: "A man, a plan, a canal: Panama" Output: "amanaP :lanac a ,nalp a ,nam A"     Easy Two Pointers String Python2.7 (3 solutions: Recursive, Classic, Pythonic) Reverse String Write a function that takes a string as input and returns the string reversed. Example 1:  Input: "hello" Output: "olleh"   Example 2: Input: "A man, a plan, a canal: Panama" Output: "amanaP :lanac a ,nalp a ,nam A"     Easy Two Pointers String Simple C++ solution Reverse String Write a function that takes a string as input and returns the string reversed. Example 1:  Input: "hello" Output: "olleh"   Example 2: Input: "A man, a plan, a canal: Panama" Output: "amanaP :lanac a ,nalp a ,nam A"     Easy Two Pointers String Python solution Reverse String Write a function that takes a string as input and returns the string reversed. Example 1:  Input: "hello" Output: "olleh"   Example 2: Input: "A man, a plan, a canal: Panama" Output: "amanaP :lanac a ,nalp a ,nam A"     Easy Two Pointers String C solution sharing Reverse String Write a function that takes a string as input and returns the string reversed. Example 1:  Input: "hello" Output: "olleh"   Example 2: Input: "A man, a plan, a canal: Panama" Output: "amanaP :lanac a ,nalp a ,nam A"     Easy Two Pointers String Java Standard Two Pointer Solution Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".    Easy Two Pointers String Super clean C++ solution using find_first_of and find_last_of Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".    Easy Two Pointers String 1-2 lines Python/Ruby Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".    Easy Two Pointers String Python 2 Pointers Solution Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".    Easy Two Pointers String One pass Java Solution 13ms Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".    Easy Two Pointers String Java O(n) Solution - Bucket Sort Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.   Medium Hash Table Heap 3 Java Solution using Array, MaxHeap, TreeMap Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.   Medium Hash Table Heap C++ O(n log(n-k)) unordered_map and priority_queue(maxheap) solution Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.   Medium Hash Table Heap 3 ways to solve this problem Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.   Medium Hash Table Heap Simple C++ solution using hash table and bucket sort Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.   Medium Hash Table Heap Three Java Solutions Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.     Easy Hash Table Two Pointers Binary Search Sort 8ms concise C++ using unordered_set Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.     Easy Hash Table Two Pointers Binary Search Sort Small C++ solution Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.     Easy Hash Table Two Pointers Binary Search Sort 5ms Java Using 1 hashset and time complexity of O(m+n) Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.     Easy Hash Table Two Pointers Binary Search Sort Python code, 3 lines using set Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.     Easy Hash Table Two Pointers Binary Search Sort Solution to 3rd follow-up question Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   Easy Hash Table Two Pointers Binary Search Sort AC solution using Java HashMap Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   Easy Hash Table Two Pointers Binary Search Sort C++ hash table solution and sort + two pointers solution with time and space complexity Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   Easy Hash Table Two Pointers Binary Search Sort Short Python / C++ Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   Easy Hash Table Two Pointers Binary Search Sort 2 lines in Python Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   Easy Hash Table Two Pointers Binary Search Sort Java solution using TreeMap, real O(logN) per adding. Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? Hard Binary Search Tree Very concise c++ solution. Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? Hard Binary Search Tree Share my python solution using heap Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? Hard Binary Search Tree Java fast log (N) solution (186ms) without using the TreeMap but a customized BST Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? Hard Binary Search Tree I can not understand the question description, can any one explain it? Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? Hard Binary Search Tree Java NLogN Solution with Explanation Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).    Hard Binary Search Dynamic Programming Simple DP solution Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).    Hard Binary Search Dynamic Programming [[1,3],[3,5],[6,7],[6,8],[8,4],[9,5]] should be 4 not 3 Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).    Hard Binary Search Dynamic Programming C++ 9-line Short and Clean O(nlogn) solution (plus classic O(n^2) dp solution). Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).    Hard Binary Search Dynamic Programming A Trick to solve this problem. Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).    Hard Binary Search Dynamic Programming Java OO Design with most efficient function getNewsFeed Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);   Medium Hash Table Heap Design Python solution Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);   Medium Hash Table Heap Design Java Solutions with Two Maps and PriorityQueue Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);   Medium Hash Table Heap Design 72ms C++ solution Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);   Medium Hash Table Heap Design Java OOD solution with detailed explanation Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);   Medium Hash Table Heap Design JAVA DP O(1) solution. Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99   Medium Math Dynamic Programming Backtracking Java, O(1), with explanation Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99   Medium Math Dynamic Programming Backtracking Share my 0ms C++ solution with proof and explanation Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99   Medium Math Dynamic Programming Backtracking Backtracking solution Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99   Medium Math Dynamic Programming Backtracking Simple Python solution, 90% Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99   Medium Math Dynamic Programming Backtracking Accepted C++ codes with explanation and references Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?  Hard Binary Search Dynamic Programming Queue Java Binary Search solution time complexity min(m,n)^2*max(m,n)*log(max(m,n)) Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?  Hard Binary Search Dynamic Programming Queue 2 Accepted Java Solution Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?  Hard Binary Search Dynamic Programming Queue JAVA 117ms, beat 99.81%, merge sort Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?  Hard Binary Search Dynamic Programming Queue Any Accepted Python Solution? Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?  Hard Binary Search Dynamic Programming Queue Math solution - Java solution Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False  Medium Math This problem should be classified as HARD Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False  Medium Math A little explanation on GCD method. C++/Java/Python Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False  Medium Math Breadth-First Search with explanation. Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False  Medium Math Clear Explanation of Why Using GCD Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False  Medium Math A square number is 1+3+5+7+..., JAVA code Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false    Easy Math Binary Search 3-4 short lines, Integer Newton, Most Languages Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false    Easy Math Binary Search Java Three Solutions 1,3,5,.. Sequence/Binary Search/Newton Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false    Easy Math Binary Search O(1) time c++ solution inspired by Q_rsqrt Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false    Easy Math Binary Search O(logN) Bisection method Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false    Easy Math Binary Search Classic DP solution similar to LIS, O(n^2) Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]    Medium Math Dynamic Programming C++ Solution with Explanations Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]    Medium Math Dynamic Programming 4 lines in Python Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]    Medium Math Dynamic Programming Easy understood Java DP solution in 28ms with O(n^2) time Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]    Medium Math Dynamic Programming Java Solution in 32ms O(N^2) time, O(N) space Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]    Medium Math Dynamic Programming A summary: how to use bit manipulation to solve problems easily and efficiently Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.  Example 1: Input: a = 1, b = 2 Output: 3   Example 2: Input: a = -2, b = 3 Output: 1    Easy Bit Manipulation Java simple easy understand solution with explanation Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.  Example 1: Input: a = 1, b = 2 Output: 3   Example 2: Input: a = -2, b = 3 Output: 1    Easy Bit Manipulation Python solution with no "+-*/%", completely bit manipulation guaranteed Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.  Example 1: Input: a = 1, b = 2 Output: 3   Example 2: Input: a = -2, b = 3 Output: 1    Easy Bit Manipulation Share my C++ solutions,easy to understand Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.  Example 1: Input: a = 1, b = 2 Output: 3   Example 2: Input: a = -2, b = 3 Output: 1    Easy Bit Manipulation Simple explanation on how to arrive at the solution  Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.  Example 1: Input: a = 1, b = 2 Output: 3   Example 2: Input: a = -2, b = 3 Output: 1    Easy Bit Manipulation C++ Clean and Short Solution Super Pow Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024    Medium Math Math solusion based on Euler's theorem, power called only ONCE, C++/Java/1-line-Python Super Pow Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024    Medium Math What's the point of this kind of question? Super Pow Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024    Medium Math Java 4ms solution using the remainder repeat pattern Super Pow Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024    Medium Math Fermat and Chinese Remainder Super Pow Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024    Medium Math simple Java O(KlogK) solution with explanation Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:               [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:               [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  Medium Heap Slow 1-liner to Fast solutions Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:               [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:               [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  Medium Heap Share My Solution which beat 96.42% Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:               [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:               [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  Medium Heap Java 9ms heap queue solution, k log(k) Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:               [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:               [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  Medium Heap Clean 16ms C++ O(N) Space O(KlogN) Time Solution using Priority queue Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:               [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:               [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  Medium Heap The key point is to read the problem carefully. Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6    Easy Binary Search 2 lines as usual Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6    Easy Binary Search 0ms c++ binary search Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6    Easy Binary Search Short Java code using binary search Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6    Easy Binary Search I hope developers of Leetcode can make the question definition more clear. Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6    Easy Binary Search Simple DP solution with explanation~~ Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Medium Dynamic Programming Minimax Improve the Question and Example Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Medium Dynamic Programming Minimax Clarification on the problem description. [Problem description need to be updated !!! ] Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Medium Dynamic Programming Minimax Java DP solution Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Medium Dynamic Programming Minimax Java commented DP solution Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Medium Dynamic Programming Minimax Easy understanding DP solution with O(n), Java version Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?    Medium Dynamic Programming Greedy Very Simple Java Solution with detail explanation Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?    Medium Dynamic Programming Greedy C++ 0ms O(N) dynamic programming solution Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?    Medium Dynamic Programming Greedy Two solutions. One is DP, the other is greedy (8 lines). Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?    Medium Dynamic Programming Greedy 3 lines O(n) Python with explanation/proof Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?    Medium Dynamic Programming Greedy 1ms Java DP Solution with Detailed Explanation Combination Sum IV  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Dynamic Programming My 3ms Java DP solution Combination Sum IV  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Dynamic Programming Are you kidding me? It is Combination?? Combination Sum IV  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Dynamic Programming C++ template for ALL Combination Problem Set Combination Sum IV  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Dynamic Programming JAVA recursion solution using HashMap as memory. Combination Sum IV  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Dynamic Programming Share my thoughts and Clean Java Code Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2. Medium Binary Search Heap Java 1ms nlog(max -min) solution Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2. Medium Binary Search Heap O(n) from paper. Yes, O(#rows). Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2. Medium Binary Search Heap My solution using Binary Search in C++ Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2. Medium Binary Search Heap Binary Search, Heap and Sorting comparison, with concise code and 1-liners, Python 72 ms Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2. Medium Binary Search Heap Java solution using a HashMap and an ArrayList along with a follow-up. (131 ms) Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();   Medium Array Hash Table Design Simple solution in Python Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();   Medium Array Hash Table Design AC C++ Solution. Unordered_map + Vector Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();   Medium Array Hash Table Design JAVA Solution, concise code with HashMap and ArrayList, easy to understand Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();   Medium Array Hash Table Design Java solution with two HashMaps: easy to understand Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();   Medium Array Hash Table Design C++ 128m Solution, Real O(1) Solution Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();   Hard Array Hash Table Design Java HaspMap, LinkedHashSet, ArrayList (155 ms) Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();   Hard Array Hash Table Design Frugal Python code Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();   Hard Array Hash Table Design Clean O(1) Java Solution with HashMap and Set Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();   Hard Array Hash Table Design Easy Understanding Java Solution using HashSet Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();   Hard Array Hash Table Design Brief explanation for Reservoir Sampling Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?  Example: // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();   Medium Reservoir Sampling Java Solution with cases explain Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?  Example: // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();   Medium Reservoir Sampling using "Reservoir sampling" O(1) space, O(n) time complexity\uff0cc++ Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?  Example: // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();   Medium Reservoir Sampling O(n) Time & O(1) Space Java Solution Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?  Example: // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();   Medium Reservoir Sampling "buffered" reservoir sampling Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?  Example: // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();   Medium Reservoir Sampling Java O(n) Solution---Easy to understand Ransom Note  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true   Easy String O(m+n) one-liner Python Ransom Note  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true   Easy String Java Map solution Ransom Note  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true   Easy String Share My Easy to Understand 5 lines of Java Code, 13ms beats 96% Ransom Note  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true   Easy String Two AC C++ solutions (unordered_map/vector) Ransom Note  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true   Easy String First Accepted Solution - Java Shuffle an Array Shuffle a set of numbers without duplicates.  Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums);  // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle();  // Resets the array back to its original configuration [1,2,3]. solution.reset();  // Returns the random shuffling of array [1,2,3]. solution.shuffle();   Medium Python hack Shuffle an Array Shuffle a set of numbers without duplicates.  Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums);  // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle();  // Resets the array back to its original configuration [1,2,3]. solution.reset();  // Returns the random shuffling of array [1,2,3]. solution.shuffle();   Medium simple java solution Shuffle an Array Shuffle a set of numbers without duplicates.  Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums);  // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle();  // Resets the array back to its original configuration [1,2,3]. solution.reset();  // Returns the random shuffling of array [1,2,3]. solution.shuffle();   Medium Straight-forward C++ solution Shuffle an Array Shuffle a set of numbers without duplicates.  Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums);  // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle();  // Resets the array back to its original configuration [1,2,3]. solution.reset();  // Returns the random shuffling of array [1,2,3]. solution.shuffle();   Medium easy python solution based on generating random index and swapping Shuffle an Array Shuffle a set of numbers without duplicates.  Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums);  // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle();  // Resets the array back to its original configuration [1,2,3]. solution.reset();  // Returns the random shuffling of array [1,2,3]. solution.shuffle();   Medium An Java Iterative Solution Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.   Medium String Stack Clarification Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.   Medium String Stack Python & C++ solutions Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.   Medium String Stack C++ Non-Recursive One-Pass Solution (using Stack) || A Possible Implementation of NestedInteger Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.   Medium String Stack Short Java recursive solution Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.   Medium String Stack Java O(n) time, O(1) space iterative solution 130ms Lexicographical Numbers  Given an integer n, return 1 - n in lexicographical order.   For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.  Medium Simple Java DFS Solution Lexicographical Numbers  Given an integer n, return 1 - n in lexicographical order.   For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.  Medium AC 200ms c++ solution, beats 98% Lexicographical Numbers  Given an integer n, return 1 - n in lexicographical order.   For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.  Medium The most elegant python solution so far. 10 liner. iterative. O(n) time, O(1) space. Lexicographical Numbers  Given an integer n, return 1 - n in lexicographical order.   For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.  Medium Python with Sorting Lexicographical Numbers  Given an integer n, return 1 - n in lexicographical order.   For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.  Medium Java 7 lines solution 29ms First Unique Character in a String  Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.  Easy Hash Table String Python 3 lines beats 100% (~ 60ms) ! First Unique Character in a String  Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.  Easy Hash Table String Java One Pass Solution with LinkedHashMap First Unique Character in a String  Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.  Easy Hash Table String JavaScript solution First Unique Character in a String  Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.  Easy Hash Table String C++ 2 solutions First Unique Character in a String  Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.  Easy Hash Table String 9 lines 4ms Java solution Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents: dir     subdir1     subdir2         file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents: dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:  The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a ..   Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Medium Simple Python solution Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents: dir     subdir1     subdir2         file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents: dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:  The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a ..   Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Medium This problem is not well-defined. It should state that 4-space is considered as a TAB under certain situation. Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents: dir     subdir1     subdir2         file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents: dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:  The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a ..   Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Medium Simple C++ O(n) Solution,0ms Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents: dir     subdir1     subdir2         file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents: dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:  The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a ..   Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Medium Java O(n) Solution Using Stack Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents: dir     subdir1     subdir2         file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents: dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:  The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a ..   Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Medium Java solution using bit manipulation Find the Difference  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.  Easy Hash Table Bit Manipulation Simple JAVA 8ms solution, 4 lines Find the Difference  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.  Easy Hash Table Bit Manipulation Concise C++ solution using XOR Find the Difference  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.  Easy Hash Table Bit Manipulation 3 Different Python Solutions (Dictionary, Difference, XOR) Find the Difference  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.  Easy Hash Table Bit Manipulation 1-liners and 2-liner in Python Find the Difference  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.  Easy Hash Table Bit Manipulation JAVA: Easiest solution O(logN) with explanation Elimination Game  There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: Input: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6  Output: 6   Medium C 1 line solution with explanation Elimination Game  There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: Input: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6  Output: 6   Medium O(logN) solution. clear break down Elimination Game  There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: Input: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6  Output: 6   Medium one line java solution based on Josephus Problem Elimination Game  There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: Input: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6  Output: 6   Medium C++ 29ms with Complexity of Log4(N) and Explanation Elimination Game  There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: Input: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6  Output: 6   Medium Really Easy Understanding Solution(O(n), Java) Perfect Rectangle Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).  Example 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ]  Return true. All 5 rectangles together form an exact cover of a rectangular region.       Example 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ]  Return false. Because there is a gap between the two rectangular regions.       Example 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ]  Return false. Because there is a gap in the top center.       Example 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ]  Return false. Because two of the rectangles overlap with each other.     Hard O(n) solution by counting corners with detailed explaination Perfect Rectangle Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).  Example 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ]  Return true. All 5 rectangles together form an exact cover of a rectangular region.       Example 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ]  Return false. Because there is a gap between the two rectangular regions.       Example 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ]  Return false. Because there is a gap in the top center.       Example 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ]  Return false. Because two of the rectangles overlap with each other.     Hard O(n log n) sweep line solution Perfect Rectangle Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).  Example 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ]  Return true. All 5 rectangles together form an exact cover of a rectangular region.       Example 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ]  Return false. Because there is a gap between the two rectangular regions.       Example 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ]  Return false. Because there is a gap in the top center.       Example 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ]  Return false. Because two of the rectangles overlap with each other.     Hard Short Java solution with explanation (updated) Perfect Rectangle Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).  Example 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ]  Return true. All 5 rectangles together form an exact cover of a rectangular region.       Example 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ]  Return false. Because there is a gap between the two rectangular regions.       Example 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ]  Return false. Because there is a gap in the top center.       Example 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ]  Return false. Because two of the rectangles overlap with each other.     Hard Easy Understanding O(n) Python Solution Perfect Rectangle Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).  Example 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ]  Return true. All 5 rectangles together form an exact cover of a rectangular region.       Example 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ]  Return false. Because there is a gap between the two rectangular regions.       Example 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ]  Return false. Because there is a gap in the top center.       Example 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ]  Return false. Because two of the rectangles overlap with each other.     Hard Binary search solution for follow-up with detailed comments Is Subsequence  Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Binary Search Dynamic Programming Greedy Straight forward Java simple solution Is Subsequence  Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Binary Search Dynamic Programming Greedy 3 lines C Is Subsequence  Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Binary Search Dynamic Programming Greedy 2 lines Python Is Subsequence  Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Binary Search Dynamic Programming Greedy Java code for the follow-up question Is Subsequence  Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. Medium Binary Search Dynamic Programming Greedy Concise C++ implementation UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:  For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:    Char. number range  |        UTF-8 octet sequence       (hexadecimal)    |              (binary)    --------------------+---------------------------------------------    0000 0000-0000 007F | 0xxxxxxx    0000 0080-0000 07FF | 110xxxxx 10xxxxxx    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   Given an array of integers representing the data, return whether it is a valid utf-8 encoding.   Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.   Example 1: data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.  Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.    Example 2: data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.  Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.   Medium Bit Manipulation Feeling like an English reading comprehension problem UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:  For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:    Char. number range  |        UTF-8 octet sequence       (hexadecimal)    |              (binary)    --------------------+---------------------------------------------    0000 0000-0000 007F | 0xxxxxxx    0000 0080-0000 07FF | 110xxxxx 10xxxxxx    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   Given an array of integers representing the data, return whether it is a valid utf-8 encoding.   Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.   Example 1: data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.  Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.    Example 2: data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.  Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.   Medium Bit Manipulation Bit Manipulation, Java, 6ms UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:  For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:    Char. number range  |        UTF-8 octet sequence       (hexadecimal)    |              (binary)    --------------------+---------------------------------------------    0000 0000-0000 007F | 0xxxxxxx    0000 0080-0000 07FF | 110xxxxx 10xxxxxx    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   Given an array of integers representing the data, return whether it is a valid utf-8 encoding.   Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.   Example 1: data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.  Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.    Example 2: data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.  Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.   Medium Bit Manipulation one pass simple solution UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:  For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:    Char. number range  |        UTF-8 octet sequence       (hexadecimal)    |              (binary)    --------------------+---------------------------------------------    0000 0000-0000 007F | 0xxxxxxx    0000 0080-0000 07FF | 110xxxxx 10xxxxxx    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   Given an array of integers representing the data, return whether it is a valid utf-8 encoding.   Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.   Example 1: data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.  Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.    Example 2: data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.  Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.   Medium Bit Manipulation Short'n'Clean 12-lines Python solution UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:  For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:    Char. number range  |        UTF-8 octet sequence       (hexadecimal)    |              (binary)    --------------------+---------------------------------------------    0000 0000-0000 007F | 0xxxxxxx    0000 0080-0000 07FF | 110xxxxx 10xxxxxx    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   Given an array of integers representing the data, return whether it is a valid utf-8 encoding.   Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.   Example 1: data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.  Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.    Example 2: data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.  Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.   Medium Bit Manipulation 0ms simple C++ solution Decode String  Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.  You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].  Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".   Medium Stack Depth-first Search Simple Java Solution using Stack Decode String  Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.  You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].  Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".   Medium Stack Depth-first Search Share my Python Stack Simple Solution (Easy to understand) Decode String  Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.  You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].  Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".   Medium Stack Depth-first Search Java short and easy-understanding solution using stack Decode String  Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.  You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].  Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".   Medium Stack Depth-first Search Python solution using stack Decode String  Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.  You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].  Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".   Medium Stack Depth-first Search Java Strict O(N) Two-Pointer Solution Longest Substring with At Least K Repeating Characters  Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.  Example 1: Input: s = "aaabb", k = 3  Output: 3  The longest substring is "aaa", as 'a' is repeated 3 times.   Example 2: Input: s = "ababbc", k = 2  Output: 5  The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.   Medium 4 lines Python Longest Substring with At Least K Repeating Characters  Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.  Example 1: Input: s = "aaabb", k = 3  Output: 3  The longest substring is "aaa", as 'a' is repeated 3 times.   Example 2: Input: s = "ababbc", k = 2  Output: 5  The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.   Medium Java divide and conquer(recursion) solution Longest Substring with At Least K Repeating Characters  Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.  Example 1: Input: s = "aaabb", k = 3  Output: 3  The longest substring is "aaa", as 'a' is repeated 3 times.   Example 2: Input: s = "ababbc", k = 2  Output: 5  The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.   Medium C++ recursive solution Longest Substring with At Least K Repeating Characters  Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.  Example 1: Input: s = "aaabb", k = 3  Output: 3  The longest substring is "aaa", as 'a' is repeated 3 times.   Example 2: Input: s = "ababbc", k = 2  Output: 5  The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.   Medium Java 20 lines very easy solution 7ms with explanation Longest Substring with At Least K Repeating Characters  Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.  Example 1: Input: s = "aaabb", k = 3  Output: 3  The longest substring is "aaa", as 'a' is repeated 3 times.   Example 2: Input: s = "ababbc", k = 2  Output: 5  The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.   Medium Java O(n) solution with explanation Rotate Function  Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.   Medium Math Java Solution O(n) with non mathametical explaination Rotate Function  Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.   Medium Math Java solution Rotate Function  Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.   Medium Math C++ solution Rotate Function  Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.   Medium Math My O(n) Simple C++ Solution Rotate Function  Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.   Medium Math A couple of Java solutions with explanations Integer Replacement  Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1   Medium Math Bit Manipulation Java 12 line 4(5)ms iterative solution with explanations. No other data structures. Integer Replacement  Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1   Medium Math Bit Manipulation Python O(log n) time, O(1) space with explanation and proof Integer Replacement  Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1   Medium Math Bit Manipulation C++ 0ms 11 lines "DP" solution Integer Replacement  Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1   Medium Math Bit Manipulation 0 ms C++ recursion solution with Explanation Integer Replacement  Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1   Medium Math Bit Manipulation Simple Reservoir Sampling solution Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);   Medium Reservoir Sampling What on earth is meant by too much memory? Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);   Medium Reservoir Sampling C++_Time: O(n), Space: O(n)_116ms_96.41%_with clear explanation by probability Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);   Medium Reservoir Sampling Clean, understandable, O(1) momery, O(n) time, JAVA solution Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);   Medium Reservoir Sampling Simple Python solution Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);   Medium Reservoir Sampling Java AC Solution using graph Evaluate Division  Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.  Example: Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].   The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.  According to the example above: equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].    The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.  Medium Graph 9 lines "Floyd\u2013Warshall" in Python Evaluate Division  Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.  Example: Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].   The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.  According to the example above: equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].    The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.  Medium Graph 0ms C++ Union-Find Solution [EASY to UNDERSTAND] Evaluate Division  Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.  Example: Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].   The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.  According to the example above: equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].    The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.  Medium Graph Python fast BFS solution with detailed explantion Evaluate Division  Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.  Example: Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].   The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.  According to the example above: equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].    The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.  Medium Graph Esay understand Java solution, 3ms Evaluate Division  Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.  Example: Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].   The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.  According to the example above: equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].    The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.  Medium Graph Java solution Nth Digit Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Easy Math 0ms C++ Solution with Detail-Explanation Nth Digit Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Easy Math Short Python+Java Nth Digit Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Easy Math 4-liner in Python, and complexity analysis Nth Digit Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Easy Math Sharing my thinking process Nth Digit Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Easy Math Simple Python+Java Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads "3:25". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]  Note:  The order of output does not matter. The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00". The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".   Easy Backtracking Bit Manipulation Straight-forward 6-line c++ solution, no need to explain Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads "3:25". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]  Note:  The order of output does not matter. The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00". The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".   Easy Backtracking Bit Manipulation 3ms Java Solution Using Backtracking and Idea of "Permutation and Combination" Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads "3:25". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]  Note:  The order of output does not matter. The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00". The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".   Easy Backtracking Bit Manipulation Just for fun!!!!!!!   java 1ms, beats 100% Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads "3:25". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]  Note:  The order of output does not matter. The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00". The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".   Easy Backtracking Bit Manipulation straightforward java answer Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads "3:25". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]  Note:  The order of output does not matter. The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00". The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".   Easy Backtracking Bit Manipulation Straightforward Java Solution Using Stack Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.   Medium Stack Greedy A greedy method using stack, O(n) time and O(n) space Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.   Medium Stack Greedy Two algorithms with detailed explaination Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.   Medium Stack Greedy Short Python, one O(n) and one RegEx Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.   Medium Stack Greedy My Easy Understandable C++ Solution Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.   Medium Stack Greedy Java iterative and recursive solutions Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.   Easy Tree Java Solution using BFS Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.   Easy Tree 3-line c++ solution Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.   Easy Tree 3 line recursive c++ solution, no need to explain Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.   Easy Tree 4 Lines Python Recursive AC Solution Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.   Easy Tree Simple Java solution with comment Convert a Number to Hexadecimal  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  Note:  All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.   Example 1: Input: 26  Output: "1a"   Example 2: Input: -1  Output: "ffffffff"   Easy Bit Manipulation Concise C++ Solution Convert a Number to Hexadecimal  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  Note:  All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.   Example 1: Input: 26  Output: "1a"   Example 2: Input: -1  Output: "ffffffff"   Easy Bit Manipulation easy 10-line python solution with inline explanation Convert a Number to Hexadecimal  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  Note:  All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.   Example 1: Input: 26  Output: "1a"   Example 2: Input: -1  Output: "ffffffff"   Easy Bit Manipulation 1-liner in Python Convert a Number to Hexadecimal  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  Note:  All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.   Example 1: Input: 26  Output: "1a"   Example 2: Input: -1  Output: "ffffffff"   Easy Bit Manipulation Python solution Convert a Number to Hexadecimal  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  Note:  All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.   Example 1: Input: 26  Output: "1a"   Example 2: Input: -1  Output: "ffffffff"   Easy Bit Manipulation Easy concept with Python/C++/Java Solution Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  Note: The number of people is less than 1,100.   Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]   Medium Greedy Explanation of the neat Sort+Insert solution Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  Note: The number of people is less than 1,100.   Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]   Medium Greedy 6 lines  Concise C++ Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  Note: The number of people is less than 1,100.   Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]   Medium Greedy I don't understand the question. Reconstruct the queue to what? Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  Note: The number of people is less than 1,100.   Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]   Medium Greedy Java solution using Arrays.sort() and "insert sorting" idea Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  Note: The number of people is less than 1,100.   Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]   Medium Greedy Java solution using PriorityQueue Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.   Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.   Example: Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.   The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.    After the rain, water is trapped between the blocks. The total volume of water trapped is 4.  Hard Heap Breadth-first Search Visualization - No Code Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.   Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.   Example: Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.   The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.    After the rain, water is trapped between the blocks. The total volume of water trapped is 4.  Hard Heap Breadth-first Search python solution with heap Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.   Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.   Example: Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.   The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.    After the rain, water is trapped between the blocks. The total volume of water trapped is 4.  Hard Heap Breadth-first Search How to get the solution to 2-D "Trapping Rain Water" problem from 1-D case Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.   Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.   Example: Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.   The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.    After the rain, water is trapped between the blocks. The total volume of water trapped is 4.  Hard Heap Breadth-first Search Alternative approach using Dijkstra in O(rc max(log r, log c)) time Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.   Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.   Example: Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.   The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.    After the rain, water is trapped between the blocks. The total volume of water trapped is 4.  Hard Heap Breadth-first Search Simple HashSet solution Java Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.   Easy Hash Table What are the odds? (Python & C++) Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.   Easy Hash Table JAVA Solution. Simple and Clear, Using int[26] Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.   Easy Hash Table Simple Java Solution in One Pass Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.   Easy Hash Table Easy to understand accepted solution with explanation Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.   Easy Hash Table Clear Explanation: 8ms Binary Search Java Split Array Largest Sum Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Hard Binary Search Dynamic Programming [C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search Split Array Largest Sum Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Hard Binary Search Dynamic Programming DP Java Split Array Largest Sum Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Hard Binary Search Dynamic Programming Java easy binary search solution 8ms Split Array Largest Sum Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Hard Binary Search Dynamic Programming Python solution dp and binary search Split Array Largest Sum Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Hard Binary Search Dynamic Programming Java 4ms solution , Not using "%" operation Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,  Return: [     "1",     "2",     "Fizz",     "4",     "Buzz",     "Fizz",     "7",     "8",     "Fizz",     "Buzz",     "11",     "Fizz",     "13",     "14",     "FizzBuzz" ]   Easy Python Golf Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,  Return: [     "1",     "2",     "Fizz",     "4",     "Buzz",     "Fizz",     "7",     "8",     "Fizz",     "Buzz",     "11",     "Fizz",     "13",     "14",     "FizzBuzz" ]   Easy Java easy iterative solution Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,  Return: [     "1",     "2",     "Fizz",     "4",     "Buzz",     "Fizz",     "7",     "8",     "Fizz",     "Buzz",     "11",     "Fizz",     "13",     "14",     "FizzBuzz" ]   Easy Java, Fuzz Buzz--Follow up(no if else, and extendable) Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,  Return: [     "1",     "2",     "Fizz",     "4",     "Buzz",     "Fizz",     "7",     "8",     "Fizz",     "Buzz",     "11",     "Fizz",     "13",     "14",     "FizzBuzz" ]   Easy One-line c# solution Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,  Return: [     "1",     "2",     "Fizz",     "4",     "Buzz",     "Fizz",     "7",     "8",     "Fizz",     "Buzz",     "11",     "Fizz",     "13",     "14",     "FizzBuzz" ]   Easy Simple Java solution 9 lines, 2ms Arithmetic Slices A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  Medium Math Dynamic Programming 3ms C++ Standard DP Solution with Very Detailed Explanation Arithmetic Slices A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  Medium Math Dynamic Programming 2ms Java O(n) time, O(1) space solution Arithmetic Slices A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  Medium Math Dynamic Programming Python DP solution Arithmetic Slices A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  Medium Math Dynamic Programming java 2ms O(n) solution using DP with detail explanation Arithmetic Slices A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.  Medium Math Dynamic Programming Java neat and easy understand solution, O(n) time, O(1) space Third Maximum Number Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.   Easy Array Short easy C++ using set Third Maximum Number Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.   Easy Array Intuitive and Short Python solution Third Maximum Number Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.   Easy Array A python amusing solution, which actually beats 98%... Third Maximum Number Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.   Easy Array Java PriorityQueue O(n) + O(1) Third Maximum Number Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.   Easy Array 0/1 knapsack detailed explanation Partition Equal Subset Sum Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  Note:  Each of the array element will not exceed 100. The array size will not exceed 200.   Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].   Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.   Medium Dynamic Programming Java Solution similar to backpack problem - Easy to understand Partition Equal Subset Sum Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  Note:  Each of the array element will not exceed 100. The array size will not exceed 200.   Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].   Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.   Medium Dynamic Programming Simple C++ 4-line solution using a bitset Partition Equal Subset Sum Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  Note:  Each of the array element will not exceed 100. The array size will not exceed 200.   Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].   Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.   Medium Dynamic Programming Concise C++ Solution summary with DFS, DP, BIT Partition Equal Subset Sum Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  Note:  Each of the array element will not exceed 100. The array size will not exceed 200.   Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].   Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.   Medium Dynamic Programming Java Solution similar to 'Subset Sum Problem' Partition Equal Subset Sum Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  Note:  Each of the array element will not exceed 100. The array size will not exceed 200.   Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].   Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.   Medium Dynamic Programming Java BFS & DFS from Ocean Pacific Atlantic Water Flow Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.   Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).   Medium Depth-first Search Breadth-first Search Python DFS bests 85%. Tips for all DFS in matrix question. Pacific Atlantic Water Flow Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.   Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).   Medium Depth-first Search Breadth-first Search Not understanding the problem. Could someone please explain? Pacific Atlantic Water Flow Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.   Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).   Medium Depth-first Search Breadth-first Search Very Concise C++ solution using DFS and bit mask Pacific Atlantic Water Flow Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.   Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).   Medium Depth-first Search Breadth-first Search Simple commented java solution with thinking progress O(n) Pacific Atlantic Water Flow Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.   Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).   Medium Depth-first Search Breadth-first Search Simple Java Solution Battleships in a Board Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:   You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.  Example: X..X ...X ...X  In the above board there are 2 battleships.  Invalid Example: ...X XXXX ...X  This is an invalid board that you will not receive - as battleships will always have a cell separating between them.  Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Medium Share my 7-line code, 1-line core code, 3ms, super easy Battleships in a Board Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:   You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.  Example: X..X ...X ...X  In the above board there are 2 battleships.  Invalid Example: ...X XXXX ...X  This is an invalid board that you will not receive - as battleships will always have a cell separating between them.  Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Medium Python solution Battleships in a Board Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:   You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.  Example: X..X ...X ...X  In the above board there are 2 battleships.  Invalid Example: ...X XXXX ...X  This is an invalid board that you will not receive - as battleships will always have a cell separating between them.  Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Medium 4ms Java Optimized code Battleships in a Board Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:   You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.  Example: X..X ...X ...X  In the above board there are 2 battleships.  Invalid Example: ...X XXXX ...X  This is an invalid board that you will not receive - as battleships will always have a cell separating between them.  Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Medium Confused with test cases Battleships in a Board Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:   You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.  Example: X..X ...X ...X  In the above board there are 2 battleships.  Invalid Example: ...X XXXX ...X  This is an invalid board that you will not receive - as battleships will always have a cell separating between them.  Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Medium C++ 0ms O(n) 35 lines solution with detailed explanation Strong Password Checker A password is considered strong if below conditions are all met:   It has at least 6 characters and at most 20 characters.   It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.   It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).   Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. Hard O(n) java solution by analyzing changes allowed to fix each problem Strong Password Checker A password is considered strong if below conditions are all met:   It has at least 6 characters and at most 20 characters.   It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.   It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).   Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. Hard Simple Python solution Strong Password Checker A password is considered strong if below conditions are all met:   It has at least 6 characters and at most 20 characters.   It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.   It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).   Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. Hard JAVA Easy Solution with explanation Strong Password Checker A password is considered strong if below conditions are all met:   It has at least 6 characters and at most 20 characters.   It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.   It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).   Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. Hard Java O(n) Greedy solution with super clear explanation Strong Password Checker A password is considered strong if below conditions are all met:   It has at least 6 characters and at most 20 characters.   It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.   It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).   Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. Hard Java O(n) solution using bit manipulation and HashMap Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. Could you do this in O(n) runtime? Example: Input: [3, 10, 5, 25, 2, 8]  Output: 28  Explanation: The maximum result is 5 ^ 25 = 28.   Medium Bit Manipulation Trie Java O(n) solution using Trie Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. Could you do this in O(n) runtime? Example: Input: [3, 10, 5, 25, 2, 8]  Output: 28  Explanation: The maximum result is 5 ^ 25 = 28.   Medium Bit Manipulation Trie Python 6 lines, bit by bit Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. Could you do this in O(n) runtime? Example: Input: [3, 10, 5, 25, 2, 8]  Output: 28  Explanation: The maximum result is 5 ^ 25 = 28.   Medium Bit Manipulation Trie 使用前缀树(二叉树表示) 打败 92% Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. Could you do this in O(n) runtime? Example: Input: [3, 10, 5, 25, 2, 8]  Output: 28  Explanation: The maximum result is 5 ^ 25 = 28.   Medium Bit Manipulation Trie C++, O(n) solution, explanation added Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. Could you do this in O(n) runtime? Example: Input: [3, 10, 5, 25, 2, 8]  Output: 28  Explanation: The maximum result is 5 ^ 25 = 28.   Medium Bit Manipulation Trie one pass O(n) JAVA Solution, Simple and Clear Reconstruct Original Digits from English Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"   Medium Math Fun fact Reconstruct Original Digits from English Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"   Medium Math Share my simple and easy O(N) solution Reconstruct Original Digits from English Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"   Medium Math Straightforward C++ Accepted Solution Reconstruct Original Digits from English Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"   Medium Math Short Matrix Solution Reconstruct Original Digits from English Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"   Medium Math Java 12 lines O(n) sliding window solution with explanation Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104.   Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.   Medium Sliding window, similar to finding longest substring with k distinct characters Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104.   Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.   Medium 7 lines C++ Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104.   Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.   Medium Consise Python sliding window Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104.   Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.   Medium Java Sliding Window Easy to Understand Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104.   Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.   Medium Please correct your Example illustration !!! Construct Quad Tree We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree:  It can be divided according to the definition above:    The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *.  Note:  N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki.   Easy Recursive Java Solution Construct Quad Tree We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree:  It can be divided according to the definition above:    The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *.  Note:  N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki.   Easy Python short & readable DFS solution Construct Quad Tree We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree:  It can be divided according to the definition above:    The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *.  Note:  N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki.   Easy Java recursive solution Construct Quad Tree We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree:  It can be divided according to the definition above:    The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *.  Note:  N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki.   Easy non-leaf nodes seems have to be true value Construct Quad Tree We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree:  It can be divided according to the definition above:    The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *.  Note:  N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki.   Easy Python 5 lines BFS solution  N-ary Tree Level Order Traversal Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Breadth-first Search Basic C++ solution using queue. Super easy for beginners. N-ary Tree Level Order Traversal Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Breadth-first Search Java Solution N-ary Tree Level Order Traversal Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Breadth-first Search Python iterative solution beat 96% N-ary Tree Level Order Traversal Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Breadth-first Search Beat 100% of Java -  DFS (recursive) N-ary Tree Level Order Traversal Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Breadth-first Search Easy Understanding Java beat 95.7% with Explanation Flatten a Multilevel Doubly Linked List You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:   Medium Linked List Depth-first Search Java Recursive Solution Flatten a Multilevel Doubly Linked List You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:   Medium Linked List Depth-first Search Python easy solution using stack  Flatten a Multilevel Doubly Linked List You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:   Medium Linked List Depth-first Search c++, about 10 lines solution Flatten a Multilevel Doubly Linked List You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:   Medium Linked List Depth-first Search Python solution with explanation Flatten a Multilevel Doubly Linked List You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:   Medium Linked List Depth-first Search Java AC all strict O(1) not average O(1), easy to read All O`one Data Structure Implement a data structure supporting the following operations:   Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".    Challenge: Perform all these in O(1) time complexity.  Hard Design All in O(1), with detailed explantation All O`one Data Structure Implement a data structure supporting the following operations:   Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".    Challenge: Perform all these in O(1) time complexity.  Hard Design C++ solution with comments All O`one Data Structure Implement a data structure supporting the following operations:   Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".    Challenge: Perform all these in O(1) time complexity.  Hard Design An accepted JAVA solution, detailed explanation.(HashMap + double linked list) All O`one Data Structure Implement a data structure supporting the following operations:   Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".    Challenge: Perform all these in O(1) time complexity.  Hard Design Python solution with detailed comments All O`one Data Structure Implement a data structure supporting the following operations:   Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".    Challenge: Perform all these in O(1) time complexity.  Hard Design Java Solution using BFS Minimum Genetic Mutation A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T". Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string. For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation. Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string. Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1. Note:  Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.    Example 1: start: "AACCGGTT" end:   "AACCGGTA" bank: ["AACCGGTA"]  return: 1    Example 2: start: "AACCGGTT" end:   "AAACGGTA" bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]  return: 2    Example 3: start: "AAAAACCC" end:   "AACCCCCC" bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]  return: 3     Medium C++ two end BFS solution, exactly same as 127.Word Ladder Minimum Genetic Mutation A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T". Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string. For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation. Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string. Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1. Note:  Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.    Example 1: start: "AACCGGTT" end:   "AACCGGTA" bank: ["AACCGGTA"]  return: 1    Example 2: start: "AACCGGTT" end:   "AAACGGTA" bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]  return: 2    Example 3: start: "AAAAACCC" end:   "AACCCCCC" bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]  return: 3     Medium Python Solution using BFS Minimum Genetic Mutation A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T". Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string. For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation. Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string. Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1. Note:  Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.    Example 1: start: "AACCGGTT" end:   "AACCGGTA" bank: ["AACCGGTA"]  return: 1    Example 2: start: "AACCGGTT" end:   "AAACGGTA" bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]  return: 2    Example 3: start: "AAAAACCC" end:   "AACCCCCC" bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]  return: 3     Medium Clear Java solution based on BFS (similar to Word Ladder) Minimum Genetic Mutation A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T". Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string. For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation. Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string. Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1. Note:  Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.    Example 1: start: "AACCGGTT" end:   "AACCGGTA" bank: ["AACCGGTA"]  return: 1    Example 2: start: "AACCGGTT" end:   "AAACGGTA" bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]  return: 2    Example 3: start: "AAAAACCC" end:   "AACCCCCC" bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]  return: 3     Medium C++ BFS (0ms) Minimum Genetic Mutation A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T". Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string. For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation. Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string. Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1. Note:  Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.    Example 1: start: "AACCGGTT" end:   "AACCGGTA" bank: ["AACCGGTA"]  return: 1    Example 2: start: "AACCGGTT" end:   "AAACGGTA" bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]  return: 2    Example 3: start: "AAAAACCC" end:   "AACCCCCC" bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]  return: 3     Medium Clean java solution O(n) Number of Segments in a String Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5   Easy String one-liners Number of Segments in a String Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5   Easy String O(n) sentinel value concise solution, C++ Number of Segments in a String Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5   Easy String 2-line C++ solution simply using stringstream >> operator Number of Segments in a String Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5   Easy String AC Solution Java with trim() and split() Number of Segments in a String Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5   Easy String Java: Least is Most Non-overlapping Intervals  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.   Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Example 2: Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.   Example 3: Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.   Medium Greedy Short Ruby and Python Non-overlapping Intervals  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.   Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Example 2: Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.   Example 3: Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.   Medium Greedy Concise C++ Solution Non-overlapping Intervals  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.   Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Example 2: Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.   Example 3: Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.   Medium Greedy Java Solution with clear explain Non-overlapping Intervals  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.   Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Example 2: Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.   Example 3: Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.   Medium Greedy Python greedy solution with explanation Non-overlapping Intervals  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.   Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Example 2: Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.   Example 3: Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.   Medium Greedy Java clear O(n logn) solution based on TreeMap Find Right Interval  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.   For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.  Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.   Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.   Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.   Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.   Medium Binary Search C++ map solution Find Right Interval  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.   For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.  Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.   Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.   Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.   Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.   Medium Binary Search Python O(nlogn) short solution with explanation Find Right Interval  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.   For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.  Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.   Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.   Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.   Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.   Medium Binary Search Java Concise Binary Search Find Right Interval  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.   For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.  Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.   Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.   Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.   Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.   Medium Binary Search 2 lines Python / Ruby Find Right Interval  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.   For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.  Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.   Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.   Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.   Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.   Medium Binary Search 17 ms O(n) java Prefix sum method Path Sum III You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11   Easy Tree Simple Java DFS Path Sum III You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11   Easy Tree Simple AC Java Solution DFS Path Sum III You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11   Easy Tree Python solution with detailed explanation Path Sum III You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11   Easy Tree Python step-by-step walk through. Easy to understand. Two solutions comparison. : ) Path Sum III You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11   Easy Tree Sliding Window algorithm template to solve all the Leetcode substring search problem. Find All Anagrams in a String Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".   Easy Hash Table Shortest/Concise JAVA O(n) Sliding Window Solution Find All Anagrams in a String Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".   Easy Hash Table O(n) Sliding Window JAVA Solution, Extremely Detailed Explanation Find All Anagrams in a String Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".   Easy Hash Table Python Sliding Window Solution using Counter Find All Anagrams in a String Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".   Easy Hash Table C++ O(n) sliding window concise solution with explanation Find All Anagrams in a String Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".   Easy Hash Table Concise/Easy-to-understand Java 5ms solution with Explaination K-th Smallest in Lexicographical Order Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: Input: n: 13   k: 2  Output: 10  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.    Hard C++/Python 0ms O((log n)^2)-time O(1)-space super easy solution with detailed explanations K-th Smallest in Lexicographical Order Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: Input: n: 13   k: 2  Output: 10  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.    Hard Java 7ms denary(trie?) tree solution with detailed explanation K-th Smallest in Lexicographical Order Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: Input: n: 13   k: 2  Output: 10  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.    Hard It's a denary tree K-th Smallest in Lexicographical Order Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: Input: n: 13   k: 2  Output: 10  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.    Hard what's wrong with my answer??? I AM DEFINITELY RIGHT K-th Smallest in Lexicographical Order Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: Input: n: 13   k: 2  Output: 10  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.    Hard [JAVA] Clean Code with Explanations and Running Time [2 Solutions] Arranging Coins You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.   Easy Math Binary Search Java O(1) Solution - Math Problem Arranging Coins You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.   Easy Math Binary Search C++ 1 line code Arranging Coins You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.   Easy Math Binary Search [JAVA] Cleaner and easier to understand solution. Arranging Coins You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.   Easy Math Binary Search O(logn) binary search java solution Arranging Coins You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.   Easy Math Binary Search Java Simple Solution Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]  Medium Array Python O(n) time O(1) space Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]  Medium Array Very simple C++ solution Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]  Medium Array C++ beats 98% Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]  Medium Array Java solution without destroying the input array. O(n) time. O(1) space. Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]  Medium Array Simple Easy to Understand Java solution String Compression Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.   Easy String Python Two Pointers - O(n) time O(1) space String Compression Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.   Easy String Java O(n), two pointers and a counter String Compression Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.   Easy String Python 5-liner, O(N) time, no pointers! String Compression Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.   Easy String Python solution with detailed explanation String Compression Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.   Easy String Easy O(n) Java Solution using Stack Add Two Numbers II You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.   Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7   Medium Linked List C++ O(1) extra space except for output. Reverse output instead. Is this cheating? Add Two Numbers II You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.   Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7   Medium Linked List Java O(n) recursive solution by counting the difference of length Add Two Numbers II You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.   Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7   Medium Linked List There is no maximum of INT in python, so..... Add Two Numbers II You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.   Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7   Medium Linked List Concise C++ Solution without reverse Add Two Numbers II You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.   Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7   Medium Linked List Detailed explanation for Java O(n^2) solution Arithmetic Slices II - Subsequence A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A.  The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.  Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]   Hard Dynamic Programming JAVA 15 lines solution Arithmetic Slices II - Subsequence A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A.  The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.  Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]   Hard Dynamic Programming 11 line Python O(n^2) solution Arithmetic Slices II - Subsequence A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A.  The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.  Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]   Hard Dynamic Programming C++_DP_Accepted Arithmetic Slices II - Subsequence A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A.  The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.  Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]   Hard Dynamic Programming O(N^2) MLE/TLE in C++? Try this one, Concise and Fast. Arithmetic Slices II - Subsequence A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A.  The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.  Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]   Hard Dynamic Programming Clean java solution: O(n^2) 166ms Number of Boomerangs Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]   Easy Hash Table Short Python O(n^2) hashmap solution Number of Boomerangs Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]   Easy Hash Table 7 lines ~1050 ms C++ Number of Boomerangs Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]   Easy Hash Table C++ clean solution O(n^2). Fully commented and explained. Number of Boomerangs Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]   Easy Hash Table Share my straightforward solution with HashMap, O(N^2) Number of Boomerangs Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]   Easy Hash Table Java accepted simple solution Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]   Easy Array Python 4 lines with short explanation Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]   Easy Array 5-line Java Easy-understanding Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]   Easy Array c++ solution O(1) space Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]   Easy Array Simple Java In-place sort solution Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]   Easy Array Java PreOrder + Queue solution Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.   Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Medium Tree Concise C++ 19ms solution beating 99.4% Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.   Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Medium Tree Deserialize from preorder and computed inorder, reusing old solution Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.   Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Medium Tree what's the difference between this and #297 ? Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.   Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Medium Tree Using lower bound and upper bound to deserialize BST Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.   Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.  Medium Tree Recursive Easy to Understand Java Solution Delete Node in a BST Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7   Medium Tree Iterative solution in Java, O(h) time and O(1) space Delete Node in a BST Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7   Medium Tree Very Concise C++ Solution for General Binary Tree not only BST Delete Node in a BST Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7   Medium Tree Simple Python Solution With Explanation Delete Node in a BST Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7   Medium Tree Java Easy to Understand Solution Delete Node in a BST Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7   Medium Tree Java O(n) Bucket Sort Solution / O(nlogm) PriorityQueue Solution, easy to understand Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.   Medium Hash Table Heap C++ O(n) solution without sort() Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.   Medium Hash Table Heap O(n) Easy to understand Java Solution Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.   Medium Hash Table Heap Concise C++ solution using STL sort Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.   Medium Hash Table Heap 1 line Python code. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.   Medium Hash Table Heap Share my explained Greedy solution Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.  Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Medium Greedy Greedy, Python (132 ms) Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.  Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Medium Greedy Java Greedy Soution Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.  Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Medium Greedy C++ easy understood solution (sort) Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.  Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Medium Greedy A Concise Template for "Overlapping Interval Problem" Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.  Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Medium Greedy It is a math question Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]   Easy Math Java O(n) solution. Short. Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]   Easy Math Simple one-liners Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]   Easy Math What if we are not smart enough to come up with decrease 1. Here is how we do it. Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]   Easy Math Four Python solutions with detailed explanation Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]   Easy Math Clean java solution O(n^2) 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0   Medium Hash Table Binary Search Easy 2 lines O(N^2) Python 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0   Medium Hash Table Binary Search Simple Java Solution with Explanation 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0   Medium Hash Table Binary Search Concise C++ 11 code beat 99.5% 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0   Medium Hash Table Binary Search python O(n^2) solution with hashtable 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0   Medium Hash Table Binary Search Simple Greedy Java Solution Assign Cookies  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.   Easy Greedy Array sort + Two pointer greedy solution O(nlogn) Assign Cookies  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.   Easy Greedy Simple PYTHON O(nlogn) Assign Cookies  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.   Easy Greedy Easy Understanding C++ solution O(nlogn) Assign Cookies  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.   Easy Greedy Simple Python Solution Assign Cookies  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.   Easy Greedy Single pass C++ O(n) space and time solution (8 lines) with detailed explanation. 132 Pattern  Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: Input: [1, 2, 3, 4]  Output: False  Explanation: There is no 132 pattern in the sequence.   Example 2: Input: [3, 1, 4, 2]  Output: True  Explanation: There is a 132 pattern in the sequence: [1, 4, 2].   Example 3: Input: [-1, 3, 2, 0]  Output: True  Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].   Medium Stack Java solutions from O(n^3) to O(n) for "132" pattern (updated with one-pass slution) 132 Pattern  Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: Input: [1, 2, 3, 4]  Output: False  Explanation: There is no 132 pattern in the sequence.   Example 2: Input: [3, 1, 4, 2]  Output: True  Explanation: There is a 132 pattern in the sequence: [1, 4, 2].   Example 3: Input: [-1, 3, 2, 0]  Output: True  Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].   Medium Stack Java O(n) solution using stack in detail explanation 132 Pattern  Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: Input: [1, 2, 3, 4]  Output: False  Explanation: There is no 132 pattern in the sequence.   Example 2: Input: [3, 1, 4, 2]  Output: True  Explanation: There is a 132 pattern in the sequence: [1, 4, 2].   Example 3: Input: [-1, 3, 2, 0]  Output: True  Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].   Medium Stack 10-line Python Solution 132 Pattern  Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: Input: [1, 2, 3, 4]  Output: False  Explanation: There is no 132 pattern in the sequence.   Example 2: Input: [3, 1, 4, 2]  Output: True  Explanation: There is a 132 pattern in the sequence: [1, 4, 2].   Example 3: Input: [-1, 3, 2, 0]  Output: True  Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].   Medium Stack Share my easy and simple solution 132 Pattern  Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: Input: [1, 2, 3, 4]  Output: False  Explanation: There is no 132 pattern in the sequence.   Example 2: Input: [3, 1, 4, 2]  Output: True  Explanation: There is a 132 pattern in the sequence: [1, 4, 2].   Example 3: Input: [-1, 3, 2, 0]  Output: True  Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].   Medium Stack I cannot understand why test case [-2, 1, -1, -2, -2] gives false? Circular Array Loop You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'. Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0. Example 2: Given the array [-1, 2], there is no loop. Note: The given array is guaranteed to contain no element "0". Can you do it in O(n) time complexity and O(1) space complexity?  Medium Java Slow/Fast Pointer Solution Circular Array Loop You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'. Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0. Example 2: Given the array [-1, 2], there is no loop. Note: The given array is guaranteed to contain no element "0". Can you do it in O(n) time complexity and O(1) space complexity?  Medium Why {3, 1, 2} is a loop and {-1, -2, -3, -4, -5} is not? Circular Array Loop You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'. Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0. Example 2: Given the array [-1, 2], there is no loop. Note: The given array is guaranteed to contain no element "0". Can you do it in O(n) time complexity and O(1) space complexity?  Medium python 1 pointer O(n) time O(1) space Circular Array Loop You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'. Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0. Example 2: Given the array [-1, 2], there is no loop. Note: The given array is guaranteed to contain no element "0". Can you do it in O(n) time complexity and O(1) space complexity?  Medium two pass O(n) solution by marking failed loop by zero Circular Array Loop You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'. Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0. Example 2: Given the array [-1, 2], there is no loop. Note: The given array is guaranteed to contain no element "0". Can you do it in O(n) time complexity and O(1) space complexity?  Medium Another explanation and solution Poor Pigs There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.  Easy Solution with detailed explanation Poor Pigs There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.  Easy Why is the difficulty of this problem easy? Poor Pigs There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.  Easy Why should pig die? Poor Pigs There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.  Easy Major flaw in current algorithm [FIXED] Poor Pigs There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.  Easy Easy python solution with explaination Repeated Substring Pattern Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)   Easy String Java Simple Solution with Explanation Repeated Substring Pattern Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)   Easy String Simple Java solution, 2 lines Repeated Substring Pattern Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)   Easy String C++ O(n) using KMP, 32ms, 8 lines of code with brief explanation. Repeated Substring Pattern Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)   Easy String Java & O(n) Repeated Substring Pattern Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)   Easy String JAVA O(1) very easy solution using 3 HashMaps and LinkedHashSet LFU Cache Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.  Follow up: Could you do both operations in O(1) time complexity? Example: LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Java O(1) Accept Solution Using HashMap, DoubleLinkedList and LinkedHashSet LFU Cache Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.  Follow up: Could you do both operations in O(1) time complexity? Example: LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Concise C++ O(1) solution using 3 hash maps with explanation LFU Cache Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.  Follow up: Could you do both operations in O(1) time complexity? Example: LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Java O(1) Solution Using Two HashMap and One DoubleLinkedList LFU Cache Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.  Follow up: Could you do both operations in O(1) time complexity? Example: LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Java solutions of three different ways. PriorityQueue : O(capacity)  TreeMap : O(log(capacity)) DoubleLinkedList  : O(1) LFU Cache Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.   get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.  Follow up: Could you do both operations in O(1) time complexity? Example: LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4   Hard Design Java 1 Line Solution :D Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y < 231.  Example: Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑  The above arrows point to positions where the corresponding bits are different.   Easy Bit Manipulation My C++ solution using bit manipulation Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y < 231.  Example: Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑  The above arrows point to positions where the corresponding bits are different.   Easy Bit Manipulation Python 1 line 49ms Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y < 231.  Example: Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑  The above arrows point to positions where the corresponding bits are different.   Easy Bit Manipulation Java 3-Line Solution Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y < 231.  Example: Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑  The above arrows point to positions where the corresponding bits are different.   Easy Bit Manipulation Javascript one line solution Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y < 231.  Example: Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑  The above arrows point to positions where the corresponding bits are different.   Easy Bit Manipulation Java(just like meeting point problem) Minimum Moves to Equal Array Elements II Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]   Medium Math 2 lines Python, 2 ways Minimum Moves to Equal Array Elements II Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]   Medium Math Java O(n) Time using QuickSelect Minimum Moves to Equal Array Elements II Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]   Medium Math O(n) solution with detailed explanation. Minimum Moves to Equal Array Elements II Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]   Medium Math Why median is better than average? Minimum Moves to Equal Array Elements II Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]   Medium Math clear and easy java solution Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:     Easy Hash Table Short Python Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:     Easy Hash Table Java 9 line solution, add 4 for each land and remove 2 for each internal edge Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:     Easy Hash Table C++ solution with explanation Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:     Easy Hash Table Easy to read Python solution Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:     Easy Hash Table Java solution using HashMap with detailed explanation Can I Win In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.   Medium Dynamic Programming Minimax Python solution, easy to understand Can I Win In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.   Medium Dynamic Programming Minimax 7-liner C++ beat 98.4%, DFS with early termination check (detailed explanation) Can I Win In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.   Medium Dynamic Programming Minimax brute force and memoization Can I Win In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.   Medium Dynamic Programming Minimax Java easy strightforward solution with explanation Can I Win In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.   Medium Dynamic Programming Minimax Ugly Java brute force solution, but accepted. 1088ms. Count The Repetitions Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2   Hard Dynamic Programming C++ solution inspired by @70664914 with organized explanation Count The Repetitions Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2   Hard Dynamic Programming C++ 0ms O(str1.length*str2.length) Count The Repetitions Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2   Hard Dynamic Programming Easy-understanding Java Solution with detailed explanation, 21ms! Count The Repetitions Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2   Hard Dynamic Programming Very clean and short 7ms Java solution based on @70664914 's idea Count The Repetitions Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2   Hard Dynamic Programming Concise Java solution using DP Unique Substrings in Wraparound String Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.   Medium Dynamic Programming C++ Concise Solution Unique Substrings in Wraparound String Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.   Medium Dynamic Programming Python Concise Solution Unique Substrings in Wraparound String Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.   Medium Dynamic Programming Evolve from brute force to optimal Unique Substrings in Wraparound String Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.   Medium Dynamic Programming Concise O(n) 6-liner in Python Unique Substrings in Wraparound String Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.   Medium Dynamic Programming Java Simple Solution Validate IP Address  Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.   Medium String Python easy understand solution Validate IP Address  Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.   Medium String C++ solution straightforward string processing Validate IP Address  Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.   Medium String Java Simple Solution with RegExp Validate IP Address  Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.   Medium String Short RegExp solution Validate IP Address  Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.   Medium String Java DP Solution Concatenated Words Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.    Hard Dynamic Programming Depth-first Search Trie 102ms java Trie + DFS solution. With explanation, easy to understand. Concatenated Words Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.    Hard Dynamic Programming Depth-first Search Trie Simple Java Trie + DFS solution 144ms Concatenated Words Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.    Hard Dynamic Programming Depth-first Search Trie C++ 772 ms dp solution Concatenated Words Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.    Hard Dynamic Programming Depth-first Search Trie 20 line C++ 169 ms Beats 100% & Why I think this problem is not properly judged. Concatenated Words Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.    Hard Dynamic Programming Depth-first Search Trie Java DFS Solution with Explanation Matchsticks to Square Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.   Medium Depth-first Search cpp 6ms solution with DFS Matchsticks to Square Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.   Medium Depth-first Search Java DFS solution with various optimizations (sorting, sequential-partition, DP) Matchsticks to Square Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.   Medium Depth-first Search C++ bit masking + DP solution with detailed comments Matchsticks to Square Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.   Medium Depth-first Search Python DFS solution Matchsticks to Square Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.   Medium Depth-first Search c++ DP solution with comments Ones and Zeroes In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.  Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.  Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.   Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”   Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".   Medium Dynamic Programming 0-1 knapsack detailed explanation. Ones and Zeroes In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.  Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.  Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.   Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”   Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".   Medium Dynamic Programming Have you graduated from primary school? Ones and Zeroes In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.  Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.  Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.   Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”   Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".   Medium Dynamic Programming Java Iterative DP Solution - O(mn) Space Ones and Zeroes In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.  Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.  Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.   Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”   Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".   Medium Dynamic Programming 0-1 knapsack in python Ones and Zeroes In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.  Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.  Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.   Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”   Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".   Medium Dynamic Programming Short and Clean Java Binary Search Solution Heaters Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.   Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.   Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.   Easy Binary Search Simple Java Solution with 2 Pointers Heaters Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.   Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.   Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.   Easy Binary Search Short Python Heaters Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.   Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.   Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.   Easy Binary Search C++ clean solution with explanation Heaters Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.   Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.   Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.   Easy Binary Search 10 lines python with easy understanding Heaters Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.   Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.   Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.   Easy Binary Search 3 line C++ Number Complement Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:  The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.   Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.   Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Easy Bit Manipulation Java 1 line bit manipulation solution Number Complement Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:  The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.   Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.   Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Easy Bit Manipulation Java, very simple code and self-evident, explanation Number Complement Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:  The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.   Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.   Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Easy Bit Manipulation Simple Python Number Complement Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:  The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.   Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.   Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Easy Bit Manipulation maybe fewest operations Number Complement Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:  The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.   Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.   Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Easy Bit Manipulation Java O(n) time O(1) Space Total Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example: Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.   Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.    Medium Bit Manipulation Share my O(n) C++ bitwise solution with thinking process and explanation Total Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example: Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.   Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.    Medium Bit Manipulation Python via Strings Total Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example: Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.   Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.    Medium Bit Manipulation Java Solution with Explanation Total Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example: Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.   Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.    Medium Bit Manipulation Python Explanation Total Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example: Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.   Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.    Medium Bit Manipulation Polar Coordinates 10 lines Generate Random Point in a Circle Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.   Medium Math Random Rejection Sampling How is the solution verified? Generate Random Point in a Circle Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.   Medium Math Random Rejection Sampling Explanation with Graphs why using Math.sqrt() Generate Random Point in a Circle Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.   Medium Math Random Rejection Sampling Very simple Python solution Generate Random Point in a Circle Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.   Medium Math Random Rejection Sampling Python Solution without using Rejection Sampling Generate Random Point in a Circle Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.   Medium Math Random Rejection Sampling I don't feel like this is a easy question Largest Palindrome Product Find the largest palindrome made from the product of two n-digit numbers.  Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987   Note: The range of n is [1,8].   Easy Java Solution using assumed max palindrom Largest Palindrome Product Find the largest palindrome made from the product of two n-digit numbers.  Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987   Note: The range of n is [1,8].   Easy Java solutions with two different approaches Largest Palindrome Product Find the largest palindrome made from the product of two n-digit numbers.  Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987   Note: The range of n is [1,8].   Easy Trickiness depending on language you use Largest Palindrome Product Find the largest palindrome made from the product of two n-digit numbers.  Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987   Note: The range of n is [1,8].   Easy Java Solution with explanation Largest Palindrome Product Find the largest palindrome made from the product of two n-digit numbers.  Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987   Note: The range of n is [1,8].   Easy O(n log k) C++ using multiset and updating middle-iterator Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6  Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array. Hard Java solution using two PriorityQueues Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6  Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array. Hard Easy to understand O(nlogk) Java solution using TreeMap Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6  Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array. Hard Java using two Tree Sets - O(n logk) Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6  Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array. Hard Easy Python O(nk) Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6  Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array. Hard Simple Java solution using one array and two pointers Magical String  A magical string S consists of only '1' and '2' and obeys the following rules:   The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.   The first few elements of string S is the following: S = "1221121221221121122……"   If we group the consecutive '1's and '2's in S, it will be:   1   22  11  2  1  22  1  22  11  2  11  22 ......   and the occurrences of '1's or '2's in each group are:   1   2	   2    1   1    2     1    2     2    1    2    2 ......   You can see that the occurrence sequence above is the S itself.    Given an integer N as input, return the number of '1's in the first N number in the magical string S.  Note: N will not exceed 100,000.  Example 1: Input: 6 Output: 3 Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.   Medium Short C++ Magical String  A magical string S consists of only '1' and '2' and obeys the following rules:   The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.   The first few elements of string S is the following: S = "1221121221221121122……"   If we group the consecutive '1's and '2's in S, it will be:   1   22  11  2  1  22  1  22  11  2  11  22 ......   and the occurrences of '1's or '2's in each group are:   1   2	   2    1   1    2     1    2     2    1    2    2 ......   You can see that the occurrence sequence above is the S itself.    Given an integer N as input, return the number of '1's in the first N number in the magical string S.  Note: N will not exceed 100,000.  Example 1: Input: 6 Output: 3 Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.   Medium Is the magical string unique? Magical String  A magical string S consists of only '1' and '2' and obeys the following rules:   The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.   The first few elements of string S is the following: S = "1221121221221121122……"   If we group the consecutive '1's and '2's in S, it will be:   1   22  11  2  1  22  1  22  11  2  11  22 ......   and the occurrences of '1's or '2's in each group are:   1   2	   2    1   1    2     1    2     2    1    2    2 ......   You can see that the occurrence sequence above is the S itself.    Given an integer N as input, return the number of '1's in the first N number in the magical string S.  Note: N will not exceed 100,000.  Example 1: Input: 6 Output: 3 Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.   Medium O(log n) space using recursive generators Magical String  A magical string S consists of only '1' and '2' and obeys the following rules:   The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.   The first few elements of string S is the following: S = "1221121221221121122……"   If we group the consecutive '1's and '2's in S, it will be:   1   22  11  2  1  22  1  22  11  2  11  22 ......   and the occurrences of '1's or '2's in each group are:   1   2	   2    1   1    2     1    2     2    1    2    2 ......   You can see that the occurrence sequence above is the S itself.    Given an integer N as input, return the number of '1's in the first N number in the magical string S.  Note: N will not exceed 100,000.  Example 1: Input: 6 Output: 3 Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.   Medium Very Straightforward and simple Java solution O(n) Magical String  A magical string S consists of only '1' and '2' and obeys the following rules:   The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.   The first few elements of string S is the following: S = "1221121221221121122……"   If we group the consecutive '1's and '2's in S, it will be:   1   22  11  2  1  22  1  22  11  2  11  22 ......   and the occurrences of '1's or '2's in each group are:   1   2	   2    1   1    2     1    2     2    1    2    2 ......   You can see that the occurrence sequence above is the S itself.    Given an integer N as input, return the number of '1's in the first N number in the magical string S.  Note: N will not exceed 100,000.  Example 1: Input: 6 Output: 3 Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.   Medium Java 5 lines clean solution License Key Formatting You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: Input: S = "5F3Z-2e-9-w", K = 4  Output: "5F3Z-2E9W"  Explanation: The string S has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.   Example 2: Input: S = "2-5g-3-J", K = 2  Output: "2-5G-3J"  Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Note:  The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty.   Easy Python solution License Key Formatting You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: Input: S = "5F3Z-2e-9-w", K = 4  Output: "5F3Z-2E9W"  Explanation: The string S has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.   Example 2: Input: S = "2-5g-3-J", K = 2  Output: "2-5G-3J"  Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Note:  The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty.   Easy Easy to understand using StringBuilder License Key Formatting You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: Input: S = "5F3Z-2e-9-w", K = 4  Output: "5F3Z-2E9W"  Explanation: The string S has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.   Example 2: Input: S = "2-5g-3-J", K = 2  Output: "2-5G-3J"  Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Note:  The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty.   Easy 4-line C++ concise solution to scan string backward License Key Formatting You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: Input: S = "5F3Z-2e-9-w", K = 4  Output: "5F3Z-2E9W"  Explanation: The string S has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.   Example 2: Input: S = "2-5g-3-J", K = 2  Output: "2-5G-3J"  Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Note:  The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty.   Easy beats 100% python3 submission License Key Formatting You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: Input: S = "5F3Z-2e-9-w", K = 4  Output: "5F3Z-2E9W"  Explanation: The string S has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.   Example 2: Input: S = "2-5g-3-J", K = 2  Output: "2-5G-3J"  Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Note:  The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty.   Easy Python solution with detailed mathematical explanation and derivation Smallest Good Base For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format.  Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.   Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.   Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.   Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.   Hard Math Binary Search 3ms, AC, C++, long long int + binary search Smallest Good Base For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format.  Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.   Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.   Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.   Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.   Hard Math Binary Search Java solution with hand-writing explain Smallest Good Base For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format.  Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.   Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.   Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.   Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.   Hard Math Binary Search Java O((logn)^2) binary search solution Smallest Good Base For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format.  Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.   Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.   Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.   Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.   Hard Math Binary Search Short Python O(log(N)) Smallest Good Base For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format.  Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.   Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.   Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.   Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.   Hard Math Binary Search Java 4 lines concise solution with explanation Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000   Easy Array Easy Java Solution Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000   Easy Array Simple C Solution with easy explanation Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000   Easy Array Simple Python Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000   Easy Array Simple C++ code Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000   Easy Array JAVA 9 lines DP solution, easy to understand with improvement to O(N) space complexity. Predict the Winner Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.   Medium Dynamic Programming Minimax Java '1 Line' Recursive Solution O(n^2) Time and O(n) Space Predict the Winner Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.   Medium Dynamic Programming Minimax DP O(n^2)  + MIT OCW solution explanation Predict the Winner Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.   Medium Dynamic Programming Minimax C++ DP solution with explanation Predict the Winner Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.   Medium Dynamic Programming Minimax java DP solution with explanation Predict the Winner Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.   Medium Dynamic Programming Minimax Standard test program is wrong? Zuma Game Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.   Hard Depth-first Search "short" java solution, beats 98% Zuma Game Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.   Hard Depth-first Search StraightForward Recursive Java Solution beat 97% Zuma Game Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.   Hard Depth-first Search Concise 3ms C++ Solution Zuma Game Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.   Hard Depth-first Search Recursive java solution Zuma Game Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.   Hard Depth-first Search Java solution beats 100% Increasing Subsequences  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .  Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]   Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.   Medium Depth-first Search Java 20 lines backtracking solution using set, beats 100%. Increasing Subsequences  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .  Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]   Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.   Medium Depth-first Search Simple Python Increasing Subsequences  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .  Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]   Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.   Medium Depth-first Search C++ dfs solution using unordered_set Increasing Subsequences  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .  Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]   Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.   Medium Depth-first Search Clean 20ms solution Increasing Subsequences  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .  Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]   Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.   Medium Depth-first Search 3 line Clean and easy understand solution Construct the Rectangle  For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible.  You need to output the length L and the width W of the web page you designed in sequence.  Example: Input: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].  But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.   Note:  The given area won't exceed 10,000,000 and is a positive integer The web page's width and length you designed must be positive integers.   Easy Simple Java Solution, Beats 100% Construct the Rectangle  For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible.  You need to output the length L and the width W of the web page you designed in sequence.  Example: Input: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].  But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.   Note:  The given area won't exceed 10,000,000 and is a positive integer The web page's width and length you designed must be positive integers.   Easy Simple Python Construct the Rectangle  For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible.  You need to output the length L and the width W of the web page you designed in sequence.  Example: Input: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].  But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.   Note:  The given area won't exceed 10,000,000 and is a positive integer The web page's width and length you designed must be positive integers.   Easy 3 line C++ clean solution with Explanation Construct the Rectangle  For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible.  You need to output the length L and the width W of the web page you designed in sequence.  Example: Input: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].  But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.   Note:  The given area won't exceed 10,000,000 and is a positive integer The web page's width and length you designed must be positive integers.   Easy Python solution (linear time, constant space) with explanation Construct the Rectangle  For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible.  You need to output the length L and the width W of the web page you designed in sequence.  Example: Input: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].  But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.   Note:  The given area won't exceed 10,000,000 and is a positive integer The web page's width and length you designed must be positive integers.   Easy General principles behind problems similar to "Reverse Pairs" Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree Very Short and Clear MergeSort & BST Java Solutions Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree C++ with iterators Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree Clean Java Solution using Enhanced Binary Search Tree Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree Java merge sort solution, O(nlog(n)) Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.   Hard Divide and Conquer Binary Indexed Tree Segment Tree Binary Search Tree Java (15 ms) C++ (3 ms) O(ns) iterative DP solution using subset sum with explanation Target Sum  You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.   Medium Dynamic Programming Depth-first Search Short Java DP Solution with Explanation Target Sum  You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.   Medium Dynamic Programming Depth-first Search Java simple DFS with memorization Target Sum  You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.   Medium Dynamic Programming Depth-first Search Python DP Target Sum  You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.   Medium Dynamic Programming Depth-first Search Java Short DFS Solution Target Sum  You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.   Medium Dynamic Programming Depth-first Search Java 10 lines linear time complexity O(n) with explanation Next Greater Element I  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.    The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.  Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.   Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.   Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.   Easy Stack C++ stack + unordered_map Next Greater Element I  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.    The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.  Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.   Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.   Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.   Easy Stack Python Solution with O(n) Next Greater Element I  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.    The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.  Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.   Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.   Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.   Easy Stack Meh, 1000 is small Next Greater Element I  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.    The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.  Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.   Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.   Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.   Easy Stack Whys is it -1 for findNums[2] = 2 instead of 4. Next Greater Element I  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.    The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.  Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.   Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.   Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.   Easy Stack Java randomly pick a rectangle then pick a point inside Random Point in Non-overlapping Rectangles Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.        Medium Binary Search Random Python weighted probability solution Random Point in Non-overlapping Rectangles Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.        Medium Binary Search Random Java TreeMap solution only one random per pick Random Point in Non-overlapping Rectangles Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.        Medium Binary Search Random C++ solution using reservoir sampling with explanation - concise and easy to understand Random Point in Non-overlapping Rectangles Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.        Medium Binary Search Random Is [1,0,3,0] a valid rectangle? Random Point in Non-overlapping Rectangles Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.        Medium Binary Search Random Java 15 lines without using boolean Diagonal Traverse Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.   Example: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]  Output:  [1,2,4,7,5,3,6,8,9]  Explanation:     Note: The total number of elements of the given matrix will not exceed 10,000.  Medium Concise Java Solution Diagonal Traverse Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.   Example: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]  Output:  [1,2,4,7,5,3,6,8,9]  Explanation:     Note: The total number of elements of the given matrix will not exceed 10,000.  Medium Simply Python Solution Diagonal Traverse Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.   Example: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]  Output:  [1,2,4,7,5,3,6,8,9]  Explanation:     Note: The total number of elements of the given matrix will not exceed 10,000.  Medium C++ without paying too much attention on direction switch Diagonal Traverse Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.   Example: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]  Output:  [1,2,4,7,5,3,6,8,9]  Explanation:     Note: The total number of elements of the given matrix will not exceed 10,000.  Medium sorting and normal Python Diagonal Traverse Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.   Example: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]  Output:  [1,2,4,7,5,3,6,8,9]  Explanation:     Note: The total number of elements of the given matrix will not exceed 10,000.  Medium Java 1-Line Solution via Regex and Stream Keyboard Row Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.   Easy Hash Table Easy understand solution in 7 lines for everyone Keyboard Row Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.   Easy Hash Table Short Easy Java with Explanation Keyboard Row Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.   Easy Hash Table one-liner Ruby + Python Keyboard Row Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.   Easy Hash Table Solution in python using set Keyboard Row Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.   Easy Hash Table Proper O(1) space Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).  Easy Tree Java 4ms Beats 100% Extra O(1) solution - No Map Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).  Easy Tree 11-liner C++ O(N) time O(1) extra space In-Order Traversal (detailed explanation) Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).  Easy Tree What does "mode" mean? Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).  Easy Tree Java AC Solution Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).  Easy Tree Very Simple (Greedy) Java Solution using two PriorityQueues IPO  Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.   Hard Heap Greedy Python solution by priority queue with explanation IPO  Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.   Hard Heap Greedy 8-liner C++ 42ms beat 98% greedy algorithm (detailed explanation) IPO  Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.   Hard Heap Greedy Python solution IPO  Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.   Hard Heap Greedy Why does Greedy solution work for this; why not Dynamic Programming ? IPO  Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.   Hard Heap Greedy Java 10 lines and C++ 12 lines linear time complexity O(n) with explanation Next Greater Element II  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.  Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.   Note: The length of given array won't exceed 10000.  Medium Stack Typical ways to solve circular array problems. Java solution. Next Greater Element II  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.  Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.   Note: The length of given array won't exceed 10000.  Medium Stack Python 6 lines solution using stack Next Greater Element II  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.  Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.   Note: The length of given array won't exceed 10000.  Medium Stack NO STACK: O(n) time complexity and O(1) space complexity using DP Next Greater Element II  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.  Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.   Note: The length of given array won't exceed 10000.  Medium Stack Python solution with detailed explanation Next Greater Element II  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.  Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.   Note: The length of given array won't exceed 10000.  Medium Stack Simple Java, oneliner Ruby Base 7 Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202"   Example 2: Input: -7 Output: "-10"   Note: The input will be in range of [-1e7, 1e7].  Easy Python easy understand solution Base 7 Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202"   Example 2: Input: -7 Output: "-10"   Note: The input will be in range of [-1e7, 1e7].  Easy 3-liner C++ to build string backward + 1-liner recursive solutions Base 7 Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202"   Example 2: Input: -7 Output: "-10"   Note: The input will be in range of [-1e7, 1e7].  Easy Verbose Java Solution Base 7 Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202"   Example 2: Input: -7 Output: "-10"   Note: The input will be in range of [-1e7, 1e7].  Easy 3ms C++ 3 lines Solution Base 7 Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202"   Example 2: Input: -7 Output: "-10"   Note: The input will be in range of [-1e7, 1e7].  Easy Easy Java Solution, Sorting. Relative Ranks  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal". Example 1: Input: [5, 4, 3, 2, 1] Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"] Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.   Note:  N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique.    Easy Python solution Relative Ranks  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal". Example 1: Input: [5, 4, 3, 2, 1] Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"] Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.   Note:  N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique.    Easy Simple Sorting O(n log n) solution Relative Ranks  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal". Example 1: Input: [5, 4, 3, 2, 1] Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"] Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.   Note:  N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique.    Easy C++ Easy to Understand Relative Ranks  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal". Example 1: Input: [5, 4, 3, 2, 1] Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"] Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.   Note:  N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique.    Easy Java 6ms solution O(n) without sorting Relative Ranks  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal". Example 1: Input: [5, 4, 3, 2, 1] Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"] Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.   Note:  N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique.    Easy Verbose Java solution, postOrder traverse, HashMap (18ms) Most Frequent Subtree Sum  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.  Medium Hash Table Tree Python easy understand solution Most Frequent Subtree Sum  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.  Medium Hash Table Tree Short Clean C++ O(n)  Solution Most Frequent Subtree Sum  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.  Medium Hash Table Tree Java divide and conquer Most Frequent Subtree Sum  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.  Medium Hash Table Tree Short Easy Java Most Frequent Subtree Sum  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.  Medium Hash Table Tree Right-to-Left BFS (Python + Java) Find Bottom Left Tree Value  Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.  Medium Tree Depth-first Search Breadth-first Search Simple Java Solution, beats 100.0%! Find Bottom Left Tree Value  Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.  Medium Tree Depth-first Search Breadth-first Search Verbose Java Solution, Binary tree level order traversal Find Bottom Left Tree Value  Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.  Medium Tree Depth-first Search Breadth-first Search C++ recursive solution (beats 100%) with basic explanation Find Bottom Left Tree Value  Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.  Medium Tree Depth-first Search Breadth-first Search my BFS solution for python Find Bottom Left Tree Value  Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.  Medium Tree Depth-first Search Breadth-first Search Concise Java DP Solution Freedom Trail In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.   Hard Divide and Conquer Dynamic Programming Depth-first Search Evolve from brute force to dp Freedom Trail In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.   Hard Divide and Conquer Dynamic Programming Depth-first Search Shared my C++ dp solution ,19ms Freedom Trail In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.   Hard Divide and Conquer Dynamic Programming Depth-first Search Java Clear Solution, dfs+memoization Freedom Trail In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.   Hard Divide and Conquer Dynamic Programming Depth-first Search Super clear DFS + memorization solution Freedom Trail In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.   Hard Divide and Conquer Dynamic Programming Depth-first Search 9ms JAVA DFS solution Find Largest Value in Each Tree Row You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]    Medium Tree Depth-first Search Breadth-first Search Python BFS Find Largest Value in Each Tree Row You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]    Medium Tree Depth-first Search Breadth-first Search Java BFS Find Largest Value in Each Tree Row You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]    Medium Tree Depth-first Search Breadth-first Search 1-liner Python, Divide and conquer Find Largest Value in Each Tree Row You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]    Medium Tree Depth-first Search Breadth-first Search C++ a different approach (12ms beats 100%) Find Largest Value in Each Tree Row You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]    Medium Tree Depth-first Search Breadth-first Search Straight forward Java DP solution Longest Palindromic Subsequence  Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".  Medium Dynamic Programming Evolve from brute force to dp Longest Palindromic Subsequence  Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".  Medium Dynamic Programming What is the meaning of example 1? Longest Palindromic Subsequence  Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".  Medium Dynamic Programming Python DP O(n) space O(n^2) time Longest Palindromic Subsequence  Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".  Medium Dynamic Programming Fast and concise Python solution that actually gets AC Longest Palindromic Subsequence  Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".  Medium Dynamic Programming Super Short & Easy Java O(n) Solution Super Washing Machines You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].   Hard Math Dynamic Programming C++ 16ms O(n) solution (with trivial proof) Super Washing Machines You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].   Hard Math Dynamic Programming Very intuitive O(n) solution Super Washing Machines You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].   Hard Math Dynamic Programming Java O(n) DP Solution Super Washing Machines You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].   Hard Math Dynamic Programming Easy understand solution O(n) time and O(1) space Super Washing Machines You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].   Hard Math Dynamic Programming Knapsack problem - Java solution with thinking process O(nm) Time and O(m) Space Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that  0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer    Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1    Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.    Example 3: Input: amount = 10, coins = [10]  Output: 1     Medium Video explaining how dynamic programming works with the Coin Change problem Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that  0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer    Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1    Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.    Example 3: Input: amount = 10, coins = [10]  Output: 1     Medium Logical Thinking with Clear Java Code Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that  0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer    Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1    Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.    Example 3: Input: amount = 10, coins = [10]  Output: 1     Medium python O(n) space dp solution Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that  0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer    Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1    Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.    Example 3: Input: amount = 10, coins = [10]  Output: 1     Medium C# - DFS with memorization - of course DP is better Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that  0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer    Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1    Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.    Example 3: Input: amount = 10, coins = [10]  Output: 1     Medium Java AC Solution, call Least times of Random.nextInt() function Random Flip Matrix You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity. Note:  1 <= n_rows, n_cols <= 10000 0 <= row.id < n_rows and 0 <= col.id < n_cols flip will not be called when the matrix has no 0 values left. the total number of calls to flip and reset will not exceed 1000.  Example 1: Input:  ["Solution","flip","flip","flip","flip"] [[2,3],[],[],[],[]] Output: [null,[0,1],[1,2],[1,0],[1,1]]   Example 2: Input:  ["Solution","flip","flip","reset","flip"] [[1,2],[],[],[],[]] Output: [null,[0,0],[0,1],null,[0,0]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Random Step By Step Algorithm Explanation Random Flip Matrix You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity. Note:  1 <= n_rows, n_cols <= 10000 0 <= row.id < n_rows and 0 <= col.id < n_cols flip will not be called when the matrix has no 0 values left. the total number of calls to flip and reset will not exceed 1000.  Example 1: Input:  ["Solution","flip","flip","flip","flip"] [[2,3],[],[],[],[]] Output: [null,[0,1],[1,2],[1,0],[1,1]]   Example 2: Input:  ["Solution","flip","flip","reset","flip"] [[1,2],[],[],[],[]] Output: [null,[0,0],[0,1],null,[0,0]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Random Python solution based on random shuffle with explanation Random Flip Matrix You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity. Note:  1 <= n_rows, n_cols <= 10000 0 <= row.id < n_rows and 0 <= col.id < n_cols flip will not be called when the matrix has no 0 values left. the total number of calls to flip and reset will not exceed 1000.  Example 1: Input:  ["Solution","flip","flip","flip","flip"] [[2,3],[],[],[],[]] Output: [null,[0,1],[1,2],[1,0],[1,1]]   Example 2: Input:  ["Solution","flip","flip","reset","flip"] [[1,2],[],[],[],[]] Output: [null,[0,0],[0,1],null,[0,0]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Random Shuffle Random Flip Matrix You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity. Note:  1 <= n_rows, n_cols <= 10000 0 <= row.id < n_rows and 0 <= col.id < n_cols flip will not be called when the matrix has no 0 values left. the total number of calls to flip and reset will not exceed 1000.  Example 1: Input:  ["Solution","flip","flip","flip","flip"] [[2,3],[],[],[],[]] Output: [null,[0,1],[1,2],[1,0],[1,1]]   Example 2: Input:  ["Solution","flip","flip","reset","flip"] [[1,2],[],[],[],[]] Output: [null,[0,0],[0,1],null,[0,0]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Random c++ solution Random Flip Matrix You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity. Note:  1 <= n_rows, n_cols <= 10000 0 <= row.id < n_rows and 0 <= col.id < n_cols flip will not be called when the matrix has no 0 values left. the total number of calls to flip and reset will not exceed 1000.  Example 1: Input:  ["Solution","flip","flip","flip","flip"] [[2,3],[],[],[],[]] Output: [null,[0,1],[1,2],[1,0],[1,1]]   Example 2: Input:  ["Solution","flip","flip","reset","flip"] [[1,2],[],[],[],[]] Output: [null,[0,0],[0,1],null,[0,0]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Random 3 Lines Detect Capital  Given a word, you need to judge whether the usage of capitals in it is right or not.   We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital if it has more than one letter, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.  Example 1: Input: "USA" Output: True   Example 2: Input: "FlaG" Output: False   Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.  Easy String Python has useful methods... Detect Capital  Given a word, you need to judge whether the usage of capitals in it is right or not.   We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital if it has more than one letter, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.  Example 1: Input: "USA" Output: True   Example 2: Input: "FlaG" Output: False   Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.  Easy String Java 1-Liner Detect Capital  Given a word, you need to judge whether the usage of capitals in it is right or not.   We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital if it has more than one letter, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.  Example 1: Input: "USA" Output: True   Example 2: Input: "FlaG" Output: False   Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.  Easy String Simple Java Solution O(n) time O(1) space Detect Capital  Given a word, you need to judge whether the usage of capitals in it is right or not.   We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital if it has more than one letter, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.  Example 1: Input: "USA" Output: True   Example 2: Input: "FlaG" Output: False   Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.  Easy String Java short solution using built-in String methods Detect Capital  Given a word, you need to judge whether the usage of capitals in it is right or not.   We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital if it has more than one letter, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.  Example 1: Input: "USA" Output: True   Example 2: Input: "FlaG" Output: False   Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.  Easy String I feel this problem is just perfect for April Fools' day Longest Uncommon Subsequence I   Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.    Easy String Java 1-liner Longest Uncommon Subsequence I   Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.    Easy String Python, Simple Explanation Longest Uncommon Subsequence I   Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.    Easy String This is a silly question Longest Uncommon Subsequence I   Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.    Easy String This is a boring word game Longest Uncommon Subsequence I   Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.    Easy String Python, Simple Explanation Longest Uncommon Subsequence II  Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].   Medium String Java(15ms) - Sort + check subsequence Longest Uncommon Subsequence II  Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].   Medium String Java Hashing Solution Longest Uncommon Subsequence II  Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].   Medium String hashmap + sort solution, c++ Longest Uncommon Subsequence II  Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].   Medium String JAVA 13 lines 5ms beats 100% with explaination Longest Uncommon Subsequence II  Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].   Medium String Java O(n) time O(k) space Continuous Subarray Sum  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.  Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.   Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.   Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.   Medium Math Dynamic Programming Need to pay attention to a lot of corner cases... Continuous Subarray Sum  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.  Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.   Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.   Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.   Medium Math Dynamic Programming Concise C++ solution, use set instead of map Continuous Subarray Sum  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.  Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.   Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.   Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.   Medium Math Dynamic Programming Share my O(n) C++ accumulation-modulo solution with thinking process and explanation Continuous Subarray Sum  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.  Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.   Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.   Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.   Medium Math Dynamic Programming Math behind the solutions Continuous Subarray Sum  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.  Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.   Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.   Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.   Medium Math Dynamic Programming Short Java Solutions - Sorting Dictionary and Without Sorting Longest Word in Dictionary through Deleting  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.   Medium Two Pointers Sort Short Python solutions Longest Word in Dictionary through Deleting  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.   Medium Two Pointers Sort Python Simple (Two pointer) Longest Word in Dictionary through Deleting  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.   Medium Two Pointers Sort 10 lines solutions for c++ Longest Word in Dictionary through Deleting  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.   Medium Two Pointers Sort Easy Java Solution, isSubSequence Longest Word in Dictionary through Deleting  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.   Medium Two Pointers Sort Easy Java O(n) Solution, PreSum + HashMap Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.  Medium Hash Table Python O(n) Solution with Visual Explanation Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.  Medium Hash Table One pass,use a HashMap to record 0-1 count difference Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.  Medium Hash Table Python and Java with little tricks (incl. a oneliner :-) Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.  Medium Hash Table Share my DP&Map solution, one pass Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.  Medium Hash Table Java Solution, Backtracking Beautiful Arrangement  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:  The number at the ith position is divisible by i. i is divisible by the number at the ith position.    Now given N, how many beautiful arrangements can you construct?  Example 1: Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.   Note:  N is a positive integer and will not exceed 15.   Medium Backtracking Java 6ms beats 98% back tracking (swap) starting from the back Beautiful Arrangement  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:  The number at the ith position is divisible by i. i is divisible by the number at the ith position.    Now given N, how many beautiful arrangements can you construct?  Example 1: Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.   Note:  N is a positive integer and will not exceed 15.   Medium Backtracking My C++ elegant solution with back-tracking Beautiful Arrangement  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:  The number at the ith position is divisible by i. i is divisible by the number at the ith position.    Now given N, how many beautiful arrangements can you construct?  Example 1: Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.   Note:  N is a positive integer and will not exceed 15.   Medium Backtracking Python recursion + DP 66ms Beautiful Arrangement  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:  The number at the ith position is divisible by i. i is divisible by the number at the ith position.    Now given N, how many beautiful arrangements can you construct?  Example 1: Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.   Note:  N is a positive integer and will not exceed 15.   Medium Backtracking Easy Python, ~230ms Beautiful Arrangement  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:  The number at the ith position is divisible by i. i is divisible by the number at the ith position.    Now given N, how many beautiful arrangements can you construct?  Example 1: Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.   Note:  N is a positive integer and will not exceed 15.   Medium Backtracking Please someone explain this question? Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Binary Search Random Java accumulated freq sum & binary search Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Binary Search Random JAVA 8 lines TreeMap Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Binary Search Random Very easy solution based on uniform sampling with explanation Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Binary Search Random C++ concise binary search solution Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Medium Binary Search Random Java Solution, DFS + BFS Minesweeper Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.   Medium Depth-first Search Breadth-first Search Straight forward Java solution Minesweeper Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.   Medium Depth-first Search Breadth-first Search 10 line python solution Minesweeper Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.   Medium Depth-first Search Breadth-first Search C++ DFS solution, easy to understand Minesweeper Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.   Medium Depth-first Search Breadth-first Search Simple Python (DFS) Minesweeper Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.   Medium Depth-first Search Breadth-first Search Java O(n) solution - one Hashmap, easy to understand K-diff Pairs in an Array  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].   Easy Array Two Pointers 1-liner in Python, O(n) time K-diff Pairs in an Array  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].   Easy Array Two Pointers Two-pointer Approach K-diff Pairs in an Array  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].   Easy Array Two Pointers Easy Understood Python Solution K-diff Pairs in an Array  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].   Easy Array Two Pointers [C++] [Java] Clean Code with Explanation [set] [map] K-diff Pairs in an Array  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].   Easy Array Two Pointers c++ using stringstream Complex Number Multiplication  Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.   Medium Math String Java 3-liner Complex Number Multiplication  Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.   Medium Math String Java - (a1+b1)*(a2+b2) = (a1a2 + b1b2 + (a1b2+b1a2)) Complex Number Multiplication  Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.   Medium Math String python simple 3 lines solution Complex Number Multiplication  Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.   Medium Math String 2 lines Python Complex Number Multiplication  Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.   Medium Math String Java Recursive O(n) time Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13   Easy Tree c++ solution beats 100% Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13   Easy Tree Java Solution, 7 liner, reversed traversal Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13   Easy Tree Java Three O(n) Methods: Recursive, Iterative, and Morris Traversal Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13   Easy Tree Python, Simple with Explanation Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13   Easy Tree Verbose Java Solution, Bucket Minimum Time Difference Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.   Medium String Java 10 liner solution. Simplest so far Minimum Time Difference Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.   Medium String Python, Straightforward with Explanation Minimum Time Difference Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.   Medium String [C++] Clean Code Minimum Time Difference Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.   Medium String Java sorting with a sentinel node Minimum Time Difference Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.   Medium String Java Binary Search, short (7l), O(log(n)) w/ explanations Single Element in a Sorted Array  Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.   Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2   Example 2: Input: [3,3,7,7,10,11,11] Output: 10   Note: Your solution should run in O(log n) time and O(1) space.   Medium Java Binary Search O(log(n)) Shorter Than Others Single Element in a Sorted Array  Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.   Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2   Example 2: Input: [3,3,7,7,10,11,11] Output: 10   Note: Your solution should run in O(log n) time and O(1) space.   Medium Short, compare nums[i] with nums[i^1] Single Element in a Sorted Array  Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.   Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2   Example 2: Input: [3,3,7,7,10,11,11] Output: 10   Note: Your solution should run in O(log n) time and O(1) space.   Medium Java Code by using binary search O(log(n)) Single Element in a Sorted Array  Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.   Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2   Example 2: Input: [3,3,7,7,10,11,11] Output: 10   Note: Your solution should run in O(log n) time and O(1) space.   Medium C++ binary search Single Element in a Sorted Array  Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.   Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2   Example 2: Input: [3,3,7,7,10,11,11] Output: 10   Note: Your solution should run in O(log n) time and O(1) space.   Medium Java Concise Solution Reverse String II  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]  Easy String Python, Straightforward with Explanation Reverse String II  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]  Easy String [C++][Java] Clean Code Reverse String II  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]  Easy String 1 line simple recursive Python Reverse String II  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]  Easy String One line C++ Reverse String II  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]  Easy String Java Solution, BFS 01 Matrix  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.  The distance between two adjacent cells is 1.  Example 1:  Input: 0 0 0 0 1 0 0 0 0  Output: 0 0 0 0 1 0 0 0 0   Example 2:  Input: 0 0 0 0 1 0 1 1 1  Output: 0 0 0 0 1 0 1 2 1   Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.    Medium Depth-first Search Breadth-first Search Short solution - Each path needs at most one turn 01 Matrix  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.  The distance between two adjacent cells is 1.  Example 1:  Input: 0 0 0 0 1 0 0 0 0  Output: 0 0 0 0 1 0 0 0 0   Example 2:  Input: 0 0 0 0 1 0 1 1 1  Output: 0 0 0 0 1 0 1 2 1   Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.    Medium Depth-first Search Breadth-first Search Java 33ms solution with two sweeps in O(n) 01 Matrix  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.  The distance between two adjacent cells is 1.  Example 1:  Input: 0 0 0 0 1 0 0 0 0  Output: 0 0 0 0 1 0 0 0 0   Example 2:  Input: 0 0 0 0 1 0 1 1 1  Output: 0 0 0 0 1 0 1 2 1   Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.    Medium Depth-first Search Breadth-first Search Simple Java solution beat 99% (use DP) 01 Matrix  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.  The distance between two adjacent cells is 1.  Example 1:  Input: 0 0 0 0 1 0 0 0 0  Output: 0 0 0 0 1 0 0 0 0   Example 2:  Input: 0 0 0 0 1 0 1 1 1  Output: 0 0 0 0 1 0 1 2 1   Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.    Medium Depth-first Search Breadth-first Search Python, Simple with Explanation 01 Matrix  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.  The distance between two adjacent cells is 1.  Example 1:  Input: 0 0 0 0 1 0 0 0 0  Output: 0 0 0 0 1 0 0 0 0   Example 2:  Input: 0 0 0 0 1 0 1 1 1  Output: 0 0 0 0 1 0 1 2 1   Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.    Medium Depth-first Search Breadth-first Search Java Solution, MaxDepth Diameter of Binary Tree  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.  Easy Tree Simple Python Diameter of Binary Tree  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.  Easy Tree Python, Simple with Explanation Diameter of Binary Tree  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.  Easy Tree [543. Diameter of Binary Tree] C++_Recursive_with brief explanation Diameter of Binary Tree  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.  Easy Tree Java easy to understand solution Diameter of Binary Tree  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.  Easy Tree Java top-down and bottom-up DP solutions Remove Boxes Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.   Hard Dynamic Programming Depth-first Search Memoization DFS C++ Remove Boxes Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.   Hard Dynamic Programming Depth-first Search Java DP + Memorization 60ms Remove Boxes Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.   Hard Dynamic Programming Depth-first Search Python, Fast DP with Explanation Remove Boxes Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.   Hard Dynamic Programming Depth-first Search C++ 29ms dp solution! Remove Boxes Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.   Hard Dynamic Programming Depth-first Search Neat DFS java solution Friend Circles  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.   Medium Depth-first Search Union Find Java solution, Union Find Friend Circles  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.   Medium Depth-first Search Union Find Python, Simple Explanation Friend Circles  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.   Medium Depth-first Search Union Find Oneliners :-P Friend Circles  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.   Medium Depth-first Search Union Find [C++] Clean Code - DFS|UnionFind Friend Circles  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.   Medium Depth-first Search Union Find Java 1-liner Student Attendance Record I You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False    Easy String C++ very simple solution Student Attendance Record I You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False    Easy String Java Simple without Regex 3 lines Student Attendance Record I You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False    Easy String Java O(N) solution - Accepted Student Attendance Record I You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False    Easy String Python 1 liner without regex Student Attendance Record I You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False    Easy String Share my O(n) C++ DP solution with thinking process and explanation Student Attendance Record II Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.   Hard Dynamic Programming Improving the runtime from O(n) to O(log n) Student Attendance Record II Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.   Hard Dynamic Programming Simple Java O(n) solution Student Attendance Record II Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.   Hard Dynamic Programming Python DP with explanation Student Attendance Record II Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.   Hard Dynamic Programming O(n) time O(1) space solution Student Attendance Record II Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.   Hard Dynamic Programming Easy to understand simple O(n) solution with explanation Optimal Division Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.   Medium Math String Java Solution, Backtracking Optimal Division Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.   Medium Math String Brute force with memory in case of your interviewer forbid tricky solution Optimal Division Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.   Medium Math String O(n) very easy Java solution. Optimal Division Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.   Medium Math String Python, Straightforward with Explanation (Insightful Approach) Optimal Division Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.   Medium Math String I DON'T THINK THERE IS A BETTER PERSON THAN ME TO ANSWER THIS QUESTION Brick Wall There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.   Medium Hash Table C++ 6 lines (hash map) Brick Wall There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.   Medium Hash Table Clear Python Solution Brick Wall There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.   Medium Hash Table Neat Java Solution O(n) using hashmap Brick Wall There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.   Medium Hash Table Verbose Java Solution, PriorityQueue Brick Wall There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.   Medium Hash Table Simple Java solution (4ms) with explanation. Next Greater Element III Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1     Medium String C++ 4 lines (next_permutation) Next Greater Element III Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1     Medium String [C++] Solution with explanation Next Greater Element III Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1     Medium String Java Solution like Next Permutation Problem O(n) Next Greater Element III Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1     Medium String Easy Python3 beats 100% Next Greater Element III Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1     Medium String 1 line Ruby / Python Reverse Words in a String III Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.  Easy String short java code without explanation Reverse Words in a String III Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.  Easy String [C++] [Java] Clean Code Reverse Words in a String III Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.  Easy String Easiest Java Solution (9ms) - Similar to Reverse Words in a String II Reverse Words in a String III Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.  Easy String C++ Solution Reverse Words in a String III Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.  Easy String Python simple & short & readable AC solution Quad Tree Intersection A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: A: +-------+-------+   T: true |       |       |   F: false |   T   |   T   | |       |       | +-------+-------+ |       |       | |   F   |   F   | |       |       | +-------+-------+ topLeft: T topRight: T bottomLeft: F bottomRight: F  B:                +-------+---+---+ |       | F | F | |   T   +---+---+ |       | T | T | +-------+---+---+ |       |       | |   T   |   F   | |       |       | +-------+-------+ topLeft: T topRight:      topLeft: F      topRight: F      bottomLeft: T      bottomRight: T bottomLeft: T bottomRight: F    Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. A:                 B:                 C (A or B): +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       | F | F |  |       |       | |   T   |   T   |  |   T   +---+---+  |   T   |   T   | |       |       |  |       | T | T |  |       |       | +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       |       |  |       |       | |   F   |   F   |  |   T   |   F   |  |   T   |   F   | |       |       |  |       |       |  |       |       | +-------+-------+  +-------+-------+  +-------+-------+  Note:  Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.   Easy [FIXED] Incorrect test cases Quad Tree Intersection A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: A: +-------+-------+   T: true |       |       |   F: false |   T   |   T   | |       |       | +-------+-------+ |       |       | |   F   |   F   | |       |       | +-------+-------+ topLeft: T topRight: T bottomLeft: F bottomRight: F  B:                +-------+---+---+ |       | F | F | |   T   +---+---+ |       | T | T | +-------+---+---+ |       |       | |   T   |   F   | |       |       | +-------+-------+ topLeft: T topRight:      topLeft: F      topRight: F      bottomLeft: T      bottomRight: T bottomLeft: T bottomRight: F    Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. A:                 B:                 C (A or B): +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       | F | F |  |       |       | |   T   |   T   |  |   T   +---+---+  |   T   |   T   | |       |       |  |       | T | T |  |       |       | +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       |       |  |       |       | |   F   |   F   |  |   T   |   F   |  |   T   |   F   | |       |       |  |       |       |  |       |       | +-------+-------+  +-------+-------+  +-------+-------+  Note:  Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.   Easy C++ 10 line beat 100% Quad Tree Intersection A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: A: +-------+-------+   T: true |       |       |   F: false |   T   |   T   | |       |       | +-------+-------+ |       |       | |   F   |   F   | |       |       | +-------+-------+ topLeft: T topRight: T bottomLeft: F bottomRight: F  B:                +-------+---+---+ |       | F | F | |   T   +---+---+ |       | T | T | +-------+---+---+ |       |       | |   T   |   F   | |       |       | +-------+-------+ topLeft: T topRight:      topLeft: F      topRight: F      bottomLeft: T      bottomRight: T bottomLeft: T bottomRight: F    Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. A:                 B:                 C (A or B): +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       | F | F |  |       |       | |   T   |   T   |  |   T   +---+---+  |   T   |   T   | |       |       |  |       | T | T |  |       |       | +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       |       |  |       |       | |   F   |   F   |  |   T   |   F   |  |   T   |   F   | |       |       |  |       |       |  |       |       | +-------+-------+  +-------+-------+  +-------+-------+  Note:  Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.   Easy Java concise code beat 100% Quad Tree Intersection A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: A: +-------+-------+   T: true |       |       |   F: false |   T   |   T   | |       |       | +-------+-------+ |       |       | |   F   |   F   | |       |       | +-------+-------+ topLeft: T topRight: T bottomLeft: F bottomRight: F  B:                +-------+---+---+ |       | F | F | |   T   +---+---+ |       | T | T | +-------+---+---+ |       |       | |   T   |   F   | |       |       | +-------+-------+ topLeft: T topRight:      topLeft: F      topRight: F      bottomLeft: T      bottomRight: T bottomLeft: T bottomRight: F    Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. A:                 B:                 C (A or B): +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       | F | F |  |       |       | |   T   |   T   |  |   T   +---+---+  |   T   |   T   | |       |       |  |       | T | T |  |       |       | +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       |       |  |       |       | |   F   |   F   |  |   T   |   F   |  |   T   |   F   | |       |       |  |       |       |  |       |       | +-------+-------+  +-------+-------+  +-------+-------+  Note:  Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.   Easy Python solution to a badly worded question Quad Tree Intersection A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: A: +-------+-------+   T: true |       |       |   F: false |   T   |   T   | |       |       | +-------+-------+ |       |       | |   F   |   F   | |       |       | +-------+-------+ topLeft: T topRight: T bottomLeft: F bottomRight: F  B:                +-------+---+---+ |       | F | F | |   T   +---+---+ |       | T | T | +-------+---+---+ |       |       | |   T   |   F   | |       |       | +-------+-------+ topLeft: T topRight:      topLeft: F      topRight: F      bottomLeft: T      bottomRight: T bottomLeft: T bottomRight: F    Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. A:                 B:                 C (A or B): +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       | F | F |  |       |       | |   T   |   T   |  |   T   +---+---+  |   T   |   T   | |       |       |  |       | T | T |  |       |       | +-------+-------+  +-------+---+---+  +-------+-------+ |       |       |  |       |       |  |       |       | |   F   |   F   |  |   T   |   F   |  |   T   |   F   | |       |       |  |       |       |  |       |       | +-------+-------+  +-------+-------+  +-------+-------+  Note:  Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.   Easy [Solution] Python, C++, Simple, with explanation Maximum Depth of N-ary Tree Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Depth-first Search Breadth-first Search Java Top down DFS solutions Maximum Depth of N-ary Tree Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Depth-first Search Breadth-first Search Java BFS Iterative Solution Maximum Depth of N-ary Tree Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Depth-first Search Breadth-first Search DFS & BFS solutions in C++. Maximum Depth of N-ary Tree Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Depth-first Search Breadth-first Search Java solution with explain, same logic with Maximum Depth of binary tree Maximum Depth of N-ary Tree Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.   Easy Tree Depth-first Search Breadth-first Search Java Solution, PreSum + HashMap Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].    Medium Array Hash Table Python, Simple with Explanation Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].    Medium Array Hash Table C++ prefix sum + map Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].    Medium Array Hash Table Three Approaches With Explanation Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].    Medium Array Hash Table Super Simple Python Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].    Medium Array Hash Table Java Solution, Sorting. And rough proof of algorithm. Array Partition I  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].   Easy Array Please explain: The question doesn't make sense. Array Partition I  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].   Easy Array Java O(n) beats 100% Array Partition I  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].   Easy Array c++ code O(n),beats 100% Array Partition I  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].   Easy Array Python 1 line (sorting is accepted) Array Partition I  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].   Easy Array Java Solution, post-order traversal Binary Tree Tilt Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.   Easy Tree Python, Simple with Explanation Binary Tree Tilt Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.   Easy Tree Simple Java Solution  -- without Global Variable Binary Tree Tilt Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.   Easy Tree Python straightforward solution Binary Tree Tilt Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.   Easy Tree Java Solution, no globle varible, Easy and clean Binary Tree Tilt Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.   Easy Tree Python, Simple with Explanation Find the Closest Palindrome Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.   Hard String Java solution with full explaination Find the Closest Palindrome Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.   Hard String Java solution with detailed proof Find the Closest Palindrome Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.   Hard String C++ short solution, only need to compare 5 numbers Find the Closest Palindrome Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.   Hard String Concise Java Solution Find the Closest Palindrome Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.   Hard String [C++] [Java] Clean Code - O(N) Array Nesting A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}   Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].   Medium Array This is actually DFS Array Nesting A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}   Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].   Medium Array Python solution Array Nesting A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}   Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].   Medium Array Short Python Array Nesting A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}   Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].   Medium Array Java O(n) Time O(1) Space Array Nesting A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}   Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].   Medium Array Java Concise O(nm) time Reshape the Matrix In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.   Easy Array One loop Reshape the Matrix In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.   Easy Array Python Solutions Reshape the Matrix In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.   Easy Array Easy Java Solution Reshape the Matrix In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.   Easy Array C solution Reshape the Matrix In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.   Easy Array Java Solution, Sliding Window Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1: Input:s1 = "ab" s2 = "eidbaooo" Output:True Explanation: s2 contains one permutation of s1 ("ba").   Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False   Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].   Medium Two Pointers 8 lines slide window solution in Java Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1: Input:s1 = "ab" s2 = "eidbaooo" Output:True Explanation: s2 contains one permutation of s1 ("ba").   Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False   Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].   Medium Two Pointers Python, Simple with Explanation Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1: Input:s1 = "ab" s2 = "eidbaooo" Output:True Explanation: s2 contains one permutation of s1 ("ba").   Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False   Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].   Medium Two Pointers Sliding Window in Java, very similar to Find All Anagrams in a String Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1: Input:s1 = "ab" s2 = "eidbaooo" Output:True Explanation: s2 contains one permutation of s1 ("ba").   Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False   Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].   Medium Two Pointers Java Solution Two pointers Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1: Input:s1 = "ab" s2 = "eidbaooo" Output:True Explanation: s2 contains one permutation of s1 ("ba").   Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False   Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].   Medium Two Pointers Java Solution, tree traversal Subtree of Another Tree  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.  Easy Tree Easy O(n) java solution using preorder traversal Subtree of Another Tree  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.  Easy Tree Python, Straightforward with Explanation (O(ST) and O(S+T) approaches) Subtree of Another Tree  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.  Easy Tree Short Python by converting into strings Subtree of Another Tree  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.  Easy Tree Java Concise O(n+m) Time O(n+m) Space Subtree of Another Tree  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.  Easy Tree Python, Straightforward with Explanation Distribute Candies Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].   Easy Hash Table Java Solution, 3 lines, HashSet Distribute Candies Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].   Easy Hash Table C++, bitset, beats 99.60% Distribute Candies Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].   Easy Hash Table [C++] Clean Code - 2 Solutions: Set and Sort Distribute Candies Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].   Easy Hash Table 1-line JavaScript O(n) solution using Set Distribute Candies Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].   Easy Hash Table Java Solution, DP with space compression Out of Boundary Paths There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].   Medium Dynamic Programming Depth-first Search C++ 6 lines DP O(N * m * n), 6 ms Out of Boundary Paths There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].   Medium Dynamic Programming Depth-first Search Clean Code - 8 Solutions (6 C++ & 2 java) Out of Boundary Paths There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].   Medium Dynamic Programming Depth-first Search Java DFS with memorization Out of Boundary Paths There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].   Medium Dynamic Programming Depth-first Search Fast Python solution using NumPy Out of Boundary Paths There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].   Medium Dynamic Programming Depth-first Search Java O(n) Time O(1) Space Shortest Unsorted Continuous Subarray Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.    Easy Array Ideas behind the O(n) two-pass and one-pass solutions Shortest Unsorted Continuous Subarray Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.    Easy Array Java Solution, Sort. Shortest Unsorted Continuous Subarray Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.    Easy Array Python 2 lines Sort Solution Shortest Unsorted Continuous Subarray Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.    Easy Array C++ O(n) solution Shortest Unsorted Continuous Subarray Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.    Easy Array Java DP Solution (Longest Common Subsequence) Delete Operation for Two Strings  Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.   Medium String Java DP Solution, same as Edit Distance Delete Operation for Two Strings  Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.   Medium String Longest Common Subsequence DP Java Solution Delete Operation for Two Strings  Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.   Medium String Python DP solution Delete Operation for Two Strings  Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.   Medium String Python, Straightforward with Explanation Delete Operation for Two Strings  Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.   Medium String Java Solution, Convex Hull Algorithm - Gift wrapping aka Jarvis march Erect the Fence There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.   Example 1: Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation:   Example 2: Input: [[1,2],[2,2],[4,2]] Output: [[1,2],[2,2],[4,2]] Explanation:  Even you only have trees in a line, you need to use rope to enclose them.     Note:  All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group. All input integers will range from 0 to 100. The garden has at least one tree. All coordinates are distinct. Input points have NO order. No order required for output.   Hard Geometry Java Graham scan with adapted sorting to deal with collinear points Erect the Fence There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.   Example 1: Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation:   Example 2: Input: [[1,2],[2,2],[4,2]] Output: [[1,2],[2,2],[4,2]] Explanation:  Even you only have trees in a line, you need to use rope to enclose them.     Note:  All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group. All input integers will range from 0 to 100. The garden has at least one tree. All coordinates are distinct. Input points have NO order. No order required for output.   Hard Geometry C++ and Python easy wiki solution Erect the Fence There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.   Example 1: Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation:   Example 2: Input: [[1,2],[2,2],[4,2]] Output: [[1,2],[2,2],[4,2]] Explanation:  Even you only have trees in a line, you need to use rope to enclose them.     Note:  All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group. All input integers will range from 0 to 100. The garden has at least one tree. All coordinates are distinct. Input points have NO order. No order required for output.   Hard Geometry Python, AM Chain with Explanation Erect the Fence There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.   Example 1: Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation:   Example 2: Input: [[1,2],[2,2],[4,2]] Output: [[1,2],[2,2],[4,2]] Explanation:  Even you only have trees in a line, you need to use rope to enclose them.     Note:  All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group. All input integers will range from 0 to 100. The garden has at least one tree. All coordinates are distinct. Input points have NO order. No order required for output.   Hard Geometry c++ Graham Scan/Monotone Chain dealing with collinear cases Erect the Fence There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.   Example 1: Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation:   Example 2: Input: [[1,2],[2,2],[4,2]] Output: [[1,2],[2,2],[4,2]] Explanation:  Even you only have trees in a line, you need to use rope to enclose them.     Note:  All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group. All input integers will range from 0 to 100. The garden has at least one tree. All coordinates are distinct. Input points have NO order. No order required for output.   Hard Geometry Java Iterative and Recursive Solutions N-ary Tree Preorder Traversal Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?  Easy Tree Python short iterative solution beats 100% // 66 ms faster than fastest ! N-ary Tree Preorder Traversal Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?  Easy Tree C++ simple 10-line iterative solution, beat 100%! N-ary Tree Preorder Traversal Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?  Easy Tree C++ 44ms beats 100% both iterative and recursive N-ary Tree Preorder Traversal Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?  Easy Tree Java Time O(N) and space O(N) recursive / iterative solution using helper method N-ary Tree Preorder Traversal Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?  Easy Tree Java Solution: Use startsWith and indexOf Tag Validator Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.   Hard String Stack Short Python, accepted but not sure if correct Tag Validator Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.   Hard String Stack Java Solution, 7 lines, Regular Expression Tag Validator Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.   Hard String Stack [C++] Clean Code - Recursive Parser Tag Validator Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.   Hard String Stack Clean C++ Solution Tag Validator Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.   Hard String Stack Small simple C++/Java/Python Fraction Addition and Subtraction Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.   Medium Math Concise Java Solution Fraction Addition and Subtraction Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.   Medium Math Python easy understood 2-line solution Fraction Addition and Subtraction Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.   Medium Math Java Solution, Fraction Addition and GCD Fraction Addition and Subtraction Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.   Medium Math C++ clean code Fraction Addition and Subtraction Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.   Medium Math C++ 3 lines (unordered_set) Valid Square Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:   All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.   Medium Math Simple Java Solution - Square distances Valid Square Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:   All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.   Medium Math 4 Liner Java Valid Square Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:   All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.   Medium Math A general solution to find combination of squares in n points in O(n^2) time Valid Square Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:   All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.   Medium Math Share my simple Python solution Valid Square Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:   All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.   Medium Math Simple Java HashMap Solution Longest Harmonious Subsequence We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].   Note: The length of the input array will not exceed 20,000.   Easy Hash Table Python, Straightforward with Explanation Longest Harmonious Subsequence We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].   Note: The length of the input array will not exceed 20,000.   Easy Hash Table Three C++ Solution run time with explanation Longest Harmonious Subsequence We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].   Note: The length of the input array will not exceed 20,000.   Easy Hash Table Short Python using Counter Longest Harmonious Subsequence We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].   Note: The length of the input array will not exceed 20,000.   Easy Hash Table Java Solution, HashMap Longest Harmonious Subsequence We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].   Note: The length of the input array will not exceed 20,000.   Easy Hash Table Union and OR and the Explanation Big Countries SQL SchemaThere is a table World  +-----------------+------------+------------+--------------+---------------+ | name            | continent  | area       | population   | gdp           | +-----------------+------------+------------+--------------+---------------+ | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      | | Albania         | Europe     | 28748      | 2831741      | 12960000      | | Algeria         | Africa     | 2381741    | 37100000     | 188681000     | | Andorra         | Europe     | 468        | 78115        | 3712000       | | Angola          | Africa     | 1246700    | 20609294     | 100990000     | +-----------------+------------+------------+--------------+---------------+   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.  Write a SQL solution to output big countries' name, population and area.   For example, according to the above table, we should output: +--------------+-------------+--------------+ | name         | population  | area         | +--------------+-------------+--------------+ | Afghanistan  | 25500100    | 652230       | | Algeria      | 37100000    | 2381741      | +--------------+-------------+--------------+   Easy Easy AC Big Countries SQL SchemaThere is a table World  +-----------------+------------+------------+--------------+---------------+ | name            | continent  | area       | population   | gdp           | +-----------------+------------+------------+--------------+---------------+ | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      | | Albania         | Europe     | 28748      | 2831741      | 12960000      | | Algeria         | Africa     | 2381741    | 37100000     | 188681000     | | Andorra         | Europe     | 468        | 78115        | 3712000       | | Angola          | Africa     | 1246700    | 20609294     | 100990000     | +-----------------+------------+------------+--------------+---------------+   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.  Write a SQL solution to output big countries' name, population and area.   For example, according to the above table, we should output: +--------------+-------------+--------------+ | name         | population  | area         | +--------------+-------------+--------------+ | Afghanistan  | 25500100    | 652230       | | Algeria      | 37100000    | 2381741      | +--------------+-------------+--------------+   Easy Description and author's solution are inconsistent Big Countries SQL SchemaThere is a table World  +-----------------+------------+------------+--------------+---------------+ | name            | continent  | area       | population   | gdp           | +-----------------+------------+------------+--------------+---------------+ | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      | | Albania         | Europe     | 28748      | 2831741      | 12960000      | | Algeria         | Africa     | 2381741    | 37100000     | 188681000     | | Andorra         | Europe     | 468        | 78115        | 3712000       | | Angola          | Africa     | 1246700    | 20609294     | 100990000     | +-----------------+------------+------------+--------------+---------------+   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.  Write a SQL solution to output big countries' name, population and area.   For example, according to the above table, we should output: +--------------+-------------+--------------+ | name         | population  | area         | +--------------+-------------+--------------+ | Afghanistan  | 25500100    | 652230       | | Algeria      | 37100000    | 2381741      | +--------------+-------------+--------------+   Easy Obvious solution: Runtime: 1724 ms, faster than 92.81% of MySQL online submissions Big Countries SQL SchemaThere is a table World  +-----------------+------------+------------+--------------+---------------+ | name            | continent  | area       | population   | gdp           | +-----------------+------------+------------+--------------+---------------+ | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      | | Albania         | Europe     | 28748      | 2831741      | 12960000      | | Algeria         | Africa     | 2381741    | 37100000     | 188681000     | | Andorra         | Europe     | 468        | 78115        | 3712000       | | Angola          | Africa     | 1246700    | 20609294     | 100990000     | +-----------------+------------+------------+--------------+---------------+   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.  Write a SQL solution to output big countries' name, population and area.   For example, according to the above table, we should output: +--------------+-------------+--------------+ | name         | population  | area         | +--------------+-------------+--------------+ | Afghanistan  | 25500100    | 652230       | | Algeria      | 37100000    | 2381741      | +--------------+-------------+--------------+   Easy For those wondering the units Big Countries SQL SchemaThere is a table World  +-----------------+------------+------------+--------------+---------------+ | name            | continent  | area       | population   | gdp           | +-----------------+------------+------------+--------------+---------------+ | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      | | Albania         | Europe     | 28748      | 2831741      | 12960000      | | Algeria         | Africa     | 2381741    | 37100000     | 188681000     | | Andorra         | Europe     | 468        | 78115        | 3712000       | | Angola          | Africa     | 1246700    | 20609294     | 100990000     | +-----------------+------------+------------+--------------+---------------+   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.  Write a SQL solution to output big countries' name, population and area.   For example, according to the above table, we should output: +--------------+-------------+--------------+ | name         | population  | area         | +--------------+-------------+--------------+ | Afghanistan  | 25500100    | 652230       | | Algeria      | 37100000    | 2381741      | +--------------+-------------+--------------+   Easy All the same Classes More Than 5 Students SQL Schema There is a table courses with columns: student and class  Please list out all classes which have more than or equal to 5 students.   For example, the table:  +---------+------------+ | student | class      | +---------+------------+ | A       | Math       | | B       | English    | | C       | Math       | | D       | Biology    | | E       | Math       | | F       | Computer   | | G       | Math       | | H       | Math       | | I       | Math       | +---------+------------+   Should output: +---------+ | class   | +---------+ | Math    | +---------+    Note: The students should not be counted duplicate in each course.  Easy my solution Classes More Than 5 Students SQL Schema There is a table courses with columns: student and class  Please list out all classes which have more than or equal to 5 students.   For example, the table:  +---------+------------+ | student | class      | +---------+------------+ | A       | Math       | | B       | English    | | C       | Math       | | D       | Biology    | | E       | Math       | | F       | Computer   | | G       | Math       | | H       | Math       | | I       | Math       | +---------+------------+   Should output: +---------+ | class   | +---------+ | Math    | +---------+    Note: The students should not be counted duplicate in each course.  Easy My first mysql Solution,  Classes More Than 5 Students SQL Schema There is a table courses with columns: student and class  Please list out all classes which have more than or equal to 5 students.   For example, the table:  +---------+------------+ | student | class      | +---------+------------+ | A       | Math       | | B       | English    | | C       | Math       | | D       | Biology    | | E       | Math       | | F       | Computer   | | G       | Math       | | H       | Math       | | I       | Math       | +---------+------------+   Should output: +---------+ | class   | +---------+ | Math    | +---------+    Note: The students should not be counted duplicate in each course.  Easy can not be more simpler Classes More Than 5 Students SQL Schema There is a table courses with columns: student and class  Please list out all classes which have more than or equal to 5 students.   For example, the table:  +---------+------------+ | student | class      | +---------+------------+ | A       | Math       | | B       | English    | | C       | Math       | | D       | Biology    | | E       | Math       | | F       | Computer   | | G       | Math       | | H       | Math       | | I       | Math       | +---------+------------+   Should output: +---------+ | class   | +---------+ | Math    | +---------+    Note: The students should not be counted duplicate in each course.  Easy Concise solution using distinct and having. Classes More Than 5 Students SQL Schema There is a table courses with columns: student and class  Please list out all classes which have more than or equal to 5 students.   For example, the table:  +---------+------------+ | student | class      | +---------+------------+ | A       | Math       | | B       | English    | | C       | Math       | | D       | Biology    | | E       | Math       | | F       | Computer   | | G       | Math       | | H       | Math       | | I       | Math       | +---------+------------+   Should output: +---------+ | class   | +---------+ | Math    | +---------+    Note: The students should not be counted duplicate in each course.  Easy Java Solution, find Min Range Addition II Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.   Easy Math Python solution , beat 100% Range Addition II Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.   Easy Math Python, Straightforward with Explanation Range Addition II Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.   Easy Math Java simple solution Range Addition II Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.   Easy Math C++ short solution Range Addition II Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.   Easy Math Java O(n+m) Time O(n) Space Minimum Index Sum of Two Lists  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.   Easy Hash Table UCSD Students? Minimum Index Sum of Two Lists  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.   Easy Hash Table Python, Straightforward with Explanation Minimum Index Sum of Two Lists  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.   Easy Hash Table C++ 9 lines hash table easy to understand Minimum Index Sum of Two Lists  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.   Easy Hash Table Bug Report Minimum Index Sum of Two Lists  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.   Easy Hash Table Java Solution, DP Non-negative Integers without Consecutive Ones Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109   Hard Dynamic Programming C++, Non-DP, O(32) Fibonacci solution Non-negative Integers without Consecutive Ones Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109   Hard Dynamic Programming C++ 4 lines DP/Fibonacci 6 ms Non-negative Integers without Consecutive Ones Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109   Hard Dynamic Programming Java O(1) time O(1) space DP Solution Non-negative Integers without Consecutive Ones Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109   Hard Dynamic Programming python dp solution easily understood Non-negative Integers without Consecutive Ones Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109   Hard Dynamic Programming A simple solution Human Traffic of Stadium SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people  Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).    For example, the table stadium: +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 1    | 2017-01-01 | 10        | | 2    | 2017-01-02 | 109       | | 3    | 2017-01-03 | 150       | | 4    | 2017-01-04 | 99        | | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   For the sample data above, the output is:  +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   Note: Each day only have one row record, and the dates are increasing with id increasing.   Hard solution using join Human Traffic of Stadium SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people  Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).    For example, the table stadium: +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 1    | 2017-01-01 | 10        | | 2    | 2017-01-02 | 109       | | 3    | 2017-01-03 | 150       | | 4    | 2017-01-04 | 99        | | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   For the sample data above, the output is:  +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   Note: Each day only have one row record, and the dates are increasing with id increasing.   Hard I don't understand the problem Human Traffic of Stadium SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people  Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).    For example, the table stadium: +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 1    | 2017-01-01 | 10        | | 2    | 2017-01-02 | 109       | | 3    | 2017-01-03 | 150       | | 4    | 2017-01-04 | 99        | | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   For the sample data above, the output is:  +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   Note: Each day only have one row record, and the dates are increasing with id increasing.   Hard Wrong testcase Human Traffic of Stadium SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people  Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).    For example, the table stadium: +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 1    | 2017-01-01 | 10        | | 2    | 2017-01-02 | 109       | | 3    | 2017-01-03 | 150       | | 4    | 2017-01-04 | 99        | | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   For the sample data above, the output is:  +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   Note: Each day only have one row record, and the dates are increasing with id increasing.   Hard A solution with union, join and where Human Traffic of Stadium SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people  Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).    For example, the table stadium: +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 1    | 2017-01-01 | 10        | | 2    | 2017-01-02 | 109       | | 3    | 2017-01-03 | 150       | | 4    | 2017-01-04 | 99        | | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   For the sample data above, the output is:  +------+------------+-----------+ | id   | date       | people    | +------+------------+-----------+ | 5    | 2017-01-05 | 145       | | 6    | 2017-01-06 | 1455      | | 7    | 2017-01-07 | 199       | | 8    | 2017-01-08 | 188       | +------+------------+-----------+   Note: Each day only have one row record, and the dates are increasing with id increasing.   Hard Java - Greedy solution - O(flowerbed) - beats 100% Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.   Easy Array [Java] Very easy solution Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.   Easy Array Python, Straightforward with Explanation Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.   Easy Array simplest c++ code Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.   Easy Array [C++][Java] Clean Code Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.   Easy Array Java Solution, Tree Traversal Construct String from Binary Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.   Easy String Tree Python, Straightforward with Explanation Construct String from Binary Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.   Easy String Tree Java simple recursion Construct String from Binary Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.   Easy String Tree [Java/C++] 1 liner Construct String from Binary Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.   Easy String Tree Python Simple Solution Construct String from Binary Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.   Easy String Tree C++ clean solution, answers to follow up Find Duplicate File in System Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format:  "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:  "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]   Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.   Follow-up beyond contest:   Imagine you are given a real file system, how will you search files? DFS or BFS?  If the file content is very large (GB level), how will you modify your solution?  If you can only read the file by 1kb each time, how will you modify your solution?  What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?  How to make sure the duplicated files you find are not false positive?  Medium Hash Table String Python, Straightforward with Explanation Find Duplicate File in System Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format:  "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:  "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]   Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.   Follow-up beyond contest:   Imagine you are given a real file system, how will you search files? DFS or BFS?  If the file content is very large (GB level), how will you modify your solution?  If you can only read the file by 1kb each time, how will you modify your solution?  What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?  How to make sure the duplicated files you find are not false positive?  Medium Hash Table String Java Solution, HashMap Find Duplicate File in System Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format:  "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:  "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]   Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.   Follow-up beyond contest:   Imagine you are given a real file system, how will you search files? DFS or BFS?  If the file content is very large (GB level), how will you modify your solution?  If you can only read the file by 1kb each time, how will you modify your solution?  What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?  How to make sure the duplicated files you find are not false positive?  Medium Hash Table String Straight forward solution with a tiny bit of Java8 Find Duplicate File in System Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format:  "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:  "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]   Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.   Follow-up beyond contest:   Imagine you are given a real file system, how will you search files? DFS or BFS?  If the file content is very large (GB level), how will you modify your solution?  If you can only read the file by 1kb each time, how will you modify your solution?  What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?  How to make sure the duplicated files you find are not false positive?  Medium Hash Table String Follow up questions discussion Find Duplicate File in System Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format:  "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:  "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]   Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.   Follow-up beyond contest:   Imagine you are given a real file system, how will you search files? DFS or BFS?  If the file content is very large (GB level), how will you modify your solution?  If you can only read the file by 1kb each time, how will you modify your solution?  What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?  How to make sure the duplicated files you find are not false positive?  Medium Hash Table String Java O(n^2) Time O(1) Space Valid Triangle Number Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].    Medium Array Java Solution, 3 pointers Valid Triangle Number Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].    Medium Array O(N^2) solution for C++ & Python Valid Triangle Number Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].    Medium Array A similar O(n^2) solution to 3-Sum  Valid Triangle Number Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].    Medium Array Can this problem  possibly be solved by python? Valid Triangle Number Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].    Medium Array Python, Straightforward with Explanation Merge Two Binary Trees Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.  Easy Tree Java Solution, 6 lines, Tree Traversal Merge Two Binary Trees Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.  Easy Tree Short Recursive Solution w/ Python & C++ Merge Two Binary Trees Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.  Easy Tree [Java/C++] Clean Code - Unique Node | Shared Node - 5 liner Merge Two Binary Trees Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.  Easy Tree Java One Recursive Solution and Two Iterative Solutions (DFS and BFS) with Explanations Merge Two Binary Trees Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.  Easy Tree My solution Not Boring Movies SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.    Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.   For example, table cinema: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   1     | War       |   great 3D   |   8.9     | |   2     | Science   |   fiction    |   8.5     | |   3     | irish     |   boring     |   6.2     | |   4     | Ice song  |   Fantacy    |   8.6     | |   5     | House card|   Interesting|   9.1     | +---------+-----------+--------------+-----------+  For the example above, the output should be: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   5     | House card|   Interesting|   9.1     | |   1     | War       |   great 3D   |   8.9     | +---------+-----------+--------------+-----------+   Easy Judge parity using '&' Not Boring Movies SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.    Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.   For example, table cinema: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   1     | War       |   great 3D   |   8.9     | |   2     | Science   |   fiction    |   8.5     | |   3     | irish     |   boring     |   6.2     | |   4     | Ice song  |   Fantacy    |   8.6     | |   5     | House card|   Interesting|   9.1     | +---------+-----------+--------------+-----------+  For the example above, the output should be: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   5     | House card|   Interesting|   9.1     | |   1     | War       |   great 3D   |   8.9     | +---------+-----------+--------------+-----------+   Easy My first post of SQL questions! : ) Not Boring Movies SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.    Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.   For example, table cinema: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   1     | War       |   great 3D   |   8.9     | |   2     | Science   |   fiction    |   8.5     | |   3     | irish     |   boring     |   6.2     | |   4     | Ice song  |   Fantacy    |   8.6     | |   5     | House card|   Interesting|   9.1     | +---------+-----------+--------------+-----------+  For the example above, the output should be: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   5     | House card|   Interesting|   9.1     | |   1     | War       |   great 3D   |   8.9     | +---------+-----------+--------------+-----------+   Easy The problem description could be worded better Not Boring Movies SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.    Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.   For example, table cinema: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   1     | War       |   great 3D   |   8.9     | |   2     | Science   |   fiction    |   8.5     | |   3     | irish     |   boring     |   6.2     | |   4     | Ice song  |   Fantacy    |   8.6     | |   5     | House card|   Interesting|   9.1     | +---------+-----------+--------------+-----------+  For the example above, the output should be: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   5     | House card|   Interesting|   9.1     | |   1     | War       |   great 3D   |   8.9     | +---------+-----------+--------------+-----------+   Easy A slightly different way of solving this sql using CASE Not Boring Movies SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.    Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.   For example, table cinema: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   1     | War       |   great 3D   |   8.9     | |   2     | Science   |   fiction    |   8.5     | |   3     | irish     |   boring     |   6.2     | |   4     | Ice song  |   Fantacy    |   8.6     | |   5     | House card|   Interesting|   9.1     | +---------+-----------+--------------+-----------+  For the example above, the output should be: +---------+-----------+--------------+-----------+ |   id    | movie     |  description |  rating   | +---------+-----------+--------------+-----------+ |   5     | House card|   Interesting|   9.1     | |   1     | War       |   great 3D   |   8.9     | +---------+-----------+--------------+-----------+   Easy Concise Java using array Design Circular Queue Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations:  MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not.    Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1);  // return true circularQueue.enQueue(2);  // return true circularQueue.enQueue(3);  // return true circularQueue.enQueue(4);  // return false, the queue is full circularQueue.Rear();  // return 3 circularQueue.isFull();  // return true circularQueue.deQueue();  // return true circularQueue.enQueue(4);  // return true circularQueue.Rear();  // return 4     Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.   Medium Design Queue Python short & simple AC doubly linked list solution Design Circular Queue Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations:  MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not.    Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1);  // return true circularQueue.enQueue(2);  // return true circularQueue.enQueue(3);  // return true circularQueue.enQueue(4);  // return false, the queue is full circularQueue.Rear();  // return 3 circularQueue.isFull();  // return true circularQueue.deQueue();  // return true circularQueue.enQueue(4);  // return true circularQueue.Rear();  // return 4     Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.   Medium Design Queue Straightforward Implementation in C++ [20ms] Design Circular Queue Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations:  MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not.    Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1);  // return true circularQueue.enQueue(2);  // return true circularQueue.enQueue(3);  // return true circularQueue.enQueue(4);  // return false, the queue is full circularQueue.Rear();  // return 3 circularQueue.isFull();  // return true circularQueue.deQueue();  // return true circularQueue.enQueue(4);  // return true circularQueue.Rear();  // return 4     Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.   Medium Design Queue Java Solution with Explanation Design Circular Queue Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations:  MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not.    Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1);  // return true circularQueue.enQueue(2);  // return true circularQueue.enQueue(3);  // return true circularQueue.enQueue(4);  // return false, the queue is full circularQueue.Rear();  // return 3 circularQueue.isFull();  // return true circularQueue.deQueue();  // return true circularQueue.enQueue(4);  // return true circularQueue.Rear();  // return 4     Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.   Medium Design Queue Simple Java solution using Doubly Linked List Design Circular Queue Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations:  MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not.    Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1);  // return true circularQueue.enQueue(2);  // return true circularQueue.enQueue(3);  // return true circularQueue.enQueue(4);  // return false, the queue is full circularQueue.Rear();  // return 3 circularQueue.isFull();  // return true circularQueue.deQueue();  // return true circularQueue.enQueue(4);  // return true circularQueue.Rear();  // return 4     Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.   Medium Design Queue [C++] [Java] 10 line Solution - no helper Add One Row to Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.   Medium Tree Java, three methods, one BFS and two DFS Add One Row to Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.   Medium Tree Short Python BFS Add One Row to Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.   Medium Tree Simple Java solution - O(N) Add One Row to Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.   Medium Tree Simple C++ solution Add One Row to Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.   Medium Tree 4 line solution using if statement Exchange Seats SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? +---------+---------+ |    id   | student | +---------+---------+ |    1    | Abbot   | |    2    | Doris   | |    3    | Emerson | |    4    | Green   | |    5    | Jeames  | +---------+---------+  For the sample input, the output is: +---------+---------+ |    id   | student | +---------+---------+ |    1    | Doris   | |    2    | Abbot   | |    3    | Green   | |    4    | Emerson | |    5    | Jeames  | +---------+---------+   Note: If the number of students is odd, there is no need to change the last one's seat.  Medium Using two UNION operators Exchange Seats SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? +---------+---------+ |    id   | student | +---------+---------+ |    1    | Abbot   | |    2    | Doris   | |    3    | Emerson | |    4    | Green   | |    5    | Jeames  | +---------+---------+  For the sample input, the output is: +---------+---------+ |    id   | student | +---------+---------+ |    1    | Doris   | |    2    | Abbot   | |    3    | Green   | |    4    | Emerson | |    5    | Jeames  | +---------+---------+   Note: If the number of students is odd, there is no need to change the last one's seat.  Medium A solution without using union and order by Exchange Seats SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? +---------+---------+ |    id   | student | +---------+---------+ |    1    | Abbot   | |    2    | Doris   | |    3    | Emerson | |    4    | Green   | |    5    | Jeames  | +---------+---------+  For the sample input, the output is: +---------+---------+ |    id   | student | +---------+---------+ |    1    | Doris   | |    2    | Abbot   | |    3    | Green   | |    4    | Emerson | |    5    | Jeames  | +---------+---------+   Note: If the number of students is odd, there is no need to change the last one's seat.  Medium simple case solution Exchange Seats SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? +---------+---------+ |    id   | student | +---------+---------+ |    1    | Abbot   | |    2    | Doris   | |    3    | Emerson | |    4    | Green   | |    5    | Jeames  | +---------+---------+  For the sample input, the output is: +---------+---------+ |    id   | student | +---------+---------+ |    1    | Doris   | |    2    | Abbot   | |    3    | Green   | |    4    | Emerson | |    5    | Jeames  | +---------+---------+   Note: If the number of students is odd, there is no need to change the last one's seat.  Medium A Simple Solution Exchange Seats SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? +---------+---------+ |    id   | student | +---------+---------+ |    1    | Abbot   | |    2    | Doris   | |    3    | Emerson | |    4    | Green   | |    5    | Jeames  | +---------+---------+  For the sample input, the output is: +---------+---------+ |    id   | student | +---------+---------+ |    1    | Doris   | |    2    | Abbot   | |    3    | Green   | |    4    | Emerson | |    5    | Jeames  | +---------+---------+   Note: If the number of students is odd, there is no need to change the last one's seat.  Medium Accept solution with xor Swap Salary SQL SchemaGiven a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.   For example: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | m   | 2500   | | 2  | B    | f   | 1500   | | 3  | C    | m   | 5500   | | 4  | D    | f   | 500    |  After running your query, the above salary table should have the following rows: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | f   | 2500   | | 2  | B    | m   | 1500   | | 3  | C    | f   | 5500   | | 4  | D    | m   | 500    |   Easy Short and Simple Swap Salary SQL SchemaGiven a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.   For example: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | m   | 2500   | | 2  | B    | f   | 1500   | | 3  | C    | m   | 5500   | | 4  | D    | f   | 500    |  After running your query, the above salary table should have the following rows: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | f   | 2500   | | 2  | B    | m   | 1500   | | 3  | C    | f   | 5500   | | 4  | D    | m   | 500    |   Easy Simple and short with IF Swap Salary SQL SchemaGiven a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.   For example: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | m   | 2500   | | 2  | B    | f   | 1500   | | 3  | C    | m   | 5500   | | 4  | D    | f   | 500    |  After running your query, the above salary table should have the following rows: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | f   | 2500   | | 2  | B    | m   | 1500   | | 3  | C    | f   | 5500   | | 4  | D    | m   | 500    |   Easy Solution using ASCII code Swap Salary SQL SchemaGiven a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.   For example: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | m   | 2500   | | 2  | B    | f   | 1500   | | 3  | C    | m   | 5500   | | 4  | D    | f   | 500    |  After running your query, the above salary table should have the following rows: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | f   | 2500   | | 2  | B    | m   | 1500   | | 3  | C    | f   | 5500   | | 4  | D    | m   | 500    |   Easy the solution with multiplication and division of ascii codes Swap Salary SQL SchemaGiven a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.   For example: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | m   | 2500   | | 2  | B    | f   | 1500   | | 3  | C    | m   | 5500   | | 4  | D    | f   | 500    |  After running your query, the above salary table should have the following rows: | id | name | sex | salary | |----|------|-----|--------| | 1  | A    | f   | 2500   | | 2  | B    | m   | 1500   | | 3  | C    | f   | 5500   | | 4  | D    | m   | 500    |   Easy Java O(1) space O(n) time solution beat 100% Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6   Example 2: Input: [1,2,3,4] Output: 24   Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.   Easy Array Math Java Easy AC... Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6   Example 2: Input: [1,2,3,4] Output: 24   Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.   Easy Array Math Python concise solution, O(N) and 1 line Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6   Example 2: Input: [1,2,3,4] Output: 24   Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.   Easy Array Math Share my python solution: one pass, O(n) time O(1) space Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6   Example 2: Input: [1,2,3,4] Output: 24   Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.   Easy Array Math General solution for any K  Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6   Example 2: Input: [1,2,3,4] Output: 24   Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.   Easy Array Math Java DP O(nk) solution K Inverse Pairs Array  Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.    We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.   Since the answer may be very large, the answer should be modulo 109 + 7.  Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.   Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.   Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].   Hard Dynamic Programming Shared my C++ O(n * k) solution with explanation K Inverse Pairs Array  Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.    We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.   Since the answer may be very large, the answer should be modulo 109 + 7.  Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.   Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.   Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].   Hard Dynamic Programming Python, Straightforward with Explanation K Inverse Pairs Array  Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.    We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.   Since the answer may be very large, the answer should be modulo 109 + 7.  Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.   Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.   Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].   Hard Dynamic Programming Python concise solution K Inverse Pairs Array  Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.    We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.   Since the answer may be very large, the answer should be modulo 109 + 7.  Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.   Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.   Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].   Hard Dynamic Programming java,DP.Thank you so much @GardenAAA for your advice. K Inverse Pairs Array  Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.    We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.   Since the answer may be very large, the answer should be modulo 109 + 7.  Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.   Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.   Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].   Hard Dynamic Programming Short Java code using PriorityQueue Course Schedule III  There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.   Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.  Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.   Note:  The integer 1 <= d, t, n <= 10,000.  You can't take two courses simultaneously.   Hard Greedy Python, Straightforward with Explanation Course Schedule III  There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.   Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.  Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.   Note:  The integer 1 <= d, t, n <= 10,000.  You can't take two courses simultaneously.   Hard Greedy C++ 13 lines With Explanation Course Schedule III  There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.   Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.  Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.   Note:  The integer 1 <= d, t, n <= 10,000.  You can't take two courses simultaneously.   Hard Greedy C++ Short & Elegant O(nlogn) Time, O(k) Space Solution Course Schedule III  There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.   Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.  Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.   Note:  The integer 1 <= d, t, n <= 10,000.  You can't take two courses simultaneously.   Hard Greedy C++ short code using priority queue, O(NlogN) Course Schedule III  There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.   Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.  Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.   Note:  The integer 1 <= d, t, n <= 10,000.  You can't take two courses simultaneously.   Hard Greedy Java Code using PriorityQueue. similar to merge k array Smallest Range You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.  We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500  -105 <= value of elements <= 105. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.    Hard Hash Table Two Pointers String Python, Heap-based solution Smallest Range You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.  We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500  -105 <= value of elements <= 105. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.    Hard Hash Table Two Pointers String Clean C++ priority_queue solution using iterators Smallest Range You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.  We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500  -105 <= value of elements <= 105. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.    Hard Hash Table Two Pointers String Java 8, Sliding window Smallest Range You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.  We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500  -105 <= value of elements <= 105. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.    Hard Hash Table Two Pointers String Java Solution with maxHeap&minHeap Smallest Range You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.  We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500  -105 <= value of elements <= 105. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.    Hard Hash Table Two Pointers String Java Two Pointers Solution Sum of Square Numbers  Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.  Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5   Example 2: Input: 3 Output: False    Easy Math HashSet, Java, quick solution, one for loop Sum of Square Numbers  Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.  Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5   Example 2: Input: 3 Output: False    Easy Math Python, Straightforward with Explanation Sum of Square Numbers  Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.  Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5   Example 2: Input: 3 Output: False    Easy Math Fermat Sum of Square Numbers  Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.  Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5   Example 2: Input: 3 Output: False    Easy Math C++ very simple O(1) space solution Sum of Square Numbers  Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.  Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5   Example 2: Input: 3 Output: False    Easy Math Java Stack Solution O(n) Time O(n) Space Exclusive Time of Functions Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.  Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.  Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1.  Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time.  So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.   Note:  Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 <= n <= 100   Medium Stack Python, Straightforward with Explanation Exclusive Time of Functions Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.  Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.  Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1.  Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time.  So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.   Note:  Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 <= n <= 100   Medium Stack How is function 1 executing 4 units of time? Exclusive Time of Functions Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.  Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.  Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1.  Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time.  So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.   Note:  Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 <= n <= 100   Medium Stack C++ O(n) stack with explaination Exclusive Time of Functions Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.  Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.  Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1.  Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time.  So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.   Note:  Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 <= n <= 100   Medium Stack Java clean solution with normalized time explained Exclusive Time of Functions Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.  Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.  Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1.  Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time.  So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.   Note:  Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 <= n <= 100   Medium Stack Java BFS Solution Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.   Easy Tree A good problem to practice (BFS + DFS) Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.   Easy Tree C++ simple and clear BFS solution Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.   Easy Tree Python, Straightforward with Explanation Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.   Easy Tree "one-liner" Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.   Easy Tree Very Easy to understand JAVA Solution beats 95% with explanation Shopping Offers  In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.   Medium Dynamic Programming Depth-first Search Concise c++ DFS solution, 6ms Shopping Offers  In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.   Medium Dynamic Programming Depth-first Search Simple Java recursive solution Shopping Offers  In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.   Medium Dynamic Programming Depth-first Search Java DFS + DP Shopping Offers  In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.   Medium Dynamic Programming Depth-first Search Python dfs with memorization. Shopping Offers  In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.   Medium Dynamic Programming Depth-first Search Java O(N) by General Solution for all DP problems Decode Ways II  A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.   Hard Dynamic Programming Python, Straightforward with Explanation Decode Ways II  A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.   Hard Dynamic Programming Java DP, O(n) time and O(1) space Decode Ways II  A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.   Hard Dynamic Programming C++, DP, O(n) time O(1) space Decode Ways II  A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.   Hard Dynamic Programming Python 6-lines DP solution Decode Ways II  A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.   Hard Dynamic Programming Concise Java Solution Solve the Equation  Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"   Medium Math Simple 2-liner (and more) Solve the Equation  Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"   Medium Math C++, Two pointers, concise solution Solve the Equation  Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"   Medium Math Python Regex Solution explained Solve the Equation  Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"   Medium Math Clear Java Code with Detailed Example Solve the Equation  Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"   Medium Math c++ 99% ring buffer no edge cases. fb interviewer really loves it. easy to impl in 4mins. cheers! Design Circular Deque Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations:  MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not.  isFull(): Checks whether Deque is full or not.    Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);			// return true circularDeque.insertLast(2);			// return true circularDeque.insertFront(3);			// return true circularDeque.insertFront(4);			// return false, the queue is full circularDeque.getRear();  			// return 2 circularDeque.isFull();				// return true circularDeque.deleteLast();			// return true circularDeque.insertFront(4);			// return true circularDeque.getFront();			// return 4    Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library.   Medium Design Queue Java doubly LinkedList  solution, very straightforward Design Circular Deque Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations:  MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not.  isFull(): Checks whether Deque is full or not.    Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);			// return true circularDeque.insertLast(2);			// return true circularDeque.insertFront(3);			// return true circularDeque.insertFront(4);			// return false, the queue is full circularDeque.getRear();  			// return 2 circularDeque.isFull();				// return true circularDeque.deleteLast();			// return true circularDeque.insertFront(4);			// return true circularDeque.getFront();			// return 4    Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library.   Medium Design Queue Is the example return value correct, and why Circular? Design Circular Deque Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations:  MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not.  isFull(): Checks whether Deque is full or not.    Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);			// return true circularDeque.insertLast(2);			// return true circularDeque.insertFront(3);			// return true circularDeque.insertFront(4);			// return false, the queue is full circularDeque.getRear();  			// return 2 circularDeque.isFull();				// return true circularDeque.deleteLast();			// return true circularDeque.insertFront(4);			// return true circularDeque.getFront();			// return 4    Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library.   Medium Design Queue Straightforward w/ Array in Java(corner cases) Design Circular Deque Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations:  MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not.  isFull(): Checks whether Deque is full or not.    Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);			// return true circularDeque.insertLast(2);			// return true circularDeque.insertFront(3);			// return true circularDeque.insertFront(4);			// return false, the queue is full circularDeque.getRear();  			// return 2 circularDeque.isFull();				// return true circularDeque.deleteLast();			// return true circularDeque.insertFront(4);			// return true circularDeque.getFront();			// return 4    Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library.   Medium Design Queue python3, using list, easy to understand Design Circular Deque Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations:  MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not.  isFull(): Checks whether Deque is full or not.    Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);			// return true circularDeque.insertLast(2);			// return true circularDeque.insertFront(3);			// return true circularDeque.insertFront(4);			// return false, the queue is full circularDeque.getRear();  			// return 2 circularDeque.isFull();				// return true circularDeque.deleteLast();			// return true circularDeque.insertFront(4);			// return true circularDeque.getFront();			// return 4    Note:  All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library.   Medium Design Queue Java solution, Sum of Sliding window Maximum Average Subarray I  Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.  Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75   Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].   Easy Array Python, Straightforward with Explanation Maximum Average Subarray I  Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.  Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75   Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].   Easy Array 2 lines Python, 2 versions Maximum Average Subarray I  Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.  Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75   Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].   Easy Array C++ simple sliding-window solution Maximum Average Subarray I  Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.  Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75   Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].   Easy Array Simple Java solution - sliding window Maximum Average Subarray I  Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.  Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75   Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].   Easy Array Java O(n) Time O(1) Space Set Mismatch  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.   Easy Hash Table Math [C++] 6 lines solution with explanation Set Mismatch  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.   Easy Hash Table Math XOR, one pass Set Mismatch  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.   Easy Hash Table Math Python, Straightforward with Explanation Set Mismatch  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.   Easy Hash Table Math Simple Java O(n) solution - HashSet Set Mismatch  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.   Easy Hash Table Math easy dp Maximum Length of Pair Chain  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].   Medium Dynamic Programming 4-Liner Python Greedy Maximum Length of Pair Chain  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].   Medium Dynamic Programming Java O(nlog(n)) Time O(1) Space Maximum Length of Pair Chain  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].   Medium Dynamic Programming [C++] Clean Code Maximum Length of Pair Chain  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].   Medium Dynamic Programming [Java] Very Simple without DP Maximum Length of Pair Chain  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].   Medium Dynamic Programming Java solution, 8 lines, extendPalindrome Palindromic Substrings  Given a string, your task is to count how many palindromic substrings in this string.   The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.   Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".   Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".   Note:  The input string length won't exceed 1000.   Medium String Dynamic Programming Very Simple Java Solution with Detail Explanation Palindromic Substrings  Given a string, your task is to count how many palindromic substrings in this string.   The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.   Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".   Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".   Note:  The input string length won't exceed 1000.   Medium String Dynamic Programming Java DP solution based on longest palindromic substring Palindromic Substrings  Given a string, your task is to count how many palindromic substrings in this string.   The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.   Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".   Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".   Note:  The input string length won't exceed 1000.   Medium String Dynamic Programming Python, Straightforward with Explanation (Bonus O(N) solution) Palindromic Substrings  Given a string, your task is to count how many palindromic substrings in this string.   The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.   Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".   Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".   Note:  The input string length won't exceed 1000.   Medium String Dynamic Programming [Java/C++] 6 lines solution - NO DP Palindromic Substrings  Given a string, your task is to count how many palindromic substrings in this string.   The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.   Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".   Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".   Note:  The input string length won't exceed 1000.   Medium String Dynamic Programming Java Simple/Classical Trie question/solution (Beat 96%) Replace Words  In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.   Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.   You need to output the sentence after the replacement.  Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"   Note:  The input will only have lower-case letters.  1 <= dict words number <= 1000   1 <= sentence words number <= 1000    1 <= root length <= 100   1 <= sentence words length <= 1000    Medium Hash Table Trie Python, Straightforward with Explanation (Prefix hash, Trie solutions) Replace Words  In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.   Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.   You need to output the sentence after the replacement.  Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"   Note:  The input will only have lower-case letters.  1 <= dict words number <= 1000   1 <= sentence words number <= 1000    1 <= root length <= 100   1 <= sentence words length <= 1000    Medium Hash Table Trie Java solution, 12 lines, HashSet Replace Words  In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.   Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.   You need to output the sentence after the replacement.  Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"   Note:  The input will only have lower-case letters.  1 <= dict words number <= 1000   1 <= sentence words number <= 1000    1 <= root length <= 100   1 <= sentence words length <= 1000    Medium Hash Table Trie Simple Java 8 and Trie based solution Replace Words  In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.   Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.   You need to output the sentence after the replacement.  Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"   Note:  The input will only have lower-case letters.  1 <= dict words number <= 1000   1 <= sentence words number <= 1000    1 <= root length <= 100   1 <= sentence words length <= 1000    Medium Hash Table Trie Easy Python Solution, 6 Lines Replace Words  In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.   Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.   You need to output the sentence after the replacement.  Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"   Note:  The input will only have lower-case letters.  1 <= dict words number <= 1000   1 <= sentence words number <= 1000    1 <= root length <= 100   1 <= sentence words length <= 1000    Medium Hash Table Trie [Java/C++] Very simple greedy solution with explanation Dota2 Senate  In the world of Dota2, there are two parties: the Radiant and the Dire.   The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.   The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.   Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.  Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.   Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Note:  The length of the given string will in the range [1, 10,000].   Medium Greedy Python, Straightforward with Explanation Dota2 Senate  In the world of Dota2, there are two parties: the Radiant and the Dire.   The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.   The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.   Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.  Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.   Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Note:  The length of the given string will in the range [1, 10,000].   Medium Greedy Java solution, Greedy Dota2 Senate  In the world of Dota2, there are two parties: the Radiant and the Dire.   The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.   The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.   Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.  Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.   Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Note:  The length of the given string will in the range [1, 10,000].   Medium Greedy C++, O(n) solution Dota2 Senate  In the world of Dota2, there are two parties: the Radiant and the Dire.   The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.   The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.   Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.  Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.   Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Note:  The length of the given string will in the range [1, 10,000].   Medium Greedy Confusion about the logic Dota2 Senate  In the world of Dota2, there are two parties: the Radiant and the Dire.   The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.   The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.   Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.  Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.   Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Note:  The length of the given string will in the range [1, 10,000].   Medium Greedy Java DP Solution 2 Keys Keyboard  Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.   Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.   Note:  The n will be in the range [1, 1000].   Medium Dynamic Programming Loop best case log(n), no DP, no extra space, no recursion, with explanation 2 Keys Keyboard  Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.   Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.   Note:  The n will be in the range [1, 1000].   Medium Dynamic Programming Very Simple Java Solution With Detail Explanation 2 Keys Keyboard  Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.   Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.   Note:  The n will be in the range [1, 1000].   Medium Dynamic Programming [Java/C++] Clean Code with Explanation - 4 lines, No DP 2 Keys Keyboard  Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.   Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.   Note:  The n will be in the range [1, 1000].   Medium Dynamic Programming Java solutions from naive-DP to optimized-DP to non-DP 2 Keys Keyboard  Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.   Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.   Note:  The n will be in the range [1, 1000].   Medium Dynamic Programming Java Concise Postorder Traversal Solution Find Duplicate Subtrees Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list. Medium Tree O(n) time and space, lots of analysis Find Duplicate Subtrees Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list. Medium Tree [C++] [Java] Clean Code Find Duplicate Subtrees Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list. Medium Tree Python easy understand solution Find Duplicate Subtrees Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list. Medium Tree Verbose Java solution, tree traversal Find Duplicate Subtrees Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list. Medium Tree [Java/C++] Three simple methods - choose one you like Two Sum IV - Input is a BST Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True   Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False    Easy Tree [C++] Clean Code - O(n) time O(lg n) space - BinaryTree Iterator Two Sum IV - Input is a BST Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True   Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False    Easy Tree Java Simple AC with Time O(n) Space O(log n) in Average Two Sum IV - Input is a BST Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True   Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False    Easy Tree C++/Python Straight Forward Solution Two Sum IV - Input is a BST Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True   Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False    Easy Tree Java Code - O(n) time / O(lg(n)) space using DFS + Stack Two Sum IV - Input is a BST Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True   Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False    Easy Tree C++ O(N) solution Maximum Binary Tree  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].   Medium Tree Java worst case O(N) solution Maximum Binary Tree  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].   Medium Tree Java solution, recursion Maximum Binary Tree  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].   Medium Tree C++ 9 lines O(n log n) map, plus stack with binary search Maximum Binary Tree  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].   Medium Tree poor quality question Maximum Binary Tree  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].   Medium Tree Python one liner Robot Return to Origin There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.   Easy String [C++] [Java] Clean Code Robot Return to Origin There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.   Easy String If you can't describe the problem in a right way, please don't make it a problem. Robot Return to Origin There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.   Easy String 2 Lines Python Robot Return to Origin There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.   Easy String Easy 2 lines Java Robot Return to Origin There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.   Easy String Java O(n) Time O(n) Space Split Array into Consecutive Subsequences You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split. Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False   Note:  The length of the input is in range of [1, 10000]   Medium Heap Greedy Java O(n) time & O(1) space solution -- greedily extending shorter subsequence Split Array into Consecutive Subsequences You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split. Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False   Note:  The length of the input is in range of [1, 10000]   Medium Heap Greedy C++ O(n) solution, two pass Split Array into Consecutive Subsequences You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split. Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False   Note:  The length of the input is in range of [1, 10000]   Medium Heap Greedy Python esay understand solution Split Array into Consecutive Subsequences You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split. Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False   Note:  The length of the input is in range of [1, 10000]   Medium Heap Greedy Simple C++ Greedy O(nlogn) Solution (with explanation) Split Array into Consecutive Subsequences You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split. Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False   Note:  The length of the input is in range of [1, 10000]   Medium Heap Greedy C++ O(1) space using "game of life" idea Image Smoother Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].   Easy Array Very Clean Solution in Java Image Smoother Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].   Easy Array Straightforward python solution Image Smoother Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].   Easy Array Don't understand the question and sample output Image Smoother Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].   Easy Array python O(m*n) Image Smoother Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].   Easy Array [Java/C++] Very simple dfs solution Maximum Width of Binary Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.  The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.  Medium Tree [C++/Java] * [BFS/DFS/3liner] Clean Code  With Explanation Maximum Width of Binary Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.  The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.  Medium Tree Java One Queue Solution with HashMap Maximum Width of Binary Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.  The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.  Medium Tree JAVA\uff0cLevel Traversal,Using Two Queue Maximum Width of Binary Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.  The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.  Medium Tree Python, Straightforward BFS and DFS solutions Maximum Width of Binary Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.  The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.  Medium Tree Java O(n^3) DP Solution with Explanation and Simple Optimization Strange Printer  There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100. Hard Dynamic Programming Depth-first Search Java solution, DP Strange Printer  There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100. Hard Dynamic Programming Depth-first Search Python, Straightforward DP with Explanation Strange Printer  There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100. Hard Dynamic Programming Depth-first Search Java O(n^3) short DP Solution Strange Printer  There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100. Hard Dynamic Programming Depth-first Search Same as Remove Boxes Strange Printer  There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100. Hard Dynamic Programming Depth-first Search [Java/C++] Simple greedy like solution with explanation Non-decreasing Array  Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].  Easy Array Python Extremely Easy to Understand Non-decreasing Array  Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].  Easy Array [C++] [Java] Clean Code - 6 liner Without Modifying Input Non-decreasing Array  Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].  Easy Array The easiest python solution.... Non-decreasing Array  Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].  Easy Array Java solution, 7 liner. Non-decreasing Array  Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].  Easy Array [C++] [Java] Clean Code 4-liner Beautiful Arrangement II  Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.   Medium Array Python, Straightforward with Explanation Beautiful Arrangement II  Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.   Medium Array Java, easy to understand with explanation Beautiful Arrangement II  Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.   Medium Array C++, concise code, O(n) Beautiful Arrangement II  Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.   Medium Array Short+simple with explanation Beautiful Arrangement II  Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.   Medium Array Java solution, binary search Kth Smallest Number in Multiplication Table  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]   Hard Binary Search This name is very miss leading Kth Smallest Number in Multiplication Table  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]   Hard Binary Search Python, Straightforward with Explanation Kth Smallest Number in Multiplication Table  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]   Hard Binary Search This problem is found on another Online Judge Kth Smallest Number in Multiplication Table  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]   Hard Binary Search solution like Kth Smallest Number in Sorted Matrix Kth Smallest Number in Multiplication Table  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]   Hard Binary Search Java solution, 6 liner Trim a Binary Search Tree  Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1   Easy Tree Java solution, iteration version Trim a Binary Search Tree  Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1   Easy Tree C++, recursion Trim a Binary Search Tree  Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1   Easy Tree clear python solution Trim a Binary Search Tree  Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1   Easy Tree Clean Java solution with explanation and video link Trim a Binary Search Tree  Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1   Easy Tree Java simple solution, O(n) time Maximum Swap  Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]   Medium Array Math C++ one-pass simple & fast solution: 1-3ms, O(n) time Maximum Swap  Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]   Medium Array Math [C++] 3ms, O(n) time, O(n) space, DP solution Maximum Swap  Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]   Medium Array Math Simple AC O(n) java solution with ex Maximum Swap  Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]   Medium Array Math Python, Straightforward with Explanation Maximum Swap  Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]   Medium Array Math Java divide and conquer solution Second Minimum Node In a Binary Tree  Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.    Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.    If no such second minimum value exists, output -1 instead.  Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.   Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.   Easy Tree C++, DFS recursion Second Minimum Node In a Binary Tree  Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.    Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.    If no such second minimum value exists, output -1 instead.  Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.   Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.   Easy Tree Python Extremely Easy To Understand (Beats 91%) Second Minimum Node In a Binary Tree  Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.    Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.    If no such second minimum value exists, output -1 instead.  Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.   Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.   Easy Tree Java 4 lines Second Minimum Node In a Binary Tree  Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.    Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.    If no such second minimum value exists, output -1 instead.  Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.   Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.   Easy Tree Very simple Java solution Second Minimum Node In a Binary Tree  Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.    Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.    If no such second minimum value exists, output -1 instead.  Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.   Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.   Easy Tree Java O(1) Bulb Switcher II  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.   Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...   Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]   Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]   Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].   Note: n and m both fit in range [0, 1000].   Medium Math C++, concise code, O(1) Bulb Switcher II  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.   Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...   Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]   Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]   Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].   Note: n and m both fit in range [0, 1000].   Medium Math Short and Clean Java O(1) Solution Bulb Switcher II  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.   Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...   Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]   Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]   Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].   Note: n and m both fit in range [0, 1000].   Medium Math Python, Straightforward with Explanation Bulb Switcher II  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.   Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...   Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]   Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]   Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].   Note: n and m both fit in range [0, 1000].   Medium Math Easy to understand Java BFS solution O(m) Bulb Switcher II  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.   Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...   Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]   Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]   Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].   Note: n and m both fit in range [0, 1000].   Medium Math [Java/C++] Simple dp solution with explanation Number of Longest Increasing Subsequence  Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.  Medium Dynamic Programming C++, DP with explanation, O(n^2) Number of Longest Increasing Subsequence  Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.  Medium Dynamic Programming Python DP with explanation (Beats 88%) Number of Longest Increasing Subsequence  Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.  Medium Dynamic Programming 9ms [C++] Explanation: DP + Binary search + prefix sums O(NlogN) time; O(N) space Number of Longest Increasing Subsequence  Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.  Medium Dynamic Programming python DP solution with DETAILED explanation Number of Longest Increasing Subsequence  Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.  Medium Dynamic Programming [Java/C++]Clean solution Longest Continuous Increasing Subsequence  Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.  Easy Array Python Simple Solution Longest Continuous Increasing Subsequence  Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.  Easy Array Java code---6 liner Longest Continuous Increasing Subsequence  Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.  Easy Array Java solution, DP Longest Continuous Increasing Subsequence  Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.  Easy Array [C++/Java] Clean Code - 3 liner [2 Pointers] Longest Continuous Increasing Subsequence  Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.  Easy Array Java solution, PriorityQueue + BFS Cut Off Trees for Golf Event  You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:  0 represents the obstacle can't be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.    You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).    You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.   You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.  Example 1: Input:  [  [1,2,3],  [0,0,4],  [7,6,5] ] Output: 6   Example 2: Input:  [  [1,2,3],  [0,0,0],  [7,6,5] ] Output: -1   Example 3: Input:  [  [2,3,4],  [0,0,5],  [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.    Hint: size of the given matrix will not exceed 50x50.  Hard Breadth-first Search Very simple Python BFS,  But Why TLE?? Cut Off Trees for Golf Event  You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:  0 represents the obstacle can't be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.    You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).    You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.   You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.  Example 1: Input:  [  [1,2,3],  [0,0,4],  [7,6,5] ] Output: 6   Example 2: Input:  [  [1,2,3],  [0,0,0],  [7,6,5] ] Output: -1   Example 3: Input:  [  [2,3,4],  [0,0,5],  [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.    Hint: size of the given matrix will not exceed 50x50.  Hard Breadth-first Search Python solution based on wufangjie's (Hadlock's algorithm?) Cut Off Trees for Golf Event  You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:  0 represents the obstacle can't be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.    You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).    You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.   You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.  Example 1: Input:  [  [1,2,3],  [0,0,4],  [7,6,5] ] Output: 6   Example 2: Input:  [  [1,2,3],  [0,0,0],  [7,6,5] ] Output: -1   Example 3: Input:  [  [2,3,4],  [0,0,5],  [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.    Hint: size of the given matrix will not exceed 50x50.  Hard Breadth-first Search my python solution, inspired by A* algorithm Cut Off Trees for Golf Event  You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:  0 represents the obstacle can't be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.    You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).    You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.   You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.  Example 1: Input:  [  [1,2,3],  [0,0,4],  [7,6,5] ] Output: 6   Example 2: Input:  [  [1,2,3],  [0,0,0],  [7,6,5] ] Output: -1   Example 3: Input:  [  [2,3,4],  [0,0,5],  [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.    Hint: size of the given matrix will not exceed 50x50.  Hard Breadth-first Search C++, Sort + BFS with explanation Cut Off Trees for Golf Event  You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:  0 represents the obstacle can't be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.    You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).    You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.   You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.  Example 1: Input:  [  [1,2,3],  [0,0,4],  [7,6,5] ] Output: 6   Example 2: Input:  [  [1,2,3],  [0,0,0],  [7,6,5] ] Output: -1   Example 3: Input:  [  [2,3,4],  [0,0,5],  [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.    Hint: size of the given matrix will not exceed 50x50.  Hard Breadth-first Search Easy 14 lines Java solution, HashMap Implement Magic Dictionary  Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.   Medium Hash Table Trie Python, without *26 factor in complexity Implement Magic Dictionary  Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.   Medium Hash Table Trie Easiest JAVA with Trie, no need to count the number of changes Implement Magic Dictionary  Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.   Medium Hash Table Trie Easy Java Solution Implement Magic Dictionary  Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.   Medium Hash Table Trie Python intuitive solution using dictionary Implement Magic Dictionary  Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.   Medium Hash Table Trie Java solution, Trie Map Sum Pairs  Implement a MapSum class with insert, and sum methods.   For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.  Example 1: Input: insert("apple", 3), Output: Null Input: sum("ap"), Output: 3 Input: insert("app", 2), Output: Null Input: sum("ap"), Output: 5    Medium Trie C++, Easy solution, ordered map Map Sum Pairs  Implement a MapSum class with insert, and sum methods.   For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.  Example 1: Input: insert("apple", 3), Output: Null Input: sum("ap"), Output: 3 Input: insert("app", 2), Output: Null Input: sum("ap"), Output: 5    Medium Trie Simple Java HashMap Solution - O(1) sum, and O(len(key)) insert Map Sum Pairs  Implement a MapSum class with insert, and sum methods.   For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.  Example 1: Input: insert("apple", 3), Output: Null Input: sum("ap"), Output: 3 Input: insert("app", 2), Output: Null Input: sum("ap"), Output: 5    Medium Trie Python easy and concise 3 lines solution Map Sum Pairs  Implement a MapSum class with insert, and sum methods.   For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.  Example 1: Input: insert("apple", 3), Output: Null Input: sum("ap"), Output: 3 Input: insert("app", 2), Output: Null Input: sum("ap"), Output: 5    Medium Trie Python Efficient O(k) Insert and Sum using Trie Map Sum Pairs  Implement a MapSum class with insert, and sum methods.   For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.  Example 1: Input: insert("apple", 3), Output: Null Input: sum("ap"), Output: 3 Input: insert("app", 2), Output: Null Input: sum("ap"), Output: 5    Medium Trie Short Java O(n) time, O(1) space, one pass Valid Parenthesis String  Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].   Medium String Java 12 lines solution, backtracking Valid Parenthesis String  Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].   Medium String Very concise C++ solution with explaination. No DP Valid Parenthesis String  Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].   Medium String Java using 2 stacks.  O(n) space and time complexity. Valid Parenthesis String  Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].   Medium String Java, Very easy solution. No recursion or dp. Valid Parenthesis String  Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].   Medium String \ub5a2\ube3b\uac01\uac4e\ub0c7\uac05\uac38\uae9a\ubd5f\uc223\uc684\ubd74\ubd5e\ub93c\uac08\uac0c\ub914\ub58c\uc60a\uba54\ub284\uc22d\uceb8\uae36\uae9b\uc616\uac0d\ub1d0\uca62\uacf4\ub4c7\uac6f\uad84\uc615\uc679\ub21e\uc1b4\uac43\ub057\uae2c\ub549\uadbf\uac00\uc300\ub090\uac44\uc224\ubeb4\ub298\uac58\uaf78\uc222\uac42\uac0b\uac03\ucad0\uaf14\uc1be\uca61\uc1d4\uc1bf\ub05b\ub91c\uac04\ube3a\uca6c\uc6e8\ub534\uc620\ub91b\uac02\ubd6a\ub360\ub1a4\ube50\uc60b\uadd2\ub282\uac30\uac16\ub1a5\uadbe\uac06\uc60c\ubf18\ubb30\uac70\uac0e\uae37\ub0a4\uacbc 24 Game  You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.    Hard Depth-first Search [JAVA] Easy to understand. Backtracking. 24 Game  You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.    Hard Depth-first Search Short Python 24 Game  You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.    Hard Depth-first Search C++, Concise code 24 Game  You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.    Hard Depth-first Search 小时候真的玩儿过这个游戏 24 Game  You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.    Hard Depth-first Search Java O(n) Time O(1) Space Valid Palindrome II  Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.   Easy String Easy to Understand Python Solution Valid Palindrome II  Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.   Easy String Java solution, isPalindrome Valid Palindrome II  Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.   Easy String Easy and concise solution [C++/Java/Python]  Valid Palindrome II  Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.   Easy String [C++/Java] Clean Code - 2 liner - Generic for "you may delete at most N character" Valid Palindrome II  Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.   Easy String Straightforward Python Baseball Game  You're now a baseball game point recorder.   Given a list of strings, each string can be one of the 4 following types:  Integer (one round's score): Directly represents the number of points you get in this round. "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points. "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points. "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.    Each round's operation is permanent and could have an impact on the round before and the round after.   You need to return the sum of the points you could get in all the rounds.  Example 1: Input: ["5","2","C","D","+"] Output: 30 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.   Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30.   Example 2: Input: ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.   Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27.   Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  Easy Stack Verbose Java solution, LinkedList Baseball Game  You're now a baseball game point recorder.   Given a list of strings, each string can be one of the 4 following types:  Integer (one round's score): Directly represents the number of points you get in this round. "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points. "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points. "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.    Each round's operation is permanent and could have an impact on the round before and the round after.   You need to return the sum of the points you could get in all the rounds.  Example 1: Input: ["5","2","C","D","+"] Output: 30 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.   Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30.   Example 2: Input: ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.   Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27.   Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  Easy Stack [C++] Clean Code Baseball Game  You're now a baseball game point recorder.   Given a list of strings, each string can be one of the 4 following types:  Integer (one round's score): Directly represents the number of points you get in this round. "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points. "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points. "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.    Each round's operation is permanent and could have an impact on the round before and the round after.   You need to return the sum of the points you could get in all the rounds.  Example 1: Input: ["5","2","C","D","+"] Output: 30 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.   Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30.   Example 2: Input: ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.   Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27.   Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  Easy Stack Simple C++ using vector Baseball Game  You're now a baseball game point recorder.   Given a list of strings, each string can be one of the 4 following types:  Integer (one round's score): Directly represents the number of points you get in this round. "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points. "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points. "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.    Each round's operation is permanent and could have an impact on the round before and the round after.   You need to return the sum of the points you could get in all the rounds.  Example 1: Input: ["5","2","C","D","+"] Output: 30 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.   Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30.   Example 2: Input: ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.   Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27.   Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  Easy Stack JAVA very concise and easy to understand using stack Baseball Game  You're now a baseball game point recorder.   Given a list of strings, each string can be one of the 4 following types:  Integer (one round's score): Directly represents the number of points you get in this round. "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points. "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points. "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.    Each round's operation is permanent and could have an impact on the round before and the round after.   You need to return the sum of the points you could get in all the rounds.  Example 1: Input: ["5","2","C","D","+"] Output: 30 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.   Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30.   Example 2: Input: ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation:  Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.   Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27.   Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  Easy Stack Beats 97.96% Union Find Java with Explanations Redundant Connection  In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.  Medium Tree Union Find Graph 10 line Java solution, Union Find. Redundant Connection  In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.  Medium Tree Union Find Graph Unicode-Find (5 short lines) Redundant Connection  In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.  Medium Tree Union Find Graph Why does this(Input: [[2,3],[5,2],[1,5],[4,2],[4,1]] Output: [4,2] Expected: [4,1] ) happens? Redundant Connection  In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.  Medium Tree Union Find Graph C++ solution  using union find Redundant Connection  In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.  Medium Tree Union Find Graph C++/Java, Union Find with explanation, O(n) Redundant Connection II  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Hard Tree Depth-first Search Union Find Graph one pass disjoint set solution with explain Redundant Connection II  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Hard Tree Depth-first Search Union Find Graph Python O(N) concise solution with detailed explanation, passed updated testcases Redundant Connection II  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Hard Tree Depth-first Search Union Find Graph Share my solution, C++ Redundant Connection II  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Hard Tree Depth-first Search Union Find Graph Easiest understanding Java Solution, using Union Find O(n). Redundant Connection II  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Hard Tree Depth-first Search Union Find Graph C++ 4 lines O(m * n) | O(1) and KMP O(m + n) | O(n) Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.  Easy String Intuitive Python 2-liner Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.  Easy String Java Solution - Just keep building (OJ Missing Test Cases) Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.  Easy String share my java solution! Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.  Easy String Understandable Python Solution Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.  Easy String [Java/C++] Clean Code Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.  Example 1:   Input:               5              / \             4   5            / \   \           1   1   5    Output: 2    Example 2:   Input:               1              / \             4   5            / \   \           4   4   5    Output: 2   Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.  Easy Tree Recursion java solution with global variable Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.  Example 1:   Input:               5              / \             4   5            / \   \           1   1   5    Output: 2    Example 2:   Input:               1              / \             4   5            / \   \           4   4   5    Output: 2   Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.  Easy Tree Recursion Python Simple to Understand Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.  Example 1:   Input:               5              / \             4   5            / \   \           1   1   5    Output: 2    Example 2:   Input:               1              / \             4   5            / \   \           4   4   5    Output: 2   Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.  Easy Tree Recursion Java Solution With Explanation Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.  Example 1:   Input:               5              / \             4   5            / \   \           1   1   5    Output: 2    Example 2:   Input:               1              / \             4   5            / \   \           4   4   5    Output: 2   Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.  Easy Tree Recursion test cases incorrect Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.  Example 1:   Input:               5              / \             4   5            / \   \           1   1   5    Output: 2    Example 2:   Input:               1              / \             4   5            / \   \           4   4   5    Output: 2   Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.  Easy Tree Recursion My accepted DP solution Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.   Medium Dynamic Programming My easy understand dp solution Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.   Medium Dynamic Programming Evolve from recursive to dp,beats 94% Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.   Medium Dynamic Programming C++/Java, DP, concise solution Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.   Medium Dynamic Programming Simple Java DP solution with explanation Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.   Medium Dynamic Programming C++/Java, DP with explanation, O(n) Maximum Sum of 3 Non-Overlapping Subarrays  In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).  Hard Array Dynamic Programming Python o(n) time, o(1) space. Greedy solution. Maximum Sum of 3 Non-Overlapping Subarrays  In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).  Hard Array Dynamic Programming Clean Java DP O(n) Solution. Easy extend to Sum of K Non-Overlapping SubArrays. Maximum Sum of 3 Non-Overlapping Subarrays  In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).  Hard Array Dynamic Programming Java DP O(n) solution. Explanation inline.  Maximum Sum of 3 Non-Overlapping Subarrays  In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).  Hard Array Dynamic Programming C++ O(n) time O(n) space concise solution Maximum Sum of 3 Non-Overlapping Subarrays  In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).  Hard Array Dynamic Programming Java HashMap bfs dfs Employee Importance You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.  For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.   Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.   Easy Hash Table Depth-first Search Breadth-first Search I literally didn't understand the data type of `employees` from the question Employee Importance You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.  For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.   Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.   Easy Hash Table Depth-first Search Breadth-first Search 3-liner Python Solution (beats 99%) Employee Importance You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.  For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.   Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.   Easy Hash Table Depth-first Search Breadth-first Search C++ DFS using STL Employee Importance You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.  For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.   Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.   Easy Hash Table Depth-first Search Breadth-first Search Java 5-liner Employee Importance You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.  For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.   Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.   Easy Hash Table Depth-first Search Breadth-first Search C++/Java/Python, DP + Memoization with optimization, 29 ms (C++) Stickers to Spell Word  We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.  Hard Dynamic Programming Backtracking Rewrite of contest winner's solution Stickers to Spell Word  We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.  Hard Dynamic Programming Backtracking Explaining StefanPochmann's Rewrite of contest winner's solution & +java Stickers to Spell Word  We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.  Hard Dynamic Programming Backtracking java BFS solution Stickers to Spell Word  We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.  Hard Dynamic Programming Backtracking C++ BFS solution Stickers to Spell Word  We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.  Hard Dynamic Programming Backtracking My simple Java solution using HashMap & PriorityQueue - O(nlogk) time & O(n) space Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.   Medium Hash Table Heap Trie Java O(n) solution using HashMap, BucketSort and Trie - 22ms Beat 81% Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.   Medium Hash Table Heap Trie Python 3 solution with O(nlogk) and O(n) Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.   Medium Hash Table Heap Trie O(nlog(k)) Priority Queue C++ code Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.   Medium Hash Table Heap Trie Simplest Python Solution Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.   Medium Hash Table Heap Trie Oneliners (C++, Java, Ruby, Python) Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101   Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111.   Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.   Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.   Easy Bit Manipulation Java super simple explanation with inline example Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101   Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111.   Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.   Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.   Easy Bit Manipulation C++, concise code Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101   Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111.   Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.   Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.   Easy Bit Manipulation Why not give the fu*king precise definition of the fuc*king "Alternating bits"? Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101   Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111.   Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.   Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.   Easy Bit Manipulation easy python Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101   Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111.   Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.   Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.   Easy Bit Manipulation Java O(n) Time O(1) Space Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.  Easy String [Python/C++/Java] Easy and Concise with Explanation Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.  Easy String Acceptable JAVA solution with explaination Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.  Easy String Python intuitive approaches with explanation (3-liner) Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.  Easy String C++ easy understanding solution Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.  Easy String The example for this question is poor Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  Easy Array Easy understand Java Solution (Beats 100% solutions) Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  Easy Array straightforward c++ solution, 35ms Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  Easy Array [C++/Java/Python] one-pass and O(M) space Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  Easy Array Python easy and concise solution Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  Easy Array [Java/C++]Straightforward dfs solution Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.   Note: 1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.  Medium Dynamic Programming Recursion Easy to understand java solution Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.   Note: 1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.  Medium Dynamic Programming Recursion Cpp solution with explanation in details Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.   Note: 1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.  Medium Dynamic Programming Recursion Clear explanation, easy to understand C++ : 4ms beat 100% Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.   Note: 1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.  Medium Dynamic Programming Recursion C++ 3ms DFS solution with pruning Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.   Note: 1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.  Medium Dynamic Programming Recursion Easy Understood O(n^2) Solution with explanation Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.  Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].  Example 1: Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].    Example 2: Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.   Note: 1 <= positions.length <= 1000. 1 <= positions[i][0] <= 10^8. 1 <= positions[i][1] <= 10^6.  Hard Segment Tree Binary Search Tree Treemap solution and Segment tree (Java) solution with lazy propagation and coordinates compression Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.  Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].  Example 1: Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].    Example 2: Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.   Note: 1 <= positions.length <= 1000. 1 <= positions[i][0] <= 10^8. 1 <= positions[i][1] <= 10^6.  Hard Segment Tree Binary Search Tree Easy Understood TreeMap Solution Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.  Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].  Example 1: Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].    Example 2: Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.   Note: 1 <= positions.length <= 1000. 1 <= positions[i][0] <= 10^8. 1 <= positions[i][1] <= 10^6.  Hard Segment Tree Binary Search Tree Easy and Concise Python Solution (97%) Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.  Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].  Example 1: Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].    Example 2: Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.   Note: 1 <= positions.length <= 1000. 1 <= positions[i][0] <= 10^8. 1 <= positions[i][1] <= 10^6.  Hard Segment Tree Binary Search Tree Java 14ms, beats 99.38% using interval tree Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.  Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].  Example 1: Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].    Example 2: Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.   Note: 1 <= positions.length <= 1000. 1 <= positions[i][0] <= 10^8. 1 <= positions[i][1] <= 10^6.  Hard Segment Tree Binary Search Tree Java beats 100% concise method using recursion and iteration Search in a Binary Search Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.  Easy Tree Python 3 lines DFS solution w/ a very simple approach Search in a Binary Search Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.  Easy Tree Concise iterative solution (C++) Search in a Binary Search Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.  Easy Tree Swift bug Search in a Binary Search Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.  Easy Tree Beats 100% Java code Search in a Binary Search Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.  Easy Tree java iterative 100% Insert into a Binary Search Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4   Medium Tree C++: very simple Insert into a Binary Search Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4   Medium Tree Java easy to understand solution Insert into a Binary Search Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4   Medium Tree [Java] Beats 100%.  Simple and Elegant solution Insert into a Binary Search Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4   Medium Tree Python - 4 line clean recursive solution Insert into a Binary Search Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4   Medium Tree Python simple heapq solution beats 100 % Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3);   // returns 4 kthLargest.add(5);   // returns 5 kthLargest.add(10);  // returns 5 kthLargest.add(9);   // returns 8 kthLargest.add(4);   // returns 8  Note:  You may assume that nums' length ≥ k-1 and k ≥ 1.  Easy Heap Explanation of MinHeap solution (NO CODE) Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3);   // returns 4 kthLargest.add(5);   // returns 5 kthLargest.add(10);  // returns 5 kthLargest.add(9);   // returns 8 kthLargest.add(4);   // returns 8  Note:  You may assume that nums' length ≥ k-1 and k ≥ 1.  Easy Heap Java, Priority Queue Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3);   // returns 4 kthLargest.add(5);   // returns 5 kthLargest.add(10);  // returns 5 kthLargest.add(9);   // returns 8 kthLargest.add(4);   // returns 8  Note:  You may assume that nums' length ≥ k-1 and k ≥ 1.  Easy Heap O(h) Java Solution Using BST Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3);   // returns 4 kthLargest.add(5);   // returns 5 kthLargest.add(10);  // returns 5 kthLargest.add(9);   // returns 8 kthLargest.add(4);   // returns 8  Note:  You may assume that nums' length ≥ k-1 and k ≥ 1.  Easy Heap MinHeap solution Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3);   // returns 4 kthLargest.add(5);   // returns 5 kthLargest.add(10);  // returns 5 kthLargest.add(9);   // returns 8 kthLargest.add(4);   // returns 8  Note:  You may assume that nums' length ≥ k-1 and k ≥ 1.  Easy Heap Python typical solutions beat 100 % Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].   Easy Binary Search Java Solution Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].   Easy Binary Search c++ solution Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].   Easy Binary Search Python recursive + iterative easy to understand Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].   Easy Binary Search JavaScript solution Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].   Easy Binary Search Beats 100% Real Java Solution (Not boolean array) Design HashSet Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.   Easy Hash Table Design can you guys think before doing? Design HashSet Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.   Easy Hash Table Design Python solution // Can we do better than boolean array ? Design HashSet Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.   Easy Hash Table Design C++ 97.97% without a massive array or using a map, BST Design HashSet Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.   Easy Hash Table Design Description Error in "Design HashSet" Design HashSet Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.   Easy Hash Table Design Java Solution Design HashMap Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.   Easy Hash Table Design Java Simple Solution Design HashMap Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.   Easy Hash Table Design Hash with Chaining [Python] Design HashMap Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.   Easy Hash Table Design Python straightforward solution, one line for each function Design HashMap Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.   Easy Hash Table Design javascript solution: 104ms Design HashMap Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.   Easy Hash Table Design Python solution Design Linked List Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class:  get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3 linkedList.get(1);            // returns 2 linkedList.deleteAtIndex(1);  // now the linked list is 1->3 linkedList.get(1);            // returns 3  Note:  All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.   Easy Linked List Design Python AC short & simple linked list solution Design Linked List Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class:  get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3 linkedList.get(1);            // returns 2 linkedList.deleteAtIndex(1);  // now the linked list is 1->3 linkedList.get(1);            // returns 3  Note:  All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.   Easy Linked List Design C++ SOLUTION -24ms Design Linked List Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class:  get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3 linkedList.get(1);            // returns 2 linkedList.deleteAtIndex(1);  // now the linked list is 1->3 linkedList.get(1);            // returns 3  Note:  All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.   Easy Linked List Design C++ deque Design Linked List Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class:  get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3 linkedList.get(1);            // returns 2 linkedList.deleteAtIndex(1);  // now the linked list is 1->3 linkedList.get(1);            // returns 3  Note:  All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.   Easy Linked List Design C++ simple solution, beats 97.27%! Design Linked List Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class:  get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3 linkedList.get(1);            // returns 2 linkedList.deleteAtIndex(1);  // now the linked list is 1->3 linkedList.get(1);            // returns 3  Note:  All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.   Easy Linked List Design Java, no library methods To Lower Case Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"      Easy String Easy C++ Solution To Lower Case Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"      Easy String Python short 1 line ASCII & string method solutions To Lower Case Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"      Easy String C Solution- 9 lines, 0ms (With Test Cases) To Lower Case Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"      Easy String Javascript solution (not using built in method) To Lower Case Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"      Easy String Java O(B) / O(1), HashMap Random Pick with Blacklist Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Hard Hash Table Binary Search Sort Random [C++] DO NOT use rand() after C++11 ! Random Pick with Blacklist Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Hard Hash Table Binary Search Sort Random Simple Java solution with Binary Search Random Pick with Blacklist Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Hard Hash Table Binary Search Sort Random Super Simple Python AC w/ Remapping Random Pick with Blacklist Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Hard Hash Table Binary Search Sort Random Python AC solution with a very simple approach Random Pick with Blacklist Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.  Hard Hash Table Binary Search Sort Random C++, DP, with explanation Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].  Medium Dynamic Programming Concise DP solution Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].  Medium Dynamic Programming [Java]{DP}(With Explanation) Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].  Medium Dynamic Programming [Java/C++] Clean Code Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].  Medium Dynamic Programming elegant python solution using dp Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].  Medium Dynamic Programming [Java/C++] Clean Code with Explanation Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.  Medium Array Two Pointers Java Two Pointers O(n) time O(1) space Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.  Medium Array Two Pointers C++, concise solution, O(n) Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.  Medium Array Two Pointers Python solution with detailed explanation Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.  Medium Array Two Pointers Straightforward Solution Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.  Medium Array Two Pointers Most consistent ways of dealing with the series of stock problems Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.  Medium Array Dynamic Programming Greedy 2 solutions, 2 states DP solutions, clear explanation! Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.  Medium Array Dynamic Programming Greedy C++, concise solution, O(n) time O(1) space Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.  Medium Array Dynamic Programming Greedy Java simple DP solutions. O(n) Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.  Medium Array Dynamic Programming Greedy Java DP solution O(n) to O(1) space Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.  Medium Array Dynamic Programming Greedy Java TreeMap Range Module A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Note: A half open interval [left, right) denotes all real numbers left <= x < right. 0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  Hard Array Segment Tree Binary Search Tree C++, vector O(n) and map O(logn), compare two solutions Range Module A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Note: A half open interval [left, right) denotes all real numbers left <= x < right. 0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  Hard Array Segment Tree Binary Search Tree Python Range Module A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Note: A half open interval [left, right) denotes all real numbers left <= x < right. 0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  Hard Array Segment Tree Binary Search Tree C++ O(nlogn) based on disjoint intervals data structure Range Module A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Note: A half open interval [left, right) denotes all real numbers left <= x < right. 0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  Hard Array Segment Tree Binary Search Tree clean python solution Range Module A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Note: A half open interval [left, right) denotes all real numbers left <= x < right. 0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  Hard Array Segment Tree Binary Search Tree JAVA, check only the end of array 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.  Easy Array Java solution, 1 or 2 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.  Easy Array python solution, easy 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.  Easy Array Easy to understand C++ solution with modified for loop 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.  Easy Array Single Regular Expression - JS: ES6 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.  Easy Array Concise Java DP: Same idea of Longest Common Substring Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].   Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100   Medium Array Hash Table Binary Search Dynamic Programming [Java/C++] Clean Code - 8 lines Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].   Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100   Medium Array Hash Table Binary Search Dynamic Programming Java O(mn) time, O(1) space Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].   Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100   Medium Array Hash Table Binary Search Dynamic Programming Python Concise DP Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].   Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100   Medium Array Hash Table Binary Search Dynamic Programming Simple O(nm) DP solution Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].   Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100   Medium Array Hash Table Binary Search Dynamic Programming [Java/C++] Clean Code Longest Word in Dictionary Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  Easy Hash Table Trie Python Elegant and Extremely Easy to Understand Longest Word in Dictionary Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  Easy Hash Table Trie [JAVA 16ms (99%) @ 20180108] Trie+DFS: clean, easy, explained and illustrated Longest Word in Dictionary Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  Easy Hash Table Trie Java Solution with Trie + BFS Longest Word in Dictionary Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  Easy Hash Table Trie 1-liner Longest Word in Dictionary Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  Easy Hash Table Trie [Java/C++] Union Find Accounts Merge Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].  Medium Depth-first Search Union Find Java Solution (Build graph + DFS search) Accounts Merge Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].  Medium Depth-first Search Union Find Python Simple DFS with explanation!!! Accounts Merge Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].  Medium Depth-first Search Union Find Summary for DFS Templates Accounts Merge Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].  Medium Depth-first Search Union Find HashMap plus union found solution using Java programming! Accounts Merge Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].  Medium Depth-first Search Union Find One pass solution in Java Remove Comments Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.  Medium String 1-liners Remove Comments Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.  Medium String Simple Python one-pass with clear inline explanation!!! Remove Comments Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.  Medium String C++ O(N) (one pass) Remove Comments Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.  Medium String Just kill me Remove Comments Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.  Medium String Short Python O(n) time O(1) space with Explanation Find Pivot Index Given an array of integers nums, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.  Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.   Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  Easy Array This is a very poorly described problem Find Pivot Index Given an array of integers nums, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.  Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.   Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  Easy Array Java 6 liner Find Pivot Index Given an array of integers nums, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.  Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.   Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  Easy Array [Java/C++] Clean Code Find Pivot Index Given an array of integers nums, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.  Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.   Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  Easy Array Easy to understand c++ code  Find Pivot Index Given an array of integers nums, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.  Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.   Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  Easy Array [Java/C++] Clean Code Split Linked List in Parts Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1: Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].   Example 2: Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.   Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  Medium Linked List Elegant Python with Explanation - 45ms Split Linked List in Parts Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1: Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].   Example 2: Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.   Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  Medium Linked List C++ Solution O(1) Space 9ms Split Linked List in Parts Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1: Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].   Example 2: Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.   Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  Medium Linked List Easy to Follow Python Solution Split Linked List in Parts Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1: Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].   Example 2: Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.   Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  Medium Linked List Simple pythonic solution. Beats 100% Split Linked List in Parts Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1: Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].   Example 2: Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.   Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  Medium Linked List Java Solution using Stack and Map Number of Atoms Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  Hard Hash Table Stack Recursion Neat Python with Explanation - 35ms Number of Atoms Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  Hard Hash Table Stack Recursion Python // 20 lines very readable, simplest and shortest solution // 36 ms // beats 100 % Number of Atoms Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  Hard Hash Table Stack Recursion [C++] Recursive Parser Number of Atoms Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  Hard Hash Table Stack Recursion C++ iterative solution Number of Atoms Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  Hard Hash Table Stack Recursion Python Elegant 2-liner!!! Self Dividing Numbers  A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.  Easy Math [Java/C++] Clean Code Self Dividing Numbers  A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.  Easy Math One-line Python (Learn some Python tricks that you might not know) Self Dividing Numbers  A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.  Easy Math Java solution with explanation, no toString() conversion Self Dividing Numbers  A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.  Easy Math My Javascript Solution Self Dividing Numbers  A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.  Easy Math Java 8 liner, TreeMap My Calendar I  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array [Java/C++] Clean Code with Explanation My Calendar I  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree python My Calendar I  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array [JAVA] Simple 6 line Solution, TreeMap lowerEntry My Calendar I  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Short brute force python solution My Calendar I  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Java 96ms DP Solution with Detailed Explanation Count Different Palindromic Subsequences  Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.  Hard String Dynamic Programming Accepted Java Solution using memoization Count Different Palindromic Subsequences  Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.  Hard String Dynamic Programming C++ O(N^2) time, O(N) memory with explanation Count Different Palindromic Subsequences  Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.  Hard String Dynamic Programming N^2 DP Python with Explanation Count Different Palindromic Subsequences  Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.  Hard String Dynamic Programming Java solution using simple DP. O(n^2) run time and O(n^2) space Count Different Palindromic Subsequences  Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.  Hard String Dynamic Programming [Java/C++] Clean Code with Explanation My Calendar II  Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree N^2 Python, Short and Elegant My Calendar II  Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree nlogd Java solution using segment tree with lazy propagation -- applicable to the general case of K-booking My Calendar II  Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree Simplified winner's solution My Calendar II  Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree Simple AC by TreeMap My Calendar II  Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  Medium Array Binary Search Tree [Java/C++] Clean Code My Calendar III Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example 1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.    Note:  The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].     Hard Segment Tree Binary Search Tree Question explanation please My Calendar III Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example 1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.    Note:  The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].     Hard Segment Tree Binary Search Tree C++ O(n) method My Calendar III Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example 1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.    Note:  The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].     Hard Segment Tree Binary Search Tree Is this a right test case? My Calendar III Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example 1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.    Note:  The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].     Hard Segment Tree Binary Search Tree Java Solution O(n log(len)) beats 100% Segment Tree My Calendar III Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example 1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.    Note:  The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].     Hard Segment Tree Binary Search Tree Java 9 liner, DFS Flood Fill  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  Easy Depth-first Search Easy Python DFS (no need for visited)!!! Flood Fill  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  Easy Depth-first Search [Java/C++] Clean Code Flood Fill  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  Easy Depth-first Search C# DFS solution Flood Fill  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  Easy Depth-first Search Java easy BFS Flood Fill  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  Easy Depth-first Search [Java/C++] Clean Code Asteroid Collision  We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.  Example 1: Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.   Example 2: Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.   Example 3: Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.   Example 4: Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  Medium Stack Python O(n) Stack-based with explanation Asteroid Collision  We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.  Example 1: Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.   Example 2: Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.   Example 3: Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.   Example 4: Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  Medium Stack Java solution, Stack Asteroid Collision  We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.  Example 1: Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.   Example 2: Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.   Example 3: Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.   Example 4: Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  Medium Stack Java solution - beat 90% - No extra space. Asteroid Collision  We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.  Example 1: Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.   Example 2: Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.   Example 3: Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.   Example 4: Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  Medium Stack Stack Java solution Asteroid Collision  We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.  Example 1: Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.   Example 2: Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.   Example 3: Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.   Example 4: Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  Medium Stack C++ recursion solution with explaination Parse Lisp Expression  You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.  Hard String I don't think this problem is good one for interview to be honest Parse Lisp Expression  You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.  Hard String python solution using stacks. Parse Lisp Expression  You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.  Hard String A Clean Java Solution Parse Lisp Expression  You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.  Hard String Java modularized solution Parse Lisp Expression  You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.  Hard String Simple and very short C++ solution Monotone Increasing Digits  Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].  Medium Greedy Simple Python solution w/ Explanation Monotone Increasing Digits  Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].  Medium Greedy Simple and very short Java solution Monotone Increasing Digits  Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].  Medium Greedy easy java Monotone Increasing Digits  Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].  Medium Greedy Simple java solution with clear explanation. Very easy to understand. Monotone Increasing Digits  Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].  Medium Greedy [Java] Easy AC Solution with Stack Daily Temperatures  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].  Medium Hash Table Stack [C++] Clean code with explanation: O(n) time and O(1) space (beats 99.13%) Daily Temperatures  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].  Medium Hash Table Stack Elegant Python Solution with Stack Daily Temperatures  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].  Medium Hash Table Stack javascript stack solution with explaination Daily Temperatures  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].  Medium Hash Table Stack Simple Python by hashing the temperatures Daily Temperatures  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].  Medium Hash Table Stack [Java/C++] Clean Code with Explanation Delete and Earn  Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.  Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.   Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.   Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].  Medium Dynamic Programming Awesome Python 4-liner with explanation - Reduce to House Robbers Question \U0001f31d Delete and Earn  Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.  Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.   Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.   Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].  Medium Dynamic Programming Sharing my Simple Straight Forward Java O(n) Solution -- Explanation Included Delete and Earn  Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.  Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.   Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.   Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].  Medium Dynamic Programming [Java] Easy DP Solution Delete and Earn  Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.  Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.   Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.   Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].  Medium Dynamic Programming Java ------ 4 lines Delete and Earn  Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.  Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.   Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.   Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].  Medium Dynamic Programming Step by step guidance of the O(N^3) time and O(N^2) space solution Cherry Pickup  In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.  Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   Note: grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.  Hard Dynamic Programming Annotated C++ DP Solution Cherry Pickup  In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.  Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   Note: grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.  Hard Dynamic Programming C++ DP solution Cherry Pickup  In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.  Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   Note: grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.  Hard Dynamic Programming Java O(N^3) DP solution w/ specific explanation Cherry Pickup  In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.  Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   Note: grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.  Hard Dynamic Programming Python clean&commented O(N^3) DP Cherry Pickup  In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.  Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   Note: grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.  Hard Dynamic Programming [C++] Bellman Ford Network Delay Time  There are N network nodes, labelled 1 to N.  Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.  Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.   Easy Heap Depth-first Search Breadth-first Search Graph Simple JAVA Djikstra's (PriorityQueue optimized) Solution with explanation Network Delay Time  There are N network nodes, labelled 1 to N.  Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.  Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.   Easy Heap Depth-first Search Breadth-first Search Graph OJ was testing out of given conditions. Network Delay Time  There are N network nodes, labelled 1 to N.  Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.  Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.   Easy Heap Depth-first Search Breadth-first Search Graph Straightforward Python Dijkstra's \U0001f60c Network Delay Time  There are N network nodes, labelled 1 to N.  Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.  Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.   Easy Heap Depth-first Search Breadth-first Search Graph Simple Java Solution using BFS (similar to dijkstra's shortest path algorithm) with explanation Network Delay Time  There are N network nodes, labelled 1 to N.  Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.  Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.   Easy Heap Depth-first Search Breadth-first Search Graph Easy Binary Search in Java - O(log(n)) time Find Smallest Letter Greater Than Target  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.   Easy Binary Search Python no brainer! \U0001f921 Find Smallest Letter Greater Than Target  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.   Easy Binary Search [C++] 2 lines Solution using upper_bound Find Smallest Letter Greater Than Target  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.   Easy Binary Search Java 2 lines O(log n) Find Smallest Letter Greater Than Target  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.   Easy Binary Search Java Binary search Find Smallest Letter Greater Than Target  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.   Easy Binary Search Three ways to solve this problem in Java Prefix and Suffix Search  Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.  Examples: Input: WordFilter(["apple"]) WordFilter.f("a", "e") // returns 0 WordFilter.f("b", "") // returns -1  Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.   Hard Trie Python few ways to do it, with EXPLANATIONS! \U0001f389 Prefix and Suffix Search  Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.  Examples: Input: WordFilter(["apple"]) WordFilter.f("a", "e") // returns 0 WordFilter.f("b", "") // returns -1  Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.   Hard Trie Java Beat 95%, just small modifications in implementing Trie. Prefix and Suffix Search  Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.  Examples: Input: WordFilter(["apple"]) WordFilter.f("a", "e") // returns 0 WordFilter.f("b", "") // returns -1  Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.   Hard Trie Accepted Java Code  Using Trie Prefix and Suffix Search  Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.  Examples: Input: WordFilter(["apple"]) WordFilter.f("a", "e") // returns 0 WordFilter.f("b", "") // returns -1  Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.   Hard Trie C++ solution using two Trie, time & memory efficient. Prefix and Suffix Search  Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.  Examples: Input: WordFilter(["apple"]) WordFilter.f("a", "e") // returns 0 WordFilter.f("b", "") // returns -1  Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.   Hard Trie Easy to understand C++ using DP with detailed explanation Min Cost Climbing Stairs  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].   Easy Array Dynamic Programming 3 Lines Java Solution - O(1) space Min Cost Climbing Stairs  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].   Easy Array Dynamic Programming Easy to understand - Python solution - O(1) space Min Cost Climbing Stairs  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].   Easy Array Dynamic Programming Doubt ?? Min Cost Climbing Stairs  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].   Easy Array Dynamic Programming Simple Python Solution Min Cost Climbing Stairs  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].   Easy Array Dynamic Programming Python O(n) time and O(1) space without fancy builtins Largest Number At Least Twice of Others In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].     Easy Array [Java] One pass solution o(n) complexity Largest Number At Least Twice of Others In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].     Easy Array One Pass O(N) Java Solution 9ms 100% Largest Number At Least Twice of Others In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].     Easy Array My C++ Solution Largest Number At Least Twice of Others In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].     Easy Array [Java]-Fetch two largest values, One Pass TC-O(N), SC-O(1) Largest Number At Least Twice of Others In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].     Easy Array Java 6ms beats 100% PRIME NUMBERS Shortest Completing Word  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].   Easy Hash Table Java Solution using character Array Shortest Completing Word  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].   Easy Hash Table Python solutions Shortest Completing Word  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].   Easy Hash Table Java solution 17ms using char array Shortest Completing Word  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].   Easy Hash Table easy java Shortest Completing Word  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].   Easy Hash Table Funniest output answer I've ever seen on LeetCode Contain Virus  A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.   Hard Depth-first Search C++, DFS, 12ms Contain Virus  A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.   Hard Depth-first Search My Neat Java Solution Using Dfs Contain Virus  A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.   Hard Depth-first Search After a region is quarantined, is it still considered continuous with other regions? Contain Virus  A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.   Hard Depth-first Search Did the problem logic change during the contest? Contain Virus  A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.   Hard Depth-first Search Regular java BFS solution and 2-end BFS solution with improvement Open the Lock  You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.  The lock initially starts at '0000', a string representing the state of the 4 wheels.  You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.  Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.  Example 1: Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202" Output: 6 Explanation: A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202". Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end "0102".   Example 2: Input: deadends = ["8888"], target = "0009" Output: 1 Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".   Example 3: Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888" Output: -1 Explanation: We can't reach the target without getting stuck.   Example 4: Input: deadends = ["0000"], target = "8888" Output: -1   Note:  The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.   Medium Breadth-first Search BFS solution C++ Open the Lock  You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.  The lock initially starts at '0000', a string representing the state of the 4 wheels.  You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.  Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.  Example 1: Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202" Output: 6 Explanation: A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202". Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end "0102".   Example 2: Input: deadends = ["8888"], target = "0009" Output: 1 Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".   Example 3: Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888" Output: -1 Explanation: We can't reach the target without getting stuck.   Example 4: Input: deadends = ["0000"], target = "8888" Output: -1   Note:  The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.   Medium Breadth-first Search Accepted Python/Java BFS  + how to avoid TLE Open the Lock  You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.  The lock initially starts at '0000', a string representing the state of the 4 wheels.  You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.  Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.  Example 1: Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202" Output: 6 Explanation: A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202". Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end "0102".   Example 2: Input: deadends = ["8888"], target = "0009" Output: 1 Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".   Example 3: Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888" Output: -1 Explanation: We can't reach the target without getting stuck.   Example 4: Input: deadends = ["0000"], target = "8888" Output: -1   Note:  The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.   Medium Breadth-first Search why wrong answer? Open the Lock  You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.  The lock initially starts at '0000', a string representing the state of the 4 wheels.  You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.  Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.  Example 1: Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202" Output: 6 Explanation: A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202". Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end "0102".   Example 2: Input: deadends = ["8888"], target = "0009" Output: 1 Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".   Example 3: Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888" Output: -1 Explanation: We can't reach the target without getting stuck.   Example 4: Input: deadends = ["0000"], target = "8888" Output: -1   Note:  The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.   Medium Breadth-first Search Python 16 lines // simple and readable // BFS solution // beats 94 % Open the Lock  You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.  The lock initially starts at '0000', a string representing the state of the 4 wheels.  You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.  Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.  Example 1: Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202" Output: 6 Explanation: A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202". Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end "0102".   Example 2: Input: deadends = ["8888"], target = "0009" Output: 1 Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".   Example 3: Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888" Output: -1 Explanation: We can't reach the target without getting stuck.   Example 4: Input: deadends = ["0000"], target = "8888" Output: -1   Note:  The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.   Medium Breadth-first Search Short JAVA Solution with Explanation Reach a Number  You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].  Easy Math C++ O(1) Solution, without loop Reach a Number  You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].  Easy Math Not an easy Reach a Number  You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].  Easy Math Concise Python with explanation and example Reach a Number  You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].  Easy Math Learn from other with my explanations. Reach a Number  You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].  Easy Math Java solution - map + backtracking Pyramid Transition Matrix  We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.  For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.  We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.  Return true if we can build the pyramid all the way to the top, otherwise false.  Example 1: Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   D   E  / \ / \ X   Y   Z  This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.   Example 2: Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.   Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.   Medium Bit Manipulation Depth-first Search counter example to the standard code Pyramid Transition Matrix  We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.  For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.  We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.  Return true if we can build the pyramid all the way to the top, otherwise false.  Example 1: Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   D   E  / \ / \ X   Y   Z  This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.   Example 2: Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.   Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.   Medium Bit Manipulation Depth-first Search C++ passed counter example, DFS with memoization, 6 ms Pyramid Transition Matrix  We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.  For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.  We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.  Return true if we can build the pyramid all the way to the top, otherwise false.  Example 1: Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   D   E  / \ / \ X   Y   Z  This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.   Example 2: Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.   Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.   Medium Bit Manipulation Depth-first Search Easy and Concise Python solution Pyramid Transition Matrix  We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.  For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.  We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.  Return true if we can build the pyramid all the way to the top, otherwise false.  Example 1: Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   D   E  / \ / \ X   Y   Z  This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.   Example 2: Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.   Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.   Medium Bit Manipulation Depth-first Search DP O(n^2 * m) Pyramid Transition Matrix  We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.  For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.  We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.  Return true if we can build the pyramid all the way to the top, otherwise false.  Example 1: Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   D   E  / \ / \ X   Y   Z  This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.   Example 2: Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.   Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.   Medium Bit Manipulation Depth-first Search Ever wonder why the greedy algorithm works? Here is the explanation! Set Intersection Size At Least Two  An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].  Hard Greedy Java O(nlogn) Solution, Greedy Set Intersection Size At Least Two  An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].  Hard Greedy C++ concise solution, O(nlogn) greedy, 39 ms Set Intersection Size At Least Two  An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].  Hard Greedy Hope you enjoy this problem. : )  O(NlogN)/Java/Greedy  Easy to understand solution Set Intersection Size At Least Two  An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].  Hard Greedy C++ Greedy O(nlogn) with explanations Set Intersection Size At Least Two  An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].  Hard Greedy Easy and Concise Solution with Explanation [C++/Java/Python] Special Binary String  Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.  Hard String Recursion Think of it as Valid-Parentheses Special Binary String  Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.  Hard String Recursion What is the definition of "Special"? Special Binary String  Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.  Hard String Recursion Logical Thinking with Clear Code Special Binary String  Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.  Hard String Recursion Sharing my Simple / Easy to Understand Straight Forward Java Solution Special Binary String  Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.  Hard String Recursion 665772 Prime Number of Set Bits in Binary Representation  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)  Example 1:Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)  Example 2:Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)  Note: L, R will be integers L <= R in the range [1, 10^6]. R - L will be at most 10000.  Easy Bit Manipulation [Java/C++] Clean Code Prime Number of Set Bits in Binary Representation  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)  Example 1:Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)  Example 2:Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)  Note: L, R will be integers L <= R in the range [1, 10^6]. R - L will be at most 10000.  Easy Bit Manipulation Easy O(n) Java solution using DP Prime Number of Set Bits in Binary Representation  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)  Example 1:Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)  Example 2:Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)  Note: L, R will be integers L <= R in the range [1, 10^6]. R - L will be at most 10000.  Easy Bit Manipulation Sort Easy Python Prime Number of Set Bits in Binary Representation  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)  Example 1:Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)  Example 2:Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)  Note: L, R will be integers L <= R in the range [1, 10^6]. R - L will be at most 10000.  Easy Bit Manipulation Python 1 line Prime Number of Set Bits in Binary Representation  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)  Example 1:Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)  Example 2:Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)  Note: L, R will be integers L <= R in the range [1, 10^6]. R - L will be at most 10000.  Easy Bit Manipulation Java 2 pass O(n) time O(1) space, extending end pointer solution Partition Labels  A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.  Medium Two Pointers Greedy Short easy Python Partition Labels  A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.  Medium Two Pointers Greedy C++ 6 lines O(n) / O(1) - two simple passes Partition Labels  A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.  Medium Two Pointers Greedy Easy O(n) Java solution using sliding window (two pointers), comments and explanation given Partition Labels  A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.  Medium Two Pointers Greedy Java very Short and Easy solution Partition Labels  A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.  Medium Two Pointers Greedy Java/C++/Python O(N^2) solution using only one grid matrix Largest Plus Sign  In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)  Medium Dynamic Programming Easy to Understand Java Solution Largest Plus Sign  In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)  Medium Dynamic Programming Python 250ms solution Largest Plus Sign  In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)  Medium Dynamic Programming My Simple O(N^2) Time and O(N^2) Space Accepted Solution 150ms Largest Plus Sign  In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)  Medium Dynamic Programming C++ O(n^3) solution 226ms with explanation. Largest Plus Sign  In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)  Medium Dynamic Programming Java/C++ O(N) solution using cyclic swapping Couples Holding Hands  N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.  Hard Greedy Union Find Graph Java, union find, easy to understand, 5 ms Couples Holding Hands  N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.  Hard Greedy Union Find Graph Java AC O(n) greedy solution. Couples Holding Hands  N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.  Hard Greedy Union Find Graph Na\xefve solution accepted (with a proof)... wrong difficulty? Couples Holding Hands  N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.  Hard Greedy Union Find Graph Union find, understand in 60 seconds, beats 99.6% Couples Holding Hands  N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.  Hard Greedy Union Find Graph Java solution, 4 liner. Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?   Easy Array Python Easy and Concise Solution Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?   Easy Array [C++/Java] Clean Code Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?   Easy Array Java Answers to the follow-ups (load partial row/column one time), the 3rd one beats 98%  Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?   Easy Array One Line Easy Python Solution, Using Slice. Only 1 "For Loop". Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?   Easy Array Java solution, PriorityQueue Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].     Medium String Heap Greedy Sort 4 lines Python Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].     Medium String Heap Greedy Sort C++, Greedy sort, O(N) Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].     Medium String Heap Greedy Sort Simple python solution using PriorityQueue Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].     Medium String Heap Greedy Sort Java solution, 99% similar to 358 Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].     Medium String Heap Greedy Sort Java solution, left max and right min. Max Chunks To Make Sorted II This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].     Hard Array [C++] 9 lines, 15ms Max Chunks To Make Sorted II This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].     Hard Array Python Easy and Concise Solution Max Chunks To Make Sorted II This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].     Hard Array Simple Java Solution with explanation Max Chunks To Make Sorted II This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].     Hard Array C++ 7 lines, O (n * log n) / O(n) Max Chunks To Make Sorted II This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].     Hard Array Simple Java O(n) Solution with detailed explanation Max Chunks To Make Sorted Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].     Medium Array Java solution, left max and right min. Max Chunks To Make Sorted Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].     Medium Array C++ 4 lines O(n) / O(1) Max Chunks To Make Sorted Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].     Medium Array [C++] 6 lines, 3ms Solution Max Chunks To Make Sorted Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].     Medium Array Java O(n), beats 100% Max Chunks To Make Sorted Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].     Medium Array I would give up directly if asked this question in interview Basic Calculator IV Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].   Hard Hash Table String Stack Easy :-P Basic Calculator IV Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].   Hard Hash Table String Stack C++, unordered_map + stack, with explanation Basic Calculator IV Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].   Hard Hash Table String Stack Java solution, using stack Basic Calculator IV Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].   Hard Hash Table String Stack Do it the hard way: real tokenizer & parser Basic Calculator IV Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].   Hard Hash Table String Stack 1-liners Python/Java/Ruby Jewels and Stones You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.   Easy Hash Table [C++/Java/Python] Easy and Concise Solution O(M+N)  Jewels and Stones You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.   Easy Hash Table Java: O(S+J) Time and O(1) Space Jewels and Stones You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.   Easy Hash Table Python O(M+N) Hash - 公瑾 Jewels and Stones You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.   Easy Hash Table Two-line JavaScript solution Jewels and Stones You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.   Easy Hash Table Java 19ms 26 clean lines BFS with comment. Sliding Puzzle On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move.  Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved.  Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]  Input: board = [[3,2,4],[1,5,0]] Output: 14  Note:  board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].   Hard Breadth-first Search Java 8ms BFS with algorithm explained Sliding Puzzle On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move.  Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved.  Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]  Input: board = [[3,2,4],[1,5,0]] Output: 14  Note:  board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].   Hard Breadth-first Search C++ 9 lines DFS and BFS Sliding Puzzle On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move.  Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved.  Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]  Input: board = [[3,2,4],[1,5,0]] Output: 14  Note:  board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].   Hard Breadth-first Search Readable java solution Sliding Puzzle On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move.  Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved.  Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]  Input: board = [[3,2,4],[1,5,0]] Output: 14  Note:  board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].   Hard Breadth-first Search Java Intuitive DFS+Backtracking Sliding Puzzle On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move.  Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved.  Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]  Input: board = [[3,2,4],[1,5,0]] Output: 14  Note:  board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].   Hard Breadth-first Search My 3 lines C++ Solution Global and Local Inversions We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.   Medium Array Math Easy and Concise Solution [C++/Java/Python] Global and Local Inversions We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.   Medium Array Math check if we can sort the array with only local inversions Global and Local Inversions We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.   Medium Array Math Java O(n) solution with explanation Global and Local Inversions We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.   Medium Array Math Logical Thinking with Clear Code Global and Local Inversions We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.   Medium Array Math Simple Java one pass O(n) solution with explaination Swap Adjacent in LR String In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = "RXXLRXRXL", end = "XRLXXRRLX" Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX  Note:  1 <= len(start) = len(end) <= 10000. Both start and end will only consist of characters in {'L', 'R', 'X'}.   Medium Brainteaser Simple Java Solution Swap Adjacent in LR String In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = "RXXLRXRXL", end = "XRLXXRRLX" Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX  Note:  1 <= len(start) = len(end) <= 10000. Both start and end will only consist of characters in {'L', 'R', 'X'}.   Medium Brainteaser Python simple solution, 3 lines O(n) Swap Adjacent in LR String In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = "RXXLRXRXL", end = "XRLXXRRLX" Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX  Note:  1 <= len(start) = len(end) <= 10000. Both start and end will only consist of characters in {'L', 'R', 'X'}.   Medium Brainteaser [C++] Simple subsequence matching with position constraint. Swap Adjacent in LR String In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = "RXXLRXRXL", end = "XRLXXRRLX" Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX  Note:  1 <= len(start) = len(end) <= 10000. Both start and end will only consist of characters in {'L', 'R', 'X'}.   Medium Brainteaser C++ with explanation, O(n), 14ms Swap Adjacent in LR String In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = "RXXLRXRXL", end = "XRLXXRRLX" Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX  Note:  1 <= len(start) = len(end) <= 10000. Both start and end will only consist of characters in {'L', 'R', 'X'}.   Medium Brainteaser Easy and Concise Solution using PriorityQueue [Python/C++] Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].   Hard Binary Search Heap Depth-first Search Union Find C++ two solutions, Binary Search+DFS and Dijkstra+BFS, O(n^2logn), 11ms Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].   Hard Binary Search Heap Depth-first Search Union Find Java - DFS and Union Find Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].   Hard Binary Search Heap Depth-first Search Union Find Easy and Concise Solution using Binary Search [Python/C++] Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].   Hard Binary Search Heap Depth-first Search Union Find O(n^2) Solution, Union-Find, Python Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].   Hard Binary Search Heap Depth-first Search Union Find My 3 lines C++ recursive solution K-th Symbol in Grammar On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). Examples: Input: N = 1, K = 1 Output: 0  Input: N = 2, K = 1 Output: 0  Input: N = 2, K = 2 Output: 1  Input: N = 4, K = 5 Output: 1  Explanation: row 1: 0 row 2: 01 row 3: 0110 row 4: 01101001  Note:  N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)].   Medium Recursion [JAVA] one line K-th Symbol in Grammar On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). Examples: Input: N = 1, K = 1 Output: 0  Input: N = 2, K = 1 Output: 0  Input: N = 2, K = 2 Output: 1  Input: N = 4, K = 5 Output: 1  Explanation: row 1: 0 row 2: 01 row 3: 0110 row 4: 01101001  Note:  N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)].   Medium Recursion Python 1-line K-th Symbol in Grammar On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). Examples: Input: N = 1, K = 1 Output: 0  Input: N = 2, K = 1 Output: 0  Input: N = 2, K = 2 Output: 1  Input: N = 4, K = 5 Output: 1  Explanation: row 1: 0 row 2: 01 row 3: 0110 row 4: 01101001  Note:  N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)].   Medium Recursion [Python/Java/C++] Easy 1-line Solution with detailed explanation K-th Symbol in Grammar On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). Examples: Input: N = 1, K = 1 Output: 0  Input: N = 2, K = 1 Output: 0  Input: N = 2, K = 2 Output: 1  Input: N = 4, K = 5 Output: 1  Explanation: row 1: 0 row 2: 01 row 3: 0110 row 4: 01101001  Note:  N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)].   Medium Recursion C++ with explanation, three solutions O(n), O(logn), and O(loglogn) K-th Symbol in Grammar On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). Examples: Input: N = 1, K = 1 Output: 0  Input: N = 2, K = 1 Output: 0  Input: N = 2, K = 2 Output: 1  Input: N = 4, K = 5 Output: 1  Explanation: row 1: 0 row 2: 01 row 3: 0110 row 4: 01101001  Note:  N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)].   Medium Recursion Easy and Concise 2-line Solution[Python/C++/Java] Reaching Points A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].   Hard Math [C++] Simple iterative. Reaching Points A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].   Hard Math [Java] Easy to understand recursion solution Reaching Points A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].   Hard Math [Java] Simple solution with explanation Reaching Points A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].   Hard Math C++ Simple 6 Line Solution Reaching Points A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].   Hard Math  [C++/Java/Python] Easy and Concise Solution Rabbits in Forest In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].   Medium Hash Table Math My easy Java HashMap solution Rabbits in Forest In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].   Medium Hash Table Math Java Solution with HashMap O(N) and comments Rabbits in Forest In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].   Medium Hash Table Math Java Simple Solution Rabbits in Forest In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].   Medium Hash Table Math \u3010Simple Python\u3011 Rabbits in Forest In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].   Medium Hash Table Math Easy and Concise Solution with Explanation [C++/Java/Python] Transform to Chessboard An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.   Hard Array Math Key Observation on property of ChessBoard Transform to Chessboard An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.   Hard Array Math Short C++ solution, no swaps, 9ms, O(n^2) time, O(1) space Transform to Chessboard An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.   Hard Array Math Java Clear Code with Detailed Explanations Transform to Chessboard An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.   Hard Array Math C++ O(N^2) time solution with explantion Transform to Chessboard An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.   Hard Array Math Come on guys, it is obviously the same as Problems 530. Minimum Absolute Difference in BST Minimum Distance Between BST Nodes Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.   Easy Binary Search Tree Inorder Traversal O(N) time Recursion [C++/Java/Python] Minimum Distance Between BST Nodes Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.   Easy Binary Search Tree Problem title is confusing Minimum Distance Between BST Nodes Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.   Easy Binary Search Tree what the result of [2147483647,-2147483648,null]? Minimum Distance Between BST Nodes Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.   Easy Binary Search Tree C++ Recursive and Iterative Summary for Question 783 & 530. Minimum Distance Between BST Nodes Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.   Easy Binary Search Tree Java Easy BFS / DFS solution with explanation Letter Case Permutation Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create. Examples: Input: S = "a1b2" Output: ["a1b2", "a1B2", "A1b2", "A1B2"]  Input: S = "3z4" Output: ["3z4", "3Z4"]  Input: S = "12345" Output: ["12345"]  Note:  S will be a string with length between 1 and 12. S will consist only of letters or digits.   Easy Backtracking Bit Manipulation Python simple solution (7 lines) Letter Case Permutation Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create. Examples: Input: S = "a1b2" Output: ["a1b2", "a1B2", "A1b2", "A1B2"]  Input: S = "3z4" Output: ["3z4", "3Z4"]  Input: S = "12345" Output: ["12345"]  Note:  S will be a string with length between 1 and 12. S will consist only of letters or digits.   Easy Backtracking Bit Manipulation C++ backtrack solution w/ trick Letter Case Permutation Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create. Examples: Input: S = "a1b2" Output: ["a1b2", "a1B2", "A1b2", "A1B2"]  Input: S = "3z4" Output: ["3z4", "3Z4"]  Input: S = "12345" Output: ["12345"]  Note:  S will be a string with length between 1 and 12. S will consist only of letters or digits.   Easy Backtracking Bit Manipulation Easy Python 2 line solution Letter Case Permutation Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create. Examples: Input: S = "a1b2" Output: ["a1b2", "a1B2", "A1b2", "A1B2"]  Input: S = "3z4" Output: ["3z4", "3Z4"]  Input: S = "12345" Output: ["12345"]  Note:  S will be a string with length between 1 and 12. S will consist only of letters or digits.   Easy Backtracking Bit Manipulation Java solution using recursion Letter Case Permutation Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create. Examples: Input: S = "a1b2" Output: ["a1b2", "a1B2", "A1b2", "A1B2"]  Input: S = "3z4" Output: ["3z4", "3Z4"]  Input: S = "12345" Output: ["12345"]  Note:  S will be a string with length between 1 and 12. S will consist only of letters or digits.   Easy Backtracking Bit Manipulation Java Clean DFS solution with Explanation Is Graph Bipartite? Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].   Medium Depth-first Search Breadth-first Search Graph java BFS  Is Graph Bipartite? Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].   Medium Depth-first Search Breadth-first Search Graph Java Short Iterative Solution Is Graph Bipartite? Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].   Medium Depth-first Search Breadth-first Search Graph Why is this even a test case? [[1],[0],[0,1]] Is Graph Bipartite? Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].   Medium Depth-first Search Breadth-first Search Graph Easy Python Solution Is Graph Bipartite? Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].   Medium Depth-first Search Breadth-first Search Graph Summary of solutions for problems "reducible" to LeetCode 378 K-th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  Hard Binary Search Heap [Java] AC O(max(n,k) * logn) Short Easy PriorityQueue K-th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  Hard Binary Search Heap C++ 9lines priority queue K-th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  Hard Binary Search Heap O(n) K-th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  Hard Binary Search Heap Python solution using Binary Search K-th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  Hard Binary Search Heap  [Java/Python] Priority Queue Solution Cheapest Flights Within K Stops There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.   Medium Dynamic Programming Heap Breadth-first Search c++ 8 line bellman ford Cheapest Flights Within K Stops There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.   Medium Dynamic Programming Heap Breadth-first Search 5 ms AC Java Solution based on Dijkstra's Algorithm  Cheapest Flights Within K Stops There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.   Medium Dynamic Programming Heap Breadth-first Search Three C++ solutions BFS, DFS, and BF Cheapest Flights Within K Stops There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.   Medium Dynamic Programming Heap Breadth-first Search C++ solution using Dynamic Programming Cheapest Flights Within K Stops There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.   Medium Dynamic Programming Heap Breadth-first Search Java dp solution 9ms Rotated Digits X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].   Easy String Easily Understood Java Solution Rotated Digits X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].   Easy String the question need to be explained clearly Rotated Digits X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].   Easy String Easy to understand Python Solution (using String) Rotated Digits X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].   Easy String O(log10(N)) Easy to understand Java solution Rotated Digits X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].   Easy String Why interception in the middle is not a good idea for ghosts. Escape The Ghosts You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.   Medium Math Java 5 liner Escape The Ghosts You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.   Medium Math Short with explanation, python Escape The Ghosts You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.   Medium Math Test case showing True, but False in output Escape The Ghosts You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.   Medium Math [C++/Java/Python] Easy and Concise Solution Escape The Ghosts You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.   Medium Math Detail and explanation of O(n) solution why dp[n]=2*d[n-1]+dp[n-3] Domino and Tromino Tiling We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].     Medium Dynamic Programming Schematic explanation of two equivalent DP recurrence formula Domino and Tromino Tiling We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].     Medium Dynamic Programming Python recursive DP solution with cache w/ Explanation Domino and Tromino Tiling We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].     Medium Dynamic Programming Easy to understand O(n) solution with Drawing Picture Explanation! Domino and Tromino Tiling We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].     Medium Dynamic Programming O(N) time and O(1) space [C++/Java/Python] Domino and Tromino Tiling We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].     Medium Dynamic Programming Java 5 ms 10 line counting solution with comment Custom Sort String S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.   Medium String Two Lines C++ Custom Sort String S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.   Medium String Java Bucket sort solution O(N+M) with follow up questions Custom Sort String S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.   Medium String Easy Python Solution Custom Sort String S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.   Medium String Python Priority queue solution O(NlgN) Custom Sort String S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.   Medium String Efficient and simple, go through words in parallel, with explanation Number of Matching Subsequences Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].   Medium Array Java solution using HashMap and Queue Number of Matching Subsequences Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].   Medium Array Simple Python solution Number of Matching Subsequences Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].   Medium Array Java O(n) Solution Number of Matching Subsequences Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].   Medium Array C++ 12 Line Solution with Explanation Number of Matching Subsequences Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].   Medium Array Four binary search solutions based on different ideas Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].   Hard Binary Search binary search python code [40ms] Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].   Hard Binary Search C++, O(logn), math solution with explanation Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].   Hard Binary Search Using Binary Search Java Solution Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].   Hard Binary Search Python simple binary search solution Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].   Hard Binary Search Straightforward Java solution with explaination Valid Tic-Tac-Toe State A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.   Medium Math Recursion 4 lines Python Valid Tic-Tac-Toe State A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.   Medium Math Recursion Simple Python Solution with explanation Valid Tic-Tac-Toe State A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.   Medium Math Recursion Java - 20 lines with a cute trick. Valid Tic-Tac-Toe State A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.   Medium Math Recursion Easy to understand in C Valid Tic-Tac-Toe State A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.   Medium Math Recursion Short Java O(n) Solution Number of Subarrays with Bounded Maximum We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].   Medium Array C++, O(n), <10 lines Number of Subarrays with Bounded Maximum We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].   Medium Array Python , standard DP solution with explanation  Number of Subarrays with Bounded Maximum We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].   Medium Array C++ O(n) solution with explanations Number of Subarrays with Bounded Maximum We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].   Medium Array Clean & simple O(n) Java  Number of Subarrays with Bounded Maximum We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].   Medium Array C++ / Java / Python 1 Line Solution Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true  Example 2: Input: A = 'abcde', B = 'abced' Output: false  Note:  A and B will have length at most 100.   Easy Java 1 line solution Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true  Example 2: Input: A = 'abcde', B = 'abced' Output: false  Note:  A and B will have length at most 100.   Easy [C++/Java/Python] 1-line solution Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true  Example 2: Input: A = 'abcde', B = 'abced' Output: false  Note:  A and B will have length at most 100.   Easy 1 Line C++ Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true  Example 2: Input: A = 'abcde', B = 'abced' Output: false  Note:  A and B will have length at most 100.   Easy Python 3, beats 100% Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true  Example 2: Input: A = 'abcde', B = 'abced' Output: false  Note:  A and B will have length at most 100.   Easy Java DFS Solution All Paths From Source to Target Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []]  Output: [[0,1,3],[0,2,3]]  Explanation: The graph looks like this: 0--->1 |    | v    v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.  Note:  The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.   Medium Easy and Concise DFS Solution [C++ / 2-line Python] All Paths From Source to Target Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []]  Output: [[0,1,3],[0,2,3]]  Explanation: The graph looks like this: 0--->1 |    | v    v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.  Note:  The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.   Medium C++ DFS Recursive, Easy to Understand All Paths From Source to Target Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []]  Output: [[0,1,3],[0,2,3]]  Explanation: The graph looks like this: 0--->1 |    | v    v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.  Note:  The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.   Medium short python iterative dfs All Paths From Source to Target Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []]  Output: [[0,1,3],[0,2,3]]  Explanation: The graph looks like this: 0--->1 |    | v    v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.  Note:  The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.   Medium JavaScript solution All Paths From Source to Target Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []]  Output: [[0,1,3],[0,2,3]]  Explanation: The graph looks like this: 0--->1 |    | v    v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.  Note:  The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.   Medium  [C++/Java/Python] Solution with Explanation Smallest Rotation with Highest Score  Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point.  For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation:   Scores for each K are listed below:  K = 0,  A = [2,3,1,4,0],    score 2 K = 1,  A = [3,1,4,0,2],    score 3 K = 2,  A = [1,4,0,2,3],    score 3 K = 3,  A = [4,0,2,3,1],    score 4 K = 4,  A = [0,2,3,1,4],    score 3  So we should choose K = 3, which has the highest score.   Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation:  A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0.  Note:  A will have length at most 20000. A[i] will be in the range [0, A.length].   Hard Java  O(n)Time O(n) Space Solution Smallest Rotation with Highest Score  Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point.  For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation:   Scores for each K are listed below:  K = 0,  A = [2,3,1,4,0],    score 2 K = 1,  A = [3,1,4,0,2],    score 3 K = 2,  A = [1,4,0,2,3],    score 3 K = 3,  A = [4,0,2,3,1],    score 4 K = 4,  A = [0,2,3,1,4],    score 3  So we should choose K = 3, which has the highest score.   Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation:  A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0.  Note:  A will have length at most 20000. A[i] will be in the range [0, A.length].   Hard Easy C++, w/ comments - O(n) time Smallest Rotation with Highest Score  Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point.  For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation:   Scores for each K are listed below:  K = 0,  A = [2,3,1,4,0],    score 2 K = 1,  A = [3,1,4,0,2],    score 3 K = 2,  A = [1,4,0,2,3],    score 3 K = 3,  A = [4,0,2,3,1],    score 4 K = 4,  A = [0,2,3,1,4],    score 3  So we should choose K = 3, which has the highest score.   Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation:  A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0.  Note:  A will have length at most 20000. A[i] will be in the range [0, A.length].   Hard Two Python3 O(n) time and space AC solutions with picture explanation Smallest Rotation with Highest Score  Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point.  For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation:   Scores for each K are listed below:  K = 0,  A = [2,3,1,4,0],    score 2 K = 1,  A = [3,1,4,0,2],    score 3 K = 2,  A = [1,4,0,2,3],    score 3 K = 3,  A = [4,0,2,3,1],    score 4 K = 4,  A = [0,2,3,1,4],    score 3  So we should choose K = 3, which has the highest score.   Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation:  A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0.  Note:  A will have length at most 20000. A[i] will be in the range [0, A.length].   Hard Java Solution w/ Comments Smallest Rotation with Highest Score  Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point.  For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation:   Scores for each K are listed below:  K = 0,  A = [2,3,1,4,0],    score 2 K = 1,  A = [3,1,4,0,2],    score 3 K = 2,  A = [1,4,0,2,3],    score 3 K = 3,  A = [4,0,2,3,1],    score 4 K = 4,  A = [0,2,3,1,4],    score 3  So we should choose K = 3, which has the highest score.   Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation:  A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0.  Note:  A will have length at most 20000. A[i] will be in the range [0, A.length].   Hard [20ms] C++, Easy understand solution Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.  Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.    Note:  poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99].     Medium [9ms] 5 Lines Code [ C++/Java ] Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.  Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.    Note:  poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99].     Medium  [C++/Java/Python] O(101) space solution Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.  Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.    Note:  poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99].     Medium Simple C++ solution and explanations Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.  Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.    Note:  poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99].     Medium Simple Python DP solution Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.  Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.    Note:  poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99].     Medium Java O(n) DP Solution Minimum Swaps To Make Sequences Increasing We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].   Medium Dynamic Programming Python 14-line O(1) space O(n) time DP solution Minimum Swaps To Make Sequences Increasing We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].   Medium Dynamic Programming [C++/Java/Python] Easy Understood DP Solution Minimum Swaps To Make Sequences Increasing We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].   Medium Dynamic Programming Logical Thinking with Optimization Minimum Swaps To Make Sequences Increasing We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].   Medium Dynamic Programming Java neat and easy to understand DP O(n) solution! Minimum Swaps To Make Sequences Increasing We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].   Medium Dynamic Programming Straightforward Java solution, easy to understand! Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].   Medium Depth-first Search Graph 20-line Python concise sol by removing 0 out degree nodes Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].   Medium Depth-first Search Graph Python  easy peasy // 11 lines very simple and clear solution // 192 ms // beats 100 % Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].   Medium Depth-first Search Graph C++, Simple Topological Sorting with DP Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].   Medium Depth-first Search Graph C++ DFS Solution with Explanation, O(n) Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].   Medium Depth-first Search Graph Python Solution by reversely adding hits bricks back Bricks Falling When Hit We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1: Input:  grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation:  If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2: Input:  grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation:  When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.   Note:  The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.   Hard Union Find Tricky problem that reverses LC305 Bricks Falling When Hit We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1: Input:  grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation:  If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2: Input:  grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation:  When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.   Note:  The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.   Hard Union Find C++ DFS (similar to LC749) Bricks Falling When Hit We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1: Input:  grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation:  If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2: Input:  grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation:  When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.   Note:  The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.   Hard Union Find Java Solution Bricks Falling When Hit We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1: Input:  grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation:  If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2: Input:  grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation:  When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.   Note:  The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.   Hard Union Find JAVA Simple DFS 16ms, reversely add bricks back Bricks Falling When Hit We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1: Input:  grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation:  If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2: Input:  grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation:  When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.   Note:  The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.   Hard Union Find is the description of the problem correct? Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.   Easy String [C++/Java/Python]  Easy and Concise Solution Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.   Easy String C++, Straightforward Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.   Easy String Accepted Java Solution Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.   Easy String easy python solution Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.   Easy String C++ Solution with explanation, early termination (Updated for new test case) Split Array With Same Average In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].     Hard Math DP with bitset over *sum* (fast Python/Ruby, decent C++) Split Array With Same Average In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].     Hard Math Simple python with explanation Split Array With Same Average In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].     Hard Math Java, accepted recursive solution, with explanation Split Array With Same Average In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].     Hard Math Easy and Concise Solution ［C++/Java/Python］  Split Array With Same Average In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].     Hard Math The description of the question has to be updated Number of Lines To Write String We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.   Example : Input:  widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "abcdefghijklmnopqrstuvwxyz" Output: [3, 60] Explanation:  All letters have the same length of 10. To write all 26 letters, we need two full lines and one line with 60 units.  Example : Input:  widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "bbbcccdddaaa" Output: [2, 4] Explanation:  All letters except 'a' have the same length of 10, and  "bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units. For the last 'a', it is written on the second line because there is only 2 units left in the first line. So the answer is 2 lines, plus 4 units in the second line.    Note:  The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10].   Easy Easy Solution 6-lines [C++/Java/Python]  Number of Lines To Write String We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.   Example : Input:  widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "abcdefghijklmnopqrstuvwxyz" Output: [3, 60] Explanation:  All letters have the same length of 10. To write all 26 letters, we need two full lines and one line with 60 units.  Example : Input:  widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "bbbcccdddaaa" Output: [2, 4] Explanation:  All letters except 'a' have the same length of 10, and  "bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units. For the last 'a', it is written on the second line because there is only 2 units left in the first line. So the answer is 2 lines, plus 4 units in the second line.    Note:  The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10].   Easy This question is so inane and badly written it should be deleted. Number of Lines To Write String We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.   Example : Input:  widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "abcdefghijklmnopqrstuvwxyz" Output: [3, 60] Explanation:  All letters have the same length of 10. To write all 26 letters, we need two full lines and one line with 60 units.  Example : Input:  widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "bbbcccdddaaa" Output: [2, 4] Explanation:  All letters except 'a' have the same length of 10, and  "bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units. For the last 'a', it is written on the second line because there is only 2 units left in the first line. So the answer is 2 lines, plus 4 units in the second line.    Note:  The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10].   Easy Regex Number of Lines To Write String We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.   Example : Input:  widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "abcdefghijklmnopqrstuvwxyz" Output: [3, 60] Explanation:  All letters have the same length of 10. To write all 26 letters, we need two full lines and one line with 60 units.  Example : Input:  widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "bbbcccdddaaa" Output: [2, 4] Explanation:  All letters except 'a' have the same length of 10, and  "bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units. For the last 'a', it is written on the second line because there is only 2 units left in the first line. So the answer is 2 lines, plus 4 units in the second line.    Note:  The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10].   Easy C++, Straightforward  Number of Lines To Write String We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.   Example : Input:  widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "abcdefghijklmnopqrstuvwxyz" Output: [3, 60] Explanation:  All letters have the same length of 10. To write all 26 letters, we need two full lines and one line with 60 units.  Example : Input:  widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = "bbbcccdddaaa" Output: [2, 4] Explanation:  All letters except 'a' have the same length of 10, and  "bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units. For the last 'a', it is written on the second line because there is only 2 units left in the first line. So the answer is 2 lines, plus 4 units in the second line.    Note:  The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10].   Easy Easy and Concise Solution [C++/Java/Python]  Max Increase to Keep City Skyline In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:  The grid is: [ [3, 0, 8, 4],    [2, 4, 5, 7],   [9, 2, 6, 3],   [0, 3, 1, 0] ]  The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3]  The grid after increasing the height of buildings without affecting skylines is:  gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]   Notes:   1 < grid.length = grid[0].length <= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.   Medium What is this question?  Max Increase to Keep City Skyline In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:  The grid is: [ [3, 0, 8, 4],    [2, 4, 5, 7],   [9, 2, 6, 3],   [0, 3, 1, 0] ]  The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3]  The grid after increasing the height of buildings without affecting skylines is:  gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]   Notes:   1 < grid.length = grid[0].length <= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.   Medium 48ms Python3 solution Max Increase to Keep City Skyline In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:  The grid is: [ [3, 0, 8, 4],    [2, 4, 5, 7],   [9, 2, 6, 3],   [0, 3, 1, 0] ]  The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3]  The grid after increasing the height of buildings without affecting skylines is:  gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]   Notes:   1 < grid.length = grid[0].length <= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.   Medium C++, Straightforward O(m*n) time Max Increase to Keep City Skyline In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:  The grid is: [ [3, 0, 8, 4],    [2, 4, 5, 7],   [9, 2, 6, 3],   [0, 3, 1, 0] ]  The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3]  The grid after increasing the height of buildings without affecting skylines is:  gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]   Notes:   1 < grid.length = grid[0].length <= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.   Medium Simple Python solution Max Increase to Keep City Skyline In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:  The grid is: [ [3, 0, 8, 4],    [2, 4, 5, 7],   [9, 2, 6, 3],   [0, 3, 1, 0] ]  The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3]  The grid after increasing the height of buildings without affecting skylines is:  gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]   Notes:   1 < grid.length = grid[0].length <= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.   Medium [C++/Java/Python] When N >= 4800, just return 1 Soup Servings There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.   Medium Dynamic Programming Straightforward Java Recursion with Memorization Soup Servings There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.   Medium Dynamic Programming Easy understand C++ recursive solution Soup Servings There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.   Medium Dynamic Programming Python // 7 lines clear DP solution // 44 ms // beats 97.5 % Soup Servings There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.   Medium Dynamic Programming [Java]Top down search with hashMap memorized Soup Servings There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.   Medium Dynamic Programming [C++/Java/Python] 2 Pointers and 4 pointers Expressive Words Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy.  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters     Medium String Short straight-forward C++ solution, two pointers one pass scan Expressive Words Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy.  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters     Medium String Some test case have problems? Expressive Words Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy.  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters     Medium String 15 lines java code - 2 pointers 1 pass. Expressive Words Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy.  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters     Medium String Simple and Clear Solution with Detailed Exaplanation Expressive Words Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy.  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters     Medium String Why [1,2,3] return true? Chalkboard XOR Game We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.     Hard Math [C++/Java/Python] 3-lines Easy Solution with Complaint and Explanation Chalkboard XOR Game We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.     Hard Math [810.Chalkboard XOR Game] C++ AC Chalkboard XOR Game We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.     Hard Math Solution based on minimax.. but returns false for [1,2,3] so not accepted in OJ Chalkboard XOR Game We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.     Hard Math O(n) simple python3 with explanation -- beats 100% Chalkboard XOR Game We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.     Hard Math [C++/Java/Python] Easy Understood Solution Subdomain Visit Count A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.   Easy Hash Table Java: Do not use String.split() to handle the string in this case and the code will run faster Subdomain Visit Count A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.   Easy Hash Table Python short & understandable solution [68 ms] Subdomain Visit Count A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.   Easy Hash Table C++ 10 Line Solution w/ Explanation Subdomain Visit Count A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.   Easy Hash Table Java solution,very easy to understand! Subdomain Visit Count A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.   Easy Hash Table [C++/Java/Python] Solution with Explanation and Prove Largest Triangle Area You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.     Easy Math Bad Problem, Solution is Brute Force Largest Triangle Area You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.     Easy Math Simple Java - Easy Understand  Largest Triangle Area You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.     Easy Math [Python] Another convex hull solution (44ms) to reduce the search space.  Largest Triangle Area You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.     Easy Math Javascript T(n^3) S(1) Largest Triangle Area You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.     Easy Math [C++/Java/Python] Easy Understood Solution with Explanation Largest Sum of Averages We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.   Medium Dynamic Programming [Naive] Detailed Step by Step Approach from Recursive to DP O(N) solution Largest Sum of Averages We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.   Medium Dynamic Programming Java bottom-up DP with Explanation Largest Sum of Averages We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.   Medium Dynamic Programming C++ DP Largest Sum of Averages We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.   Medium Dynamic Programming C++ DP Simple Solution use O(N*K) Space and O(K*N^2) Time With Detailed Explanation Largest Sum of Averages We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.   Medium Dynamic Programming [C++/Java/Python]  Self-Explaining Solution and 2-lines Binary Tree Pruning We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.   Medium Tree 3 recursive lines dedicated to python Binary Tree Pruning We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.   Medium Tree Java 4 lines Solution using Recursion Binary Tree Pruning We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.   Medium Tree Clean recursive - python Binary Tree Pruning We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.   Medium Tree Java Backtracking with O(N) time complexity Binary Tree Pruning We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.   Medium Tree Simple Java Solution using BFS Bus Routes We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:   1 <= routes.length <= 500. 1 <= routes[i].length <= 500. 0 <= routes[i][j] < 10 ^ 6.   Hard Breadth-first Search [C++/Java/Python] BFS Solution Bus Routes We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:   1 <= routes.length <= 500. 1 <= routes[i].length <= 500. 0 <= routes[i][j] < 10 ^ 6.   Hard Breadth-first Search Data Invaild? Bus Routes We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:   1 <= routes.length <= 500. 1 <= routes[i].length <= 500. 0 <= routes[i][j] < 10 ^ 6.   Hard Breadth-first Search Python BFS With Explanation Bus Routes We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:   1 <= routes.length <= 500. 1 <= routes[i].length <= 500. 0 <= routes[i][j] < 10 ^ 6.   Hard Breadth-first Search Python // short & simple & readable & self-explanatory BFS solution // ~170 ms Bus Routes We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:   1 <= routes.length <= 500. 1 <= routes[i].length <= 500. 0 <= routes[i][j] < 10 ^ 6.   Hard Breadth-first Search [C++/Java/Python] Solution with Explanation Ambiguous Coordinates We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.     Medium String Really clear Java code Ambiguous Coordinates We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.     Medium String Concise C++ solution with comments Ambiguous Coordinates We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.     Medium String Kotlin solution Ambiguous Coordinates We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.     Medium String 64ms intuitive Python solution that beats 99% Ambiguous Coordinates We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.     Medium String [C++/Java/Python] Easy and Concise Solution with Explanation Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:  head: 0->1->2->3 G = [0, 1, 3] Output: 2 Explanation:  0 and 1 are connected, so [0, 1] and [3] are the two connected components.  Example 2: Input:  head: 0->1->2->3->4 G = [0, 3, 1, 4] Output: 2 Explanation:  0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.  Note:   If N is the length of the linked list given by head, 1 <= N <= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 <= G.length <= 10000. G is a subset of all values in the linked list.   Medium Linked List Can someone explain the test case Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:  head: 0->1->2->3 G = [0, 1, 3] Output: 2 Explanation:  0 and 1 are connected, so [0, 1] and [3] are the two connected components.  Example 2: Input:  head: 0->1->2->3->4 G = [0, 3, 1, 4] Output: 2 Explanation:  0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.  Note:   If N is the length of the linked list given by head, 1 <= N <= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 <= G.length <= 10000. G is a subset of all values in the linked list.   Medium Linked List How is 3  a connected component in this example statement Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:  head: 0->1->2->3 G = [0, 1, 3] Output: 2 Explanation:  0 and 1 are connected, so [0, 1] and [3] are the two connected components.  Example 2: Input:  head: 0->1->2->3->4 G = [0, 3, 1, 4] Output: 2 Explanation:  0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.  Note:   If N is the length of the linked list given by head, 1 <= N <= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 <= G.length <= 10000. G is a subset of all values in the linked list.   Medium Linked List Java solution using hashset Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:  head: 0->1->2->3 G = [0, 1, 3] Output: 2 Explanation:  0 and 1 are connected, so [0, 1] and [3] are the two connected components.  Example 2: Input:  head: 0->1->2->3->4 G = [0, 3, 1, 4] Output: 2 Explanation:  0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.  Note:   If N is the length of the linked list given by head, 1 <= N <= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 <= G.length <= 10000. G is a subset of all values in the linked list.   Medium Linked List Python using Two Pointers Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:  head: 0->1->2->3 G = [0, 1, 3] Output: 2 Explanation:  0 and 1 are connected, so [0, 1] and [3] are the two connected components.  Example 2: Input:  head: 0->1->2->3->4 G = [0, 3, 1, 4] Output: 2 Explanation:  0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.  Note:   If N is the length of the linked list given by head, 1 <= N <= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 <= G.length <= 10000. G is a subset of all values in the linked list.   Medium Linked List Summary of the BFS and DP solutions with intuitive explanation Race Car Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.   Hard Dynamic Programming Heap [C++/JavaPython] DP solution Race Car Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.   Hard Dynamic Programming Heap Accepted Java solution with BFS Race Car Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.   Hard Dynamic Programming Heap Accepted plain BFS Race Car Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.   Hard Dynamic Programming Heap Straightforward C++ BFS solution with Explanation Race Car Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.   Hard Dynamic Programming Heap [C++/Java/Python] Easy Solution with Explanation Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 1 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.   Easy String last test case is weird Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 1 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.   Easy String Clean 6ms C++ solution Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 1 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.   Easy String Simple Java Solution Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 1 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.   Easy String [JAVA] simple solution using hashmaps along with Asserts to test Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 1 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.   Easy String [C++/Java/Python] Easy Understood Solution with Explanation Short Encoding of Words Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = ["time", "me", "bell"] Output: 10 Explanation: S = "time#bell#" and indexes = [0, 2, 5].    Note:  1 <= words.length <= 2000. 1 <= words[i].length <= 7. Each word has only lowercase letters.   Medium Trie Solution Short Encoding of Words Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = ["time", "me", "bell"] Output: 10 Explanation: S = "time#bell#" and indexes = [0, 2, 5].    Note:  1 <= words.length <= 2000. 1 <= words[i].length <= 7. Each word has only lowercase letters.   Medium Simple Concept using Trie Short Encoding of Words Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = ["time", "me", "bell"] Output: 10 Explanation: S = "time#bell#" and indexes = [0, 2, 5].    Note:  1 <= words.length <= 2000. 1 <= words[i].length <= 7. Each word has only lowercase letters.   Medium The problem description should be improved Short Encoding of Words Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = ["time", "me", "bell"] Output: 10 Explanation: S = "time#bell#" and indexes = [0, 2, 5].    Note:  1 <= words.length <= 2000. 1 <= words[i].length <= 7. Each word has only lowercase letters.   Medium Problem statement is ambiguous: substring vs. suffix Short Encoding of Words Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = ["time", "me", "bell"] Output: 10 Explanation: S = "time#bell#" and indexes = [0, 2, 5].    Note:  1 <= words.length <= 2000. 1 <= words[i].length <= 7. Each word has only lowercase letters.   Medium [C++/Java/Python] 2-Pass with Explanation Shortest Distance to a Character Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1: Input: S = "loveleetcode", C = 'e' Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]    Note:  S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase.   Easy Explanation of description without solution Shortest Distance to a Character Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1: Input: S = "loveleetcode", C = 'e' Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]    Note:  S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase.   Easy Concise java solution with detailed explanation. Easy understand!!! Shortest Distance to a Character Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1: Input: S = "loveleetcode", C = 'e' Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]    Note:  S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase.   Easy Java - Single Pass with Trailing Pointer (Concise) Shortest Distance to a Character Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1: Input: S = "loveleetcode", C = 'e' Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]    Note:  S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase.   Easy Python 3 Shortest Distance to a Character Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1: Input: S = "loveleetcode", C = 'e' Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]    Note:  S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase.   Easy Problem statement is so confusing! Card Flipping Game On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card.  If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good?  If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i.  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3]. We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.   Note:  1 <= fronts.length == backs.length <= 1000. 1 <= fronts[i] <= 2000. 1 <= backs[i] <= 2000.   Medium [C++/Java/Python] Easy and Concise with Explanation Card Flipping Game On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card.  If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good?  If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i.  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3]. We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.   Note:  1 <= fronts.length == backs.length <= 1000. 1 <= fronts[i] <= 2000. 1 <= backs[i] <= 2000.   Medium Java solution using HashSet (The description in the problem really confuses me...) Card Flipping Game On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card.  If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good?  If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i.  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3]. We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.   Note:  1 <= fronts.length == backs.length <= 1000. 1 <= fronts[i] <= 2000. 1 <= backs[i] <= 2000.   Medium Python 2 lines Card Flipping Game On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card.  If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good?  If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i.  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3]. We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.   Note:  1 <= fronts.length == backs.length <= 1000. 1 <= fronts[i] <= 2000. 1 <= backs[i] <= 2000.   Medium Simple Java Solution - 19ms Card Flipping Game On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card.  If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good?  If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i.  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3]. We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.   Note:  1 <= fronts.length == backs.length <= 1000. 1 <= fronts[i] <= 2000. 1 <= backs[i] <= 2000.   Medium [C++/Java/Python] DP solution Binary Trees With Factors Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of it's children. How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7. Example 1: Input: A = [2, 4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: A = [2, 4, 5, 10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].   Note:  1 <= A.length <= 1000. 2 <= A[i] <= 10 ^ 9.   Medium Concise Java solution using HashMap with detailed explanation. Easily understand!!! Binary Trees With Factors Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of it's children. How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7. Example 1: Input: A = [2, 4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: A = [2, 4, 5, 10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].   Note:  1 <= A.length <= 1000. 2 <= A[i] <= 10 ^ 9.   Medium Short simple Python Binary Trees With Factors Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of it's children. How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7. Example 1: Input: A = [2, 4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: A = [2, 4, 5, 10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].   Note:  1 <= A.length <= 1000. 2 <= A[i] <= 10 ^ 9.   Medium Java accepted solution Binary Trees With Factors Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of it's children. How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7. Example 1: Input: A = [2, 4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: A = [2, 4, 5, 10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].   Note:  1 <= A.length <= 1000. 2 <= A[i] <= 10 ^ 9.   Medium Java easy understanding DP solution with explanation Binary Trees With Factors Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of it's children. How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7. Example 1: Input: A = [2, 4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: A = [2, 4, 5, 10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].   Note:  1 <= A.length <= 1000. 2 <= A[i] <= 10 ^ 9.   Medium Short C++ solution using i/o stringstream Goat Latin A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.   Easy String Java 5 ms solution with time and space complexity explanation Goat Latin A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.   Easy String C++, easy to understand, just as we think! Goat Latin A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.   Easy String [C++/Java/Python] Straight Forward Solution Goat Latin A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.   Easy String concise python solution Goat Latin A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.   Easy String age[B] > age[A] and age[B] > 100 && age[A] < 100, isn't the latter redundant? Friends Of Appropriate Ages Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.   Medium Array 10ms concise Java  solution, O(n) time and O(1) space Friends Of Appropriate Ages Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.   Medium Array C++ 5 lines O(n), sliding sum Friends Of Appropriate Ages Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.   Medium Array [C++/Java/Python] Easy and Straight Forward Friends Of Appropriate Ages Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.   Medium Array Super Clear Explanation on Both O(NlgN) and O(N) solution STEP BY STEP Friends Of Appropriate Ages Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.   Medium Array [C++/Java/Python] Sort and Two pointer Most Profit Assigning Work We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]   Medium Two Pointers Java Solution with TreeMap Most Profit Assigning Work We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]   Medium Two Pointers C++ 4 lines, sort, bucket sort, and bucked sort with two pointers Most Profit Assigning Work We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]   Medium Two Pointers Extremely Simple Using Priority Queue Most Profit Assigning Work We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]   Medium Two Pointers Python sort based Most Profit Assigning Work We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]   Medium Two Pointers C++ O(n*m) 15 ms, colorful islands Making A Large Island In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.     Hard Depth-first Search [C++/Java/Python] Straight Forward O(N^2) with Explanations Making A Large Island In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.     Hard Depth-first Search DFS JAVA AC CONCISE SOLUTION Making A Large Island In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.     Hard Depth-first Search C++ disjoint set or union find Making A Large Island In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.     Hard Depth-first Search Extremely Simple Concept Using Marker Making A Large Island In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.     Hard Depth-first Search One pass O(N), Straight Forward Unique Letter String A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.  Hard Two Pointers O(N) Java Solution, DP, Clear and easy to Understand Unique Letter String A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.  Hard Two Pointers Simple Java 2 Pointer Unique Letter String A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.  Hard Two Pointers Very simple O(N) with Prev and Next Unique Letter String A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.  Hard Two Pointers Concise DP O(n) solution Unique Letter String A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.  Hard Two Pointers 5 lines C++ solution with detailed mathematical explanation. Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.  Hard Math 5 line O(N ^ 0.5) Java code - Math method Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.  Hard Math [C++/Java/Python] 4-lines and O(logN), Count Odd Factors Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.  Hard Math C++ 2 lines O(sqrt n) Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.  Hard Math C++ solution with strict and detailed proof Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.  Hard Math [C++/Java/Python] Straight Forward Positions of Large Groups In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000  Easy Array Oneline Python using Regex Positions of Large Groups In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000  Easy Array Ambiguous: "the final answer should be in lexicographic order." Positions of Large Groups In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000  Easy Array Java Solution - Two Pointers Positions of Large Groups In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000  Easy Array Python concise Positions of Large Groups In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000  Easy Array [C++/Java/Python] Easy and Concise  Masking Personal Information We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.   Medium String Short python solution Masking Personal Information We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.   Medium String Straightforward C++ Masking Personal Information We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.   Medium String Readable Java Code  Masking Personal Information We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.   Medium String Python with regular expressions Masking Personal Information We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.   Medium String [C++/Java/Python] Reverse and Toggle Flipping an Image Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1   Easy Array Python 1 line Flipping an Image Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1   Easy Array One pass in place JAVA Solution Flipping an Image Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1   Easy Array One-Liner JavaScript Solution Flipping an Image Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1   Easy Array What are the C parameters?  Flipping an Image Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1   Easy Array [C++/Java/Python] Replace S from right to left Find And Replace in String To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.     Medium String java 10 line 14ms and 13 line 7ms  codes - both use StringBuilder replace from end. Find And Replace in String To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.     Medium String Java O(n) solution Find And Replace in String To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.     Medium String C++ 5 lines, 6 ms bucket sort O(n) Find And Replace in String To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.     Medium String Short Java TreeMap solution! Find And Replace in String To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.     Medium String [C++/Java/Python] Straight Forward Image Overlap Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1   Medium Array Python Easy Logic Image Overlap Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1   Medium Array A generic and easy to understand method Image Overlap Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1   Medium Array Short and lazy, just expand the graph Image Overlap Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1   Medium Array An interesting SOLUTION: Let us think about it as "Convolution" Image Overlap Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1   Medium Array [C++/Java/Python] 1-line Solution, 1D to 2D Rectangle Overlap A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.   Easy Math C++ Solution with easy explanation Rectangle Overlap A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.   Easy Math De Morgan's Law and Boolean Algebra Rectangle Overlap A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.   Easy Math Java One Line with explanation Rectangle Overlap A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.   Easy Math Clear Java Code x 2 Rectangle Overlap A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.   Easy Math One Pass DP O(N) New 21 Game Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.   Medium Dynamic Programming Please make sure your description is correct before you publish it, otherwise you create a disaster New 21 Game Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.   Medium Dynamic Programming Java O(K + W) DP solution with explanation New 21 Game Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.   Medium Dynamic Programming My take on how to reach at Solution New 21 Game Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.   Medium Dynamic Programming I think the answer provided isn't correct, we need to consider conditional probability New 21 Game Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.   Medium Dynamic Programming [C++/Java/Python] Two Pointers Push Dominoes There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'   Medium Two Pointers Dynamic Programming funny idea but passed within time limit (Python) Push Dominoes There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'   Medium Two Pointers Dynamic Programming Java, one pass, in-place, 13ms Push Dominoes There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'   Medium Two Pointers Dynamic Programming [Python] O(N) solution. Go through array twice Push Dominoes There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'   Medium Two Pointers Dynamic Programming Java, one pass, no extra storage, detailed explanation Push Dominoes There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'   Medium Two Pointers Dynamic Programming Short C++ solution at 220ms, using disjoint set Similar String Groups Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.   Hard Depth-first Search Union Find Graph Simple Java Solution using DFS Similar String Groups Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.   Hard Depth-first Search Union Find Graph Python, Union Find Solution with Tricky, min(O(MN^2), O(NM^2)) Similar String Groups Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.   Hard Depth-first Search Union Find Graph Simple JAVA with BFS Similar String Groups Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.   Hard Depth-first Search Union Find Graph Simple Java 8 / Python Union Find  Similar String Groups Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.   Hard Depth-first Search Union Find Graph Python, 5 and 43816729 Magic Squares In Grid A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15   Easy Array One misleading problem Magic Squares In Grid A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15   Easy Array Java 8 ms Straightforward & Ugly  Solution Magic Squares In Grid A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15   Easy Array Why is this test case yielding 0? Magic Squares In Grid A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15   Easy Array Straightforward Java Solution Magic Squares In Grid A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15   Easy Array Clean Code Keys and Rooms There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.   Medium Depth-first Search Graph Straight Forward Keys and Rooms There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.   Medium Depth-first Search Graph Python Simple Recursive DFS Keys and Rooms There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.   Medium Depth-first Search Graph BFS (9 lines, 10ms) and DFS (7 lines, 18ms) in C++ w/ beginner friendly explanation Keys and Rooms There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.   Medium Depth-first Search Graph Java   8 lines Keys and Rooms There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.   Medium Depth-first Search Graph short and fast backtracking solution Split Array into Fibonacci Sequence Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.   Medium String Backtracking Greedy Well Commented C++ Backtracking Solution Split Array into Fibonacci Sequence Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.   Medium String Backtracking Greedy what is wrong with this testcase? Split Array into Fibonacci Sequence Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.   Medium String Backtracking Greedy Backtracking with memoization Split Array into Fibonacci Sequence Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.   Medium String Backtracking Greedy Simple Java Solution using DFS Split Array into Fibonacci Sequence Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.   Medium String Backtracking Greedy Random Guess and Minimax Guess with Comparison Guess the Word This problem is an interactive problem new to the LeetCode platform. We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique. Example 1: Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]  Explanation:  master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist. master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches. master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches. master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches. master.guess("abcczz") returns 4, because "abcczz" has 4 matches.  We made 5 calls to master.guess and one of them was the secret, so we pass the test case.  Note:  Any solutions that attempt to circumvent the judge will result in disqualification.  Hard Minimax Optimal MinMax Solution (+ extra challenging test cases) Guess the Word This problem is an interactive problem new to the LeetCode platform. We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique. Example 1: Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]  Explanation:  master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist. master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches. master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches. master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches. master.guess("abcczz") returns 4, because "abcczz" has 4 matches.  We made 5 calls to master.guess and one of them was the secret, so we pass the test case.  Note:  Any solutions that attempt to circumvent the judge will result in disqualification.  Hard Minimax Screencast of LeetCode Weekly Contest 86 Guess the Word This problem is an interactive problem new to the LeetCode platform. We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique. Example 1: Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]  Explanation:  master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist. master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches. master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches. master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches. master.guess("abcczz") returns 4, because "abcczz" has 4 matches.  We made 5 calls to master.guess and one of them was the secret, so we pass the test case.  Note:  Any solutions that attempt to circumvent the judge will result in disqualification.  Hard Minimax C++ elimination histogram, beats Minimax Guess the Word This problem is an interactive problem new to the LeetCode platform. We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique. Example 1: Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]  Explanation:  master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist. master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches. master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches. master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches. master.guess("abcczz") returns 4, because "abcczz" has 4 matches.  We made 5 calls to master.guess and one of them was the secret, so we pass the test case.  Note:  Any solutions that attempt to circumvent the judge will result in disqualification.  Hard Minimax Python O(n) with maximum overlap heuristic Guess the Word This problem is an interactive problem new to the LeetCode platform. We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique. Example 1: Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]  Explanation:  master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist. master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches. master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches. master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches. master.guess("abcczz") returns 4, because "abcczz" has 4 matches.  We made 5 calls to master.guess and one of them was the secret, so we pass the test case.  Note:  Any solutions that attempt to circumvent the judge will result in disqualification.  Hard Minimax [C++/Java/Python] O(N) time and O(1) space Backspace String Compare Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?       Easy Two Pointers Stack [Java/C++] Efficient and Simple Solution WITHOUT Stack etc Backspace String Compare Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?       Easy Two Pointers Stack Java Two Pointer With Explanation - beat 98% Backspace String Compare Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?       Easy Two Pointers Stack 8 lines C++ O(1) space easy to understand Backspace String Compare Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?       Easy Two Pointers Stack Python O(1) Space Backspace String Compare Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?       Easy Two Pointers Stack [C++/Java/Python] 1-pass and O(1) space Longest Mountain in Array Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?   Medium Two Pointers Simple Java Solution Longest Mountain in Array Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?   Medium Two Pointers 1-pass Java Two Point Solution Longest Mountain in Array Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?   Medium Two Pointers Simple O(n) one pass O(1) space Java AC solution beats 99.05  Longest Mountain in Array Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?   Medium Two Pointers Easy to understand - Find peaks and then find max length mountain O(N) Longest Mountain in Array Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?   Medium Two Pointers [C++/Java/Python] O(MlogM) Complexity Hand of Straights Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.     Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], W = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. Example 2: Input: hand = [1,2,3,4,5], W = 4 Output: false Explanation: Alice's hand can't be rearranged into groups of 4.   Note:  1 <= hand.length <= 10000 0 <= hand[i] <= 10^9 1 <= W <= hand.length   Medium Map short and clear Python solution + B站讲解 Hand of Straights Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.     Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], W = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. Example 2: Input: hand = [1,2,3,4,5], W = 4 Output: false Explanation: Alice's hand can't be rearranged into groups of 4.   Note:  1 <= hand.length <= 10000 0 <= hand[i] <= 10^9 1 <= W <= hand.length   Medium Map Simple Java solution using priority queue Hand of Straights Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.     Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], W = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. Example 2: Input: hand = [1,2,3,4,5], W = 4 Output: false Explanation: Alice's hand can't be rearranged into groups of 4.   Note:  1 <= hand.length <= 10000 0 <= hand[i] <= 10^9 1 <= W <= hand.length   Medium Map Short Java solution! Hand of Straights Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.     Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], W = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. Example 2: Input: hand = [1,2,3,4,5], W = 4 Output: false Explanation: Alice's hand can't be rearranged into groups of 4.   Note:  1 <= hand.length <= 10000 0 <= hand[i] <= 10^9 1 <= W <= hand.length   Medium Map Python O(nlgn) simple solution with intuition Hand of Straights Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.     Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], W = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. Example 2: Input: hand = [1,2,3,4,5], W = 4 Output: false Explanation: Alice's hand can't be rearranged into groups of 4.   Note:  1 <= hand.length <= 10000 0 <= hand[i] <= 10^9 1 <= W <= hand.length   Medium Map Screencast of LeetCode Weekly Contest 87 Shortest Path Visiting All Nodes An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length   Hard Dynamic Programming Breadth-first Search Fast BFS Solution (46ms) -- Clear, Detailed Explanation Included Shortest Path Visiting All Nodes An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length   Hard Dynamic Programming Breadth-first Search Java DP Solution Shortest Path Visiting All Nodes An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length   Hard Dynamic Programming Breadth-first Search Python 8 lines Heapq & BFS & Deque solutions Shortest Path Visiting All Nodes An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length   Hard Dynamic Programming Breadth-first Search can't understand the description,what's the meaning of the given array[][] Shortest Path Visiting All Nodes An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length   Hard Dynamic Programming Breadth-first Search [C++/Java/Python] Easy Understood Shifting Letters We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9   Medium String Java clean solution Shifting Letters We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9   Medium String Short and concise C++ solution, 3 lines Shifting Letters We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9   Medium String C++ 2 lines, O(n) Shifting Letters We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9   Medium String Linear One Pass Solution Beats 100% Best Solution and Clean. Explanation Shifting Letters We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9   Medium String [C++/Java] 1 Pass Solution Maximize Distance to Closest Person In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.     Easy Array Clean / One Pass / Two Pointers / Java Solution Maximize Distance to Closest Person In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.     Easy Array 3 lines C++ one pass Maximize Distance to Closest Person In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.     Easy Array java one pass easy understand Maximize Distance to Closest Person In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.     Easy Array Python and C++ Solution using two pointers, short and elegant, beats 98% Maximize Distance to Closest Person In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.     Easy Array LeetCode Weekly Contest 88 screencast Rectangle Area II We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle. Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.  Example 1: Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2: Input: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:  1 <= rectangles.length <= 200 rectanges[i].length = 4 0 <= rectangles[i][j] <= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.   Hard Segment Tree 【Top】Java Solution with detailed explaination, check this one !  Rectangle Area II We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle. Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.  Example 1: Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2: Input: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:  1 <= rectangles.length <= 200 rectanges[i].length = 4 0 <= rectangles[i][j] <= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.   Hard Segment Tree [C++/Python] Discretization and O(NlogN) Rectangle Area II We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle. Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.  Example 1: Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2: Input: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:  1 <= rectangles.length <= 200 rectanges[i].length = 4 0 <= rectangles[i][j] <= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.   Hard Segment Tree Java TreeMap solution inspired by Skyline and Meeting Room Rectangle Area II We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle. Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.  Example 1: Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2: Input: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:  1 <= rectangles.length <= 200 rectanges[i].length = 4 0 <= rectangles[i][j] <= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.   Hard Segment Tree Clean Recursive Solution [Java] Rectangle Area II We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle. Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.  Example 1: Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2: Input: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:  1 <= rectangles.length <= 200 rectanges[i].length = 4 0 <= rectangles[i][j] <= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.   Hard Segment Tree [C++/Java/Python] Concise DFS  Loud and Rich In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.   Medium Depth-first Search Example is confusing Loud and Rich In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.   Medium Depth-first Search DFS with memory Loud and Rich In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.   Medium Depth-first Search C++ with topological sorting Loud and Rich In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.   Medium Depth-first Search Java BFS Loud and Rich In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.   Medium Depth-first Search [C++/Java/Python] Better than Binary Search Peak Index in a Mountain Array Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.   Easy Binary Search Java O(n) and O(log(n)) code Peak Index in a Mountain Array Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.   Easy Binary Search Java - Basic Binary Search Solution Peak Index in a Mountain Array Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.   Easy Binary Search Python & Javascript 1-liner Peak Index in a Mountain Array Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.   Easy Binary Search Python3 Binary Search Peak Index in a Mountain Array Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.   Easy Binary Search [C++/Java/Python] Straight Forward Car Fleet N cars are going to the same destination along a one lane road.  The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed. The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.  How many car fleets will arrive at the destination?   Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.   Note:  0 <= N <= 10 ^ 4 0 < target <= 10 ^ 6 0 < speed[i] <= 10 ^ 6 0 <= position[i] < target All initial positions are different.   Medium Stack Easy understanding JAVA TreeMap Solution with explanation & comment Car Fleet N cars are going to the same destination along a one lane road.  The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed. The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.  How many car fleets will arrive at the destination?   Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.   Note:  0 <= N <= 10 ^ 4 0 < target <= 10 ^ 6 0 < speed[i] <= 10 ^ 6 0 <= position[i] < target All initial positions are different.   Medium Stack Java 10 and 11 liner with comment, both time O(nlog(n)) space O(n) Car Fleet N cars are going to the same destination along a one lane road.  The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed. The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.  How many car fleets will arrive at the destination?   Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.   Note:  0 <= N <= 10 ^ 4 0 < target <= 10 ^ 6 0 < speed[i] <= 10 ^ 6 0 <= position[i] < target All initial positions are different.   Medium Stack Solution without Map Car Fleet N cars are going to the same destination along a one lane road.  The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed. The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.  How many car fleets will arrive at the destination?   Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.   Note:  0 <= N <= 10 ^ 4 0 < target <= 10 ^ 6 0 < speed[i] <= 10 ^ 6 0 <= position[i] < target All initial positions are different.   Medium Stack Java O(N) without sorting Car Fleet N cars are going to the same destination along a one lane road.  The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed. The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.  How many car fleets will arrive at the destination?   Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.   Note:  0 <= N <= 10 ^ 4 0 < target <= 10 ^ 6 0 < speed[i] <= 10 ^ 6 0 <= position[i] < target All initial positions are different.   Medium Stack JAVA BFS 32 ms clean/concise/explanation/whatever K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = "ab", B = "ba" Output: 1   Example 2: Input: A = "abc", B = "bca" Output: 2   Example 3: Input: A = "abac", B = "baca" Output: 2   Example 4: Input: A = "aabc", B = "abca" Output: 2    Note:  1 <= A.length == B.length <= 20 A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}   Hard Breadth-first Search Graph Java Backtracking with Memorization K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = "ab", B = "ba" Output: 1   Example 2: Input: A = "abc", B = "bca" Output: 2   Example 3: Input: A = "abac", B = "baca" Output: 2   Example 4: Input: A = "aabc", B = "abca" Output: 2    Note:  1 <= A.length == B.length <= 20 A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}   Hard Breadth-first Search Graph C++ 6ms Solution K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = "ab", B = "ba" Output: 1   Example 2: Input: A = "abc", B = "bca" Output: 2   Example 3: Input: A = "abac", B = "baca" Output: 2   Example 4: Input: A = "aabc", B = "abca" Output: 2    Note:  1 <= A.length == B.length <= 20 A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}   Hard Breadth-first Search Graph C++ BFS solution K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = "ab", B = "ba" Output: 1   Example 2: Input: A = "abc", B = "bca" Output: 2   Example 3: Input: A = "abac", B = "baca" Output: 2   Example 4: Input: A = "aabc", B = "abca" Output: 2    Note:  1 <= A.length == B.length <= 20 A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}   Hard Breadth-first Search Graph Problem Statement Was WRONG K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = "ab", B = "ba" Output: 1   Example 2: Input: A = "abc", B = "bca" Output: 2   Example 3: Input: A = "abac", B = "baca" Output: 2   Example 4: Input: A = "aabc", B = "abca" Output: 2    Note:  1 <= A.length == B.length <= 20 A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}   Hard Breadth-first Search Graph [Java] PriorityQueue with customized object. seat: O(logn), leave O(n) with explanation Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.   Example 1: Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.  ​​​​​​​ Note:  1 <= N <= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.   Medium Map [C++/Java/Python] Straight Forward Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.   Example 1: Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.  ​​​​​​​ Note:  1 <= N <= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.   Medium Map [Python] O(log n) time for both seat() and leave() with heapq and dicts - Detailed explanation Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.   Example 1: Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.  ​​​​​​​ Note:  1 <= N <= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.   Medium Map Java Solution based on treeset Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.   Example 1: Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.  ​​​​​​​ Note:  1 <= N <= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.   Medium Map C++ O(logn) seat() and O(logn) leave() with STL set and map Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.   Example 1: Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.  ​​​​​​​ Note:  1 <= N <= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.   Medium Map [C++/Java/Python] Concise O(1) Space Score of Parentheses Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50       Medium String Stack Java solution using Stack Score of Parentheses Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50       Medium String Stack 1-line Python Score of Parentheses Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50       Medium String Stack Python & Javascript // simple and readable // Stack solution Score of Parentheses Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50       Medium String Stack Java 8ms 11 lines recursion with explanation Score of Parentheses Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50       Medium String Stack Detailed explanation O(NlogN) Minimum Cost to Hire K Workers There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i]. Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. Every worker in the paid group must be paid at least their minimum wage expectation.  Return the least amount of money needed to form a paid group satisfying the above conditions.      Example 1: Input: quality = [10,20,5], wage = [70,50,30], K = 2 Output: 105.00000 Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.   Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3 Output: 30.66667 Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.     Note:  1 <= K <= N <= 10000, where N = quality.length = wage.length 1 <= quality[i] <= 10000 1 <= wage[i] <= 10000 Answers within 10^-5 of the correct answer will be considered correct.     Hard Heap O(NlogN) C++ code using priority queue with explanation Minimum Cost to Hire K Workers There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i]. Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. Every worker in the paid group must be paid at least their minimum wage expectation.  Return the least amount of money needed to form a paid group satisfying the above conditions.      Example 1: Input: quality = [10,20,5], wage = [70,50,30], K = 2 Output: 105.00000 Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.   Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3 Output: 30.66667 Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.     Note:  1 <= K <= N <= 10000, where N = quality.length = wage.length 1 <= quality[i] <= 10000 1 <= wage[i] <= 10000 Answers within 10^-5 of the correct answer will be considered correct.     Hard Heap N log N explanation, no code Minimum Cost to Hire K Workers There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i]. Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. Every worker in the paid group must be paid at least their minimum wage expectation.  Return the least amount of money needed to form a paid group satisfying the above conditions.      Example 1: Input: quality = [10,20,5], wage = [70,50,30], K = 2 Output: 105.00000 Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.   Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3 Output: 30.66667 Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.     Note:  1 <= K <= N <= 10000, where N = quality.length = wage.length 1 <= quality[i] <= 10000 1 <= wage[i] <= 10000 Answers within 10^-5 of the correct answer will be considered correct.     Hard Heap 75ms Java with Explanations Minimum Cost to Hire K Workers There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i]. Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. Every worker in the paid group must be paid at least their minimum wage expectation.  Return the least amount of money needed to form a paid group satisfying the above conditions.      Example 1: Input: quality = [10,20,5], wage = [70,50,30], K = 2 Output: 105.00000 Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.   Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3 Output: 30.66667 Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.     Note:  1 <= K <= N <= 10000, where N = quality.length = wage.length 1 <= quality[i] <= 10000 1 <= wage[i] <= 10000 Answers within 10^-5 of the correct answer will be considered correct.     Hard Heap Detailed Plain English Explanation With Very Simple Readable Code  Minimum Cost to Hire K Workers There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i]. Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. Every worker in the paid group must be paid at least their minimum wage expectation.  Return the least amount of money needed to form a paid group satisfying the above conditions.      Example 1: Input: quality = [10,20,5], wage = [70,50,30], K = 2 Output: 105.00000 Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.   Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3 Output: 30.66667 Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.     Note:  1 <= K <= N <= 10000, where N = quality.length = wage.length 1 <= quality[i] <= 10000 1 <= wage[i] <= 10000 Answers within 10^-5 of the correct answer will be considered correct.     Hard Heap Java short solution with a sample drawing Mirror Reflection There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p    Medium Math [C++/Java/Python] 1-line without using any package or ✖️➗% Mirror Reflection There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p    Medium Math 一看就懂 Mirror Reflection There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p    Medium Math The Most Straight Forward Solution.Pure Math.Only 13ms Mirror Reflection There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p    Medium Math Java solution with an easy-to-understand explanation Mirror Reflection There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p    Medium Math Easy Understood Buddy Strings Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.   Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false    Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A and B consist only of lowercase letters.        Easy String Java O(1) space, O(n) time Buddy Strings Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.   Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false    Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A and B consist only of lowercase letters.        Easy String Clear C++ Solution Buddy Strings Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.   Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false    Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A and B consist only of lowercase letters.        Easy String Very simple Python solution with detailed explanation [O(n) time, O(1) space with 40 ms runtime] Buddy Strings Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.   Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false    Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A and B consist only of lowercase letters.        Easy String Javascript straightforward Buddy Strings Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.   Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false    Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A and B consist only of lowercase letters.        Easy String [C++/Java/Python] Straight Forward Lemonade Change At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.       Easy Greedy Python simple & readable Lemonade Change At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.       Easy Greedy java easy undersand Lemonade Change At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.       Easy Greedy Easy to understand java solution Lemonade Change At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.       Easy Greedy 7ms Java solution with readable code and explanation Lemonade Change At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.       Easy Greedy [C++/Java/Python] Easy and Concise Score After Flipping Matrix We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.    Medium Greedy [C++,Java] From Intuition, Un-optimized code to Optimized Code with Detailed Explanation  Score After Flipping Matrix We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.    Medium Greedy Java, two steps, O(MN) Score After Flipping Matrix We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.    Medium Greedy Python O(N*M) greedy solution Score After Flipping Matrix We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.    Medium Greedy c++ easy understand Greedy method with explanation Score After Flipping Matrix We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.    Medium Greedy [C++/Java/Python] O(N) Using Deque Shortest Subarray with Sum at Least K Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9      Hard Binary Search Queue Simple Java Solution Using TreeMap Shortest Subarray with Sum at Least K Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9      Hard Binary Search Queue Python Simple & Readable // AC Heapq Solution w/ Detailed Explanation  Shortest Subarray with Sum at Least K Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9      Hard Binary Search Queue Detailed intuition behind Deque solution Shortest Subarray with Sum at Least K Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9      Hard Binary Search Queue A Java Deque Solution Time O(n) Space O(n) Shortest Subarray with Sum at Least K Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9      Hard Binary Search Queue Java BFS Solution Shortest Path to Get All Keys We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.    Example 1: Input: ["@.a.#","###.#","b.A.B"] Output: 8   Example 2: Input: ["@..aA","..B#.","....b"] Output: 6     Note:  1 <= grid.length <= 30 1 <= grid[0].length <= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.    Hard Heap Breadth-first Search LeetCode Weekly Contest 92 screencast Shortest Path to Get All Keys We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.    Example 1: Input: ["@.a.#","###.#","b.A.B"] Output: 8   Example 2: Input: ["@..aA","..B#.","....b"] Output: 6     Note:  1 <= grid.length <= 30 1 <= grid[0].length <= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.    Hard Heap Breadth-first Search O(mn2^k) 500ms Python BFS Easy to Understand Solution Shortest Path to Get All Keys We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.    Example 1: Input: ["@.a.#","###.#","b.A.B"] Output: 8   Example 2: Input: ["@..aA","..B#.","....b"] Output: 6     Note:  1 <= grid.length <= 30 1 <= grid[0].length <= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.    Hard Heap Breadth-first Search [C++] BFS with current key recorded visited map (12ms) Shortest Path to Get All Keys We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.    Example 1: Input: ["@.a.#","###.#","b.A.B"] Output: 8   Example 2: Input: ["@..aA","..B#.","....b"] Output: 6     Note:  1 <= grid.length <= 30 1 <= grid[0].length <= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.    Hard Heap Breadth-first Search Python Heapq solution w/ memoization  Shortest Path to Get All Keys We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.    Example 1: Input: ["@.a.#","###.#","b.A.B"] Output: 8   Example 2: Input: ["@..aA","..B#.","....b"] Output: 6     Note:  1 <= grid.length <= 30 1 <= grid[0].length <= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.    Hard Heap Breadth-first Search One pass Smallest Subtree with all the Deepest Nodes Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree.   Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.    Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.   Medium Tree Simple recursive Java Solution  Smallest Subtree with all the Deepest Nodes Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree.   Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.    Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.   Medium Tree Description of what the problem is asking is unclear Smallest Subtree with all the Deepest Nodes Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree.   Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.    Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.   Medium Tree Short and concise C++ solution using DFS, 3~5 lines Smallest Subtree with all the Deepest Nodes Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree.   Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.    Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.   Medium Tree Unclear problem description. Smallest Subtree with all the Deepest Nodes Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree.   Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.    Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.   Medium Tree Search Palindrome with Even Digits Prime Palindrome Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.   Medium Math C++ O(1) 0ms Prime Palindrome Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.   Medium Math Getting one over the system (O(1) solution in Java) Prime Palindrome Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.   Medium Math Faster way to find Palindrome. Accepted C++ Solution. Prime Palindrome Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.   Medium Math Java solution 6ms Prime Palindrome Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.   Medium Math Python - 1 Liner Transpose Matrix Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000     Easy Array Python self-explanatory 1 line solution Transpose Matrix Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000     Easy Array [C++/Java/Python] Easy Understood Transpose Matrix Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000     Easy Array Simple JAVA Solution Transpose Matrix Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000     Easy Array Java Solution.  Transpose Matrix Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000     Easy Array [C++/Java/Python] Dividing by 2 Binary Gap Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9          Easy Math Who can tell me, what does "distance" means? Binary Gap Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9          Easy Math Simple Java (10 ms) Binary Gap Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9          Easy Math python 1-line solution Binary Gap Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9          Easy Math Python simple solution Binary Gap Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9          Easy Math [C++/Java/Python] Straight Forward Reordered Power of 2 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9        Medium Math JAVA Naive Backtracking 15 lines Reordered Power of 2 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9        Medium Math Possibly fastest C++ solution using Multiset, 0ms runtime. Reordered Power of 2 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9        Medium Math One line python beats 70% Reordered Power of 2 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9        Medium Math Simple Java Solution Based on String Sorting Reordered Power of 2 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9        Medium Math JAVA Greedy 6 lines with Explanation Advantage Shuffle Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9     Medium Array Greedy Simple Java Solution with the idea of 田忌赛马 Advantage Shuffle Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9     Medium Array Greedy C++ 6 lines greedy, O(n log n) Advantage Shuffle Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9     Medium Array Greedy [Python] Greedy Solution Using Sort Advantage Shuffle Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9     Medium Array Greedy [C++/Java] Greedy Solution Using Map Advantage Shuffle Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9     Medium Array Greedy DP O(N^2) and Priority Queue O(NlogN) Minimum Number of Refueling Stops A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target      Hard Dynamic Programming Heap Simple Java Solution Using PriorityQueue O(nlogn) Minimum Number of Refueling Stops A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target      Hard Dynamic Programming Heap C++ DP solution Space complexity from O(n^2) to O(n). Minimum Number of Refueling Stops A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target      Hard Dynamic Programming Heap python O(NlogN)  Minimum Number of Refueling Stops A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target      Hard Dynamic Programming Heap O(n) Simple and Concise C++ solution using priority_queue, need no comment Minimum Number of Refueling Stops A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target      Hard Dynamic Programming Heap [C++/Java/Python] O(logN) Space Leaf-Similar Trees Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.   Easy Tree Depth-first Search 4 line Python Solution Leaf-Similar Trees Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.   Easy Tree Depth-first Search Simple 6 lines Java, StringBuilder + traverse with explanation Leaf-Similar Trees Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.   Easy Tree Depth-first Search C++ super easy 0ms short solution, beats 100%! Leaf-Similar Trees Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.   Easy Tree Depth-first Search C++ solution based on hashing Leaf-Similar Trees Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.   Easy Tree Depth-first Search [C++/Java/Python] Check Pair Length of Longest Fibonacci Subsequence A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)   Medium Array Dynamic Programming LeetCode Weekly Contest 94 screencast Length of Longest Fibonacci Subsequence A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)   Medium Array Dynamic Programming Java clean DP O(n^2) time O(n^2) space Length of Longest Fibonacci Subsequence A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)   Medium Array Dynamic Programming C++ DP solution Length of Longest Fibonacci Subsequence A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)   Medium Array Dynamic Programming Java HashMap Straightforward Length of Longest Fibonacci Subsequence A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)   Medium Array Dynamic Programming Maximum?! This is crazy! Walking Robot Simulation A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.   Easy Greedy Logical Thinking with Clear Code Walking Robot Simulation A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.   Easy Greedy Python short & straightforward solution w/ explanation & statement is wrong in the question !!! Walking Robot Simulation A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.   Easy Greedy Any 1160(x) 1954(o)? Walking Robot Simulation A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.   Easy Greedy Obstacle at origin Walking Robot Simulation A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.   Easy Greedy Logical Thinking with Java Code  Koko Eating Bananas Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9      Medium Binary Search [C++/Java/Python] Binary Search Koko Eating Bananas Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9      Medium Binary Search JAVA Concise Binary Search 10 lines with Explanation Koko Eating Bananas Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9      Medium Binary Search Binary search with optimized runtime Koko Eating Bananas Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9      Medium Binary Search python solution with Chinese explanation Koko Eating Bananas Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9      Medium Binary Search [C++/Java/Python] Slow and Fast Pointers Middle of the Linked List Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.    Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.    Note:  The number of nodes in the given list will be between 1 and 100.     Easy Linked List Remember this pattern for problems that require middle finding in a Linked List. Middle of the Linked List Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.    Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.    Note:  The number of nodes in the given list will be between 1 and 100.     Easy Linked List Python two pointer, extremely simple, with explaination Middle of the Linked List Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.    Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.    Note:  The number of nodes in the given list will be between 1 and 100.     Easy Linked List Java O(n) time & O(1) space solution without using fast/slow pointer Middle of the Linked List Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.    Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.    Note:  The number of nodes in the given list will be between 1 and 100.     Easy Linked List [Java] 5 Liner with explanations Middle of the Linked List Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.    Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.    Note:  The number of nodes in the given list will be between 1 and 100.     Easy Linked List [C++/Java/Python] DP or Just return true Stone Game Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.   Medium Math Dynamic Programming [Java] This is minimax + dp (fully detailed explanation + generalization + easy understand code) Stone Game Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.   Medium Math Dynamic Programming Alex won't lose Stone Game Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.   Medium Math Dynamic Programming python solution using memorization with Chinese explanation Stone Game Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.   Medium Math Dynamic Programming Alex can take all piles with odd (even) indices, thus he always wins Stone Game Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.   Medium Math Dynamic Programming [C++/Java/Python] Binary Search Nth Magical Number A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000       Hard Math Binary Search o(1) Mathematical Solution without binary or brute force search Nth Magical Number A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000       Hard Math Binary Search Python using gcd and lcm, no search needed Nth Magical Number A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000       Hard Math Binary Search Python leverage gcd and lcm to search Nth Magical Number A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000       Hard Math Binary Search Python simple & readable binary search solution Nth Magical Number A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000       Hard Math Binary Search [C++/Java/Python] DP Profitable Schemes There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100       Hard Dynamic Programming Java original 3d to 2d DP solution Profitable Schemes There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100       Hard Dynamic Programming LeetCode Weekly Contest 95 screencast Profitable Schemes There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100       Hard Dynamic Programming C++ O(PGn) top-down DP solution Profitable Schemes There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100       Hard Dynamic Programming Simple DP O(PGN) Profitable Schemes There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100       Hard Dynamic Programming [C++/Python] O(N) Time O(1) Space Decoded String at Index An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.  Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.    Example 1: Input: S = "leet2code3", K = 10 Output: "o" Explanation:  The decoded string is "leetleetcodeleetleetcodeleetleetcode". The 10th letter in the string is "o".   Example 2: Input: S = "ha22", K = 5 Output: "h" Explanation:  The decoded string is "hahahaha".  The 5th letter is "h".   Example 3: Input: S = "a2345678999999999999999", K = 1 Output: "a" Explanation:  The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".    Note:  2 <= S.length <= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 <= K <= 10^9 The decoded string is guaranteed to have less than 2^63 letters.      Medium Stack Easy to understand Java Solution Decoded String at Index An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.  Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.    Example 1: Input: S = "leet2code3", K = 10 Output: "o" Explanation:  The decoded string is "leetleetcodeleetleetcodeleetleetcode". The 10th letter in the string is "o".   Example 2: Input: S = "ha22", K = 5 Output: "h" Explanation:  The decoded string is "hahahaha".  The 5th letter is "h".   Example 3: Input: S = "a2345678999999999999999", K = 1 Output: "a" Explanation:  The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".    Note:  2 <= S.length <= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 <= K <= 10^9 The decoded string is guaranteed to have less than 2^63 letters.      Medium Stack C++ simple recursion Decoded String at Index An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.  Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.    Example 1: Input: S = "leet2code3", K = 10 Output: "o" Explanation:  The decoded string is "leetleetcodeleetleetcodeleetleetcode". The 10th letter in the string is "o".   Example 2: Input: S = "ha22", K = 5 Output: "h" Explanation:  The decoded string is "hahahaha".  The 5th letter is "h".   Example 3: Input: S = "a2345678999999999999999", K = 1 Output: "a" Explanation:  The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".    Note:  2 <= S.length <= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 <= K <= 10^9 The decoded string is guaranteed to have less than 2^63 letters.      Medium Stack Logical Thinking with Clear Code Decoded String at Index An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.  Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.    Example 1: Input: S = "leet2code3", K = 10 Output: "o" Explanation:  The decoded string is "leetleetcodeleetleetcodeleetleetcode". The 10th letter in the string is "o".   Example 2: Input: S = "ha22", K = 5 Output: "h" Explanation:  The decoded string is "hahahaha".  The 5th letter is "h".   Example 3: Input: S = "a2345678999999999999999", K = 1 Output: "a" Explanation:  The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".    Note:  2 <= S.length <= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 <= K <= 10^9 The decoded string is guaranteed to have less than 2^63 letters.      Medium Stack 15 lines clear code Decoded String at Index An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.  Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.    Example 1: Input: S = "leet2code3", K = 10 Output: "o" Explanation:  The decoded string is "leetleetcodeleetleetcodeleetleetcode". The 10th letter in the string is "o".   Example 2: Input: S = "ha22", K = 5 Output: "h" Explanation:  The decoded string is "hahahaha".  The 5th letter is "h".   Example 3: Input: S = "a2345678999999999999999", K = 1 Output: "a" Explanation:  The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".    Note:  2 <= S.length <= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 <= K <= 10^9 The decoded string is guaranteed to have less than 2^63 letters.      Medium Stack 6 lines [Java] O(nlogn) code, sorting + greedy, with greedy algorithm proof.  Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000      Medium Two Pointers Greedy [C++/Java/Python] Two Pointers Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000      Medium Two Pointers Greedy Python short 2 pointer solution & some thoughts Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000      Medium Two Pointers Greedy [Java] O(N(people)) + O(limit) solution Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000      Medium Two Pointers Greedy What if each boat carries at most K people (instead of 2 people) at the same time Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000      Medium Two Pointers Greedy Java Dijkstra Solution Reachable Nodes In Subdivided Graph Starting with an undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge.  Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge.  Return how many nodes you can reach in at most M moves.   Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:  The nodes that are reachable in the final graph after M = 6 moves are indicated below.    Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23    Note:  0 <= edges.length <= 10000 0 <= edges[i][0] < edges[i][1] < N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 <= edges[i][2] <= 10000 0 <= M <= 10^9 1 <= N <= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0.       Hard Heap [C++/Java/Python] Dijkstra + Priority Queue Reachable Nodes In Subdivided Graph Starting with an undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge.  Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge.  Return how many nodes you can reach in at most M moves.   Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:  The nodes that are reachable in the final graph after M = 6 moves are indicated below.    Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23    Note:  0 <= edges.length <= 10000 0 <= edges[i][0] < edges[i][1] < N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 <= edges[i][2] <= 10000 0 <= M <= 10^9 1 <= N <= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0.       Hard Heap god, the description of this problem just confuses me!! Reachable Nodes In Subdivided Graph Starting with an undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge.  Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge.  Return how many nodes you can reach in at most M moves.   Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:  The nodes that are reachable in the final graph after M = 6 moves are indicated below.    Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23    Note:  0 <= edges.length <= 10000 0 <= edges[i][0] < edges[i][1] < N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 <= edges[i][2] <= 10000 0 <= M <= 10^9 1 <= N <= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0.       Hard Heap Logical Thinking with Clear Code Reachable Nodes In Subdivided Graph Starting with an undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge.  Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge.  Return how many nodes you can reach in at most M moves.   Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:  The nodes that are reachable in the final graph after M = 6 moves are indicated below.    Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23    Note:  0 <= edges.length <= 10000 0 <= edges[i][0] < edges[i][1] < N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 <= edges[i][2] <= 10000 0 <= M <= 10^9 1 <= N <= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0.       Hard Heap Indecipherable description Reachable Nodes In Subdivided Graph Starting with an undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge.  Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge.  Return how many nodes you can reach in at most M moves.   Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:  The nodes that are reachable in the final graph after M = 6 moves are indicated below.    Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23    Note:  0 <= edges.length <= 10000 0 <= edges[i][0] < edges[i][1] < N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 <= edges[i][2] <= 10000 0 <= M <= 10^9 1 <= N <= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0.       Hard Heap Please change the description of the problem Projection Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50           Easy Math i don't even understand the description Projection Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50           Easy Math 11 line 1 pass [Java] code and  explanation of the problem, time O(N ^ 2) space O(1). Projection Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50           Easy Math [C++/Java/Python] Straight Forward Projection Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50           Easy Math It drove me nuts. What the hell is it talking about... Projection Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50           Easy Math [C++/Java/Python] Easy Solution with Explanation Uncommon Words from Two Sentences We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.     Easy Hash Table [Java] 3 liner and 5 liner, using HashMap and HashSets, respectively.  Uncommon Words from Two Sentences We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.     Easy Hash Table C++ 100% with unordered_map Uncommon Words from Two Sentences We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.     Easy Hash Table two C++ solutions Uncommon Words from Two Sentences We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.     Easy Hash Table [C# solution] 2 lines of code, beat 100% submission running time Uncommon Words from Two Sentences We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.     Easy Hash Table [C++/Java/Python] 1,1,2,2,3,3 Steps Spiral Matrix III On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C     Medium Math Java 15 lines concise solution with comments Spiral Matrix III On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C     Medium Math [Python] Sort All Coordinates Spiral Matrix III On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C     Medium Math Simple East to Understand Java solution  Spiral Matrix III On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C     Medium Math JAVA Simulation 17 lines with line-by-line Explanation Spiral Matrix III On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C     Medium Math Java DFS solution Possible Bipartition Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].      Medium Depth-first Search java graph  Possible Bipartition Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].      Medium Depth-first Search [Python] Decide if a graph is bipartite by checking the existence of odd cycles. Possible Bipartition Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].      Medium Depth-first Search Python DFS with explanation Possible Bipartition Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].      Medium Depth-first Search Graph Bipartite problem + DFS Possible Bipartition Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].      Medium Depth-first Search [C++/Java/Python] 2D and 1D DP, O(KlogN) Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000      Hard Math Binary Search Dynamic Programming Python DP from kn^2 to knlogn to kn Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000      Hard Math Binary Search Dynamic Programming Java DP solution from O(KN^2) to O(KNlogN) Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000      Hard Math Binary Search Dynamic Programming easy to understand Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000      Hard Math Binary Search Dynamic Programming LeetCode Weekly Contest 97 screencast Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000      Hard Math Binary Search Dynamic Programming [C++/Java/Python] Straight Forward Fair Candy Swap Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.       Easy Array Java 2 solutions clear explanation with illustration Fair Candy Swap Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.       Easy Array Python simple and quick solution without loop Fair Candy Swap Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.       Easy Array Python solution using set (similar to TwoSum concept) Fair Candy Swap Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.       Easy Array Python simple solution Fair Candy Swap Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.       Easy Array [C++/Java/Python] One Pass, Real O(N) Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.    Medium Tree Logical Thinking with Code Beats 99.89% Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.    Medium Tree C++ O(N) recursive solution Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.    Medium Tree Clean Java O(N) Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.    Medium Tree Easy Python Recursive Solution with Explanation Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.    Medium Tree [C++/Java/Python] Normalise Word Find and Replace Pattern You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20    Medium String Short python isomorphism solution Find and Replace Pattern You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20    Medium String JAVA 3ms Clear Code Find and Replace Pattern You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20    Medium String Java two maps solution Find and Replace Pattern You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20    Medium String Python double-dictionary simplest logics beat 99% Find and Replace Pattern You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20    Medium String [C++/Java/1-line Python] Sort and One Pass Sum of Subsequence Widths Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000    Hard Array Math LeetCode Weekly Contest 98 screencast Sum of Subsequence Widths Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000    Hard Array Math C++ solution, O(N log N) sort + O(N) calculate Sum of Subsequence Widths Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000    Hard Array Math pythonic O(nlogn) sorting Sum of Subsequence Widths Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000    Hard Array Math O(nlogn) solution Sum of Subsequence Widths Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000    Hard Array Math [C++/Java/1-line Python] Minus Hidden Area Surface Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50        Easy Math Geometry Java simple solution Surface Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50        Easy Math Geometry Difficulty should be Medium not Easy Surface Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50        Easy Math Geometry Java solution Surface Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50        Easy Math Geometry Java Solution with Explanation Surface Area of 3D Shapes On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50        Easy Math Geometry Java Concise Set Solution Groups of Special-Equivalent Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.       Easy String Misleading description during the contest Groups of Special-Equivalent Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.       Easy String Python 1-liner Groups of Special-Equivalent Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.       Easy String Python extremely simple solution Groups of Special-Equivalent Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.       Easy String C++ Simple Solution Groups of Special-Equivalent Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.       Easy String [C++/Java/Python] O(1) Maximum Frequency Stack Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.       Hard Hash Table Stack Python Simple PriorityQueue Maximum Frequency Stack Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.       Hard Hash Table Stack JAVA O(1) solution easy understand using bucket sort Maximum Frequency Stack Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.       Hard Hash Table Stack LeetCode Weekly Contest 99 screencast Maximum Frequency Stack Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.       Hard Hash Table Stack Java Priority Queue easy understand Maximum Frequency Stack Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.       Hard Hash Table Stack [C++/Java/Python] One Pass O(N) Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000        Easy Array Python Solution, Easy to Understand Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000        Easy Array JAVA Tricky Solution Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000        Easy Array 1-liner C++ Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000        Easy Array [Java] 1 pass 7 lines straight forward code. Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000        Easy Array [C++/Java/Python] Self-Explained, 5-line, O(N) Increasing Order Search Tree Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.   Easy Tree Depth-first Search Can someone explain this test case? Increasing Order Search Tree Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.   Easy Tree Depth-first Search Java Simple InOrder Traversal- with Explanation Increasing Order Search Tree Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.   Easy Tree Depth-first Search 6-line python O(n) solution. Increasing Order Search Tree Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.   Easy Tree Depth-first Search Inorder traversal Increasing Order Search Tree Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.   Easy Tree Depth-first Search [C++/Java/Python] O(30N) Bitwise ORs of Subarrays We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9   Medium Dynamic Programming Bit Manipulation C++ O(kN) solution Bitwise ORs of Subarrays We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9   Medium Dynamic Programming Bit Manipulation [Python] Dynamic programming solution with indepth explanation of intuition. Bitwise ORs of Subarrays We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9   Medium Dynamic Programming Bit Manipulation C++ simplest, fastest ;) (224 ms) Bitwise ORs of Subarrays We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9   Medium Dynamic Programming Bit Manipulation The exactly same code can pass now, so sad Bitwise ORs of Subarrays We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9   Medium Dynamic Programming Bit Manipulation [C++/Java/Python] Sort String or Rotate String Orderly Queue A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.     Hard Math String K>1 is bubblesort Orderly Queue A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.     Hard Math String [C++] Solution Sort/Rotate Orderly Queue A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.     Hard Math String When k > 1 you can reorder any way you like [Proof] Orderly Queue A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.     Hard Math String Java Simple Solution, 12 ms Orderly Queue A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.     Hard Math String Java Straightforward Solution, O(n) time, O(1) space RLE Iterator Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.   Medium Array [Java] straightforward code with comment -- O(n) time and O(1) space RLE Iterator Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.   Medium Array Python simple solution beats 95% python codes - O(n) RLE Iterator Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.   Medium Array C interface error, RLEIterator* rLEIteratorCreate(int* A)  missing length for C. RLE Iterator Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.   Medium Array Python3 beats 100% RLE Iterator Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.   Medium Array [C++/Java/Python] O(1) Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].    Example 1: Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation:  First, S = StockSpanner() is initialized.  Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.  Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.    Note:  Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.    Medium Stack Simple C++ solution with stack O(n), with explanation Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].    Example 1: Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation:  First, S = StockSpanner() is initialized.  Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.  Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.    Note:  Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.    Medium Stack Short Java Solution Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].    Example 1: Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation:  First, S = StockSpanner() is initialized.  Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.  Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.    Note:  Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.    Medium Stack Java short solution using list with explanation Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].    Example 1: Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation:  First, S = StockSpanner() is initialized.  Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.  Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.    Note:  Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.    Medium Stack Simple Python solution with comment Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].    Example 1: Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation:  First, S = StockSpanner() is initialized.  Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.  Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.    Note:  Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.    Medium Stack Python O(logN) Numbers At Most N Given Digit Set We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9   Hard Math Dynamic Programming C++ O(logN) Clear code with explanation Numbers At Most N Given Digit Set We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9   Hard Math Dynamic Programming Java Solution with explanation Numbers At Most N Given Digit Set We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9   Hard Math Dynamic Programming My straightforward self-explanatory Python solution Numbers At Most N Given Digit Set We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9   Hard Math Dynamic Programming Simple C++ Solution ( 0 ms, O(logN) ). With line by line explanation Numbers At Most N Given Digit Set We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9   Hard Math Dynamic Programming [C++/Java/Python] DP Solution O(N^2)  Valid Permutations for DI Sequence We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.       Hard Divide and Conquer Dynamic Programming Share my O(N^3) => O(N^2) C++ DP solution. Including the thoughts of improvement. Valid Permutations for DI Sequence We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.       Hard Divide and Conquer Dynamic Programming Top-down with Memo -> Bottom-up DP -> N^3 DP -> N^2 DP -> O(N) space Valid Permutations for DI Sequence We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.       Hard Divide and Conquer Dynamic Programming Python O(N^3) O(N) space DP solution with explanation Valid Permutations for DI Sequence We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.       Hard Divide and Conquer Dynamic Programming [Visualization] Key to the DP solution: imagine cutting a piece of paper and separating the halves Valid Permutations for DI Sequence We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.       Hard Divide and Conquer Dynamic Programming Another poorly worded question Fruit Into Baskets In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length   Medium Two Pointers Problem: Longest Subarray With 2 Elements Fruit Into Baskets In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length   Medium Two Pointers Sliding Window Fruit Into Baskets In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length   Medium Two Pointers what the fuck?what is meaning?I really cann't understand Fruit Into Baskets In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length   Medium Two Pointers Java - Longest Subarray with atmost 2 Distinct elements Fruit Into Baskets In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length   Medium Two Pointers [C++/Java] In Place Swap Sort Array By Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000    Easy Array Very simple C++/Python/Java O(n) soln (Avoid in-place swapping as the input is passed as reference) Sort Array By Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000    Easy Array My Simple Java Solution Sort Array By Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000    Easy Array Python 2 pointer in place swap, beats 99% Sort Array By Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000    Easy Array One line JavaScript.  Sort Array By Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000    Easy Array Java building the next palindrome Super Palindromes Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)       Hard Math no more this type questions for contest! Super Palindromes Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)       Hard Math Python super easy to understand, 10^5 complexity, no cheating Super Palindromes Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)       Hard Math Python AC, bfs, detail explanation Super Palindromes Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)       Hard Math [c++] straightforward backtracking solution Super Palindromes Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)       Hard Math [C++/Java/Python] Stack Solution Sum of Subarray Minimums Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000       Medium Array Stack stack solution with very  detailed explanation step by step Sum of Subarray Minimums Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000       Medium Array Stack Python Simple Stack O(n) Solution - 10 lines  Sum of Subarray Minimums Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000       Medium Array Stack Java O(n) Building Preprocessed Scope Array with Explanation Sum of Subarray Minimums Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000       Medium Array Stack One stack solution Sum of Subarray Minimums Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000       Medium Array Stack Very confusing question! Smallest Range I Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Easy [C++/Java/Python] Check Max - Min Smallest Range I Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Easy  [Java] Simple Single Pass Solution Smallest Range I Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Easy C++ 1-liner Smallest Range I Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Easy Java easy to understand solution Smallest Range I Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Easy Diagram and BFS Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:   You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:  You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.  	 (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)   If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.  A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.) Return the least number of moves required to reach square N*N.  If it is not possible, return -1. Example 1: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation:  At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.  Note:  2 <= board.length = board[0].length <= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder.   Medium Change to 1D array then BFS Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:   You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:  You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.  	 (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)   If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.  A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.) Return the least number of moves required to reach square N*N.  If it is not possible, return -1. Example 1: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation:  At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.  Note:  2 <= board.length = board[0].length <= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder.   Medium Java concise solution easy to understand Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:   You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:  You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.  	 (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)   If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.  A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.) Return the least number of moves required to reach square N*N.  If it is not possible, return -1. Example 1: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation:  At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.  Note:  2 <= board.length = board[0].length <= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder.   Medium Dude... it is literally 1-6 steps, not an example of 1-n steps when n = 6 Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:   You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:  You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.  	 (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)   If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.  A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.) Return the least number of moves required to reach square N*N.  If it is not possible, return -1. Example 1: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation:  At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.  Note:  2 <= board.length = board[0].length <= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder.   Medium How does this input gives 2? Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:   You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:  You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.  	 (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)   If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.  A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.) Return the least number of moves required to reach square N*N.  If it is not possible, return -1. Example 1: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation:  At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.  Note:  2 <= board.length = board[0].length <= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder.   Medium [C++/Java/Python] Add 0 or 2 * K Smallest Range II Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Medium simple C++ solution with explanation Smallest Range II Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Medium c++, O(n) time solution! Take the challenge! With very, very, detail description and comments Smallest Range II Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Medium Java Solution with the Picture to explain it Smallest Range II Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Medium JAVA solution very easy to understand - [sliding window] Smallest Range II Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000      Medium [C++/Java/Python] Binary Search in Times Online Election In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].    Medium Anyone else just find this question really confusing? Online Election In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].    Medium [Java] two methods with comment- using TreeMap and binary search, respectively Online Election In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].    Medium Python readable short bisect solution Online Election In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].    Medium [Java] TreeMap: O(NlogN) + O(logN)  and Binary Search: O(N) + O(logN) Online Election In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].    Medium Most of the DFS solutions are WRONG, check this case Cat and Mouse A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways:  If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.  Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.      Example 1: Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 |   | 2---5  \ /   0    Note:  3 <= graph.length <= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element.     Hard Breadth-first Search Minimax Perfect Wrong DFS/DP code explained in detail (Revised) Cat and Mouse A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways:  If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.  Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.      Example 1: Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 |   | 2---5  \ /   0    Note:  3 <= graph.length <= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element.     Hard Breadth-first Search Minimax 5ms Java solution with brief comment  Cat and Mouse A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways:  If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.  Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.      Example 1: Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 |   | 2---5  \ /   0    Note:  3 <= graph.length <= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element.     Hard Breadth-first Search Minimax So confusing the last case, can't believe it! Cat and Mouse A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways:  If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.  Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.      Example 1: Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 |   | 2---5  \ /   0    Note:  3 <= graph.length <= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element.     Hard Breadth-first Search Minimax share my thoughts and code,so confused by the last case Cat and Mouse A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways:  If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.  Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.      Example 1: Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 |   | 2---5  \ /   0    Note:  3 <= graph.length <= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element.     Hard Breadth-first Search Minimax [C++/Java/Python] Greatest Common Divisor X of a Kind in a Deck of Cards In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000             Easy Array Math c++ solutions using binary method for gcd and the power of stl. 3 lines if you use __gcd X of a Kind in a Deck of Cards In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000             Easy Array Math Need Updated Cases - Bad Code Passed [9/29/2018] X of a Kind in a Deck of Cards In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000             Easy Array Math Map Plus GCD solution X of a Kind in a Deck of Cards In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000             Easy Array Math Java GCD X of a Kind in a Deck of Cards In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000             Easy Array Math Java, one pass, 7 lines Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.       Medium Array [C++/Java/Python] Straight Forward Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.       Medium Array Explained - Python simple O(N) time O(1) space Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.       Medium Array JAVA EASIEST SIMPLEST Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.       Medium Array O(n) One Pass Solution Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.       Medium Array [C++/Java/Python] Straight Forward Word Subsets We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].        Medium String [Java] 14 line clean code - count the most frequent char of words in B Word Subsets We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].        Medium String [16ms] Fastest Solution - Prime Number Subset Step in O(1) (Detailed Explanation) Word Subsets We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].        Medium String My Python solution. Beats 98.4%. Word Subsets We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].        Medium String Cpp easy understand solution O(max(na,nb)*strLen) Word Subsets We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].        Medium String [C++/Java/Python] Two Pointers Reverse Only Letters Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "       Easy [Java] 5 line clean code - very simple logic Reverse Only Letters Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "       Easy Java Two Pointers Reverse Only Letters Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "       Easy My 2-liner Python stack solution  Reverse Only Letters Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "       Easy Java 6ms simple solution Reverse Only Letters Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "       Easy [C++/Java/Python] One Pass Maximum Sum Circular Subarray Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000       Medium C++ single pass O(N) linear time O(1) constant space Maximum Sum Circular Subarray Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000       Medium C++ O(N) solution Maximum Sum Circular Subarray Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000       Medium JAVA ONE PASS, O(n) with very detailed chinese explanation Maximum Sum Circular Subarray Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000       Medium Short Java Solution!!! Maximum Sum Circular Subarray Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000       Medium [C++/Java/Python] O(1) Insert Complete Binary Tree Inserter A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.           Medium [Java] BFS straightforward code, two methods, Initialization and insert time O(1), respectively. Complete Binary Tree Inserter A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.           Medium JavaScript ALWAYS get a runtime error even do nothing changes to template Complete Binary Tree Inserter A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.           Medium Java Solution: O(1) Insert VS. O(1) Pre-process Trade Off Complete Binary Tree Inserter A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.           Medium c++ 12 ms using queue Complete Binary Tree Inserter A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.           Medium [C++/Java/Python] DP Solution Number of Music Playlists Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100      Hard DP solution that is Easy to understand Number of Music Playlists Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100      Hard [C++] Straight forward DP, with explanation Number of Music Playlists Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100      Hard [Python3] A math solution O((N - K) * log(L - K)) Number of Music Playlists Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100      Hard Java dp solution (I think the description of the problem could be clearer) Number of Music Playlists Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100      Hard [Java] two one pass 7 liners - space O(n) and O(1), respectively Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.   Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4      Note:  S.length <= 1000 S only consists of '(' and ')' characters.           Medium [C++/Java/Python] Straight Forward One Pass Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.   Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4      Note:  S.length <= 1000 S only consists of '(' and ')' characters.           Medium Python classic valid paranthesis solution Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.   Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4      Note:  S.length <= 1000 S only consists of '(' and ')' characters.           Medium [Java] Easy to understand Stack Solution (8ms)  Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.   Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4      Note:  S.length <= 1000 S only consists of '(' and ')' characters.           Medium Python 3-line mathematically optimal solution with explanation, one-pass O(n) time O(1) space Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.   Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4      Note:  S.length <= 1000 S only consists of '(' and ')' characters.           Medium Java two pointer one pass inplace Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000       Easy Python easy 2-liner Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000       Easy C++ 5 lines, two pointers + 2-liner bonus Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000       Easy [Java] Two pointers inplace O(n) time simple & straightforward Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000       Easy [Java] simple code - swap odd and even indices elements. Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000       Easy [C++/Java/Python] O(101^2) 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300   Medium 10 lines Super Super Easy Java Solution 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300   Medium Knapsack O(n * target) or Straightforward O(n^2) 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300   Medium [Java] O(n^2) code - Sort and Match. 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300   Medium DP, python 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300   Medium [Python] Union Found Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0   Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length      Hard Python short DFS solution Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0   Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length      Hard How to explain this test case? Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0   Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length      Hard Brute force or Union Find Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0   Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length      Hard C++ Union Find With Explanation Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0   Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length      Hard [C++/Java/Python] Two Pointers Long Pressed Name Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.             Easy Java one pass solution 4ms with O(1) extra space Long Pressed Name Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.             Easy C++ 2 lines accepted and 5 lines accurate Long Pressed Name Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.             Easy Java Simple Solution -3 ms Long Pressed Name Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.             Easy Short Java Solution Long Pressed Name Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.             Easy Prefix-Suffix Java O(N) One Pass Solution - Space O(1) Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.      Medium C++/Java 4 lines O(n) | O(1), DP Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.      Medium Java DP solution O(n) time O(1) space Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.      Medium python O(n) time O(1) space solution with explanation(with extra Chinese explanation) Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.      Medium C++ one-pass DP solution, 0ms O(n) | O(1), one line, with explaination. Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.      Medium [C++] O(n) time, O(1) space, 12 ms with explanation & comments Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1      Hard Math Java O(n) Solution Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1      Hard Math [C++] O(N) time O(N) space, 40ms, 14 lines, 2 loops, easy understand with explanation Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1      Hard Math JAVA 50ms with my thinking process Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1      Hard Math Java 10ms solution with O(n) time and O(1)space Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1      Hard Math python solution with my thinking process (with extra Chinese explanation) Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length     Hard Depth-first Search Union Find Graph 分享一个详细中文C++讲解 Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length     Hard Depth-first Search Union Find Graph Short Python DFS solution w/ short explanation ~290 ms Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length     Hard Depth-first Search Union Find Graph Java (42ms) using Union Find Set and Brute Force with explaination Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length     Hard Depth-first Search Union Find Graph java bfs without copy graph Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length     Hard Depth-first Search Union Find Graph [Java] 7 liner with comment. Unique Email Addresses Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character.   Easy String python solution Unique Email Addresses Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character.   Easy String Concise C++ Unique Email Addresses Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character.   Easy String [Java] Clean O(n*maxStringLen) with and without split() Unique Email Addresses Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character.   Easy String python solution beat 91% Unique Email Addresses Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character.   Easy String [C++/Java/Python] Straight Forward Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.  Medium Hash Table Two Pointers [Java] Clean Solution 2 Sum + Prefix Sum Caching Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.  Medium Hash Table Two Pointers Java O(N) Time O(N) Space, counting contiguous zeros Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.  Medium Hash Table Two Pointers 3 ways to solve this kind of problem. Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.  Medium Hash Table Two Pointers Python easy & short Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.  Medium Hash Table Two Pointers Java DP solution, with graph illustrated explanations Minimum Falling Path Sum Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100  Medium Dynamic Programming C++/Java 4 lines DP Minimum Falling Path Sum Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100  Medium Dynamic Programming [Java] two clean DP codes - input modified and not, Time O(n ^ 2), space O(1) & O(n) Minimum Falling Path Sum Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100  Medium Dynamic Programming C 4ms DP Solution With Explanation Minimum Falling Path Sum Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100  Medium Dynamic Programming Golang DP Solution Minimum Falling Path Sum Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100  Medium Dynamic Programming [C++/Java/Python] Odd + Even Pattern, O(N) Beautiful Array For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that: For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A.  (It is guaranteed that one exists.)   Example 1: Input: 4 Output: [2,1,4,3]   Example 2: Input: 5 Output: [3,1,2,5,4]    Note:  1 <= N <= 1000      Medium Divide and Conquer LeetCode Weekly Contest 108 screencast (only record 10 mins) Beautiful Array For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that: For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A.  (It is guaranteed that one exists.)   Example 1: Input: 4 Output: [2,1,4,3]   Example 2: Input: 5 Output: [3,1,2,5,4]    Note:  1 <= N <= 1000      Medium Divide and Conquer Python 1-line solutions Beautiful Array For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that: For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A.  (It is guaranteed that one exists.)   Example 1: Input: 4 Output: [2,1,4,3]   Example 2: Input: 5 Output: [3,1,2,5,4]    Note:  1 <= N <= 1000      Medium Divide and Conquer [3 solutions] 4 lines in Python (Divide & Conquer) + DP (Top-down and bottom-up) Beautiful Array For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that: For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A.  (It is guaranteed that one exists.)   Example 1: Input: 4 Output: [2,1,4,3]   Example 2: Input: 5 Output: [3,1,2,5,4]    Note:  1 <= N <= 1000      Medium Divide and Conquer [JavaScript] How I understand the solution (with verification of the solution) Beautiful Array For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that: For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A.  (It is guaranteed that one exists.)   Example 1: Input: 4 Output: [2,1,4,3]   Example 2: Input: 5 Output: [3,1,2,5,4]    Note:  1 <= N <= 1000      Medium Divide and Conquer [Java] Three solutions: TreeMap , TreeSet, ArrayList; All time O(logN). Number of Recent Calls Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.   Example 1: Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3]   Note:  Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 <= t <= 10^9.      Easy Queue C++ Easy and Clean solution using queue Number of Recent Calls Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.   Example 1: Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3]   Note:  Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 <= t <= 10^9.      Easy Queue Python straightforward solution Number of Recent Calls Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.   Example 1: Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3]   Note:  Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 <= t <= 10^9.      Easy Queue Simple JavaScript solution (3 lines) Number of Recent Calls Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.   Example 1: Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3]   Note:  Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 <= t <= 10^9.      Easy Queue [Java] Array + binary search, 111 ms, O(log(3000)) time, O(logN) space Number of Recent Calls Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.   Example 1: Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3]   Note:  Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 <= t <= 10^9.      Easy Queue C++ BFS Island Expansion + UF Bonus Shortest Bridge In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1        Medium Depth-first Search Breadth-first Search Python concise DFS & BFS in 1 solution Shortest Bridge In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1        Medium Depth-first Search Breadth-first Search Java DFS find the island -> BFS expand the island Shortest Bridge In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1        Medium Depth-first Search Breadth-first Search Java DFS+BFS, traverse the 2D array once Shortest Bridge In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1        Medium Depth-first Search Breadth-first Search Java extremely easy to understand with comment (bfs to find answer and dfs to paint the matrix) Shortest Bridge In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1        Medium Depth-first Search Breadth-first Search O(logN) Knight Dialer A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000      Medium Dynamic Programming [Java] Top Down Memo DP O(N) Knight Dialer A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000      Medium Dynamic Programming O(n) time O(1) space DP solution + Google interview question writeup Knight Dialer A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000      Medium Dynamic Programming How to solve this problem explained for noobs!!! Knight Dialer A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000      Medium Dynamic Programming C++ 5 lines DP Knight Dialer A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000      Medium Dynamic Programming [C++] Reverse Operation, 30 ms, better than DFS Stamping The Sequence You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.  Hard String Greedy C++ simple greedy Stamping The Sequence You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.  Hard String Greedy Python AC greedy simple solution for everyone ~200 ms Stamping The Sequence You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.  Hard String Greedy Useless screencast (only 1 min, for promoting my YouTube channel) Stamping The Sequence You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.  Hard String Greedy Python Solutions Stamping The Sequence You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.  Hard String Greedy Python 1-liner Reorder Log Files You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.    Example 1: Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"] Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]    Note:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.   Easy String C++ stable_sort easy to understand Reorder Log Files You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.    Example 1: Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"] Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]    Note:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.   Easy String Java - Nothing Fancy, 15 lines, 5ms, all clear. Reorder Log Files You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.    Example 1: Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"] Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]    Note:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.   Easy String few lines C++ version, 8ms Reorder Log Files You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.    Example 1: Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"] Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]    Note:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.   Easy String C++ stable_sort and lambdas Reorder Log Files You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.    Example 1: Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"] Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]    Note:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.   Easy String [Java] 3 recursive methods with comment. Range Sum of BST Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.    Medium Binary Search Tree Python 1-liner Range Sum of BST Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.    Medium Binary Search Tree Jave easy to understand 2ms solution (tree pruning) Range Sum of BST Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.    Medium Binary Search Tree Medium??? I don't think so Range Sum of BST Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.    Medium Binary Search Tree Python3 | Easy to understand | InOrder Traversal Range Sum of BST Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.    Medium Binary Search Tree Java N^2 Hashmap Minimum Area Rectangle Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.    Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2    Note:  1 <= points.length <= 500 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct.    Medium Hash Table Python O(N^1.5), 80ms Minimum Area Rectangle Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.    Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2    Note:  1 <= points.length <= 500 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct.    Medium Hash Table C++ hash-map + set intersection 56 ms Minimum Area Rectangle Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.    Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2    Note:  1 <= points.length <= 500 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct.    Medium Hash Table Simple AF JAVA solution, with explanation O(n2) Minimum Area Rectangle Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.    Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2    Note:  1 <= points.length <= 500 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct.    Medium Hash Table Python straightforward & concise Minimum Area Rectangle Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.    Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2    Note:  1 <= points.length <= 500 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct.    Medium Hash Table [C++/Java/Python] 4 lines O(N) Time, O(1) Space Distinct Subsequences II Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000          Hard Dynamic Programming Java DP O(N^2) time -> O(N) time -> O(1) space Distinct Subsequences II Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000          Hard Dynamic Programming C++ O(n) | O (n) Geeks4Geeks improved to O(n) | O(1) Distinct Subsequences II Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000          Hard Dynamic Programming LeetCode Weekly Contest 110 screencast (rank 26) Distinct Subsequences II Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000          Hard Dynamic Programming python solution with Chinese explanation showing my thinking process Distinct Subsequences II Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000          Hard Dynamic Programming [C++/Java/Python] Climb Mountain Valid Mountain Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[B.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000           Easy Array C++ Track Peak Valid Mountain Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[B.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000           Easy Array Python 2-liner Valid Mountain Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[B.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000           Easy Array Concise C++ Valid Mountain Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[B.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000           Easy Array the 'stupid' but fast(3ms) method :) Valid Mountain Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[B.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000           Easy Array [C++/Java/Python] Straight Forward DI String Match Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".  Easy Math C++ 5 lines high-low pointers DI String Match Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".  Easy Math Python 5-liner easy to understand DI String Match Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".  Easy Math Probably the easiest java solution DI String Match Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".  Easy Math C++,implement, simple and straightforward, beats 99% DI String Match Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".  Easy Math Travelling Salesman Problem Find the Shortest Superstring Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20      Hard Dynamic Programming LeetCode Weekly Contest 111 screencast (rank 12) Find the Shortest Superstring Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20      Hard Dynamic Programming Greedy solution is WRONG. If your greedy solution gets AC it only means you are LUCKY enough. Find the Shortest Superstring Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20      Hard Dynamic Programming is this an interview level problem or not? Find the Shortest Superstring Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20      Hard Dynamic Programming Python AC concise solution ~132 ms Find the Shortest Superstring Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20      Hard Dynamic Programming Really bad example in the description Delete Columns to Make Sorted We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.  The remaining rows of strings form columns when read north to south. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000      Easy Greedy Why this problem is medium? Delete Columns to Make Sorted We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.  The remaining rows of strings form columns when read north to south. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000      Easy Greedy C++ brute force O(n * m) Delete Columns to Make Sorted We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.  The remaining rows of strings form columns when read north to south. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000      Easy Greedy Python, Count Unsorted Columns Delete Columns to Make Sorted We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.  The remaining rows of strings form columns when read north to south. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000      Easy Greedy Python easy 1-liner O(n * m) Delete Columns to Make Sorted We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.  The remaining rows of strings form columns when read north to south. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000      Easy Greedy 