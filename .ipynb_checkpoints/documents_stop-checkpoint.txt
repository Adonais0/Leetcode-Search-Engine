is this algorithm optimal or what? add two numbers you are given two non-empty linked lists representing two non-negative integers  the digits are stored in reverse order and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  medium linked list math 
[c++] sharing my 11-line c++ solution  can someone make it even more concise? add two numbers you are given two non-empty linked lists representing two non-negative integers  the digits are stored in reverse order and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  medium linked list math 
clear python code  straight forward add two numbers you are given two non-empty linked lists representing two non-negative integers  the digits are stored in reverse order and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  medium linked list math 
my accepted java solution add two numbers you are given two non-empty linked lists representing two non-negative integers  the digits are stored in reverse order and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  medium linked list math 
python concise solution  add two numbers you are given two non-empty linked lists representing two non-negative integers  the digits are stored in reverse order and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  medium linked list math 
11-line simple java solution  o(n) with explanation longest substring without repeating characters given a string  find the length of the longest substring without repeating characters  medium hash table two pointers string 
c++ code in 9 lines  longest substring without repeating characters given a string  find the length of the longest substring without repeating characters  medium hash table two pointers string 
share my java solution using hashset longest substring without repeating characters given a string  find the length of the longest substring without repeating characters  medium hash table two pointers string 
a python solution - 85ms - o(n) longest substring without repeating characters given a string  find the length of the longest substring without repeating characters  medium hash table two pointers string 
shortest o(n) dp solution with explanations longest substring without repeating characters given a string  find the length of the longest substring without repeating characters  medium hash table two pointers string 
share my o(log(min(m n)) solution with explanation median of two sorted arrays there are two sorted arrays nums1 and nums2 of size m and n respectively  find the median of the two sorted arrays  the overall run time complexity should be o(log (m+n))  you may assume nums1 and nums2 cannot be both empty  hard array binary search divide and conquer 
very concise o(log(min(m n))) iterative solution with detailed explanation median of two sorted arrays there are two sorted arrays nums1 and nums2 of size m and n respectively  find the median of the two sorted arrays  the overall run time complexity should be o(log (m+n))  you may assume nums1 and nums2 cannot be both empty  hard array binary search divide and conquer 
share my simple o(log(m+n)) solution for your reference median of two sorted arrays there are two sorted arrays nums1 and nums2 of size m and n respectively  find the median of the two sorted arrays  the overall run time complexity should be o(log (m+n))  you may assume nums1 and nums2 cannot be both empty  hard array binary search divide and conquer 
concise java solution based on binary search median of two sorted arrays there are two sorted arrays nums1 and nums2 of size m and n respectively  find the median of the two sorted arrays  the overall run time complexity should be o(log (m+n))  you may assume nums1 and nums2 cannot be both empty  hard array binary search divide and conquer 
share my iterative solution with o(log(min(n  m))) median of two sorted arrays there are two sorted arrays nums1 and nums2 of size m and n respectively  find the median of the two sorted arrays  the overall run time complexity should be o(log (m+n))  you may assume nums1 and nums2 cannot be both empty  hard array binary search divide and conquer 
very simple clean java solution longest palindromic substring given a string s  find the longest palindromic substring in s  you may assume that the maximum length of s is 1000  medium string dynamic programming 
simple c++ solution (8ms  13 lines) longest palindromic substring given a string s  find the longest palindromic substring in s  you may assume that the maximum length of s is 1000  medium string dynamic programming 
share my java solution using dynamic programming longest palindromic substring given a string s  find the longest palindromic substring in s  you may assume that the maximum length of s is 1000  medium string dynamic programming 
(ac) relatively short and very clear java solution longest palindromic substring given a string s  find the longest palindromic substring in s  you may assume that the maximum length of s is 1000  medium string dynamic programming 
python easy to understand solution with comments (from middle to two ends)  longest palindromic substring given a string s  find the longest palindromic substring in s  you may assume that the maximum length of s is 1000  medium string dynamic programming 
easy to understand java solution zigzag conversion the string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) p a h n a p l s i i g y i r and then read line by line: "pahnaplsiigyir" write the code that will take a string and make this conversion given a number of rows: string convert(string s  int numrows); medium string 
if you are confused with zigzag pattern come and see! zigzag conversion the string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) p a h n a p l s i i g y i r and then read line by line: "pahnaplsiigyir" write the code that will take a string and make this conversion given a number of rows: string convert(string s  int numrows); medium string 
python o(n) solution in 96ms (99 43%) zigzag conversion the string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) p a h n a p l s i i g y i r and then read line by line: "pahnaplsiigyir" write the code that will take a string and make this conversion given a number of rows: string convert(string s  int numrows); medium string 
share simple c++ solution zigzag conversion the string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) p a h n a p l s i i g y i r and then read line by line: "pahnaplsiigyir" write the code that will take a string and make this conversion given a number of rows: string convert(string s  int numrows); medium string 
java solution--easy and clear ( interesting approach ) zigzag conversion the string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) p a h n a p l s i i g y i r and then read line by line: "pahnaplsiigyir" write the code that will take a string and make this conversion given a number of rows: string convert(string s  int numrows); medium string 
my accepted 15 lines of code for java reverse integer given a 32-bit signed integer  reverse digits of an integer  easy math 
very short (7 lines) and elegant solution reverse integer given a 32-bit signed integer  reverse digits of an integer  easy math 
golfing in python reverse integer given a 32-bit signed integer  reverse digits of an integer  easy math 
shortest code possible in c++ reverse integer given a 32-bit signed integer  reverse digits of an integer  easy math 
8 ms simple c++ solution which checks overflow reverse integer given a 32-bit signed integer  reverse digits of an integer  easy math 
such a shitty problem string to integer (atoi) implement atoi which converts a string to an integer  the function first discards as many whitespace characters as necessary until the first non-whitespace character is found  then  starting from this character  takes an optional initial plus or minus sign followed by as many numerical digits as possible  and interprets them as a numerical value  the string can contain additional characters after those that form the integral number  which are ignored and have no effect on the behavior of this function  if the first sequence of non-whitespace characters in str is not a valid integral number  or if no such sequence exists because either str is empty or it contains only whitespace characters  no conversion is performed  if no valid conversion could be performed  a zero value is returned  note: only the space character ' ' is considered as whitespace character  assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231  231 − 1]  if the numerical value is out of the range of representable values  int_max (231 − 1) or int_min (−231) is returned  medium math string 
my simple solution string to integer (atoi) implement atoi which converts a string to an integer  the function first discards as many whitespace characters as necessary until the first non-whitespace character is found  then  starting from this character  takes an optional initial plus or minus sign followed by as many numerical digits as possible  and interprets them as a numerical value  the string can contain additional characters after those that form the integral number  which are ignored and have no effect on the behavior of this function  if the first sequence of non-whitespace characters in str is not a valid integral number  or if no such sequence exists because either str is empty or it contains only whitespace characters  no conversion is performed  if no valid conversion could be performed  a zero value is returned  note: only the space character ' ' is considered as whitespace character  assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231  231 − 1]  if the numerical value is out of the range of representable values  int_max (231 − 1) or int_min (−231) is returned  medium math string 
java solution with 4 steps explanations string to integer (atoi) implement atoi which converts a string to an integer  the function first discards as many whitespace characters as necessary until the first non-whitespace character is found  then  starting from this character  takes an optional initial plus or minus sign followed by as many numerical digits as possible  and interprets them as a numerical value  the string can contain additional characters after those that form the integral number  which are ignored and have no effect on the behavior of this function  if the first sequence of non-whitespace characters in str is not a valid integral number  or if no such sequence exists because either str is empty or it contains only whitespace characters  no conversion is performed  if no valid conversion could be performed  a zero value is returned  note: only the space character ' ' is considered as whitespace character  assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231  231 − 1]  if the numerical value is out of the range of representable values  int_max (231 − 1) or int_min (−231) is returned  medium math string 
java-------easy  version to understand!!!!!!!!!! string to integer (atoi) implement atoi which converts a string to an integer  the function first discards as many whitespace characters as necessary until the first non-whitespace character is found  then  starting from this character  takes an optional initial plus or minus sign followed by as many numerical digits as possible  and interprets them as a numerical value  the string can contain additional characters after those that form the integral number  which are ignored and have no effect on the behavior of this function  if the first sequence of non-whitespace characters in str is not a valid integral number  or if no such sequence exists because either str is empty or it contains only whitespace characters  no conversion is performed  if no valid conversion could be performed  a zero value is returned  note: only the space character ' ' is considered as whitespace character  assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231  231 − 1]  if the numerical value is out of the range of representable values  int_max (231 − 1) or int_min (−231) is returned  medium math string 
8ms c++ solution  easy to understand string to integer (atoi) implement atoi which converts a string to an integer  the function first discards as many whitespace characters as necessary until the first non-whitespace character is found  then  starting from this character  takes an optional initial plus or minus sign followed by as many numerical digits as possible  and interprets them as a numerical value  the string can contain additional characters after those that form the integral number  which are ignored and have no effect on the behavior of this function  if the first sequence of non-whitespace characters in str is not a valid integral number  or if no such sequence exists because either str is empty or it contains only whitespace characters  no conversion is performed  if no valid conversion could be performed  a zero value is returned  note: only the space character ' ' is considered as whitespace character  assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231  231 − 1]  if the numerical value is out of the range of representable values  int_max (231 − 1) or int_min (−231) is returned  medium math string 
easy dp java solution with detailed explanation regular expression matching given an input string (s) and a pattern (p)  implement regular expression matching with support for ' ' and ' '  ' ' matches any single character  ' ' matches zero or more of the preceding element  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like   or    hard string dynamic programming backtracking 
my concise recursive and dp solutions with full explanation in c++ regular expression matching given an input string (s) and a pattern (p)  implement regular expression matching with support for ' ' and ' '  ' ' matches any single character  ' ' matches zero or more of the preceding element  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like   or    hard string dynamic programming backtracking 
in the given examples  the last one ismatch("aab"  "c a b")  u2192 true; don't understand why it is true? regular expression matching given an input string (s) and a pattern (p)  implement regular expression matching with support for ' ' and ' '  ' ' matches any single character  ' ' matches zero or more of the preceding element  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like   or    hard string dynamic programming backtracking 
9-lines 16ms c++ dp solutions with explanations regular expression matching given an input string (s) and a pattern (p)  implement regular expression matching with support for ' ' and ' '  ' ' matches any single character  ' ' matches zero or more of the preceding element  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like   or    hard string dynamic programming backtracking 
my dp approach in python with comments and unittest regular expression matching given an input string (s) and a pattern (p)  implement regular expression matching with support for ' ' and ' '  ' ' matches any single character  ' ' matches zero or more of the preceding element  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like   or    hard string dynamic programming backtracking 
yet another way to see what happens in the o(n) algorithm container with most water given n non-negative integers a1  a2       an   where each represents a point at coordinate (i  ai)  n vertical lines are drawn such that the two endpoints of line i is at (i  ai) and (i  0)  find two lines  which together with x-axis forms a container  such that the container contains the most water  note: you may not slant the container and n is at least 2  the above vertical lines are represented by array [1 8 6 2 5 4 8 3 7]  in this case  the max area of water (blue section) the container can contain is 49  medium array two pointers 
simple and fast c++ c with explanation container with most water given n non-negative integers a1  a2       an   where each represents a point at coordinate (i  ai)  n vertical lines are drawn such that the two endpoints of line i is at (i  ai) and (i  0)  find two lines  which together with x-axis forms a container  such that the container contains the most water  note: you may not slant the container and n is at least 2  the above vertical lines are represented by array [1 8 6 2 5 4 8 3 7]  in this case  the max area of water (blue section) the container can contain is 49  medium array two pointers 
simple and clear proof explanation container with most water given n non-negative integers a1  a2       an   where each represents a point at coordinate (i  ai)  n vertical lines are drawn such that the two endpoints of line i is at (i  ai) and (i  0)  find two lines  which together with x-axis forms a container  such that the container contains the most water  note: you may not slant the container and n is at least 2  the above vertical lines are represented by array [1 8 6 2 5 4 8 3 7]  in this case  the max area of water (blue section) the container can contain is 49  medium array two pointers 
easy concise java o(n) solution with proof and explanation container with most water given n non-negative integers a1  a2       an   where each represents a point at coordinate (i  ai)  n vertical lines are drawn such that the two endpoints of line i is at (i  ai) and (i  0)  find two lines  which together with x-axis forms a container  such that the container contains the most water  note: you may not slant the container and n is at least 2  the above vertical lines are represented by array [1 8 6 2 5 4 8 3 7]  in this case  the max area of water (blue section) the container can contain is 49  medium array two pointers 
very simple o(n) solution container with most water given n non-negative integers a1  a2       an   where each represents a point at coordinate (i  ai)  n vertical lines are drawn such that the two endpoints of line i is at (i  ai) and (i  0)  find two lines  which together with x-axis forms a container  such that the container contains the most water  note: you may not slant the container and n is at least 2  the above vertical lines are represented by array [1 8 6 2 5 4 8 3 7]  in this case  the max area of water (blue section) the container can contain is 49  medium array two pointers 
simple solution integer to roman roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for medium math string 
my java solution easy to understand integer to roman roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for medium math string 
two lines can do the job integer to roman roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for medium math string 
share my python solution 96ms integer to roman roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for medium math string 
simple java solution integer to roman roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for medium math string 
my solution for this question but i don't know is there any easier way? roman to integer roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for easy math string 
clean o(n) c++ solution roman to integer roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for easy math string 
my straightforward python solution roman to integer roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for easy math string 
i strongly suggest leetcode explains the conversion rule clearer  roman to integer roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for easy math string 
7ms solution in java  easy to understand roman to integer roman numerals are represented by seven different symbols: i  v  x  l  c  d and m  symbol value i 1 v 5 x 10 l 50 c 100 d 500 m 1000 for easy math string 
java code with 13 lines longest common prefix write a function to find the longest common prefix string amongst an array of strings  if there is no common prefix  return an empty string ""  easy string 
what does longest common prefix mean ? longest common prefix write a function to find the longest common prefix string amongst an array of strings  if there is no common prefix  return an empty string ""  easy string 
sorted the array  java solution  2 ms longest common prefix write a function to find the longest common prefix string amongst an array of strings  if there is no common prefix  return an empty string ""  easy string 
simple python solution longest common prefix write a function to find the longest common prefix string amongst an array of strings  if there is no common prefix  return an empty string ""  easy string 
short python solution longest common prefix write a function to find the longest common prefix string amongst an array of strings  if there is no common prefix  return an empty string ""  easy string 
concise o(n^2) java solution 3sum given an array nums of n integers  are there elements a  b  c in nums such that a + b + c = 0? find all unique triplets in the array which gives the sum of zero  note: the solution set must not contain duplicate triplets  medium array two pointers 
share my ac c++ solution  around 50ms  o(n n)  with explanation and comments 3sum given an array nums of n integers  are there elements a  b  c in nums such that a + b + c = 0? find all unique triplets in the array which gives the sum of zero  note: the solution set must not contain duplicate triplets  medium array two pointers 
python easy to understand solution (o(n n) time)  3sum given an array nums of n integers  are there elements a  b  c in nums such that a + b + c = 0? find all unique triplets in the array which gives the sum of zero  note: the solution set must not contain duplicate triplets  medium array two pointers 
easiest java solution 3sum given an array nums of n integers  are there elements a  b  c in nums such that a + b + c = 0? find all unique triplets in the array which gives the sum of zero  note: the solution set must not contain duplicate triplets  medium array two pointers 
share my simple java solution 3sum given an array nums of n integers  are there elements a  b  c in nums such that a + b + c = 0? find all unique triplets in the array which gives the sum of zero  note: the solution set must not contain duplicate triplets  medium array two pointers 
java solution with o(n2) for reference 3sum closest given an array nums of n integers and an integer target  find three integers in nums such that the sum is closest to target  return the sum of the three integers  you may assume that each input would have exactly one solution  medium array two pointers 
a n^2 solution  can we do better ? 3sum closest given an array nums of n integers and an integer target  find three integers in nums such that the sum is closest to target  return the sum of the three integers  you may assume that each input would have exactly one solution  medium array two pointers 
c++ solution o(n^2) using sort 3sum closest given an array nums of n integers and an integer target  find three integers in nums such that the sum is closest to target  return the sum of the three integers  you may assume that each input would have exactly one solution  medium array two pointers 
python o(n^2) solution 3sum closest given an array nums of n integers and an integer target  find three integers in nums such that the sum is closest to target  return the sum of the three integers  you may assume that each input would have exactly one solution  medium array two pointers 
12 lines concise and easy understand c++ solultion 3sum closest given an array nums of n integers and an integer target  find three integers in nums such that the sum is closest to target  return the sum of the three integers  you may assume that each input would have exactly one solution  medium array two pointers 
7ms java code win over 100% 4sum given an array nums of n integers and an integer target  are there elements a  b  c  and d in nums such that a + b + c + d = target? find all unique quadruplets in the array which gives the sum of target  note: the solution set must not contain duplicate quadruplets  medium array hash table two pointers 
python 140ms beats 100%  and works for n-sum (n>=2) 4sum given an array nums of n integers and an integer target  are there elements a  b  c  and d in nums such that a + b + c + d = target? find all unique quadruplets in the array which gives the sum of target  note: the solution set must not contain duplicate quadruplets  medium array hash table two pointers 
my 16ms c++ code 4sum given an array nums of n integers and an integer target  are there elements a  b  c  and d in nums such that a + b + c + d = target? find all unique quadruplets in the array which gives the sum of target  note: the solution set must not contain duplicate quadruplets  medium array hash table two pointers 
clean accepted java o(n^3) solution based on 3sum 4sum given an array nums of n integers and an integer target  are there elements a  b  c  and d in nums such that a + b + c + d = target? find all unique quadruplets in the array which gives the sum of target  note: the solution set must not contain duplicate quadruplets  medium array hash table two pointers 
my solution generalized for ksums in java 4sum given an array nums of n integers and an integer target  are there elements a  b  c  and d in nums such that a + b + c + d = target? find all unique quadruplets in the array which gives the sum of target  note: the solution set must not contain duplicate quadruplets  medium array hash table two pointers 
simple java solution in one pass remove nth node from end of list given a linked list  remove the n-th node from the end of list and return its head  medium linked list two pointers 
my short c++ solution remove nth node from end of list given a linked list  remove the n-th node from the end of list and return its head  medium linked list two pointers 
3 short python solutions remove nth node from end of list given a linked list  remove the n-th node from the end of list and return its head  medium linked list two pointers 
my one pass solution remove nth node from end of list given a linked list  remove the n-th node from the end of list and return its head  medium linked list two pointers 
c++ solution  easy to understand with explanations  remove nth node from end of list given a linked list  remove the n-th node from the end of list and return its head  medium linked list two pointers 
short java solution valid parentheses given a string containing just the characters '('  ')'  '{'  '}'  '[' and ']'  determine if the input string is valid  an input string is valid if: open brackets must be closed by the same type of brackets  open brackets must be closed in the correct order  note that an empty string is also considered valid  easy string stack 
simple python solution with stack valid parentheses given a string containing just the characters '('  ')'  '{'  '}'  '[' and ']'  determine if the input string is valid  an input string is valid if: open brackets must be closed by the same type of brackets  open brackets must be closed in the correct order  note that an empty string is also considered valid  easy string stack 
my easy to understand java solution with one stack valid parentheses given a string containing just the characters '('  ')'  '{'  '}'  '[' and ']'  determine if the input string is valid  an input string is valid if: open brackets must be closed by the same type of brackets  open brackets must be closed in the correct order  note that an empty string is also considered valid  easy string stack 
[python] is this a cheating method? accepted with 40ms  easy to understand  but valid parentheses given a string containing just the characters '('  ')'  '{'  '}'  '[' and ']'  determine if the input string is valid  an input string is valid if: open brackets must be closed by the same type of brackets  open brackets must be closed in the correct order  note that an empty string is also considered valid  easy string stack 
2ms c++ sloution valid parentheses given a string containing just the characters '('  ')'  '{'  '}'  '[' and ']'  determine if the input string is valid  an input string is valid if: open brackets must be closed by the same type of brackets  open brackets must be closed in the correct order  note that an empty string is also considered valid  easy string stack 
easy to understand java backtracking solution generate parentheses given n pairs of parentheses  write a function to generate all combinations of well-formed parentheses  for medium string backtracking 
concise recursive c++ solution generate parentheses given n pairs of parentheses  write a function to generate all combinations of well-formed parentheses  for medium string backtracking 
an iterative method  generate parentheses given n pairs of parentheses  write a function to generate all combinations of well-formed parentheses  for medium string backtracking 
4-7 lines python generate parentheses given n pairs of parentheses  write a function to generate all combinations of well-formed parentheses  for medium string backtracking 
simple python dfs solution with explanation generate parentheses given n pairs of parentheses  write a function to generate all combinations of well-formed parentheses  for medium string backtracking 
a java solution based on priority queue merge k sorted lists merge k sorted linked lists and return it as one sorted list  analyze and describe its complexity  hard linked list divide and conquer heap 
my simple java solution use recursion merge k sorted lists merge k sorted linked lists and return it as one sorted list  analyze and describe its complexity  hard linked list divide and conquer heap 
sharing my straightforward c++ solution without data structure other than vector merge k sorted lists merge k sorted linked lists and return it as one sorted list  analyze and describe its complexity  hard linked list divide and conquer heap 
difference between priority-queue and heap  and c++ implementation merge k sorted lists merge k sorted linked lists and return it as one sorted list  analyze and describe its complexity  hard linked list divide and conquer heap 
10-line python solution with priority queue merge k sorted lists merge k sorted linked lists and return it as one sorted list  analyze and describe its complexity  hard linked list divide and conquer heap 
my accepted java code  used recursion  swap nodes in pairs given a linked list  swap every two adjacent nodes and return its head  medium linked list 
my simple java solution for share swap nodes in pairs given a linked list  swap every two adjacent nodes and return its head  medium linked list 
7-8 lines c++   python   ruby swap nodes in pairs given a linked list  swap every two adjacent nodes and return its head  medium linked list 
java simple recursive solution swap nodes in pairs given a linked list  swap every two adjacent nodes and return its head  medium linked list 
simple implementation with c++ swap nodes in pairs given a linked list  swap every two adjacent nodes and return its head  medium linked list 
short but recursive java code with comments reverse nodes in k-group given a linked list  reverse the nodes of a linked list k at a time and return its modified list  k is a positive integer and is less than or equal to the length of the linked list  if the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is  hard linked list 
share my java solution with comments in line reverse nodes in k-group given a linked list  reverse the nodes of a linked list k at a time and return its modified list  k is a positive integer and is less than or equal to the length of the linked list  if the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is  hard linked list 
non-recursive java solution and idea reverse nodes in k-group given a linked list  reverse the nodes of a linked list k at a time and return its modified list  k is a positive integer and is less than or equal to the length of the linked list  if the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is  hard linked list 
20-line iterative c++ solution reverse nodes in k-group given a linked list  reverse the nodes of a linked list k at a time and return its modified list  k is a positive integer and is less than or equal to the length of the linked list  if the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is  hard linked list 
succinct iterative python  o(n) time o(1) space reverse nodes in k-group given a linked list  reverse the nodes of a linked list k at a time and return its modified list  k is a positive integer and is less than or equal to the length of the linked list  if the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is  hard linked list 
my solution : time o(n)  space o(1) remove duplicates from sorted array given a sorted array nums  remove the duplicates in-place such that each element appear only once and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  easy array two pointers 
share my clean c++ code remove duplicates from sorted array given a sorted array nums  remove the duplicates in-place such that each element appear only once and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  easy array two pointers 
5 lines c++ java  nicer loops remove duplicates from sorted array given a sorted array nums  remove the duplicates in-place such that each element appear only once and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  easy array two pointers 
simple python solution - o(n) remove duplicates from sorted array given a sorted array nums  remove the duplicates in-place such that each element appear only once and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  easy array two pointers 
5 lines java solution remove duplicates from sorted array given a sorted array nums  remove the duplicates in-place such that each element appear only once and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  easy array two pointers 
elegant java solution implement strstr() implement strstr()  return the index of the first occurrence of needle in haystack  or -1 if needle is not part of haystack  easy two pointers string 
share my accepted java solution implement strstr() implement strstr()  return the index of the first occurrence of needle in haystack  or -1 if needle is not part of haystack  easy two pointers string 
c++ brute-force and kmp implement strstr() implement strstr()  return the index of the first occurrence of needle in haystack  or -1 if needle is not part of haystack  easy two pointers string 
my answer by python implement strstr() implement strstr()  return the index of the first occurrence of needle in haystack  or -1 if needle is not part of haystack  easy two pointers string 
a very clean solution  brute-force implement strstr() implement strstr()  return the index of the first occurrence of needle in haystack  or -1 if needle is not part of haystack  easy two pointers string 
detailed explained 8ms c++ solution divide two integers given two integers dividend and divisor  divide two integers without using multiplication  division and mod operator  return the quotient after dividing dividend by divisor  the integer division should truncate toward zero  medium math binary search 
clean java solution with some comment  divide two integers given two integers dividend and divisor  divide two integers without using multiplication  division and mod operator  return the quotient after dividing dividend by divisor  the integer division should truncate toward zero  medium math binary search 
clear python code divide two integers given two integers dividend and divisor  divide two integers without using multiplication  division and mod operator  return the quotient after dividing dividend by divisor  the integer division should truncate toward zero  medium math binary search 
simple o((log n) ^ 2) c++ solution divide two integers given two integers dividend and divisor  divide two integers without using multiplication  division and mod operator  return the quotient after dividing dividend by divisor  the integer division should truncate toward zero  medium math binary search 
no use of long java solution divide two integers given two integers dividend and divisor  divide two integers without using multiplication  division and mod operator  return the quotient after dividing dividend by divisor  the integer division should truncate toward zero  medium math binary search 
easy two-map solution (c++ java) substring with concatenation of all words you are given a string  s  and a list of words  words  that are all of the same length  find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters  hard hash table two pointers string 
an o(n) solution with detailed explanation substring with concatenation of all words you are given a string  s  and a list of words  words  that are all of the same length  find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters  hard hash table two pointers string 
accepted java solution 12ms with explanation substring with concatenation of all words you are given a string  s  and a list of words  words  that are all of the same length  find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters  hard hash table two pointers string 
simple java solution with two pointers and map substring with concatenation of all words you are given a string  s  and a list of words  words  that are all of the same length  find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters  hard hash table two pointers string 
why does the second example have words with different length? substring with concatenation of all words you are given a string  s  and a list of words  words  that are all of the same length  find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters  hard hash table two pointers string 
share my o(n) time solution next permutation implement next permutation  which rearranges numbers into the lexicographically next greater permutation of numbers  if such arrangement is not possible  it must rearrange it as the lowest possible order (ie  sorted in ascending order)  the replacement must be in-place and use only constant extra memory  here are some medium array 
c++ from wikipedia next permutation implement next permutation  which rearranges numbers into the lexicographically next greater permutation of numbers  if such arrangement is not possible  it must rearrange it as the lowest possible order (ie  sorted in ascending order)  the replacement must be in-place and use only constant extra memory  here are some medium array 
sharing my clean and easy-understand java code with explanation next permutation implement next permutation  which rearranges numbers into the lexicographically next greater permutation of numbers  if such arrangement is not possible  it must rearrange it as the lowest possible order (ie  sorted in ascending order)  the replacement must be in-place and use only constant extra memory  here are some medium array 
easiest java solution next permutation implement next permutation  which rearranges numbers into the lexicographically next greater permutation of numbers  if such arrangement is not possible  it must rearrange it as the lowest possible order (ie  sorted in ascending order)  the replacement must be in-place and use only constant extra memory  here are some medium array 
1  4  11 lines c++ next permutation implement next permutation  which rearranges numbers into the lexicographically next greater permutation of numbers  if such arrangement is not possible  it must rearrange it as the lowest possible order (ie  sorted in ascending order)  the replacement must be in-place and use only constant extra memory  here are some medium array 
my o(n) solution using a stack longest valid parentheses given a string containing just the characters '(' and ')'  find the length of the longest valid (well-formed) parentheses substring  hard string dynamic programming 
my dp  o(n) solution without using stack longest valid parentheses given a string containing just the characters '(' and ')'  find the length of the longest valid (well-formed) parentheses substring  hard string dynamic programming 
simple java solution  o(n) time  one stack longest valid parentheses given a string containing just the characters '(' and ')'  find the length of the longest valid (well-formed) parentheses substring  hard string dynamic programming 
my simple 8ms c++ code longest valid parentheses given a string containing just the characters '(' and ')'  find the length of the longest valid (well-formed) parentheses substring  hard string dynamic programming 
my solution using one stack in one pass longest valid parentheses given a string containing just the characters '(' and ')'  find the length of the longest valid (well-formed) parentheses substring  hard string dynamic programming 
concise o(log n) binary search solution search in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  you are given a target value to search  if found in the array return its index  otherwise return -1  you may assume no duplicate exists in the array  your algorithm's runtime complexity must be in the order of o(log n)  medium array binary search 
clever idea making it simple search in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  you are given a target value to search  if found in the array return its index  otherwise return -1  you may assume no duplicate exists in the array  your algorithm's runtime complexity must be in the order of o(log n)  medium array binary search 
revised binary search search in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  you are given a target value to search  if found in the array return its index  otherwise return -1  you may assume no duplicate exists in the array  your algorithm's runtime complexity must be in the order of o(log n)  medium array binary search 
java ac solution using once binary search search in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  you are given a target value to search  if found in the array return its index  otherwise return -1  you may assume no duplicate exists in the array  your algorithm's runtime complexity must be in the order of o(log n)  medium array binary search 
python binary search solution - o(logn) - 48ms search in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  you are given a target value to search  if found in the array return its index  otherwise return -1  you may assume no duplicate exists in the array  your algorithm's runtime complexity must be in the order of o(log n)  medium array binary search 
clean iterative solution with two binary searches (with explanation) find first and last position of element in sorted array given an array of integers nums sorted in ascending order  find the starting and ending position of a given target value  your algorithm's runtime complexity must be in the order of o(log n)  if the target is not found in the array  return [-1  -1]  medium array binary search 
a very simple java solution  with only one binary search algorithm find first and last position of element in sorted array given an array of integers nums sorted in ascending order  find the starting and ending position of a given target value  your algorithm's runtime complexity must be in the order of o(log n)  if the target is not found in the array  return [-1  -1]  medium array binary search 
9-11 lines o(log n) find first and last position of element in sorted array given an array of integers nums sorted in ascending order  find the starting and ending position of a given target value  your algorithm's runtime complexity must be in the order of o(log n)  if the target is not found in the array  return [-1  -1]  medium array binary search 
easy java o(logn) solution find first and last position of element in sorted array given an array of integers nums sorted in ascending order  find the starting and ending position of a given target value  your algorithm's runtime complexity must be in the order of o(log n)  if the target is not found in the array  return [-1  -1]  medium array binary search 
simple and strict o(logn) solution in java using recursion find first and last position of element in sorted array given an array of integers nums sorted in ascending order  find the starting and ending position of a given target value  your algorithm's runtime complexity must be in the order of o(log n)  if the target is not found in the array  return [-1  -1]  medium array binary search 
short+simple java using strings valid sudoku determine if a 9x9 sudoku board is valid  only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition  each column must contain the digits 1-9 without repetition  each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition  a partially filled sudoku which is valid  the sudoku board could be partially filled  where empty cells are filled with the character ' '  medium hash table 
shared my concise java code valid sudoku determine if a 9x9 sudoku board is valid  only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition  each column must contain the digits 1-9 without repetition  each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition  a partially filled sudoku which is valid  the sudoku board could be partially filled  where empty cells are filled with the character ' '  medium hash table 
my short solution by c++  o(n2) valid sudoku determine if a 9x9 sudoku board is valid  only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition  each column must contain the digits 1-9 without repetition  each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition  a partially filled sudoku which is valid  the sudoku board could be partially filled  where empty cells are filled with the character ' '  medium hash table 
sharing my easy-understand java solution using set valid sudoku determine if a 9x9 sudoku board is valid  only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition  each column must contain the digits 1-9 without repetition  each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition  a partially filled sudoku which is valid  the sudoku board could be partially filled  where empty cells are filled with the character ' '  medium hash table 
a readable python solution valid sudoku determine if a 9x9 sudoku board is valid  only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition  each column must contain the digits 1-9 without repetition  each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition  a partially filled sudoku which is valid  the sudoku board could be partially filled  where empty cells are filled with the character ' '  medium hash table 
please change the misleading description count and say the count-and-say sequence is the sequence of integers with the first five terms as following: 1  1 2  11 3  21 4  1211 5  111221 1 is read off as "one 1" or 11  11 is read off as "two 1s" or 21  21 is read off as "one 2  then one 1" or 1211  given an integer n where 1 ≤ n ≤ 30  generate the nth term of the count-and-say sequence  note: each term of the sequence of integers will be represented as a string  easy string 
examples of nth sequence count and say the count-and-say sequence is the sequence of integers with the first five terms as following: 1  1 2  11 3  21 4  1211 5  111221 1 is read off as "one 1" or 11  11 is read off as "two 1s" or 21  21 is read off as "one 2  then one 1" or 1211  given an integer n where 1 ≤ n ≤ 30  generate the nth term of the count-and-say sequence  note: each term of the sequence of integers will be represented as a string  easy string 
show an answer in java count and say the count-and-say sequence is the sequence of integers with the first five terms as following: 1  1 2  11 3  21 4  1211 5  111221 1 is read off as "one 1" or 11  11 is read off as "two 1s" or 21  21 is read off as "one 2  then one 1" or 1211  given an integer n where 1 ≤ n ≤ 30  generate the nth term of the count-and-say sequence  note: each term of the sequence of integers will be represented as a string  easy string 
4-5 lines python solutions count and say the count-and-say sequence is the sequence of integers with the first five terms as following: 1  1 2  11 3  21 4  1211 5  111221 1 is read off as "one 1" or 11  11 is read off as "two 1s" or 21  21 is read off as "one 2  then one 1" or 1211  given an integer n where 1 ≤ n ≤ 30  generate the nth term of the count-and-say sequence  note: each term of the sequence of integers will be represented as a string  easy string 
c++ solution easy-understand count and say the count-and-say sequence is the sequence of integers with the first five terms as following: 1  1 2  11 3  21 4  1211 5  111221 1 is read off as "one 1" or 11  11 is read off as "two 1s" or 21  21 is read off as "one 2  then one 1" or 1211  given an integer n where 1 ≤ n ≤ 30  generate the nth term of the count-and-say sequence  note: each term of the sequence of integers will be represented as a string  easy string 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partitioning) combination sum given a set of candidate numbers (candidates) (without duplicates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  the same repeated number may be chosen from candidates unlimited number of times  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
accepted 16ms c++ solution use backtracking  easy understand  combination sum given a set of candidate numbers (candidates) (without duplicates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  the same repeated number may be chosen from candidates unlimited number of times  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
python dfs solution  combination sum given a set of candidate numbers (candidates) (without duplicates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  the same repeated number may be chosen from candidates unlimited number of times  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
java solution using recursive combination sum given a set of candidate numbers (candidates) (without duplicates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  the same repeated number may be chosen from candidates unlimited number of times  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
iterative java dp solution combination sum given a set of candidate numbers (candidates) (without duplicates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  the same repeated number may be chosen from candidates unlimited number of times  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
java solution using dfs  easy understand combination sum ii given a collection of candidate numbers (candidates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  each number in candidates may only be used once in the combination  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
combination sum i  ii and iii java solution (see the similarities yourself) combination sum ii given a collection of candidate numbers (candidates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  each number in candidates may only be used once in the combination  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
c++ backtracking solution with detailed explanation combination sum ii given a collection of candidate numbers (candidates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  each number in candidates may only be used once in the combination  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
beating 98%  python solution using recursion with comments combination sum ii given a collection of candidate numbers (candidates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  each number in candidates may only be used once in the combination  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
dp solution in python combination sum ii given a collection of candidate numbers (candidates) and a target number (target)  find all unique combinations in candidates where the candidate numbers sums to target  each number in candidates may only be used once in the combination  note: all numbers (including target) will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
my short c++ solution  o(1) space  and o(n) time first missing positive given an unsorted integer array  find the smallest missing positive integer  hard array 
share my o(n) time  o(1) space solution first missing positive given an unsorted integer array  find the smallest missing positive integer  hard array 
o(1) space java solution first missing positive given an unsorted integer array  find the smallest missing positive integer  hard array 
python o(1) space   o(n) time solution with explanation first missing positive given an unsorted integer array  find the smallest missing positive integer  hard array 
a very nice solution (from ants aasma @stackoverflow) first missing positive given an unsorted integer array  find the smallest missing positive integer  hard array 
sharing my simple c++ code: o(n) time  o(1) space trapping rain water given n non-negative integers representing an elevation map where the width of each bar is 1  compute how much water it is able to trap after raining  the above elevation map is represented by array [0 1 0 2 1 0 1 3 2 1 2 1]  in this case  6 units of rain water (blue section) are being trapped  thanks marcos for contributing this image! hard array two pointers stack 
share my short solution  trapping rain water given n non-negative integers representing an elevation map where the width of each bar is 1  compute how much water it is able to trap after raining  the above elevation map is represented by array [0 1 0 2 1 0 1 3 2 1 2 1]  in this case  6 units of rain water (blue section) are being trapped  thanks marcos for contributing this image! hard array two pointers stack 
7 lines c   c++ trapping rain water given n non-negative integers representing an elevation map where the width of each bar is 1  compute how much water it is able to trap after raining  the above elevation map is represented by array [0 1 0 2 1 0 1 3 2 1 2 1]  in this case  6 units of rain water (blue section) are being trapped  thanks marcos for contributing this image! hard array two pointers stack 
a stack based solution for reference  inspired by histogram trapping rain water given n non-negative integers representing an elevation map where the width of each bar is 1  compute how much water it is able to trap after raining  the above elevation map is represented by array [0 1 0 2 1 0 1 3 2 1 2 1]  in this case  6 units of rain water (blue section) are being trapped  thanks marcos for contributing this image! hard array two pointers stack 
sharing my java code: o(n) time  o(1) space trapping rain water given n non-negative integers representing an elevation map where the width of each bar is 1  compute how much water it is able to trap after raining  the above elevation map is represented by array [0 1 0 2 1 0 1 3 2 1 2 1]  in this case  6 units of rain water (blue section) are being trapped  thanks marcos for contributing this image! hard array two pointers stack 
easiest java solution with graph explanation multiply strings given two non-negative integers num1 and num2 represented as strings  return the product of num1 and num2  also represented as a string  medium math string 
brief c++ solution using only strings and without reversal multiply strings given two non-negative integers num1 and num2 represented as strings  return the product of num1 and num2  also represented as a string  medium math string 
ac solution in java with explanation multiply strings given two non-negative integers num1 and num2 represented as strings  return the product of num1 and num2  also represented as a string  medium math string 
one easy solution with c++ multiply strings given two non-negative integers num1 and num2 represented as strings  return the product of num1 and num2  also represented as a string  medium math string 
clear java solution without reversal multiply strings given two non-negative integers num1 and num2 represented as strings  return the product of num1 and num2  also represented as a string  medium math string 
linear runtime and constant space solution wildcard matching given an input string (s) and a pattern (p)  implement wildcard pattern matching with support for '?' and ' '  '?' matches any single character  ' ' matches any sequence of characters (including the empty sequence)  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like ? or    hard string dynamic programming backtracking greedy 
my java dp solution using 2d table wildcard matching given an input string (s) and a pattern (p)  implement wildcard pattern matching with support for '?' and ' '  '?' matches any single character  ' ' matches any sequence of characters (including the empty sequence)  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like ? or    hard string dynamic programming backtracking greedy 
accepted c++ dp solution with a trick wildcard matching given an input string (s) and a pattern (p)  implement wildcard pattern matching with support for '?' and ' '  '?' matches any single character  ' ' matches any sequence of characters (including the empty sequence)  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like ? or    hard string dynamic programming backtracking greedy 
python dp solution wildcard matching given an input string (s) and a pattern (p)  implement wildcard pattern matching with support for '?' and ' '  '?' matches any single character  ' ' matches any sequence of characters (including the empty sequence)  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like ? or    hard string dynamic programming backtracking greedy 
my three c++ solutions (iterative (16ms) & dp (180ms) & modified recursion (88ms)) wildcard matching given an input string (s) and a pattern (p)  implement wildcard pattern matching with support for '?' and ' '  '?' matches any single character  ' ' matches any sequence of characters (including the empty sequence)  the matching should cover the entire input string (not partial)  note: s could be empty and contains only lowercase letters a-z  p could be empty and contains only lowercase letters a-z  and characters like ? or    hard string dynamic programming backtracking greedy 
o(n)  bfs solution jump game ii given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  your goal is to reach the last index in the minimum number of jumps  hard array greedy 
concise o(n) one loop java solution based on greedy jump game ii given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  your goal is to reach the last index in the minimum number of jumps  hard array greedy 
single loop simple java solution jump game ii given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  your goal is to reach the last index in the minimum number of jumps  hard array greedy 
10-lines c++ (16ms)   python bfs solutions with explanations jump game ii given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  your goal is to reach the last index in the minimum number of jumps  hard array greedy 
sharing my ac java solution jump game ii given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  your goal is to reach the last index in the minimum number of jumps  hard array greedy 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partioning) permutations given a collection of distinct integers  return all possible permutations  medium backtracking 
my elegant recursive c++ solution with inline explanation permutations given a collection of distinct integers  return all possible permutations  medium backtracking 
my ac simple iterative java python solution permutations given a collection of distinct integers  return all possible permutations  medium backtracking 
one-liners in python permutations given a collection of distinct integers  return all possible permutations  medium backtracking 
simple python solution (dfs)  permutations given a collection of distinct integers  return all possible permutations  medium backtracking 
really easy java solution  much easier than the solutions with very high vote permutations ii given a collection of numbers that might contain duplicates  return all possible unique permutations  medium backtracking 
a simple c++ solution in only 20 lines permutations ii given a collection of numbers that might contain duplicates  return all possible unique permutations  medium backtracking 
share my java code with detailed explanantion permutations ii given a collection of numbers that might contain duplicates  return all possible unique permutations  medium backtracking 
9-line python solution with 1 line to handle duplication  beat 99% of others :-) permutations ii given a collection of numbers that might contain duplicates  return all possible unique permutations  medium backtracking 
a non-recursive c++ implementation with o(1) space cost permutations ii given a collection of numbers that might contain duplicates  return all possible unique permutations  medium backtracking 
a common method to rotate the image rotate image you are given an n x n 2d matrix representing an image  rotate the image by 90 degrees (clockwise)  note: you have to rotate the image in-place  which means you have to modify the input 2d matrix directly  do not allocate another 2d matrix and do the rotation  medium array 
ac java in place solution with explanation easy to understand  rotate image you are given an n x n 2d matrix representing an image  rotate the image by 90 degrees (clockwise)  note: you have to rotate the image in-place  which means you have to modify the input 2d matrix directly  do not allocate another 2d matrix and do the rotation  medium array 
seven short solutions (1 to 7 lines) rotate image you are given an n x n 2d matrix representing an image  rotate the image by 90 degrees (clockwise)  note: you have to rotate the image in-place  which means you have to modify the input 2d matrix directly  do not allocate another 2d matrix and do the rotation  medium array 
4ms few lines c++ code rotate image 90 degree for o(1) space rotate image you are given an n x n 2d matrix representing an image  rotate the image by 90 degrees (clockwise)  note: you have to rotate the image in-place  which means you have to modify the input 2d matrix directly  do not allocate another 2d matrix and do the rotation  medium array 
clear java solution rotate image you are given an n x n 2d matrix representing an image  rotate the image by 90 degrees (clockwise)  note: you have to rotate the image in-place  which means you have to modify the input 2d matrix directly  do not allocate another 2d matrix and do the rotation  medium array 
share my short java solution group anagrams given an array of strings  group anagrams together  medium hash table string 
java beat 100%!!! use prime number group anagrams given an array of strings  group anagrams together  medium hash table string 
10-lines 76ms easy c++ solution (updated function signature) group anagrams given an array of strings  group anagrams together  medium hash table string 
what does it mean "return all groups"? but the return result is vector<string>? how can we return all groups? group anagrams given an array of strings  group anagrams together  medium hash table string 
o(m   n) algorithm using hash  without sort() group anagrams given an array of strings  group anagrams together  medium hash table string 
short and easy to understand solution pow(x  n) implement pow(x  n)  which calculates x raised to the power n (xn)  medium math binary search 
5 different choices when talk with interviewers pow(x  n) implement pow(x  n)  which calculates x raised to the power n (xn)  medium math binary search 
iterative log(n) solution with clear explanation pow(x  n) implement pow(x  n)  which calculates x raised to the power n (xn)  medium math binary search 
shortest python - guaranteed pow(x  n) implement pow(x  n)  which calculates x raised to the power n (xn)  medium math binary search 
o (logn) solution in java pow(x  n) implement pow(x  n)  which calculates x raised to the power n (xn)  medium math binary search 
accepted 4ms c++ solution use backtracking and bitmask  easy understand  n-queens the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return all distinct solutions to the n-queens puzzle  each solution contains a distinct board configuration of the n-queens' placement  where 'q' and ' ' both indicate a queen and an empty space respectively  hard backtracking 
my easy understanding java solution n-queens the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return all distinct solutions to the n-queens puzzle  each solution contains a distinct board configuration of the n-queens' placement  where 'q' and ' ' both indicate a queen and an empty space respectively  hard backtracking 
fast  short  and easy-to-understand python solution  11 lines  76ms n-queens the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return all distinct solutions to the n-queens puzzle  each solution contains a distinct board configuration of the n-queens' placement  where 'q' and ' ' both indicate a queen and an empty space respectively  hard backtracking 
the description should give a clear explanation of the problem of "n-queens" n-queens the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return all distinct solutions to the n-queens puzzle  each solution contains a distinct board configuration of the n-queens' placement  where 'q' and ' ' both indicate a queen and an empty space respectively  hard backtracking 
comparably concise java code n-queens the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return all distinct solutions to the n-queens puzzle  each solution contains a distinct board configuration of the n-queens' placement  where 'q' and ' ' both indicate a queen and an empty space respectively  hard backtracking 
accepted java solution n-queens ii the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return the number of distinct solutions to the n-queens puzzle  hard backtracking 
easiest java solution (1ms  98 22%) n-queens ii the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return the number of distinct solutions to the n-queens puzzle  hard backtracking 
share my java code (beats 97 83% run times) n-queens ii the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return the number of distinct solutions to the n-queens puzzle  hard backtracking 
c++ solution - dfs - easy understanding n-queens ii the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return the number of distinct solutions to the n-queens puzzle  hard backtracking 
python recursive dfs solution  n-queens ii the n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  given an integer n  return the number of distinct solutions to the n-queens puzzle  hard backtracking 
dp solution & some thoughts maximum subarray given an integer array nums  find the contiguous subarray (containing at least one number) which has the largest sum and return its sum  easy array divide and conquer dynamic programming 
accepted o(n) solution in java maximum subarray given an integer array nums  find the contiguous subarray (containing at least one number) which has the largest sum and return its sum  easy array divide and conquer dynamic programming 
a python solution maximum subarray given an integer array nums  find the contiguous subarray (containing at least one number) which has the largest sum and return its sum  easy array divide and conquer dynamic programming 
easy python way maximum subarray given an integer array nums  find the contiguous subarray (containing at least one number) which has the largest sum and return its sum  easy array divide and conquer dynamic programming 
simplest and fastest o(n) c++ solution maximum subarray given an integer array nums  find the contiguous subarray (containing at least one number) which has the largest sum and return its sum  easy array divide and conquer dynamic programming 
super simple and easy to understand solution spiral matrix given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in spiral order  medium array 
1-liner in python + ruby spiral matrix given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in spiral order  medium array 
a concise c++ implementation based on directions spiral matrix given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in spiral order  medium array 
0ms clear c++ solution spiral matrix given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in spiral order  medium array 
clean java  readable  human friendly code spiral matrix given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in spiral order  medium array 
linear and simple solution in c++ jump game given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  determine if you are able to reach the last index  medium array greedy 
simplest o(n) solution with constant space jump game given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  determine if you are able to reach the last index  medium array greedy 
java solution easy to understand jump game given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  determine if you are able to reach the last index  medium array greedy 
6 line java solution in o(n) jump game given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  determine if you are able to reach the last index  medium array greedy 
1-6 lines  o(n) time  o(1) space jump game given an array of non-negative integers  you are initially positioned at the first index of the array  each element in the array represents your maximum jump length at that position  determine if you are able to reach the last index  medium array greedy 
a simple java solution merge intervals given a collection of intervals  merge all overlapping intervals  medium array sort 
7 lines  easy  python merge intervals given a collection of intervals  merge all overlapping intervals  medium array sort 
c++ 10 line solution  easing understanding merge intervals given a collection of intervals  merge all overlapping intervals  medium array sort 
beat 98% java  sort start & end respectively  merge intervals given a collection of intervals  merge all overlapping intervals  medium array sort 
a clean java solution merge intervals given a collection of intervals  merge all overlapping intervals  medium array sort 
short and straight-forward java solution insert interval given a set of non-overlapping intervals  insert a new interval into the intervals (merge if necessary)  you may assume that the intervals were initially sorted according to their start times  hard array sort 
7+ lines  3 easy solutions insert interval given a set of non-overlapping intervals  insert a new interval into the intervals (merge if necessary)  you may assume that the intervals were initially sorted according to their start times  hard array sort 
short java code insert interval given a set of non-overlapping intervals  insert a new interval into the intervals (merge if necessary)  you may assume that the intervals were initially sorted according to their start times  hard array sort 
elegant c++ stl solution  using "equal_range" to find overlapped intervals  insert interval given a set of non-overlapping intervals  insert a new interval into the intervals (merge if necessary)  you may assume that the intervals were initially sorted according to their start times  hard array sort 
easy and clean o(n) c++ solution insert interval given a set of non-overlapping intervals  insert a new interval into the intervals (merge if necessary)  you may assume that the intervals were initially sorted according to their start times  hard array sort 
7-lines 4ms c++ solution length of last word given a string s consists of upper lower-case alphabets and empty space characters ' '  return the length of last word in the string  if the last word does not exist  return 0  note: a word is defined as a character sequence consists of non-space characters only  easy string 
my simple solution in c++ length of last word given a string s consists of upper lower-case alphabets and empty space characters ' '  return the length of last word in the string  if the last word does not exist  return 0  note: a word is defined as a character sequence consists of non-space characters only  easy string 
a single line of code in java length of last word given a string s consists of upper lower-case alphabets and empty space characters ' '  return the length of last word in the string  if the last word does not exist  return 0  note: a word is defined as a character sequence consists of non-space characters only  easy string 
this problem is not fun at all  length of last word given a string s consists of upper lower-case alphabets and empty space characters ' '  return the length of last word in the string  if the last word does not exist  return 0  note: a word is defined as a character sequence consists of non-space characters only  easy string 
one line python solution length of last word given a string s consists of upper lower-case alphabets and empty space characters ' '  return the length of last word in the string  if the last word does not exist  return 0  note: a word is defined as a character sequence consists of non-space characters only  easy string 
4-9 lines python solutions spiral matrix ii given a positive integer n  generate a square matrix filled with elements from 1 to n2 in spiral order  medium array 
my super simple solution  can be used for both spiral matrix i and ii spiral matrix ii given a positive integer n  generate a square matrix filled with elements from 1 to n2 in spiral order  medium array 
simple c++ solution(with explaination) spiral matrix ii given a positive integer n  generate a square matrix filled with elements from 1 to n2 in spiral order  medium array 
share my java solution spiral matrix ii given a positive integer n  generate a square matrix filled with elements from 1 to n2 in spiral order  medium array 
my ac solution with using direction variable spiral matrix ii given a positive integer n  generate a square matrix filled with elements from 1 to n2 in spiral order  medium array 
"explain-like-i'm-five" java solution in o(n) permutation sequence the set [1 2 3     n] contains a total of n! unique permutations  by listing and labeling all of the permutations in order  we get the following sequence for n = 3: "123" "132" "213" "231" "312" "321" given n and k  return the kth permutation sequence  note: given n will be between 1 and 9 inclusive  given k will be between 1 and n! inclusive  medium math backtracking 
an iterative solution for reference permutation sequence the set [1 2 3     n] contains a total of n! unique permutations  by listing and labeling all of the permutations in order  we get the following sequence for n = 3: "123" "132" "213" "231" "312" "321" given n and k  return the kth permutation sequence  note: given n will be between 1 and 9 inclusive  given k will be between 1 and n! inclusive  medium math backtracking 
most concise c++ solution  minimal memory required permutation sequence the set [1 2 3     n] contains a total of n! unique permutations  by listing and labeling all of the permutations in order  we get the following sequence for n = 3: "123" "132" "213" "231" "312" "321" given n and k  return the kth permutation sequence  note: given n will be between 1 and 9 inclusive  given k will be between 1 and n! inclusive  medium math backtracking 
share my python solution with detailed explanation permutation sequence the set [1 2 3     n] contains a total of n! unique permutations  by listing and labeling all of the permutations in order  we get the following sequence for n = 3: "123" "132" "213" "231" "312" "321" given n and k  return the kth permutation sequence  note: given n will be between 1 and 9 inclusive  given k will be between 1 and n! inclusive  medium math backtracking 
sharing my straightforward c++ solution with explanation permutation sequence the set [1 2 3     n] contains a total of n! unique permutations  by listing and labeling all of the permutations in order  we get the following sequence for n = 3: "123" "132" "213" "231" "312" "321" given n and k  return the kth permutation sequence  note: given n will be between 1 and 9 inclusive  given k will be between 1 and n! inclusive  medium math backtracking 
my clean c++ code  quite standard (find tail and reconnect the list) rotate list given a linked list  rotate the list to the right by k places  where k is non-negative  medium linked list two pointers 
share my java solution with explanation rotate list given a linked list  rotate the list to the right by k places  where k is non-negative  medium linked list two pointers 
anyone solve the problem without counting the length of list? rotate list given a linked list  rotate the list to the right by k places  where k is non-negative  medium linked list two pointers 
clean java solution with brief explanation rotate list given a linked list  rotate the list to the right by k places  where k is non-negative  medium linked list two pointers 
i think the description of this problem is misleading  rotate list given a linked list  rotate the list to the right by k places  where k is non-negative  medium linked list two pointers 
0ms  5-lines dp solution in c++ with explanations unique paths a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  how many possible unique paths are there? above is a 7 x 3 grid  how many possible unique paths are there? note: m and n will be at most 100  medium array dynamic programming 
my ac solution using formula unique paths a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  how many possible unique paths are there? above is a 7 x 3 grid  how many possible unique paths are there? note: m and n will be at most 100  medium array dynamic programming 
math solution  o(1) space unique paths a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  how many possible unique paths are there? above is a 7 x 3 grid  how many possible unique paths are there? note: m and n will be at most 100  medium array dynamic programming 
java dp solution with complexity o(n m) unique paths a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  how many possible unique paths are there? above is a 7 x 3 grid  how many possible unique paths are there? note: m and n will be at most 100  medium array dynamic programming 
accpeted simple python dp solution  unique paths a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  how many possible unique paths are there? above is a 7 x 3 grid  how many possible unique paths are there? note: m and n will be at most 100  medium array dynamic programming 
short java solution unique paths ii a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  now consider if some obstacles are added to the grids  how many unique paths would there be? an obstacle and empty space is marked as 1 and 0 respectively in the grid  note: m and n will be at most 100  medium array dynamic programming 
my c++ dp solution   very simple! unique paths ii a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  now consider if some obstacles are added to the grids  how many unique paths would there be? an obstacle and empty space is marked as 1 and 0 respectively in the grid  note: m and n will be at most 100  medium array dynamic programming 
4ms o(n) dp solution in c++ with explanations unique paths ii a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  now consider if some obstacles are added to the grids  how many unique paths would there be? an obstacle and empty space is marked as 1 and 0 respectively in the grid  note: m and n will be at most 100  medium array dynamic programming 
java solution using dynamic programming  o(1) space unique paths ii a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  now consider if some obstacles are added to the grids  how many unique paths would there be? an obstacle and empty space is marked as 1 and 0 respectively in the grid  note: m and n will be at most 100  medium array dynamic programming 
easy java solution  in-place  dp unique paths ii a robot is located at the top-left corner of a m x n grid (marked 'start' in the diagram below)  the robot can only move either down or right at any point in time  the robot is trying to reach the bottom-right corner of the grid (marked 'finish' in the diagram below)  now consider if some obstacles are added to the grids  how many unique paths would there be? an obstacle and empty space is marked as 1 and 0 respectively in the grid  note: m and n will be at most 100  medium array dynamic programming 
10-lines 28ms o(n)-space dp solution in c++ with explanations minimum path sum given a m x n grid filled with non-negative numbers  find a path from top left to bottom right which minimizes the sum of all numbers along its path  note: you can only move either down or right at any point in time  medium array dynamic programming 
my java solution using dp and no extra space minimum path sum given a m x n grid filled with non-negative numbers  find a path from top left to bottom right which minimizes the sum of all numbers along its path  note: you can only move either down or right at any point in time  medium array dynamic programming 
simple python dp 70ms minimum path sum given a m x n grid filled with non-negative numbers  find a path from top left to bottom right which minimizes the sum of all numbers along its path  note: you can only move either down or right at any point in time  medium array dynamic programming 
dp solution  linear space minimum path sum given a m x n grid filled with non-negative numbers  find a path from top left to bottom right which minimizes the sum of all numbers along its path  note: you can only move either down or right at any point in time  medium array dynamic programming 
my 8 lines simple solution minimum path sum given a m x n grid filled with non-negative numbers  find a path from top left to bottom right which minimizes the sum of all numbers along its path  note: you can only move either down or right at any point in time  medium array dynamic programming 
the worst problem i have ever met in this oj valid number validate if a given string can be interpreted as a decimal number  some hard math string 
clear java solution with ifs valid number validate if a given string can be interpreted as a decimal number  some hard math string 
a simple solution in python based on dfa valid number validate if a given string can be interpreted as a decimal number  some hard math string 
a simple solution in cpp valid number validate if a given string can be interpreted as a decimal number  some hard math string 
a clean design solution by using design pattern valid number validate if a given string can be interpreted as a decimal number  some hard math string 
my simple java solution plus one given a non-empty array of digits representing a non-negative integer  plus one to the integer  the digits are stored such that the most significant digit is at the head of the list  and each element in the array contain a single digit  you may assume the integer does not contain any leading zero  except the number 0 itself  easy array math 
is it a simple code(c++)? plus one given a non-empty array of digits representing a non-negative integer  plus one to the integer  the digits are stored such that the most significant digit is at the head of the list  and each element in the array contain a single digit  you may assume the integer does not contain any leading zero  except the number 0 itself  easy array math 
i cannot fully understand the meaning of question 'plus one' plus one given a non-empty array of digits representing a non-negative integer  plus one to the integer  the digits are stored such that the most significant digit is at the head of the list  and each element in the array contain a single digit  you may assume the integer does not contain any leading zero  except the number 0 itself  easy array math 
simple java solution plus one given a non-empty array of digits representing a non-negative integer  plus one to the integer  the digits are stored such that the most significant digit is at the head of the list  and each element in the array contain a single digit  you may assume the integer does not contain any leading zero  except the number 0 itself  easy array math 
simple python solution with explanation (plus one) plus one given a non-empty array of digits representing a non-negative integer  plus one to the integer  the digits are stored such that the most significant digit is at the head of the list  and each element in the array contain a single digit  you may assume the integer does not contain any leading zero  except the number 0 itself  easy array math 
short code by c++ add binary given two binary strings  return their sum (also a binary string)  the input strings are both non-empty and contains only characters 1 or 0  easy math string 
short ac solution in java with explanation add binary given two binary strings  return their sum (also a binary string)  the input strings are both non-empty and contains only characters 1 or 0  easy math string 
simple accepted java solution add binary given two binary strings  return their sum (also a binary string)  the input strings are both non-empty and contains only characters 1 or 0  easy math string 
an accepted concise python recursive solution 10 lines add binary given two binary strings  return their sum (also a binary string)  the input strings are both non-empty and contains only characters 1 or 0  easy math string 
very concise c++ solution without calculating longest string add binary given two binary strings  return their sum (also a binary string)  the input strings are both non-empty and contains only characters 1 or 0  easy math string 
share my concise c++ solution - less than 20 lines text justification given an array of words and a width maxwidth  format the text such that each line has exactly maxwidth characters and is fully (left and right) justified  you should pack your words in a greedy approach; that is  pack as many words as you can in each line  pad extra spaces ' ' when necessary so that each line has exactly maxwidth characters  extra spaces between words should be distributed as evenly as possible  if the number of spaces on a line do not divide evenly between words  the empty slots on the left will be assigned more spaces than the slots on the right  for the last line of text  it should be left justified and no extra space is inserted between words  note: a word is defined as a character sequence consisting of non-space characters only  each word's length is guaranteed to be greater than 0 and not exceed maxwidth  the input array words contains at least one word  hard string 
concise python solution  10 lines  text justification given an array of words and a width maxwidth  format the text such that each line has exactly maxwidth characters and is fully (left and right) justified  you should pack your words in a greedy approach; that is  pack as many words as you can in each line  pad extra spaces ' ' when necessary so that each line has exactly maxwidth characters  extra spaces between words should be distributed as evenly as possible  if the number of spaces on a line do not divide evenly between words  the empty slots on the left will be assigned more spaces than the slots on the right  for the last line of text  it should be left justified and no extra space is inserted between words  note: a word is defined as a character sequence consisting of non-space characters only  each word's length is guaranteed to be greater than 0 and not exceed maxwidth  the input array words contains at least one word  hard string 
simple java solution text justification given an array of words and a width maxwidth  format the text such that each line has exactly maxwidth characters and is fully (left and right) justified  you should pack your words in a greedy approach; that is  pack as many words as you can in each line  pad extra spaces ' ' when necessary so that each line has exactly maxwidth characters  extra spaces between words should be distributed as evenly as possible  if the number of spaces on a line do not divide evenly between words  the empty slots on the left will be assigned more spaces than the slots on the right  for the last line of text  it should be left justified and no extra space is inserted between words  note: a word is defined as a character sequence consisting of non-space characters only  each word's length is guaranteed to be greater than 0 and not exceed maxwidth  the input array words contains at least one word  hard string 
what does this question aim to teach? text justification given an array of words and a width maxwidth  format the text such that each line has exactly maxwidth characters and is fully (left and right) justified  you should pack your words in a greedy approach; that is  pack as many words as you can in each line  pad extra spaces ' ' when necessary so that each line has exactly maxwidth characters  extra spaces between words should be distributed as evenly as possible  if the number of spaces on a line do not divide evenly between words  the empty slots on the left will be assigned more spaces than the slots on the right  for the last line of text  it should be left justified and no extra space is inserted between words  note: a word is defined as a character sequence consisting of non-space characters only  each word's length is guaranteed to be greater than 0 and not exceed maxwidth  the input array words contains at least one word  hard string 
easy understanding solution text justification given an array of words and a width maxwidth  format the text such that each line has exactly maxwidth characters and is fully (left and right) justified  you should pack your words in a greedy approach; that is  pack as many words as you can in each line  pad extra spaces ' ' when necessary so that each line has exactly maxwidth characters  extra spaces between words should be distributed as evenly as possible  if the number of spaces on a line do not divide evenly between words  the empty slots on the left will be assigned more spaces than the slots on the right  for the last line of text  it should be left justified and no extra space is inserted between words  note: a word is defined as a character sequence consisting of non-space characters only  each word's length is guaranteed to be greater than 0 and not exceed maxwidth  the input array words contains at least one word  hard string 
c++ 10-lines solution simplify path given an absolute path for a file (unix-style)  simplify it  for medium string stack 
java 10-lines solution with stack simplify path given an absolute path for a file (unix-style)  simplify it  for medium string stack 
can someone please explain what does simplify means in this context? simplify path given an absolute path for a file (unix-style)  simplify it  for medium string stack 
9 lines of python code simplify path given an absolute path for a file (unix-style)  simplify it  for medium string stack 
my o(n) ac code   just need to handle two special cases  simplify path given an absolute path for a file (unix-style)  simplify it  for medium string stack 
20ms detailed explained c++ solutions (o(n) space) edit distance given two words word1 and word2  find the minimum number of operations required to convert word1 to word2  you have the following 3 operations permitted on a word: insert a character delete a character replace a character hard string dynamic programming 
java dp solution - o(nm) edit distance given two words word1 and word2  find the minimum number of operations required to convert word1 to word2  you have the following 3 operations permitted on a word: insert a character delete a character replace a character hard string dynamic programming 
my o(mn) time and o(n) space solution using dp with explanation edit distance given two words word1 and word2  find the minimum number of operations required to convert word1 to word2  you have the following 3 operations permitted on a word: insert a character delete a character replace a character hard string dynamic programming 
good pdf on edit distance problem  may be helpful  edit distance given two words word1 and word2  find the minimum number of operations required to convert word1 to word2  you have the following 3 operations permitted on a word: insert a character delete a character replace a character hard string dynamic programming 
python solutions and intuition edit distance given two words word1 and word2  find the minimum number of operations required to convert word1 to word2  you have the following 3 operations permitted on a word: insert a character delete a character replace a character hard string dynamic programming 
any shorter o(1) space solution? set matrix zeroes given a m x n matrix  if an element is 0  set its entire row and column to 0  do it in-place  medium array 
my ac java o(1) solution (easy to read) set matrix zeroes given a m x n matrix  if an element is 0  set its entire row and column to 0  do it in-place  medium array 
my c++ o(1) yoooooo set matrix zeroes given a m x n matrix  if an element is 0  set its entire row and column to 0  do it in-place  medium array 
my java o(1) solution (easy to understand) set matrix zeroes given a m x n matrix  if an element is 0  set its entire row and column to 0  do it in-place  medium array 
21 lines concise and easy understand c++ solution  o(1) space  three steps set matrix zeroes given a m x n matrix  if an element is 0  set its entire row and column to 0  do it in-place  medium array 
don't treat it as a 2d matrix  just treat it as a sorted list search a 2d matrix write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted from left to right  the first integer of each row is greater than the last integer of the previous row  medium array binary search 
binary search on an ordered matrix search a 2d matrix write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted from left to right  the first integer of each row is greater than the last integer of the previous row  medium array binary search 
java clear solution search a 2d matrix write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted from left to right  the first integer of each row is greater than the last integer of the previous row  medium array binary search 
a python binary search solution - o(logn) search a 2d matrix write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted from left to right  the first integer of each row is greater than the last integer of the previous row  medium array binary search 
c++ 12ms  o(log(mn))  no library functions  treat matrix as an array search a 2d matrix write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted from left to right  the first integer of each row is greater than the last integer of the previous row  medium array binary search 
share my at most two-pass constant space 10-line solution sort colors given an array with n objects colored red  white or blue  sort them in-place so that objects of the same color are adjacent  with the colors in the order red  white and blue  here  we will use the integers 0  1  and 2 to represent the color red  white  and blue respectively  note: you are not suppose to use the library's sort function for this problem  medium array two pointers sort 
four different solutions sort colors given an array with n objects colored red  white or blue  sort them in-place so that objects of the same color are adjacent  with the colors in the order red  white and blue  here  we will use the integers 0  1  and 2 to represent the color red  white  and blue respectively  note: you are not suppose to use the library's sort function for this problem  medium array two pointers sort 
ac python in place one pass solution o(n) time o(1) space  no swap no count sort colors given an array with n objects colored red  white or blue  sort them in-place so that objects of the same color are adjacent  with the colors in the order red  white and blue  here  we will use the integers 0  1  and 2 to represent the color red  white  and blue respectively  note: you are not suppose to use the library's sort function for this problem  medium array two pointers sort 
sharing c++ solution with good explanation sort colors given an array with n objects colored red  white or blue  sort them in-place so that objects of the same color are adjacent  with the colors in the order red  white and blue  here  we will use the integers 0  1  and 2 to represent the color red  white  and blue respectively  note: you are not suppose to use the library's sort function for this problem  medium array two pointers sort 
java solution  both 2-pass and 1-pass sort colors given an array with n objects colored red  white or blue  sort them in-place so that objects of the same color are adjacent  with the colors in the order red  white and blue  here  we will use the integers 0  1  and 2 to represent the color red  white  and blue respectively  note: you are not suppose to use the library's sort function for this problem  medium array two pointers sort 
here is a 10-line template that can solve most 'substring' problems minimum window substring given a string s and a string t  find the minimum window in s which will contain all the characters in t in complexity o(n)  hard hash table two pointers string 
12 lines python minimum window substring given a string s and a string t  find the minimum window in s which will contain all the characters in t in complexity o(n)  hard hash table two pointers string 
accepted o(n) solution minimum window substring given a string s and a string t  find the minimum window in s which will contain all the characters in t in complexity o(n)  hard hash table two pointers string 
java solution  using two pointers + hashmap minimum window substring given a string s and a string t  find the minimum window in s which will contain all the characters in t in complexity o(n)  hard hash table two pointers string 
can t have characters repeating ? minimum window substring given a string s and a string t  find the minimum window in s which will contain all the characters in t in complexity o(n)  hard hash table two pointers string 
short iterative c++ answer 8ms combinations given two integers n and k  return all possible combinations of k numbers out of 1     n  medium backtracking 
backtracking solution java combinations given two integers n and k  return all possible combinations of k numbers out of 1     n  medium backtracking 
a short recursive java solution based on c(n k)=c(n-1 k-1)+c(n-1 k) combinations given two integers n and k  return all possible combinations of k numbers out of 1     n  medium backtracking 
1-liner  3-liner  4-liner combinations given two integers n and k  return all possible combinations of k numbers out of 1     n  medium backtracking 
my shortest c++ solution using dfs combinations given two integers n and k  return all possible combinations of k numbers out of 1     n  medium backtracking 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partitioning) subsets given a set of distinct integers  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking bit manipulation 
my solution using bit manipulation subsets given a set of distinct integers  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking bit manipulation 
c++ recursive iterative bit-manipulation subsets given a set of distinct integers  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking bit manipulation 
python easy to understand solutions (dfs recursively  bit manipulation  iteratively)  subsets given a set of distinct integers  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking bit manipulation 
3ms  easiest solution  no backtracking  no bit manipulation  no dfs  no bullshit subsets given a set of distinct integers  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking bit manipulation 
accepted very short java solution  no additional space  word search given a 2d board and a word  find if the word exists in the grid  the word can be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once  medium array backtracking 
my java solution word search given a 2d board and a word  find if the word exists in the grid  the word can be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once  medium array backtracking 
python dfs solution with comments  word search given a 2d board and a word  find if the word exists in the grid  the word can be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once  medium array backtracking 
my 19ms accepted c++ code word search given a 2d board and a word  find if the word exists in the grid  the word can be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once  medium array backtracking 
simple solution word search given a 2d board and a word  find if the word exists in the grid  the word can be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once  medium array backtracking 
3-6 easy lines  c++  java  python  ruby remove duplicates from sorted array ii given a sorted array nums  remove the duplicates in-place such that duplicates appeared at most twice and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  medium array two pointers 
share my o(n) time and o(1) solution when duplicates are allowed at most k times remove duplicates from sorted array ii given a sorted array nums  remove the duplicates in-place such that duplicates appeared at most twice and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  medium array two pointers 
short and simple java solution (easy to understand) remove duplicates from sorted array ii given a sorted array nums  remove the duplicates in-place such that duplicates appeared at most twice and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  medium array two pointers 
my c++ solution  16ms  5 lines remove duplicates from sorted array ii given a sorted array nums  remove the duplicates in-place such that duplicates appeared at most twice and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  medium array two pointers 
o(n) time and o(1) java solution when allowed at most k times of duplicates remove duplicates from sorted array ii given a sorted array nums  remove the duplicates in-place such that duplicates appeared at most twice and return the new length  do not allocate extra space for another array  you must do this by modifying the input array in-place with o(1) extra memory  medium array two pointers 
my 8ms c++ solution (o(logn) on average  o(n) worst case) search in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  you are given a target value to search  if found in the array return true  otherwise return false  medium array binary search 
c++ concise log(n) solution search in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  you are given a target value to search  if found in the array return true  otherwise return false  medium array binary search 
neat java solution using binary search search in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  you are given a target value to search  if found in the array return true  otherwise return false  medium array binary search 
python easy to understand solution (with comments)  search in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  you are given a target value to search  if found in the array return true  otherwise return false  medium array binary search 
when there are duplicates  the worst case is o(n)  could we do better? search in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  you are given a target value to search  if found in the array return true  otherwise return false  medium array binary search 
my accepted java code remove duplicates from sorted list ii given a sorted linked list  delete all nodes that have duplicate numbers  leaving only distinct numbers from the original list  medium linked list 
my recursive java solution remove duplicates from sorted list ii given a sorted linked list  delete all nodes that have duplicate numbers  leaving only distinct numbers from the original list  medium linked list 
java simple and clean code with comment remove duplicates from sorted list ii given a sorted linked list  delete all nodes that have duplicate numbers  leaving only distinct numbers from the original list  medium linked list 
simple and clear c++ recursive solution remove duplicates from sorted list ii given a sorted linked list  delete all nodes that have duplicate numbers  leaving only distinct numbers from the original list  medium linked list 
python in-place solution with dummy head node  remove duplicates from sorted list ii given a sorted linked list  delete all nodes that have duplicate numbers  leaving only distinct numbers from the original list  medium linked list 
3 line java recursive solution remove duplicates from sorted list given a sorted linked list  delete all duplicates such that each element appear only once  easy linked list 
my pretty solution  java  remove duplicates from sorted list given a sorted linked list  delete all duplicates such that each element appear only once  easy linked list 
concise solution and memory freeing remove duplicates from sorted list given a sorted linked list  delete all duplicates such that each element appear only once  easy linked list 
simple iterative python 6 lines  60 ms remove duplicates from sorted list given a sorted linked list  delete all duplicates such that each element appear only once  easy linked list 
clean java solution remove duplicates from sorted list given a sorted linked list  delete all duplicates such that each element appear only once  easy linked list 
my concise c++ solution  ac 90 ms largest rectangle in histogram given n non-negative integers representing the histogram's bar height where the width of each bar is 1  find the area of largest rectangle in the histogram  above is a histogram where width of each bar is 1  given height = [2 1 5 6 2 3]  the largest rectangle is shown in the shaded area  which has area = 10 unit  hard array stack 
o(n) stack based java solution largest rectangle in histogram given n non-negative integers representing the histogram's bar height where the width of each bar is 1  find the area of largest rectangle in the histogram  above is a histogram where width of each bar is 1  given height = [2 1 5 6 2 3]  the largest rectangle is shown in the shaded area  which has area = 10 unit  hard array stack 
5ms o(n) java solution explained (beats 96%) largest rectangle in histogram given n non-negative integers representing the histogram's bar height where the width of each bar is 1  find the area of largest rectangle in the histogram  above is a histogram where width of each bar is 1  given height = [2 1 5 6 2 3]  the largest rectangle is shown in the shaded area  which has area = 10 unit  hard array stack 
ac python clean solution using stack 76ms largest rectangle in histogram given n non-negative integers representing the histogram's bar height where the width of each bar is 1  find the area of largest rectangle in the histogram  above is a histogram where width of each bar is 1  given height = [2 1 5 6 2 3]  the largest rectangle is shown in the shaded area  which has area = 10 unit  hard array stack 
simple divide and conquer ac solution without segment tree largest rectangle in histogram given n non-negative integers representing the histogram's bar height where the width of each bar is 1  find the area of largest rectangle in the histogram  above is a histogram where width of each bar is 1  given height = [2 1 5 6 2 3]  the largest rectangle is shown in the shaded area  which has area = 10 unit  hard array stack 
share my dp solution maximal rectangle given a 2d binary matrix filled with 0's and 1's  find the largest rectangle containing only 1's and return its area  hard array hash table dynamic programming stack 
a o(n^2) solution based on largest rectangle in histogram maximal rectangle given a 2d binary matrix filled with 0's and 1's  find the largest rectangle containing only 1's and return its area  hard array hash table dynamic programming stack 
my java solution based on maximum rectangle in histogram with explanation maximal rectangle given a 2d binary matrix filled with 0's and 1's  find the largest rectangle containing only 1's and return its area  hard array hash table dynamic programming stack 
ac python dp solutioin 120ms based on largest rectangle in histogram maximal rectangle given a 2d binary matrix filled with 0's and 1's  find the largest rectangle containing only 1's and return its area  hard array hash table dynamic programming stack 
sharing my straightforward c++ solution with o(n^2) time with explanation maximal rectangle given a 2d binary matrix filled with 0's and 1's  find the largest rectangle containing only 1's and return its area  hard array hash table dynamic programming stack 
very concise one pass solution partition list given a linked list and a value x  partition it such that all nodes less than x come before nodes greater than or equal to x  you should preserve the original relative order of the nodes in each of the two partitions  medium linked list two pointers 
concise java code with explanation  one pass partition list given a linked list and a value x  partition it such that all nodes less than x come before nodes greater than or equal to x  you should preserve the original relative order of the nodes in each of the two partitions  medium linked list two pointers 
python concise solution with dummy nodes  partition list given a linked list and a value x  partition it such that all nodes less than x come before nodes greater than or equal to x  you should preserve the original relative order of the nodes in each of the two partitions  medium linked list two pointers 
10 lines concise c++ solution partition list given a linked list and a value x  partition it such that all nodes less than x come before nodes greater than or equal to x  you should preserve the original relative order of the nodes in each of the two partitions  medium linked list two pointers 
my accepted solution  any improvement? partition list given a linked list and a value x  partition it such that all nodes less than x come before nodes greater than or equal to x  you should preserve the original relative order of the nodes in each of the two partitions  medium linked list two pointers 
share my 4ms c++ recursive solution scramble string given a string s1  we may represent it as a binary tree by partitioning it to two non-empty substrings recursively  below is one possible representation of s1 = "great": great     gr eat         g r e at     a t to scramble the string  we may choose any non-leaf node and swap its two children  for hard string dynamic programming 
accepted java solution scramble string given a string s1  we may represent it as a binary tree by partitioning it to two non-empty substrings recursively  below is one possible representation of s1 = "great": great     gr eat         g r e at     a t to scramble the string  we may choose any non-leaf node and swap its two children  for hard string dynamic programming 
my c++ solutions (recursion with cache   dp  recursion with cache and pruning) with explanation (4ms) scramble string given a string s1  we may represent it as a binary tree by partitioning it to two non-empty substrings recursively  below is one possible representation of s1 = "great": great     gr eat         g r e at     a t to scramble the string  we may choose any non-leaf node and swap its two children  for hard string dynamic programming 
simple iterative dp java solution with explanation scramble string given a string s1  we may represent it as a binary tree by partitioning it to two non-empty substrings recursively  below is one possible representation of s1 = "great": great     gr eat         g r e at     a t to scramble the string  we may choose any non-leaf node and swap its two children  for hard string dynamic programming 
can you partition a string at any index at any time in producing a scramble? scramble string given a string s1  we may represent it as a binary tree by partitioning it to two non-empty substrings recursively  below is one possible representation of s1 = "great": great     gr eat         g r e at     a t to scramble the string  we may choose any non-leaf node and swap its two children  for hard string dynamic programming 
this is my ac code  may help you merge sorted array given two sorted integer arrays nums1 and nums2  merge nums2 into nums1 as one sorted array  note: the number of elements initialized in nums1 and nums2 are m and n respectively  you may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2  easy array two pointers 
beautiful python solution merge sorted array given two sorted integer arrays nums1 and nums2  merge nums2 into nums1 as one sorted array  note: the number of elements initialized in nums1 and nums2 are m and n respectively  you may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2  easy array two pointers 
4ms c++ solution with single loop merge sorted array given two sorted integer arrays nums1 and nums2  merge nums2 into nums1 as one sorted array  note: the number of elements initialized in nums1 and nums2 are m and n respectively  you may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2  easy array two pointers 
3 line java solution merge sorted array given two sorted integer arrays nums1 and nums2  merge nums2 into nums1 as one sorted array  note: the number of elements initialized in nums1 and nums2 are m and n respectively  you may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2  easy array two pointers 
1 line solution merge sorted array given two sorted integer arrays nums1 and nums2  merge nums2 into nums1 as one sorted array  note: the number of elements initialized in nums1 and nums2 are m and n respectively  you may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2  easy array two pointers 
an accepted three line solution in java gray code the gray code is a binary numeral system where two successive values differ in only one bit  given a non-negative integer n representing the total number of bits in the code  print the sequence of gray code  a gray code sequence must begin with 0  medium backtracking 
share my solution gray code the gray code is a binary numeral system where two successive values differ in only one bit  given a non-negative integer n representing the total number of bits in the code  print the sequence of gray code  a gray code sequence must begin with 0  medium backtracking 
one-liner python solution (with demo in comments) gray code the gray code is a binary numeral system where two successive values differ in only one bit  given a non-negative integer n representing the total number of bits in the code  print the sequence of gray code  a gray code sequence must begin with 0  medium backtracking 
what is the best solution for gray code problem? no extra space used and no recursion? gray code the gray code is a binary numeral system where two successive values differ in only one bit  given a non-negative integer n representing the total number of bits in the code  print the sequence of gray code  a gray code sequence must begin with 0  medium backtracking 
backtracking c++ solution gray code the gray code is a binary numeral system where two successive values differ in only one bit  given a non-negative integer n representing the total number of bits in the code  print the sequence of gray code  a gray code sequence must begin with 0  medium backtracking 
c++ solution and explanation subsets ii given a collection of integers that might contain duplicates  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking 
simple iterative solution subsets ii given a collection of integers that might contain duplicates  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking 
simple python solution without extra space  subsets ii given a collection of integers that might contain duplicates  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking 
accepted 10ms c++ solution use backtracking  only 10 lines  easy understand  subsets ii given a collection of integers that might contain duplicates  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking 
very simple and fast java solution subsets ii given a collection of integers that might contain duplicates  nums  return all possible subsets (the power set)  note: the solution set must not contain duplicate subsets  medium array backtracking 
dp solution (java) for reference decode ways a message containing letters from a-z is being encoded to numbers using the following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given a non-empty string containing only digits  determine the total number of ways to decode it  medium string dynamic programming 
java clean dp solution with explanation decode ways a message containing letters from a-z is being encoded to numbers using the following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given a non-empty string containing only digits  determine the total number of ways to decode it  medium string dynamic programming 
a concise dp solution decode ways a message containing letters from a-z is being encoded to numbers using the following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given a non-empty string containing only digits  determine the total number of ways to decode it  medium string dynamic programming 
evolve from recursion to dp decode ways a message containing letters from a-z is being encoded to numbers using the following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given a non-empty string containing only digits  determine the total number of ways to decode it  medium string dynamic programming 
java 2ms dp solution with detailed explanation and inline comments decode ways a message containing letters from a-z is being encoded to numbers using the following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given a non-empty string containing only digits  determine the total number of ways to decode it  medium string dynamic programming 
simple java solution with clear explanation reverse linked list ii reverse a linked list from position m to n  do it in one-pass  note: 1 ≤ m ≤ n ≤ length of list  medium linked list 
12-lines 4ms c++ reverse linked list ii reverse a linked list from position m to n  do it in one-pass  note: 1 ≤ m ≤ n ≤ length of list  medium linked list 
share my 14 lines c++ solution reverse linked list ii reverse a linked list from position m to n  do it in one-pass  note: 1 ≤ m ≤ n ≤ length of list  medium linked list 
talk is cheap  show me the code (and drawing) reverse linked list ii reverse a linked list from position m to n  do it in one-pass  note: 1 ≤ m ≤ n ≤ length of list  medium linked list 
python one pass iterative solution reverse linked list ii reverse a linked list from position m to n  do it in one-pass  note: 1 ≤ m ≤ n ≤ length of list  medium linked list 
my code in java restore ip addresses given a string containing only digits  restore it by returning all possible valid ip address combinations  medium string backtracking 
who can beat this code ? restore ip addresses given a string containing only digits  restore it by returning all possible valid ip address combinations  medium string backtracking 
very simple dfs solution restore ip addresses given a string containing only digits  restore it by returning all possible valid ip address combinations  medium string backtracking 
what is the definition of a valid ip address? restore ip addresses given a string containing only digits  restore it by returning all possible valid ip address combinations  medium string backtracking 
my concise ac java code restore ip addresses given a string containing only digits  restore it by returning all possible valid ip address combinations  medium string backtracking 
iterative solution in java - simple and readable binary tree inorder traversal given a binary tree  return the inorder traversal of its nodes' values  medium hash table stack tree 
three methods to solve (c++) binary tree inorder traversal given a binary tree  return the inorder traversal of its nodes' values  medium hash table stack tree 
python recursive and iterative solutions  binary tree inorder traversal given a binary tree  return the inorder traversal of its nodes' values  medium hash table stack tree 
c++ ierative  recursive and morris traversal binary tree inorder traversal given a binary tree  return the inorder traversal of its nodes' values  medium hash table stack tree 
concise java solution based on stack binary tree inorder traversal given a binary tree  return the inorder traversal of its nodes' values  medium hash table stack tree 
a simple recursive solution unique binary search trees ii given an integer n  generate all structurally unique bst's (binary search trees) that store values 1     n  medium dynamic programming tree 
java solution with dp unique binary search trees ii given an integer n  generate all structurally unique bst's (binary search trees) that store values 1     n  medium dynamic programming tree 
divide-and-conquer   f(i) = g(i-1)   g(n-i) unique binary search trees ii given an integer n  generate all structurally unique bst's (binary search trees) that store values 1     n  medium dynamic programming tree 
should-be-6-liner unique binary search trees ii given an integer n  generate all structurally unique bst's (binary search trees) that store values 1     n  medium dynamic programming tree 
share a c++ dp solution with o(1) space unique binary search trees ii given an integer n  generate all structurally unique bst's (binary search trees) that store values 1     n  medium dynamic programming tree 
dp solution in 6 lines with explanation  f(i  n) = g(i-1)   g(n-i) unique binary search trees given n  how many structurally unique bst's (binary search trees) that store values 1     n? medium dynamic programming tree 
fantastic clean java dp solution with detail explaination unique binary search trees given n  how many structurally unique bst's (binary search trees) that store values 1     n? medium dynamic programming tree 
dp problem  10+ lines with comments unique binary search trees given n  how many structurally unique bst's (binary search trees) that store values 1     n? medium dynamic programming tree 
a very simple and straight ans based on math catalan number  o(n) times o(1)space unique binary search trees given n  how many structurally unique bst's (binary search trees) that store values 1     n? medium dynamic programming tree 
simple solution with easy explaination unique binary search trees given n  how many structurally unique bst's (binary search trees) that store values 1     n? medium dynamic programming tree 
my dp solution in c++ interleaving string given s1  s2  s3  find whether s3 is formed by the interleaving of s1 and s2  hard string dynamic programming 
8ms c++ solution using bfs  with explanation interleaving string given s1  s2  s3  find whether s3 is formed by the interleaving of s1 and s2  hard string dynamic programming 
dp solution in java interleaving string given s1  s2  s3  find whether s3 is formed by the interleaving of s1 and s2  hard string dynamic programming 
1ms tiny dfs beats 94 57% interleaving string given s1  s2  s3  find whether s3 is formed by the interleaving of s1 and s2  hard string dynamic programming 
python dp solutions (o(m n)  o(n) space)  bfs  dfs  interleaving string given s1  s2  s3  find whether s3 is formed by the interleaving of s1 and s2  hard string dynamic programming 
learn one iterative inorder traversal  apply it to multiple tree questions (java solution) validate binary search tree given a binary tree  determine if it is a valid binary search tree (bst)  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key  the right subtree of a node contains only nodes with keys greater than the node's key  both the left and right subtrees must also be binary search trees  medium tree depth-first search 
my simple java solution in 3 lines validate binary search tree given a binary tree  determine if it is a valid binary search tree (bst)  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key  the right subtree of a node contains only nodes with keys greater than the node's key  both the left and right subtrees must also be binary search trees  medium tree depth-first search 
c++ in-order traversal  and please do not rely on buggy int_max  int_min solutions any more validate binary search tree given a binary tree  determine if it is a valid binary search tree (bst)  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key  the right subtree of a node contains only nodes with keys greater than the node's key  both the left and right subtrees must also be binary search trees  medium tree depth-first search 
c++ simple recursive solution validate binary search tree given a binary tree  determine if it is a valid binary search tree (bst)  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key  the right subtree of a node contains only nodes with keys greater than the node's key  both the left and right subtrees must also be binary search trees  medium tree depth-first search 
my java inorder iteration solution validate binary search tree given a binary tree  determine if it is a valid binary search tree (bst)  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key  the right subtree of a node contains only nodes with keys greater than the node's key  both the left and right subtrees must also be binary search trees  medium tree depth-first search 
no fancy algorithm  just simple and powerful in-order traversal recover binary search tree two elements of a binary search tree (bst) are swapped by mistake  recover the tree without changing its structure  hard tree depth-first search 
detail explain about how morris traversal finds two incorrect pointer recover binary search tree two elements of a binary search tree (bst) are swapped by mistake  recover the tree without changing its structure  hard tree depth-first search 
tree deserializer and visualizer for python recover binary search tree two elements of a binary search tree (bst) are swapped by mistake  recover the tree without changing its structure  hard tree depth-first search 
share my solutions and detailed explanation with recursive iterative in-order-traversal and morris-traversal recover binary search tree two elements of a binary search tree (bst) are swapped by mistake  recover the tree without changing its structure  hard tree depth-first search 
[recommend for beginners]clean c++ implementation with detailed explaination recover binary search tree two elements of a binary search tree (bst) are swapped by mistake  recover the tree without changing its structure  hard tree depth-first search 
five line java solution with recursion same tree given two binary trees  write a function to check if they are the same or not  two binary trees are considered the same if they are structurally identical and the nodes have the same value  easy tree depth-first search 
here's a c++ recursion solution in minimal lines of code same tree given two binary trees  write a function to check if they are the same or not  two binary trees are considered the same if they are structurally identical and the nodes have the same value  easy tree depth-first search 
my non-recursive method same tree given two binary trees  write a function to check if they are the same or not  two binary trees are considered the same if they are structurally identical and the nodes have the same value  easy tree depth-first search 
shortest+simplest python same tree given two binary trees  write a function to check if they are the same or not  two binary trees are considered the same if they are structurally identical and the nodes have the same value  easy tree depth-first search 
python recursive solution and dfs iterative solution with stack and bfs iterative solution with queue same tree given two binary trees  write a function to check if they are the same or not  two binary trees are considered the same if they are structurally identical and the nodes have the same value  easy tree depth-first search 
recursive and non-recursive solutions in java symmetric tree given a binary tree  check whether it is a mirror of itself (ie  symmetric around its center)  for easy tree depth-first search breadth-first search 
1ms recursive java solution  easy to understand symmetric tree given a binary tree  check whether it is a mirror of itself (ie  symmetric around its center)  for easy tree depth-first search breadth-first search 
my c++ accepted code in 16ms with iteration solution symmetric tree given a binary tree  check whether it is a mirror of itself (ie  symmetric around its center)  for easy tree depth-first search breadth-first search 
recursively and iteratively solution in python symmetric tree given a binary tree  check whether it is a mirror of itself (ie  symmetric around its center)  for easy tree depth-first search breadth-first search 
short and clean java iterative solution symmetric tree given a binary tree  check whether it is a mirror of itself (ie  symmetric around its center)  for easy tree depth-first search breadth-first search 
java solution with a queue used binary tree level order traversal given a binary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for medium tree breadth-first search 
java solution using dfs binary tree level order traversal given a binary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for medium tree breadth-first search 
one of c++ solutions (preorder) binary tree level order traversal given a binary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for medium tree breadth-first search 
c++ solution using only one queue   use a marker null binary tree level order traversal given a binary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for medium tree breadth-first search 
5-6 lines fast python solution (48 ms) binary tree level order traversal given a binary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for medium tree breadth-first search 
my accepted java solution binary tree zigzag level order traversal given a binary tree  return the zigzag level order traversal of its nodes' values  (ie  from left to right  then right to left for the next level and alternate between)  for medium stack tree breadth-first search 
[c++] 5ms version: one queue and without reverse operation by using size of each level binary tree zigzag level order traversal given a binary tree  return the zigzag level order traversal of its nodes' values  (ie  from left to right  then right to left for the next level and alternate between)  for medium stack tree breadth-first search 
a concise and easy understanding java solution binary tree zigzag level order traversal given a binary tree  return the zigzag level order traversal of its nodes' values  (ie  from left to right  then right to left for the next level and alternate between)  for medium stack tree breadth-first search 
java double stack solution binary tree zigzag level order traversal given a binary tree  return the zigzag level order traversal of its nodes' values  (ie  from left to right  then right to left for the next level and alternate between)  for medium stack tree breadth-first search 
python simple bfs binary tree zigzag level order traversal given a binary tree  return the zigzag level order traversal of its nodes' values  (ie  from left to right  then right to left for the next level and alternate between)  for medium stack tree breadth-first search 
can leetcode share top performing solution(s) of problems for each supported language ? maximum depth of binary tree given a binary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  note: a leaf is a node with no children  easy tree depth-first search 
simple solution using java maximum depth of binary tree given a binary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  note: a leaf is a node with no children  easy tree depth-first search 
my code of c++  depth-first-search and breadth-first-search maximum depth of binary tree given a binary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  note: a leaf is a node with no children  easy tree depth-first search 
two java iterative solution dfs and bfs maximum depth of binary tree given a binary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  note: a leaf is a node with no children  easy tree depth-first search 
1 line ruby and python maximum depth of binary tree given a binary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  note: a leaf is a node with no children  easy tree depth-first search 
my accepted java solution construct binary tree from preorder and inorder traversal given preorder and inorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
python short recursive solution  construct binary tree from preorder and inorder traversal given preorder and inorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
the iterative solution is easier than you think! construct binary tree from preorder and inorder traversal given preorder and inorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
sharing my straightforward recursive solution construct binary tree from preorder and inorder traversal given preorder and inorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
5ms java clean solution with caching construct binary tree from preorder and inorder traversal given preorder and inorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
my recursive java code with o(n) time and o(n) space construct binary tree from inorder and postorder traversal given inorder and postorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
a python recursive solution construct binary tree from inorder and postorder traversal given inorder and postorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
sharing my straightforward recursive solution construct binary tree from inorder and postorder traversal given inorder and postorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
java iterative solution with explanation construct binary tree from inorder and postorder traversal given inorder and postorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
my comprehension of o(n) solution from @hongzhi construct binary tree from inorder and postorder traversal given inorder and postorder traversal of a tree  construct the binary tree  note: you may assume that duplicates do not exist in the tree  for medium array tree depth-first search 
my dfs and bfs java solution binary tree level order traversal ii given a binary tree  return the bottom-up level order traversal of its nodes' values  (ie  from left to right  level by level from leaf to root)  for easy tree breadth-first search 
is there any better idea than doing regular level order traversal and reverse the result? binary tree level order traversal ii given a binary tree  return the bottom-up level order traversal of its nodes' values  (ie  from left to right  level by level from leaf to root)  for easy tree breadth-first search 
python solutions (dfs recursively  dfs+stack  bfs+queue)  binary tree level order traversal ii given a binary tree  return the bottom-up level order traversal of its nodes' values  (ie  from left to right  level by level from leaf to root)  for easy tree breadth-first search 
java solution  using queue binary tree level order traversal ii given a binary tree  return the bottom-up level order traversal of its nodes' values  (ie  from left to right  level by level from leaf to root)  for easy tree breadth-first search 
my neat solution in c++ binary tree level order traversal ii given a binary tree  return the bottom-up level order traversal of its nodes' values  (ie  from left to right  level by level from leaf to root)  for easy tree breadth-first search 
my accepted java solution convert sorted array to binary search tree given an array where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
java iterative solution convert sorted array to binary search tree given an array where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
an easy python solution convert sorted array to binary search tree given an array where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
accepted c++ recursive solution within a single method convert sorted array to binary search tree given an array where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
python optimal solution convert sorted array to binary search tree given an array where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
share my java solution  1ms  very short and concise  convert sorted list to binary search tree given a singly linked list where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  medium linked list depth-first search 
share my o(1) space and o(n) time java code convert sorted list to binary search tree given a singly linked list where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  medium linked list depth-first search 
share my code with o(n) time and o(1) space convert sorted list to binary search tree given a singly linked list where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  medium linked list depth-first search 
my accepted c++ solution convert sorted list to binary search tree given a singly linked list where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  medium linked list depth-first search 
recursive bst construction using slow-fast traversal on linked list convert sorted list to binary search tree given a singly linked list where elements are sorted in ascending order  convert it to a height balanced bst  for this problem  a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1  medium linked list depth-first search 
the bottom up o(n) solution would be better balanced binary tree given a binary tree  determine if it is height-balanced  for this problem  a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
java solution based on height  check left and right node in every recursion to avoid further useless search balanced binary tree given a binary tree  determine if it is height-balanced  for this problem  a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
very simple python solutions (iterative and recursive)  both beat 90% balanced binary tree given a binary tree  determine if it is height-balanced  for this problem  a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
two different definitions of balanced binary tree result in two different judgments balanced binary tree given a binary tree  determine if it is height-balanced  for this problem  a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
java o(n) solution based on maximum depth of binary tree balanced binary tree given a binary tree  determine if it is height-balanced  for this problem  a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1  easy tree depth-first search 
my 4 line java solution minimum depth of binary tree given a binary tree  find its minimum depth  the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node  note: a leaf is a node with no children  easy tree depth-first search breadth-first search 
my concise c++ solution minimum depth of binary tree given a binary tree  find its minimum depth  the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node  note: a leaf is a node with no children  easy tree depth-first search breadth-first search 
3 lines in every language minimum depth of binary tree given a binary tree  find its minimum depth  the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node  note: a leaf is a node with no children  easy tree depth-first search breadth-first search 
why expected result for input of {1 2}  is 2? shouldn't it be 1? minimum depth of binary tree given a binary tree  find its minimum depth  the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node  note: a leaf is a node with no children  easy tree depth-first search breadth-first search 
bfs  c++  8ms  beats 99 94% submissions minimum depth of binary tree given a binary tree  find its minimum depth  the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node  note: a leaf is a node with no children  easy tree depth-first search breadth-first search 
[accepted]my recursive solution in java path sum given a binary tree and a sum  determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum  note: a leaf is a node with no children  easy tree depth-first search 
3 lines of  c++ solution path sum given a binary tree and a sum  determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum  note: a leaf is a node with no children  easy tree depth-first search 
short python recursive solution - o(n) path sum given a binary tree and a sum  determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum  note: a leaf is a node with no children  easy tree depth-first search 
[accepted] by using postorder traversal path sum given a binary tree and a sum  determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum  note: a leaf is a node with no children  easy tree depth-first search 
my java no-recursive method path sum given a binary tree and a sum  determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum  note: a leaf is a node with no children  easy tree depth-first search 
dfs with one linkedlist   accepted java solution path sum ii given a binary tree and a sum  find all root-to-leaf paths where each path's sum equals the given sum  note: a leaf is a node with no children  medium tree depth-first search 
12ms 11-lines c++ solution path sum ii given a binary tree and a sum  find all root-to-leaf paths where each path's sum equals the given sum  note: a leaf is a node with no children  medium tree depth-first search 
python solutions (recursively  bfs+queue  dfs+stack) path sum ii given a binary tree and a sum  find all root-to-leaf paths where each path's sum equals the given sum  note: a leaf is a node with no children  medium tree depth-first search 
simple dfs java solution path sum ii given a binary tree and a sum  find all root-to-leaf paths where each path's sum equals the given sum  note: a leaf is a node with no children  medium tree depth-first search 
java solution: iterative and recursive path sum ii given a binary tree and a sum  find all root-to-leaf paths where each path's sum equals the given sum  note: a leaf is a node with no children  medium tree depth-first search 
my short post order traversal java solution for share flatten binary tree to linked list given a binary tree  flatten it to a linked list in-place  for medium tree depth-first search 
share my simple non-recursive solution  o(1) space complexity! flatten binary tree to linked list given a binary tree  flatten it to a linked list in-place  for medium tree depth-first search 
straightforward java solution flatten binary tree to linked list given a binary tree  flatten it to a linked list in-place  for medium tree depth-first search 
accepted simple java solution   iterative flatten binary tree to linked list given a binary tree  flatten it to a linked list in-place  for medium tree depth-first search 
8ms  non-recursive  no stack  c++ solution flatten binary tree to linked list given a binary tree  flatten it to a linked list in-place  for medium tree depth-first search 
easy to understand dp in java distinct subsequences given a string s and a string t  count the number of distinct subsequences of s which equals t  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  hard string dynamic programming 
any better solution that takes less than o(n^2) space while in o(n^2) time? distinct subsequences given a string s and a string t  count the number of distinct subsequences of s which equals t  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  hard string dynamic programming 
task clarification distinct subsequences given a string s and a string t  count the number of distinct subsequences of s which equals t  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  hard string dynamic programming 
7-10 lines c++ solutions with detailed explanations (o(m n) time and o(m) space) distinct subsequences given a string s and a string t  count the number of distinct subsequences of s which equals t  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  hard string dynamic programming 
the question should be reworded  distinct subsequences given a string s and a string t  count the number of distinct subsequences of s which equals t  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  hard string dynamic programming 
a simple accepted solution populating next right pointers in each node given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  you may assume that it is a perfect binary tree (ie  all leaves are at the same level  and every parent has two children)  medium tree depth-first search 
java solution with o(1) memory+ o(n) time populating next right pointers in each node given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  you may assume that it is a perfect binary tree (ie  all leaves are at the same level  and every parent has two children)  medium tree depth-first search 
my recursive solution(java) populating next right pointers in each node given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  you may assume that it is a perfect binary tree (ie  all leaves are at the same level  and every parent has two children)  medium tree depth-first search 
my simple non-iterative c++ code with o(1) memory populating next right pointers in each node given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  you may assume that it is a perfect binary tree (ie  all leaves are at the same level  and every parent has two children)  medium tree depth-first search 
7 lines  iterative  real o(1) space populating next right pointers in each node given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  you may assume that it is a perfect binary tree (ie  all leaves are at the same level  and every parent has two children)  medium tree depth-first search 
o(1) space o(n) complexity iterative solution populating next right pointers in each node ii given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  medium tree depth-first search 
simple solution using constant space populating next right pointers in each node ii given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  medium tree depth-first search 
java solution with constant space populating next right pointers in each node ii given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  medium tree depth-first search 
ac python o(1) space solution 12 lines and easy to understand populating next right pointers in each node ii given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  medium tree depth-first search 
simple 40ms c++ o(n)  o(1) solution with only one while loop populating next right pointers in each node ii given a binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate each next pointer to point to its next right node  if there is no next right node  the next pointer should be set to null  initially  all next pointers are set to null  note: you may only use constant extra space  recursive approach is fine  implicit stack space does not count as extra space for this problem  medium tree depth-first search 
my concise solution in java pascal's triangle given a non-negative integer numrows  generate the first numrows of pascal's triangle  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
python 4 lines short solution using map  pascal's triangle given a non-negative integer numrows  generate the first numrows of pascal's triangle  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
solution in java pascal's triangle given a non-negative integer numrows  generate the first numrows of pascal's triangle  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
maybe shortest c++ solution pascal's triangle given a non-negative integer numrows  generate the first numrows of pascal's triangle  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
simple python 4 lines pascal's triangle given a non-negative integer numrows  generate the first numrows of pascal's triangle  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
here is my brief o(k) solution pascal's triangle ii given a non-negative index k where k ≤ 33  return the kth index row of the pascal's triangle  note that the row index starts from 0  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
very simple python solution pascal's triangle ii given a non-negative index k where k ≤ 33  return the kth index row of the pascal's triangle  note that the row index starts from 0  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
my accepted java solution  any better code? pascal's triangle ii given a non-negative index k where k ≤ 33  return the kth index row of the pascal's triangle  note that the row index starts from 0  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
my 8 lines java solution use arraylist pascal's triangle ii given a non-negative index k where k ≤ 33  return the kth index row of the pascal's triangle  note that the row index starts from 0  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
sharing my c++ code  very simple pascal's triangle ii given a non-negative index k where k ≤ 33  return the kth index row of the pascal's triangle  note that the row index starts from 0  in pascal's triangle  each number is the sum of the two numbers directly above it  easy array 
dp solution for triangle triangle given a triangle  find the minimum path sum from top to bottom  each step you may move to adjacent numbers on the row below  for medium array dynamic programming 
7 lines neat java solution triangle given a triangle  find the minimum path sum from top to bottom  each step you may move to adjacent numbers on the row below  for medium array dynamic programming 
my 8 line dp java code(4 meaningful lines) with o(1) space triangle given a triangle  find the minimum path sum from top to bottom  each step you may move to adjacent numbers on the row below  for medium array dynamic programming 
python easy to understand solutions (top-down  bottom-up)  triangle given a triangle  find the minimum path sum from top to bottom  each step you may move to adjacent numbers on the row below  for medium array dynamic programming 
bottom up 5 line c++ solution triangle given a triangle  find the minimum path sum from top to bottom  each step you may move to adjacent numbers on the row below  for medium array dynamic programming 
kadane's algorithm - since no one has mentioned about this so far :) (in case if interviewer twists the input) best time to buy and sell stock say you have an array for which the ith element is the price of a given stock on day i  if you were only permitted to complete at most one transaction (i e   buy one and sell one share of the stock)  design an algorithm to find the maximum profit  note that you cannot sell a stock before you buy one  easy array dynamic programming 
sharing my simple and clear c++ solution best time to buy and sell stock say you have an array for which the ith element is the price of a given stock on day i  if you were only permitted to complete at most one transaction (i e   buy one and sell one share of the stock)  design an algorithm to find the maximum profit  note that you cannot sell a stock before you buy one  easy array dynamic programming 
please explain the problem more clearly!!! best time to buy and sell stock say you have an array for which the ith element is the price of a given stock on day i  if you were only permitted to complete at most one transaction (i e   buy one and sell one share of the stock)  design an algorithm to find the maximum profit  note that you cannot sell a stock before you buy one  easy array dynamic programming 
my jave accepted solution with o(n) time and o(1) space best time to buy and sell stock say you have an array for which the ith element is the price of a given stock on day i  if you were only permitted to complete at most one transaction (i e   buy one and sell one share of the stock)  design an algorithm to find the maximum profit  note that you cannot sell a stock before you buy one  easy array dynamic programming 
easy o(n) python solution best time to buy and sell stock say you have an array for which the ith element is the price of a given stock on day i  if you were only permitted to complete at most one transaction (i e   buy one and sell one share of the stock)  design an algorithm to find the maximum profit  note that you cannot sell a stock before you buy one  easy array dynamic programming 
is this question a joke? best time to buy and sell stock ii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (i e   buy one and sell one share of the stock multiple times)  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  easy array greedy 
three lines in c++  with explanation best time to buy and sell stock ii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (i e   buy one and sell one share of the stock multiple times)  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  easy array greedy 
java o(n) solution if we're not greedy best time to buy and sell stock ii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (i e   buy one and sell one share of the stock multiple times)  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  easy array greedy 
clear 1-line python solution best time to buy and sell stock ii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (i e   buy one and sell one share of the stock multiple times)  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  easy array greedy 
shortest and fastest solution with explanation  you can never beat this  best time to buy and sell stock ii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (i e   buy one and sell one share of the stock multiple times)  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  easy array greedy 
is it best solution with o(n)  o(1)  best time to buy and sell stock iii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most two transactions  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  hard array dynamic programming 
a clean dp solution which generalizes to k transactions best time to buy and sell stock iii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most two transactions  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  hard array dynamic programming 
detail explanation of dp solution best time to buy and sell stock iii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most two transactions  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  hard array dynamic programming 
my explanation for o(n) solution! best time to buy and sell stock iii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most two transactions  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  hard array dynamic programming 
my c++ solution (o(n) time  o(1) space  8ms) best time to buy and sell stock iii say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most two transactions  note: you may not engage in multiple transactions at the same time (i e   you must sell the stock before you buy again)  hard array dynamic programming 
accepted short solution in java binary tree maximum path sum given a non-empty binary tree  find the maximum path sum  for this problem  a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections  the path must contain at least one node and does not need to go through the root  hard tree depth-first search 
simple o(n) algorithm with one traversal through the tree binary tree maximum path sum given a non-empty binary tree  find the maximum path sum  for this problem  a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections  the path must contain at least one node and does not need to go through the root  hard tree depth-first search 
elegant java solution binary tree maximum path sum given a non-empty binary tree  find the maximum path sum  for this problem  a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections  the path must contain at least one node and does not need to go through the root  hard tree depth-first search 
a very concise recursive solution binary tree maximum path sum given a non-empty binary tree  find the maximum path sum  for this problem  a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections  the path must contain at least one node and does not need to go through the root  hard tree depth-first search 
what is the meaning of path in this problem? binary tree maximum path sum given a non-empty binary tree  find the maximum path sum  for this problem  a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections  the path must contain at least one node and does not need to go through the root  hard tree depth-first search 
accepted pretty java solution(271ms) valid palindrome given a string  determine if it is a palindrome  considering only alphanumeric characters and ignoring cases  note: for the purpose of this problem  we define empty string as valid palindrome  easy two pointers string 
my three line java solution valid palindrome given a string  determine if it is a palindrome  considering only alphanumeric characters and ignoring cases  note: for the purpose of this problem  we define empty string as valid palindrome  easy two pointers string 
here's a clean c++ solution valid palindrome given a string  determine if it is a palindrome  considering only alphanumeric characters and ignoring cases  note: for the purpose of this problem  we define empty string as valid palindrome  easy two pointers string 
python in-place two-pointer solution  valid palindrome given a string  determine if it is a palindrome  considering only alphanumeric characters and ignoring cases  note: for the purpose of this problem  we define empty string as valid palindrome  easy two pointers string 
passed clean c++ code valid palindrome given a string  determine if it is a palindrome  considering only alphanumeric characters and ignoring cases  note: for the purpose of this problem  we define empty string as valid palindrome  easy two pointers string 
my concise java solution based on bfs and dfs word ladder ii given two words (beginword and endword)  and a dictionary's word list  find all shortest transformation sequence(s) from beginword to endword  such that: only one letter can be changed at a time each transformed word must exist in the word list  note that beginword is not a transformed word  note: return an empty list if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  hard array string backtracking breadth-first search 
share two similar java solution that accpted by oj  word ladder ii given two words (beginword and endword)  and a dictionary's word list  find all shortest transformation sequence(s) from beginword to endword  such that: only one letter can be changed at a time each transformed word must exist in the word list  note that beginword is not a transformed word  note: return an empty list if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  hard array string backtracking breadth-first search 
c++ solution using standard bfs method  no dfs or backtracking word ladder ii given two words (beginword and endword)  and a dictionary's word list  find all shortest transformation sequence(s) from beginword to endword  such that: only one letter can be changed at a time each transformed word must exist in the word list  note that beginword is not a transformed word  note: return an empty list if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  hard array string backtracking breadth-first search 
super fast java solution (two-end bfs) word ladder ii given two words (beginword and endword)  and a dictionary's word list  find all shortest transformation sequence(s) from beginword to endword  such that: only one letter can be changed at a time each transformed word must exist in the word list  note that beginword is not a transformed word  note: return an empty list if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  hard array string backtracking breadth-first search 
use defaultdict for traceback and easy writing  20 lines python code word ladder ii given two words (beginword and endword)  and a dictionary's word list  find all shortest transformation sequence(s) from beginword to endword  such that: only one letter can be changed at a time each transformed word must exist in the word list  note that beginword is not a transformed word  note: return an empty list if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  hard array string backtracking breadth-first search 
easy 76ms c++ solution using bfs word ladder given two words (beginword and endword)  and a dictionary's word list  find the length of shortest transformation sequence from beginword to endword  such that: only one letter can be changed at a time  each transformed word must exist in the word list  note that beginword is not a transformed word  note: return 0 if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  medium breadth-first search 
two-end bfs in java 31ms  word ladder given two words (beginword and endword)  and a dictionary's word list  find the length of shortest transformation sequence from beginword to endword  such that: only one letter can be changed at a time  each transformed word must exist in the word list  note that beginword is not a transformed word  note: return 0 if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  medium breadth-first search 
java solution using bfs  with explanation word ladder given two words (beginword and endword)  and a dictionary's word list  find the length of shortest transformation sequence from beginword to endword  such that: only one letter can be changed at a time  each transformed word must exist in the word list  note that beginword is not a transformed word  note: return 0 if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  medium breadth-first search 
share my two python solutions: a very concise one (12 lines  ~160ms) and an optimized solution(~100ms) word ladder given two words (beginword and endword)  and a dictionary's word list  find the length of shortest transformation sequence from beginword to endword  such that: only one letter can be changed at a time  each transformed word must exist in the word list  note that beginword is not a transformed word  note: return 0 if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  medium breadth-first search 
another accepted java solution (bfs) word ladder given two words (beginword and endword)  and a dictionary's word list  find the length of shortest transformation sequence from beginword to endword  such that: only one letter can be changed at a time  each transformed word must exist in the word list  note that beginword is not a transformed word  note: return 0 if there is no such transformation sequence  all words have the same length  all words contain only lowercase alphabetic characters  you may assume no duplicates in the word list  you may assume beginword and endword are non-empty and are not the same  medium breadth-first search 
my really simple java o(n) solution - accepted longest consecutive sequence given an unsorted array of integers  find the length of the longest consecutive elements sequence  your algorithm should run in o(n) complexity  hard array union find 
simple o(n) with explanation - just walk each streak longest consecutive sequence given an unsorted array of integers  find the length of the longest consecutive elements sequence  your algorithm should run in o(n) complexity  hard array union find 
possibly shortest cpp solution  only 6 lines  longest consecutive sequence given an unsorted array of integers  find the length of the longest consecutive elements sequence  your algorithm should run in o(n) complexity  hard array union find 
simple fast java solution using set longest consecutive sequence given an unsorted array of integers  find the length of the longest consecutive elements sequence  your algorithm should run in o(n) complexity  hard array union find 
a simple c++ solution using unordered_set and simple consideration about this problem longest consecutive sequence given an unsorted array of integers  find the length of the longest consecutive elements sequence  your algorithm should run in o(n) complexity  hard array union find 
short java solution  recursion  sum root to leaf numbers given a binary tree containing digits from 0-9 only  each root-to-leaf path could represent a number  an medium tree depth-first search 
can you improve this algorithm? sum root to leaf numbers given a binary tree containing digits from 0-9 only  each root-to-leaf path could represent a number  an medium tree depth-first search 
python solutions (dfs+stack  bfs+queue  dfs recursively)  sum root to leaf numbers given a binary tree containing digits from 0-9 only  each root-to-leaf path could represent a number  an medium tree depth-first search 
clean java dfs solution (preorder traversal) sum root to leaf numbers given a binary tree containing digits from 0-9 only  each root-to-leaf path could represent a number  an medium tree depth-first search 
one of the easier solution using preorder traversal (recursion) sum root to leaf numbers given a binary tree containing digits from 0-9 only  each root-to-leaf path could represent a number  an medium tree depth-first search 
a really simple and readable c++ solution uff0conly cost 12ms surrounded regions given a 2d board containing 'x' and 'o' (the letter o)  capture all regions surrounded by 'x'  a region is captured by flipping all 'o's into 'x's in that surrounded region  medium depth-first search breadth-first search union find 
solve it using union find surrounded regions given a 2d board containing 'x' and 'o' (the letter o)  capture all regions surrounded by 'x'  a region is captured by flipping all 'o's into 'x's in that surrounded region  medium depth-first search breadth-first search union find 
9 lines  python 148 ms surrounded regions given a 2d board containing 'x' and 'o' (the letter o)  capture all regions surrounded by 'x'  a region is captured by flipping all 'o's into 'x's in that surrounded region  medium depth-first search breadth-first search union find 
java dfs + boundary cell turning solution  simple and clean code  commented  surrounded regions given a 2d board containing 'x' and 'o' (the letter o)  capture all regions surrounded by 'x'  a region is captured by flipping all 'o's into 'x's in that surrounded region  medium depth-first search breadth-first search union find 
my bfs solution (c++ 28ms) surrounded regions given a 2d board containing 'x' and 'o' (the letter o)  capture all regions surrounded by 'x'  a region is captured by flipping all 'o's into 'x's in that surrounded region  medium depth-first search breadth-first search union find 
java: backtracking solution  palindrome partitioning given a string s  partition s such that every substring of the partition is a palindrome  return all possible palindrome partitioning of s  medium backtracking 
my java dp only solution without recursion  o(n^2) palindrome partitioning given a string s  partition s such that every substring of the partition is a palindrome  return all possible palindrome partitioning of s  medium backtracking 
clean c++ backtracking solution palindrome partitioning given a string s  partition s such that every substring of the partition is a palindrome  return all possible palindrome partitioning of s  medium backtracking 
java dp + dfs solution palindrome partitioning given a string s  partition s such that every substring of the partition is a palindrome  return all possible palindrome partitioning of s  medium backtracking 
python recursive iterative backtracking solution palindrome partitioning given a string s  partition s such that every substring of the partition is a palindrome  return all possible palindrome partitioning of s  medium backtracking 
my solution does not need a table for palindrome  is it right ? it uses only o(n) space  palindrome partitioning ii given a string s  partition s such that every substring of the partition is a palindrome  return the minimum cuts needed for a palindrome partitioning of s  hard dynamic programming 
easiest java dp solution (97 36%) palindrome partitioning ii given a string s  partition s such that every substring of the partition is a palindrome  return the minimum cuts needed for a palindrome partitioning of s  hard dynamic programming 
my dp solution ( explanation and code) palindrome partitioning ii given a string s  partition s such that every substring of the partition is a palindrome  return the minimum cuts needed for a palindrome partitioning of s  hard dynamic programming 
two c++ versions given (one dp 28ms  one manancher-like algorithm 10 ms) palindrome partitioning ii given a string s  partition s such that every substring of the partition is a palindrome  return the minimum cuts needed for a palindrome partitioning of s  hard dynamic programming 
dp solution & some thoughts palindrome partitioning ii given a string s  partition s such that every substring of the partition is a palindrome  return the minimum cuts needed for a palindrome partitioning of s  hard dynamic programming 
depth first simple java solution clone graph given the head of a graph  return a deep copy (clone) of the graph  each node in the graph contains a label (int) and a list (list[undirectedgraphnode]) of its neighbors  there is an edge between the given node and each of the nodes in its neighbors  oj's undirected graph serialization (so you can understand error output): nodes are labeled uniquely  we use # as a separator for each node  and   as a separator for node label and each neighbor of the node  as an medium depth-first search breadth-first search graph 
7-17 lines c++ bfs dfs solutions clone graph given the head of a graph  return a deep copy (clone) of the graph  each node in the graph contains a label (int) and a list (list[undirectedgraphnode]) of its neighbors  there is an edge between the given node and each of the nodes in its neighbors  oj's undirected graph serialization (so you can understand error output): nodes are labeled uniquely  we use # as a separator for each node  and   as a separator for node label and each neighbor of the node  as an medium depth-first search breadth-first search graph 
simple java iterative bfs solution with hashmap and queue clone graph given the head of a graph  return a deep copy (clone) of the graph  each node in the graph contains a label (int) and a list (list[undirectedgraphnode]) of its neighbors  there is an edge between the given node and each of the nodes in its neighbors  oj's undirected graph serialization (so you can understand error output): nodes are labeled uniquely  we use # as a separator for each node  and   as a separator for node label and each neighbor of the node  as an medium depth-first search breadth-first search graph 
9 line c++ dfs solution clone graph given the head of a graph  return a deep copy (clone) of the graph  each node in the graph contains a label (int) and a list (list[undirectedgraphnode]) of its neighbors  there is an edge between the given node and each of the nodes in its neighbors  oj's undirected graph serialization (so you can understand error output): nodes are labeled uniquely  we use # as a separator for each node  and   as a separator for node label and each neighbor of the node  as an medium depth-first search breadth-first search graph 
java bfs solution clone graph given the head of a graph  return a deep copy (clone) of the graph  each node in the graph contains a label (int) and a list (list[undirectedgraphnode]) of its neighbors  there is an edge between the given node and each of the nodes in its neighbors  oj's undirected graph serialization (so you can understand error output): nodes are labeled uniquely  we use # as a separator for each node  and   as a separator for node label and each neighbor of the node  as an medium depth-first search breadth-first search graph 
share some of my ideas  gas station there are n gas stations along a circular route  where the amount of gas at station i is gas[i]  you have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1)  you begin the journey with an empty tank at one of the gas stations  return the starting gas station's index if you can travel around the circuit once in the clockwise direction  otherwise return -1  note: if there exists a solution  it is guaranteed to be unique  both input arrays are non-empty and have the same length  each element in the input arrays is a non-negative integer  medium greedy 
my ac is o(1) space o(n) running time solution  does anybody have posted this solution? gas station there are n gas stations along a circular route  where the amount of gas at station i is gas[i]  you have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1)  you begin the journey with an empty tank at one of the gas stations  return the starting gas station's index if you can travel around the circuit once in the clockwise direction  otherwise return -1  note: if there exists a solution  it is guaranteed to be unique  both input arrays are non-empty and have the same length  each element in the input arrays is a non-negative integer  medium greedy 
proof of "if total gas is greater than total cost  there is a solution"  c++ gas station there are n gas stations along a circular route  where the amount of gas at station i is gas[i]  you have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1)  you begin the journey with an empty tank at one of the gas stations  return the starting gas station's index if you can travel around the circuit once in the clockwise direction  otherwise return -1  note: if there exists a solution  it is guaranteed to be unique  both input arrays are non-empty and have the same length  each element in the input arrays is a non-negative integer  medium greedy 
my one pass solution  gas station there are n gas stations along a circular route  where the amount of gas at station i is gas[i]  you have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1)  you begin the journey with an empty tank at one of the gas stations  return the starting gas station's index if you can travel around the circuit once in the clockwise direction  otherwise return -1  note: if there exists a solution  it is guaranteed to be unique  both input arrays are non-empty and have the same length  each element in the input arrays is a non-negative integer  medium greedy 
fully-commented o(n) c++ solution enabled by a single observation of mine gas station there are n gas stations along a circular route  where the amount of gas at station i is gas[i]  you have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1)  you begin the journey with an empty tank at one of the gas stations  return the starting gas station's index if you can travel around the circuit once in the clockwise direction  otherwise return -1  note: if there exists a solution  it is guaranteed to be unique  both input arrays are non-empty and have the same length  each element in the input arrays is a non-negative integer  medium greedy 
a simple solution candy there are n children standing in a line  each child is assigned a rating value  you are giving candies to these children subjected to the following requirements: each child must have at least one candy  children with a higher rating get more candies than their neighbors  what is the minimum candies you must give? hard greedy 
one-pass constant space java solution candy there are n children standing in a line  each child is assigned a rating value  you are giving candies to these children subjected to the following requirements: each child must have at least one candy  children with a higher rating get more candies than their neighbors  what is the minimum candies you must give? hard greedy 
simple o(n) java solution with comments candy there are n children standing in a line  each child is assigned a rating value  you are giving candies to these children subjected to the following requirements: each child must have at least one candy  children with a higher rating get more candies than their neighbors  what is the minimum candies you must give? hard greedy 
very simple java solution with detail explanation candy there are n children standing in a line  each child is assigned a rating value  you are giving candies to these children subjected to the following requirements: each child must have at least one candy  children with a higher rating get more candies than their neighbors  what is the minimum candies you must give? hard greedy 
two c++ solutions given with explanation (both with o(n) time  one with o(1) space  the other with o(n) space) candy there are n children standing in a line  each child is assigned a rating value  you are giving candies to these children subjected to the following requirements: each child must have at least one candy  children with a higher rating get more candies than their neighbors  what is the minimum candies you must give? hard greedy 
my o(n) solution using xor single number given a non-empty array of integers  every element appears twice except for one  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? easy hash table bit manipulation 
easiest way to solve by using bit manipulation  single number given a non-empty array of integers  every element appears twice except for one  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? easy hash table bit manipulation 
easy java solution (tell you why using bitwise xor) single number given a non-empty array of integers  every element appears twice except for one  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? easy hash table bit manipulation 
python different solutions  single number given a non-empty array of integers  every element appears twice except for one  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? easy hash table bit manipulation 
my very simple solution (linear time  no extra memory) single number given a non-empty array of integers  every element appears twice except for one  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? easy hash table bit manipulation 
challenge me   thx single number ii given a non-empty array of integers  every element appears three times except for one  which appears exactly once  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? medium bit manipulation 
detailed explanation and generalization of the bitwise operation method for single numbers single number ii given a non-empty array of integers  every element appears three times except for one  which appears exactly once  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? medium bit manipulation 
an general way to handle all this sort of questions  single number ii given a non-empty array of integers  every element appears three times except for one  which appears exactly once  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? medium bit manipulation 
java o(n) easy to understand solution  easily extended to any times of occurance single number ii given a non-empty array of integers  every element appears three times except for one  which appears exactly once  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? medium bit manipulation 
accepted code with proper explaination  does anyone have a better idea? single number ii given a non-empty array of integers  every element appears three times except for one  which appears exactly once  find that single one  note: your algorithm should have a linear runtime complexity  could you implement it without using extra memory? medium bit manipulation 
a solution with constant space complexity o(1) and linear time complexity o(n) copy list with random pointer a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null  return a deep copy of the list  medium hash table linked list 
java o(n) solution copy list with random pointer a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null  return a deep copy of the list  medium hash table linked list 
2 clean c++ algorithms without using extra array hash table   algorithms are explained step by step  copy list with random pointer a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null  return a deep copy of the list  medium hash table linked list 
clear and short python o(2n) and o(n) solution copy list with random pointer a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null  return a deep copy of the list  medium hash table linked list 
my accepted java code  o(n) but need to iterate the list 3 times copy list with random pointer a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null  return a deep copy of the list  medium hash table linked list 
java implementation using dp in two ways word break given a non-empty string s and a dictionary worddict containing a list of non-empty words  determine if s can be segmented into a space-separated sequence of one or more dictionary words  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  medium dynamic programming 
c++ dynamic programming simple and fast solution (4ms) with optimization word break given a non-empty string s and a dictionary worddict containing a list of non-empty words  determine if s can be segmented into a space-separated sequence of one or more dictionary words  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  medium dynamic programming 
a solution using bfs word break given a non-empty string s and a dictionary worddict containing a list of non-empty words  determine if s can be segmented into a space-separated sequence of one or more dictionary words  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  medium dynamic programming 
simple dp solution in python with description word break given a non-empty string s and a dictionary worddict containing a list of non-empty words  determine if s can be segmented into a space-separated sequence of one or more dictionary words  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  medium dynamic programming 
4 lines in python word break given a non-empty string s and a dictionary worddict containing a list of non-empty words  determine if s can be segmented into a space-separated sequence of one or more dictionary words  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  medium dynamic programming 
my concise java solution based on memorized dfs word break ii given a non-empty string s and a dictionary worddict containing a list of non-empty words  add spaces in s to construct a sentence where each word is a valid dictionary word  return all such possible sentences  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  hard dynamic programming backtracking 
11ms c++ solution (concise) word break ii given a non-empty string s and a dictionary worddict containing a list of non-empty words  add spaces in s to construct a sentence where each word is a valid dictionary word  return all such possible sentences  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  hard dynamic programming backtracking 
getting rid of tle word break ii given a non-empty string s and a dictionary worddict containing a list of non-empty words  add spaces in s to construct a sentence where each word is a valid dictionary word  return all such possible sentences  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  hard dynamic programming backtracking 
9 lines python  10 lines c++ word break ii given a non-empty string s and a dictionary worddict containing a list of non-empty words  add spaces in s to construct a sentence where each word is a valid dictionary word  return all such possible sentences  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  hard dynamic programming backtracking 
python easy-to-understand solution word break ii given a non-empty string s and a dictionary worddict containing a list of non-empty words  add spaces in s to construct a sentence where each word is a valid dictionary word  return all such possible sentences  note: the same word in the dictionary may be reused multiple times in the segmentation  you may assume the dictionary does not contain duplicate words  hard dynamic programming backtracking 
o(1) space solution linked list cycle given a linked list  determine if it has a cycle in it  follow up: can you solve it without using extra space? easy linked list two pointers 
except-ionally fast python linked list cycle given a linked list  determine if it has a cycle in it  follow up: can you solve it without using extra space? easy linked list two pointers 
my faster and slower runner solution linked list cycle given a linked list  determine if it has a cycle in it  follow up: can you solve it without using extra space? easy linked list two pointers 
simple and easy understanding java solution  time  o(n)  space o(1) linked list cycle given a linked list  determine if it has a cycle in it  follow up: can you solve it without using extra space? easy linked list two pointers 
by saying using no extra space  does it mean o(0) in space? linked list cycle given a linked list  determine if it has a cycle in it  follow up: can you solve it without using extra space? easy linked list two pointers 
o(n) solution by using two pointers without change anything linked list cycle ii given a linked list  return the node where the cycle begins  if there is no cycle  return null  note: do not modify the linked list  follow up: can you solve it without using extra space? medium linked list two pointers 
concise o(n) solution by using c++ with detailed alogrithm description linked list cycle ii given a linked list  return the node where the cycle begins  if there is no cycle  return null  note: do not modify the linked list  follow up: can you solve it without using extra space? medium linked list two pointers 
java o(1) space solution with detailed explanation  linked list cycle ii given a linked list  return the node where the cycle begins  if there is no cycle  return null  note: do not modify the linked list  follow up: can you solve it without using extra space? medium linked list two pointers 
concise java solution based on slow fast pointers linked list cycle ii given a linked list  return the node where the cycle begins  if there is no cycle  return null  note: do not modify the linked list  follow up: can you solve it without using extra space? medium linked list two pointers 
share my python solution with detailed explanation linked list cycle ii given a linked list  return the node where the cycle begins  if there is no cycle  return null  note: do not modify the linked list  follow up: can you solve it without using extra space? medium linked list two pointers 
java solution with 3 steps reorder list given a singly linked list l: l0→l1→…→ln-1→ln  reorder it to: l0→ln→l1→ln-1→l2→ln-2→… you may not modify the values in the list's nodes  only nodes itself may be changed  medium linked list 
a concise o(n) time  o(1) in place solution reorder list given a singly linked list l: l0→l1→…→ln-1→ln  reorder it to: l0→ln→l1→ln-1→l2→ln-2→… you may not modify the values in the list's nodes  only nodes itself may be changed  medium linked list 
java solution with 3 steps reorder list given a singly linked list l: l0→l1→…→ln-1→ln  reorder it to: l0→ln→l1→ln-1→l2→ln-2→… you may not modify the values in the list's nodes  only nodes itself may be changed  medium linked list 
a python solution o(n) time  o(1) space reorder list given a singly linked list l: l0→l1→…→ln-1→ln  reorder it to: l0→ln→l1→ln-1→l2→ln-2→… you may not modify the values in the list's nodes  only nodes itself may be changed  medium linked list 
my o(n) c++ method  accepted reorder list given a singly linked list l: l0→l1→…→ln-1→ln  reorder it to: l0→ln→l1→ln-1→l2→ln-2→… you may not modify the values in the list's nodes  only nodes itself may be changed  medium linked list 
accepted iterative solution in java using stack  binary tree preorder traversal given a binary tree  return the preorder traversal of its nodes' values  medium stack tree 
3 different solutions binary tree preorder traversal given a binary tree  return the preorder traversal of its nodes' values  medium stack tree 
accepted code  explaination with algo  binary tree preorder traversal given a binary tree  return the preorder traversal of its nodes' values  medium stack tree 
very simple iterative python solution binary tree preorder traversal given a binary tree  return the preorder traversal of its nodes' values  medium stack tree 
easy c++ solution using stack binary tree preorder traversal given a binary tree  return the preorder traversal of its nodes' values  medium stack tree 
preorder  inorder  and postorder iteratively summarization binary tree postorder traversal given a binary tree  return the postorder traversal of its nodes' values  hard stack tree 
my accepted code with explaination  does anyone have a better idea? binary tree postorder traversal given a binary tree  return the postorder traversal of its nodes' values  hard stack tree 
java simple and clean binary tree postorder traversal given a binary tree  return the postorder traversal of its nodes' values  hard stack tree 
c++ iterative  recursive and morris traversal binary tree postorder traversal given a binary tree  return the postorder traversal of its nodes' values  hard stack tree 
a very concise solution binary tree postorder traversal given a binary tree  return the postorder traversal of its nodes' values  hard stack tree 
[java] hashtable + double linked list (with a touch of pseudo nodes) lru cache design and implement a data structure for least recently used (lru) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reached its capacity  it should invalidate the least recently used item before inserting a new item  follow up: could you do both operations in o(1) time complexity? hard design 
python dict + double linkedlist lru cache design and implement a data structure for least recently used (lru) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reached its capacity  it should invalidate the least recently used item before inserting a new item  follow up: could you do both operations in o(1) time complexity? hard design 
laziest implementation: java's linkedhashmap takes care of everything lru cache design and implement a data structure for least recently used (lru) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reached its capacity  it should invalidate the least recently used item before inserting a new item  follow up: could you do both operations in o(1) time complexity? hard design 
c++11 code 74ms - hash table + list lru cache design and implement a data structure for least recently used (lru) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reached its capacity  it should invalidate the least recently used item before inserting a new item  follow up: could you do both operations in o(1) time complexity? hard design 
java-----------easy version to understand!!!! lru cache design and implement a data structure for least recently used (lru) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reached its capacity  it should invalidate the least recently used item before inserting a new item  follow up: could you do both operations in o(1) time complexity? hard design 
an easy and clear way to sort ( o(1) space ) insertion sort list sort a linked list using insertion sort  a graphical medium linked list sort 
thoughts from a google interviewer insertion sort list sort a linked list using insertion sort  a graphical medium linked list sort 
explained c++ solution (24ms) insertion sort list sort a linked list using insertion sort  a graphical medium linked list sort 
accepted solution using java insertion sort list sort a linked list using insertion sort  a graphical medium linked list sort 
clean java solution using a fake head insertion sort list sort a linked list using insertion sort  a graphical medium linked list sort 
java merge sort solution sort list sort a linked list in o(n log n) time using constant space complexity  medium linked list sort 
bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity sort list sort a linked list in o(n log n) time using constant space complexity  medium linked list sort 
i have a pretty good mergesort method  can anyone speed up the run time or reduce the memory usage? sort list sort a linked list in o(n log n) time using constant space complexity  medium linked list sort 
basically  it seems like merge sort problem(really easy understand) sort list sort a linked list in o(n log n) time using constant space complexity  medium linked list sort 
clean python code sort list sort a linked list in o(n log n) time using constant space complexity  medium linked list sort 
a java solution with notes max points on a line given n points on a 2d plane  find the maximum number of points that lie on the same straight line  hard hash table math 
sharing my simple solution with explanation max points on a line given n points on a 2d plane  find the maximum number of points that lie on the same straight line  hard hash table math 
accepted java solution  easy to understand  max points on a line given n points on a 2d plane  find the maximum number of points that lie on the same straight line  hard hash table math 
c++ o(n^2) solution for your reference max points on a line given n points on a 2d plane  find the maximum number of points that lie on the same straight line  hard hash table math 
16ms 28ms c++ solutions with explanations max points on a line given n points on a 2d plane  find the maximum number of points that lie on the same straight line  hard hash table math 
6  uff08-132 uff09= 0 or -1 evaluate reverse polish notation evaluate the value of an arithmetic expression in reverse polish notation  valid operators are +  -        each operand may be an integer or another expression  note: division between two integers should truncate toward zero  the given rpn expression is always valid  that means the expression would always evaluate to a result and there won't be any divide by zero operation  medium stack 
[java] accepted code: stack implementation  evaluate reverse polish notation evaluate the value of an arithmetic expression in reverse polish notation  valid operators are +  -        each operand may be an integer or another expression  note: division between two integers should truncate toward zero  the given rpn expression is always valid  that means the expression would always evaluate to a result and there won't be any divide by zero operation  medium stack 
accepted clean java solution evaluate reverse polish notation evaluate the value of an arithmetic expression in reverse polish notation  valid operators are +  -        each operand may be an integer or another expression  note: division between two integers should truncate toward zero  the given rpn expression is always valid  that means the expression would always evaluate to a result and there won't be any divide by zero operation  medium stack 
fancy c++ lambda expression solution evaluate reverse polish notation evaluate the value of an arithmetic expression in reverse polish notation  valid operators are +  -        each operand may be an integer or another expression  note: division between two integers should truncate toward zero  the given rpn expression is always valid  that means the expression would always evaluate to a result and there won't be any divide by zero operation  medium stack 
python solution with comments (don't use eval() function)  evaluate reverse polish notation evaluate the value of an arithmetic expression in reverse polish notation  valid operators are +  -        each operand may be an integer or another expression  note: division between two integers should truncate toward zero  the given rpn expression is always valid  that means the expression would always evaluate to a result and there won't be any divide by zero operation  medium stack 
clean java two-pointers solution (no trim( )  no split( )  no stringbuilder) reverse words in a string given an input string  reverse the string word by word  medium string 
in place simple solution reverse words in a string given an input string  reverse the string word by word  medium string 
my accepted java solution reverse words in a string given an input string  reverse the string word by word  medium string 
java 3-line builtin solution reverse words in a string given an input string  reverse the string word by word  medium string 
c++ solution  in place: runtime o(n)  memory o(1) reverse words in a string given an input string  reverse the string word by word  medium string 
possibly simplest solution with o(n) time complexity maximum product subarray given an integer array nums  find the contiguous subarray within an array (containing at least one number) which has the largest product  medium array dynamic programming 
sharing my solution: o(1) space  o(n) running time maximum product subarray given an integer array nums  find the contiguous subarray within an array (containing at least one number) which has the largest product  medium array dynamic programming 
simple java code maximum product subarray given an integer array nums  find the contiguous subarray within an array (containing at least one number) which has the largest product  medium array dynamic programming 
share my c++ solution  maybe is the simplest solution maximum product subarray given an integer array nums  find the contiguous subarray within an array (containing at least one number) which has the largest product  medium array dynamic programming 
in python  can it be more concise? maximum product subarray given an integer array nums  find the contiguous subarray within an array (containing at least one number) which has the largest product  medium array dynamic programming 
compact and clean c++ solution find minimum in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  you may assume no duplicate exists in the array  medium array binary search 
4ms simple c++ code with explanation find minimum in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  you may assume no duplicate exists in the array  medium array binary search 
a concise solution with proof in the comment find minimum in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  you may assume no duplicate exists in the array  medium array binary search 
simplest and fastest c++ solution o(lg n)  you can't beat this! find minimum in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  you may assume no duplicate exists in the array  medium array binary search 
java solution with binary search find minimum in rotated sorted array suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  you may assume no duplicate exists in the array  medium array binary search 
my pretty simple code to solve it find minimum in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  the array may contain duplicates  hard array binary search 
one simple and clear method with o(1) space and worst o(n) time find minimum in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  the array may contain duplicates  hard array binary search 
super simple and clean java  binary search  find minimum in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  the array may contain duplicates  hard array binary search 
stop wasting your time  it most likely has to be o(n)  find minimum in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  the array may contain duplicates  hard array binary search 
only two more lines code on top of the solution for part i find minimum in rotated sorted array ii suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find the minimum element  the array may contain duplicates  hard array binary search 
share my java solution with only one stack min stack design a stack that supports push  pop  top  and retrieving the minimum element in constant time  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  getmin() -- retrieve the minimum element in the stack  easy stack design 
java accepted solution using one stack min stack design a stack that supports push  pop  top  and retrieving the minimum element in constant time  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  getmin() -- retrieve the minimum element in the stack  easy stack design 
clean 6ms java solution min stack design a stack that supports push  pop  top  and retrieving the minimum element in constant time  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  getmin() -- retrieve the minimum element in the stack  easy stack design 
c++ using two stacks  quite short and easy to understand min stack design a stack that supports push  pop  top  and retrieving the minimum element in constant time  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  getmin() -- retrieve the minimum element in the stack  easy stack design 
my python solution min stack design a stack that supports push  pop  top  and retrieving the minimum element in constant time  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  getmin() -- retrieve the minimum element in the stack  easy stack design 
java solution without knowing the difference in len! intersection of two linked lists write a program to find the node at which the intersection of two singly linked lists begins  for easy linked list 
my accepted simple and shortest c++ code with comments explaining the algorithm   any comments or improvements? intersection of two linked lists write a program to find the node at which the intersection of two singly linked lists begins  for easy linked list 
concise python code with comments intersection of two linked lists write a program to find the node at which the intersection of two singly linked lists begins  for easy linked list 
concise java solution  o(1) memory o(n) time intersection of two linked lists write a program to find the node at which the intersection of two singly linked lists begins  for easy linked list 
simple c++ solution (5 lines) intersection of two linked lists write a program to find the node at which the intersection of two singly linked lists begins  for easy linked list 
find the maximum by binary search (recursion and iteration) find peak element a peak element is an element that is greater than its neighbors  given an input array nums  where nums[i] ≠ nums[i+1]  find a peak element and return its index  the array may contain multiple peaks  in that case return the index to any one of the peaks is fine  you may imagine that nums[-1] = nums[n] = -∞  medium array binary search 
o(logn) solution javacode find peak element a peak element is an element that is greater than its neighbors  given an input array nums  where nums[i] ≠ nums[i+1]  find a peak element and return its index  the array may contain multiple peaks  in that case return the index to any one of the peaks is fine  you may imagine that nums[-1] = nums[n] = -∞  medium array binary search 
java solution and explanation using invariants find peak element a peak element is an element that is greater than its neighbors  given an input array nums  where nums[i] ≠ nums[i+1]  find a peak element and return its index  the array may contain multiple peaks  in that case return the index to any one of the peaks is fine  you may imagine that nums[-1] = nums[n] = -∞  medium array binary search 
my clean and readable python solution find peak element a peak element is an element that is greater than its neighbors  given an input array nums  where nums[i] ≠ nums[i+1]  find a peak element and return its index  the array may contain multiple peaks  in that case return the index to any one of the peaks is fine  you may imagine that nums[-1] = nums[n] = -∞  medium array binary search 
a concise standard binary search solution find peak element a peak element is an element that is greater than its neighbors  given an input array nums  where nums[i] ≠ nums[i+1]  find a peak element and return its index  the array may contain multiple peaks  in that case return the index to any one of the peaks is fine  you may imagine that nums[-1] = nums[n] = -∞  medium array binary search 
[bucket sort] java solution with explanation  o(n) time and space maximum gap given an unsorted array  find the maximum difference between the successive elements in its sorted form  return 0 if the array contains less than 2 elements  hard sort 
radix sort solution in java with explanation maximum gap given an unsorted array  find the maximum difference between the successive elements in its sorted form  return 0 if the array contains less than 2 elements  hard sort 
pigeon hole principle maximum gap given an unsorted array  find the maximum difference between the successive elements in its sorted form  return 0 if the array contains less than 2 elements  hard sort 
my c++ code (12 ms  "bucket sort"  o(n) time and space) maximum gap given an unsorted array  find the maximum difference between the successive elements in its sorted form  return 0 if the array contains less than 2 elements  hard sort 
i solved it using radix sort maximum gap given an unsorted array  find the maximum difference between the successive elements in its sorted form  return 0 if the array contains less than 2 elements  hard sort 
accepted small java solution  compare version numbers compare two version numbers version1 and version2  if version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0  you may assume that the version strings are non-empty and contain only digits and the   character  the   character does not represent a decimal point and is used to separate number sequences  for instance  2 5 is not "two and a half" or "half way to version three"  it is the fifth second-level revision of the second first-level revision  medium string 
my 2ms easy solution with c c++ compare version numbers compare two version numbers version1 and version2  if version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0  you may assume that the version strings are non-empty and contain only digits and the   character  the   character does not represent a decimal point and is used to separate number sequences  for instance  2 5 is not "two and a half" or "half way to version three"  it is the fifth second-level revision of the second first-level revision  medium string 
cudos on who invent such a boring question compare version numbers compare two version numbers version1 and version2  if version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0  you may assume that the version strings are non-empty and contain only digits and the   character  the   character does not represent a decimal point and is used to separate number sequences  for instance  2 5 is not "two and a half" or "half way to version three"  it is the fifth second-level revision of the second first-level revision  medium string 
my java solution without split compare version numbers compare two version numbers version1 and version2  if version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0  you may assume that the version strings are non-empty and contain only digits and the   character  the   character does not represent a decimal point and is used to separate number sequences  for instance  2 5 is not "two and a half" or "half way to version three"  it is the fifth second-level revision of the second first-level revision  medium string 
java solution with fewer if logic compare version numbers compare two version numbers version1 and version2  if version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0  you may assume that the version strings are non-empty and contain only digits and the   character  the   character does not represent a decimal point and is used to separate number sequences  for instance  2 5 is not "two and a half" or "half way to version three"  it is the fifth second-level revision of the second first-level revision  medium string 
my clean java solution fraction to recurring decimal given two integers representing the numerator and denominator of a fraction  return the fraction in string format  if the fractional part is repeating  enclose the repeating part in parentheses  medium hash table math 
accepted cpp solution  with explainations fraction to recurring decimal given two integers representing the numerator and denominator of a fraction  return the fraction in string format  if the fractional part is repeating  enclose the repeating part in parentheses  medium hash table math 
0ms c++ solution with detailed explanations fraction to recurring decimal given two integers representing the numerator and denominator of a fraction  return the fraction in string format  if the fractional part is repeating  enclose the repeating part in parentheses  medium hash table math 
short java solution fraction to recurring decimal given two integers representing the numerator and denominator of a fraction  return the fraction in string format  if the fractional part is repeating  enclose the repeating part in parentheses  medium hash table math 
accepted clean java solution fraction to recurring decimal given two integers representing the numerator and denominator of a fraction  return the fraction in string format  if the fractional part is repeating  enclose the repeating part in parentheses  medium hash table math 
my 1 lines code in java  c++  and python excel sheet column title given a positive integer  return its corresponding column title as appear in an excel sheet  for easy math 
accepted java solution excel sheet column title given a positive integer  return its corresponding column title as appear in an excel sheet  for easy math 
python solution with explanation excel sheet column title given a positive integer  return its corresponding column title as appear in an excel sheet  for easy math 
share my simple solution  just a little trick to handle corner case 26 excel sheet column title given a positive integer  return its corresponding column title as appear in an excel sheet  for easy math 
my easy to understand java solution excel sheet column title given a positive integer  return its corresponding column title as appear in an excel sheet  for easy math 
o(n) time o(1) space fastest solution majority element given an array of size n  find the majority element  the majority element is the element that appears more than ⌊ n 2 ⌋ times  you may assume that the array is non-empty and the majority element always exist in the array  easy array divide and conquer bit manipulation 
6 suggested solutions in c++ with explanations majority element given an array of size n  find the majority element  the majority element is the element that appears more than ⌊ n 2 ⌋ times  you may assume that the array is non-empty and the majority element always exist in the array  easy array divide and conquer bit manipulation 
java solutions (sorting  hashmap  moore voting  bit manipulation)  majority element given an array of size n  find the majority element  the majority element is the element that appears more than ⌊ n 2 ⌋ times  you may assume that the array is non-empty and the majority element always exist in the array  easy array divide and conquer bit manipulation 
one line solution in python majority element given an array of size n  find the majority element  the majority element is the element that appears more than ⌊ n 2 ⌋ times  you may assume that the array is non-empty and the majority element always exist in the array  easy array divide and conquer bit manipulation 
share my solution [java] - count bits majority element given an array of size n  find the majority element  the majority element is the element that appears more than ⌊ n 2 ⌋ times  you may assume that the array is non-empty and the majority element always exist in the array  easy array divide and conquer bit manipulation 
my solutions in 3 languages  does any one have one line solution in java or c++? excel sheet column number given a column title as appear in an excel sheet  return its corresponding column number  for easy math 
asked this question on an interview excel sheet column number given a column title as appear in an excel sheet  return its corresponding column number  for easy math 
here is my java solution excel sheet column number given a column title as appear in an excel sheet  return its corresponding column number  for easy math 
my 2ms java solution excel sheet column number given a column title as appear in an excel sheet  return its corresponding column number  for easy math 
explanation in python excel sheet column number given a column title as appear in an excel sheet  return its corresponding column number  for easy math 
my one-line solutions in 3 languages factorial trailing zeroes given an integer n  return the number of trailing zeroes in n!  easy math 
simple c c++ solution (with detailed explaination) factorial trailing zeroes given an integer n  return the number of trailing zeroes in n!  easy math 
my explanation of the log(n) solution factorial trailing zeroes given an integer n  return the number of trailing zeroes in n!  easy math 
o(log_5(n)) solution  java factorial trailing zeroes given an integer n  return the number of trailing zeroes in n!  easy math 
4-lines 4ms c++ solution with explanations factorial trailing zeroes given an integer n  return the number of trailing zeroes in n!  easy math 
my solutions in 3 languages with stack binary search tree iterator implement an iterator over a binary search tree (bst)  your iterator will be initialized with the root node of a bst  calling next() will return the next smallest number in the bst  note: next() and hasnext() should run in average o(1) time and uses o(h) memory  where h is the height of the tree  credits:special thanks to @ts for adding this problem and creating all test cases  medium stack tree design 
ideal solution using stack (java) binary search tree iterator implement an iterator over a binary search tree (bst)  your iterator will be initialized with the root node of a bst  calling next() will return the next smallest number in the bst  note: next() and hasnext() should run in average o(1) time and uses o(h) memory  where h is the height of the tree  credits:special thanks to @ts for adding this problem and creating all test cases  medium stack tree design 
my java accepted solution binary search tree iterator implement an iterator over a binary search tree (bst)  your iterator will be initialized with the root node of a bst  calling next() will return the next smallest number in the bst  note: next() and hasnext() should run in average o(1) time and uses o(h) memory  where h is the height of the tree  credits:special thanks to @ts for adding this problem and creating all test cases  medium stack tree design 
my solution in c++  in average o(1) time and uses o(h) memory binary search tree iterator implement an iterator over a binary search tree (bst)  your iterator will be initialized with the root node of a bst  calling next() will return the next smallest number in the bst  note: next() and hasnext() should run in average o(1) time and uses o(h) memory  where h is the height of the tree  credits:special thanks to @ts for adding this problem and creating all test cases  medium stack tree design 
two python solutions  stack and generator binary search tree iterator implement an iterator over a binary search tree (bst)  your iterator will be initialized with the root node of a bst  calling next() will return the next smallest number in the bst  note: next() and hasnext() should run in average o(1) time and uses o(h) memory  where h is the height of the tree  credits:special thanks to @ts for adding this problem and creating all test cases  medium stack tree design 
c++ dp solution dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } the demons had captured the princess (p) and imprisoned her in the bottom-right corner of a dungeon  the dungeon consists of m x n rooms laid out in a 2d grid  our valiant knight (k) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess  the knight has an initial health point represented by a positive integer  if at any point his health point drops to 0 or below  he dies immediately  some of the rooms are guarded by demons  so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers)  in order to reach the princess as quickly as possible  the knight decides to move only rightward or downward in each step  write a function to determine the knight's minimum initial health so that he is able to rescue the princess  for hard binary search dynamic programming 
my ac java version  suggestions are welcome dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } the demons had captured the princess (p) and imprisoned her in the bottom-right corner of a dungeon  the dungeon consists of m x n rooms laid out in a 2d grid  our valiant knight (k) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess  the knight has an initial health point represented by a positive integer  if at any point his health point drops to 0 or below  he dies immediately  some of the rooms are guarded by demons  so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers)  in order to reach the princess as quickly as possible  the knight decides to move only rightward or downward in each step  write a function to determine the knight's minimum initial health so that he is able to rescue the princess  for hard binary search dynamic programming 
best solution i have found with explanations dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } the demons had captured the princess (p) and imprisoned her in the bottom-right corner of a dungeon  the dungeon consists of m x n rooms laid out in a 2d grid  our valiant knight (k) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess  the knight has an initial health point represented by a positive integer  if at any point his health point drops to 0 or below  he dies immediately  some of the rooms are guarded by demons  so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers)  in order to reach the princess as quickly as possible  the knight decides to move only rightward or downward in each step  write a function to determine the knight's minimum initial health so that he is able to rescue the princess  for hard binary search dynamic programming 
my java solution with explanation in detail dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } the demons had captured the princess (p) and imprisoned her in the bottom-right corner of a dungeon  the dungeon consists of m x n rooms laid out in a 2d grid  our valiant knight (k) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess  the knight has an initial health point represented by a positive integer  if at any point his health point drops to 0 or below  he dies immediately  some of the rooms are guarded by demons  so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers)  in order to reach the princess as quickly as possible  the knight decides to move only rightward or downward in each step  write a function to determine the knight's minimum initial health so that he is able to rescue the princess  for hard binary search dynamic programming 
sharing my solution with o(n) space  o(mn) runtime dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } the demons had captured the princess (p) and imprisoned her in the bottom-right corner of a dungeon  the dungeon consists of m x n rooms laid out in a 2d grid  our valiant knight (k) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess  the knight has an initial health point represented by a positive integer  if at any point his health point drops to 0 or below  he dies immediately  some of the rooms are guarded by demons  so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers)  in order to reach the princess as quickly as possible  the knight decides to move only rightward or downward in each step  write a function to determine the knight's minimum initial health so that he is able to rescue the princess  for hard binary search dynamic programming 
its a simple question of left join  my solution attached combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid is the primary key column for this table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid is the primary key column for this table  write a sql query for a report that provides the following information for each person in the person table  regardless if there is an address for each of those people: firstname  lastname  city  state easy 
comparative solution between left join  left join using and natural left join combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid is the primary key column for this table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid is the primary key column for this table  write a sql query for a report that provides the following information for each person in the person table  regardless if there is an address for each of those people: firstname  lastname  city  state easy 
why cannot using where combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid is the primary key column for this table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid is the primary key column for this table  write a sql query for a report that provides the following information for each person in the person table  regardless if there is an address for each of those people: firstname  lastname  city  state easy 
my solution and question with union combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid is the primary key column for this table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid is the primary key column for this table  write a sql query for a report that provides the following information for each person in the person table  regardless if there is an address for each of those people: firstname  lastname  city  state easy 
so watch your capitalization carefully uff01 combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid is the primary key column for this table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid is the primary key column for this table  write a sql query for a report that provides the following information for each person in the person table  regardless if there is an address for each of those people: firstname  lastname  city  state easy 
simple query which handles the null situation second highest salary sql schemawrite a sql query to get the second highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for easy 
a simple answer second highest salary sql schemawrite a sql query to get the second highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for easy 
accepted solution second highest salary sql schemawrite a sql query to get the second highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for easy 
my tidy soution second highest salary sql schemawrite a sql query to get the second highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for easy 
simple solution second highest salary sql schemawrite a sql query to get the second highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for easy 
accpted solution for the nth highest salary nth highest salary write a sql query to get the nth highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for medium 
my accepted simply solution any advising? nth highest salary write a sql query to get the nth highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for medium 
no variable  no limit x 1  just one query  808ms nth highest salary write a sql query to get the nth highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for medium 
why using limit n-1 1 will cause error? nth highest salary write a sql query to get the nth highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for medium 
accepted solution of nth highest salary nth highest salary write a sql query to get the nth highest salary from the employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ for medium 
simple  short  fast rank scores sql schemawrite a sql query to rank scores  if there is a tie between two scores  both should have the same ranking  note that after a tie  the next ranking number should be the next consecutive integer value  in other words  there should be no "holes" between ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ for medium 
accepted solution using innerjoin and groupby rank scores sql schemawrite a sql query to rank scores  if there is a tie between two scores  both should have the same ranking  note that after a tie  the next ranking number should be the next consecutive integer value  in other words  there should be no "holes" between ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ for medium 
maybe the simpest solution rank scores sql schemawrite a sql query to rank scores  if there is a tie between two scores  both should have the same ranking  note that after a tie  the next ranking number should be the next consecutive integer value  in other words  there should be no "holes" between ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ for medium 
accepted solution with subqueries and group by rank scores sql schemawrite a sql query to rank scores  if there is a tie between two scores  both should have the same ranking  note that after a tie  the next ranking number should be the next consecutive integer value  in other words  there should be no "holes" between ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ for medium 
accepted solution with subquery for rank rank scores sql schemawrite a sql query to rank scores  if there is a tie between two scores  both should have the same ranking  note that after a tie  the next ranking number should be the next consecutive integer value  in other words  there should be no "holes" between ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ for medium 
my java solution to share largest number given a list of non negative integers  arrange them such that they form the largest number  medium sort 
a simple c++ solution largest number given a list of non negative integers  arrange them such that they form the largest number  medium sort 
my 3-lines code in java and python largest number given a list of non negative integers  arrange them such that they form the largest number  medium sort 
share a short code in c++ largest number given a list of non negative integers  arrange them such that they form the largest number  medium sort 
python simple solution in 4 lines largest number given a list of non negative integers  arrange them such that they form the largest number  medium sort 
simple solution consecutive numbers sql schemawrite a sql query to find all numbers that appear at least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ for medium 
solution with user defined variables consecutive numbers sql schemawrite a sql query to find all numbers that appear at least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ for medium 
an ugly solution consecutive numbers sql schemawrite a sql query to find all numbers that appear at least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ for medium 
accepted solution without joins (works in n-consecutive cases with slight modification) consecutive numbers sql schemawrite a sql query to find all numbers that appear at least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ for medium 
simple sql with join  1484 ms consecutive numbers sql schemawrite a sql query to find all numbers that appear at least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ for medium 
a straightforward method employees earning more than their managers sql schemathe employee table holds all employees including their managers  every employee has an id  and there is also a column for the manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given the employee table  write a sql query that finds out employees who earn more than their managers  for the above table  joe is the only employee who earns more than his manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
sharing my solution~   simple and easy to understand employees earning more than their managers sql schemathe employee table holds all employees including their managers  every employee has an id  and there is also a column for the manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given the employee table  write a sql query that finds out employees who earn more than their managers  for the above table  joe is the only employee who earns more than his manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
sharing my solution employees earning more than their managers sql schemathe employee table holds all employees including their managers  every employee has an id  and there is also a column for the manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given the employee table  write a sql query that finds out employees who earn more than their managers  for the above table  joe is the only employee who earns more than his manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
an easy solution to this question  employees earning more than their managers sql schemathe employee table holds all employees including their managers  every employee has an id  and there is also a column for the manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given the employee table  write a sql query that finds out employees who earn more than their managers  for the above table  joe is the only employee who earns more than his manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
two straightforward way  using 'where' and 'join' employees earning more than their managers sql schemathe employee table holds all employees including their managers  every employee has an id  and there is also a column for the manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given the employee table  write a sql query that finds out employees who earn more than their managers  for the above table  joe is the only employee who earns more than his manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
i have this simple approach  anybody has some other way duplicate emails sql schemawrite a sql query to find all duplicate emails in a table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ for easy 
my simple accepted solution duplicate emails sql schemawrite a sql query to find all duplicate emails in a table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ for easy 
a solution using a group by and another one using a self join duplicate emails sql schemawrite a sql query to find all duplicate emails in a table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ for easy 
share my solution duplicate emails sql schemawrite a sql query to find all duplicate emails in a table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ for easy 
simple solution use group by duplicate emails sql schemawrite a sql query to find all duplicate emails in a table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ for easy 
three accepted solutions customers who never order sql schemasuppose that a website contains two tables  the customers table and the orders table  write a sql query to find all customers who never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using the above tables as easy 
a solution using not in and another one using left join customers who never order sql schemasuppose that a website contains two tables  the customers table and the orders table  write a sql query to find all customers who never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using the above tables as easy 
here are 3 solutions customers who never order sql schemasuppose that a website contains two tables  the customers table and the orders table  write a sql query to find all customers who never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using the above tables as easy 
share my first db answer customers who never order sql schemasuppose that a website contains two tables  the customers table and the orders table  write a sql query to find all customers who never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using the above tables as easy 
mysql solution using not in customers who never order sql schemasuppose that a website contains two tables  the customers table and the orders table  write a sql query to find all customers who never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using the above tables as easy 
three accpeted solutions department highest salary sql schemathe employee table holds all employees  every employee has an id  a salary  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who have the highest salary in each of the departments  for the above tables  max has the highest salary in the it department and henry has the highest salary in the sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
simple solution  easy to understand department highest salary sql schemathe employee table holds all employees  every employee has an id  a salary  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who have the highest salary in each of the departments  for the above tables  max has the highest salary in the it department and henry has the highest salary in the sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
sharing my simple solution department highest salary sql schemathe employee table holds all employees  every employee has an id  a salary  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who have the highest salary in each of the departments  for the above tables  max has the highest salary in the it department and henry has the highest salary in the sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
group by having not working for multiple highest salary  why? department highest salary sql schemathe employee table holds all employees  every employee has an id  a salary  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who have the highest salary in each of the departments  for the above tables  max has the highest salary in the it department and henry has the highest salary in the sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
why cannot we just use max() with group by? department highest salary sql schemathe employee table holds all employees  every employee has an id  a salary  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who have the highest salary in each of the departments  for the above tables  max has the highest salary in the it department and henry has the highest salary in the sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
accepted solution without group by or order by department top three salaries sql schemathe employee table holds all employees  every employee has an id  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who earn the top three salaries in each of the department  for the above tables  your sql query should return the following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | it | randy | 85000 | | it | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
my tidy solution department top three salaries sql schemathe employee table holds all employees  every employee has an id  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who earn the top three salaries in each of the department  for the above tables  your sql query should return the following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | it | randy | 85000 | | it | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
simple solution  easy to understand department top three salaries sql schemathe employee table holds all employees  every employee has an id  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who earn the top three salaries in each of the department  for the above tables  your sql query should return the following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | it | randy | 85000 | | it | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
best solution  clean  easy  no subquery department top three salaries sql schemathe employee table holds all employees  every employee has an id  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who earn the top three salaries in each of the department  for the above tables  your sql query should return the following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | it | randy | 85000 | | it | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
simple solution for 1112 ms department top three salaries sql schemathe employee table holds all employees  every employee has an id  and there is also a column for the department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ the department table holds all departments of the company  +----+----------+ | id | name | +----+----------+ | 1 | it | | 2 | sales | +----+----------+ write a sql query to find employees who earn the top three salaries in each of the department  for the above tables  your sql query should return the following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | it | max | 90000 | | it | randy | 85000 | | it | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
7 lines simple java  o(n) repeated dna sequences all dna is composed of a series of nucleotides abbreviated as a  c  g  and t  for medium hash table bit manipulation 
clean java solution (hashmap + bits manipulation) repeated dna sequences all dna is composed of a series of nucleotides abbreviated as a  c  g  and t  for medium hash table bit manipulation 
i did it in 10 lines of c++ repeated dna sequences all dna is composed of a series of nucleotides abbreviated as a  c  g  and t  for medium hash table bit manipulation 
short java "rolling-hash" solution repeated dna sequences all dna is composed of a series of nucleotides abbreviated as a  c  g  and t  for medium hash table bit manipulation 
20 ms solution (c++) with explanation repeated dna sequences all dna is composed of a series of nucleotides abbreviated as a  c  g  and t  for medium hash table bit manipulation 
a concise dp solution in java best time to buy and sell stock iv say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most k transactions  note: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  hard dynamic programming 
clean java dp solution with comment best time to buy and sell stock iv say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most k transactions  note: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  hard dynamic programming 
c++ solution with o(n + klgn) time using max heap and stack best time to buy and sell stock iv say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most k transactions  note: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  hard dynamic programming 
share my c++ dp solution with o(kn) time o(k) space  10ms best time to buy and sell stock iv say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most k transactions  note: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  hard dynamic programming 
easy understanding and can be easily modified to different situations java solution best time to buy and sell stock iv say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete at most k transactions  note: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  hard dynamic programming 
easy to read java solution rotate array given an array  rotate the array to the right by k steps  where k is non-negative  easy array 
summary of c++ solutions rotate array given an array  rotate the array to the right by k steps  where k is non-negative  easy array 
java o(1) space solution of rotate array  rotate array given an array  rotate the array to the right by k steps  where k is non-negative  easy array 
3-line using reverse rotate array given an array  rotate the array to the right by k steps  where k is non-negative  easy array 
my solution by using python rotate array given an array  rotate the array to the right by k steps  where k is non-negative  easy array 
o(1) bit operation c++ solution (8ms) reverse bits reverse bits of a given 32 bits unsigned integer  easy bit manipulation 
java solution and optimization reverse bits reverse bits of a given 32 bits unsigned integer  easy bit manipulation 
sharing my 2ms java solution with explanation reverse bits reverse bits of a given 32 bits unsigned integer  easy bit manipulation 
my 3ms pure c solution reverse bits reverse bits of a given 32 bits unsigned integer  easy bit manipulation 
the concise c++ solution(9ms) reverse bits reverse bits of a given 32 bits unsigned integer  easy bit manipulation 
simple java solution  bit shifting number of 1 bits write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the hamming weight)  easy bit manipulation 
short code of c++  o(m) by time  m is the count of 1's   and another several method of o(1) time number of 1 bits write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the hamming weight)  easy bit manipulation 
c++ solution: n & (n - 1) number of 1 bits write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the hamming weight)  easy bit manipulation 
readable simple java solution o(1) number of 1 bits write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the hamming weight)  easy bit manipulation 
use n=n&(n-1) trick to clear the least bit number of 1 bits write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the hamming weight)  easy bit manipulation 
my simple solution (one line with pipe) word frequency write a bash script to calculate the frequency of each word in a text file words txt  for simplicity sake  you may assume: words txt contains only lowercase characters and space ' ' characters  each word must consist of lowercase characters only  words are separated by one or more whitespace characters  medium 
solution using awk and pipes with explaination word frequency write a bash script to calculate the frequency of each word in a text file words txt  for simplicity sake  you may assume: words txt contains only lowercase characters and space ' ' characters  each word must consist of lowercase characters only  words are separated by one or more whitespace characters  medium 
my accepted answer using tr  sort  uniq and awk word frequency write a bash script to calculate the frequency of each word in a text file words txt  for simplicity sake  you may assume: words txt contains only lowercase characters and space ' ' characters  each word must consist of lowercase characters only  words are separated by one or more whitespace characters  medium 
share my accepted solution  using awk and sort! word frequency write a bash script to calculate the frequency of each word in a text file words txt  for simplicity sake  you may assume: words txt contains only lowercase characters and space ' ' characters  each word must consist of lowercase characters only  words are separated by one or more whitespace characters  medium 
my 16ms unix-pipe cat+tr+awk+sort+(hash) solution word frequency write a bash script to calculate the frequency of each word in a text file words txt  for simplicity sake  you may assume: words txt contains only lowercase characters and space ' ' characters  each word must consist of lowercase characters only  words are separated by one or more whitespace characters  medium 
three different solutions using grep  sed  and awk valid phone numbers given a text file file txt that contains list of phone numbers (one per line)  write a one liner bash script to print all valid phone numbers  you may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx  (x means a digit) you may also assume each line in the text file must not contain leading or trailing white spaces  easy 
grep -e solution with detailed explanation  good for those new to regex valid phone numbers given a text file file txt that contains list of phone numbers (one per line)  write a one liner bash script to print all valid phone numbers  you may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx  (x means a digit) you may also assume each line in the text file must not contain leading or trailing white spaces  easy 
simple solution using awk valid phone numbers given a text file file txt that contains list of phone numbers (one per line)  write a one liner bash script to print all valid phone numbers  you may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx  (x means a digit) you may also assume each line in the text file must not contain leading or trailing white spaces  easy 
my "grep -e" solution valid phone numbers given a text file file txt that contains list of phone numbers (one per line)  write a one liner bash script to print all valid phone numbers  you may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx  (x means a digit) you may also assume each line in the text file must not contain leading or trailing white spaces  easy 
my easy understand grep -e solution valid phone numbers given a text file file txt that contains list of phone numbers (one per line)  write a one liner bash script to print all valid phone numbers  you may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx  (x means a digit) you may also assume each line in the text file must not contain leading or trailing white spaces  easy 
ac solution using awk and statement just like c  transpose file given a text file file txt  transpose its content  you may assume that each row has the same number of columns and each field is separated by the ' ' character  medium 
simple bash solution that oj hates transpose file given a text file file txt  transpose its content  you may assume that each row has the same number of columns and each field is separated by the ' ' character  medium 
solution using awk with explanations transpose file given a text file file txt  transpose its content  you may assume that each row has the same number of columns and each field is separated by the ' ' character  medium 
my 28ms awk solution transpose file given a text file file txt  transpose its content  you may assume that each row has the same number of columns and each field is separated by the ' ' character  medium 
memory limit exceeded transpose file given a text file file txt  transpose its content  you may assume that each row has the same number of columns and each field is separated by the ' ' character  medium 
share four different solutions tenth line given a text file file txt  print just the 10th line of the file  easy 
super simple solution tenth line given a text file file txt  print just the 10th line of the file  easy 
my three simple solutions tenth line given a text file file txt  print just the 10th line of the file  easy 
a generalized approach with head tail tenth line given a text file file txt  print just the 10th line of the file  easy 
simple solution using awk tenth line given a text file file txt  print just the 10th line of the file  easy 
simple solution delete duplicate emails write a sql query to delete all duplicate email entries in a table named person  keeping only unique emails based on its smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
a skillful mysql solution  avoid " select and update conflict" delete duplicate emails write a sql query to delete all duplicate email entries in a table named person  keeping only unique emails based on its smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
solution in a single query without any conflicts delete duplicate emails write a sql query to delete all duplicate email entries in a table named person  keeping only unique emails based on its smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
i can't believe i get it wrong! what's wrong with my code? delete duplicate emails write a sql query to delete all duplicate email entries in a table named person  keeping only unique emails based on its smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
a simple ac solution  delete duplicate emails write a sql query to delete all duplicate email entries in a table named person  keeping only unique emails based on its smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
simple solution rising temperature sql schemagiven a weather table  write a sql query to find all dates' ids with higher temperature compared to its previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ for easy 
my simple solution using inner join rising temperature sql schemagiven a weather table  write a sql query to find all dates' ids with higher temperature compared to its previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ for easy 
two solutions           rising temperature sql schemagiven a weather table  write a sql query to find all dates' ids with higher temperature compared to its previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ for easy 
my simple solution rising temperature sql schemagiven a weather table  write a sql query to find all dates' ids with higher temperature compared to its previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ for easy 
why is subtracting 1 directly from date not working  but subdate(a date 1) works? rising temperature sql schemagiven a weather table  write a sql query to find all dates' ids with higher temperature compared to its previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ for easy 
from good to great  how to approach most of dp problems  house robber you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  easy dynamic programming 
c 1ms  o(1)space   very simple solution house robber you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  easy dynamic programming 
java o(n) solution  space o(1) house robber you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  easy dynamic programming 
python solution  3 lines  house robber you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  easy dynamic programming 
java dp solution  o(n) runtime and o(1) space  with inline comment house robber you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  easy dynamic programming 
my simple accepted solution(java) binary tree right side view given a binary tree  imagine yourself standing on the right side of it  return the values of the nodes you can see ordered from top to bottom  medium tree depth-first search breadth-first search 
my c++ solution  modified preorder traversal binary tree right side view given a binary tree  imagine yourself standing on the right side of it  return the values of the nodes you can see ordered from top to bottom  medium tree depth-first search breadth-first search 
reverse level order traversal  java binary tree right side view given a binary tree  imagine yourself standing on the right side of it  return the values of the nodes you can see ordered from top to bottom  medium tree depth-first search breadth-first search 
5-9 lines python  48+ ms binary tree right side view given a binary tree  imagine yourself standing on the right side of it  return the values of the nodes you can see ordered from top to bottom  medium tree depth-first search breadth-first search 
simple c++ solution (btw: i like clean codes) binary tree right side view given a binary tree  imagine yourself standing on the right side of it  return the values of the nodes you can see ordered from top to bottom  medium tree depth-first search breadth-first search 
very concise java ac solution number of islands given a 2d grid map of '1's (land) and '0's (water)  count the number of islands  an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically  you may assume all four edges of the grid are all surrounded by water  medium depth-first search breadth-first search union find 
7 lines python  ~14 lines java number of islands given a 2d grid map of '1's (land) and '0's (water)  count the number of islands  an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically  you may assume all four edges of the grid are all surrounded by water  medium depth-first search breadth-first search union find 
1d union find java solution  easily generalized to other problems number of islands given a 2d grid map of '1's (land) and '0's (water)  count the number of islands  an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically  you may assume all four edges of the grid are all surrounded by water  medium depth-first search breadth-first search union find 
python simple dfs solution number of islands given a 2d grid map of '1's (land) and '0's (water)  count the number of islands  an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically  you may assume all four edges of the grid are all surrounded by water  medium depth-first search breadth-first search union find 
simple java solution number of islands given a 2d grid map of '1's (land) and '0's (water)  count the number of islands  an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically  you may assume all four edges of the grid are all surrounded by water  medium depth-first search breadth-first search union find 
bit operation solution(java) bitwise and of numbers range given a range [m  n] where 0 <= m <= n <= 2147483647  return the bitwise and of all numbers in this range  inclusive  medium bit manipulation 
one line c++ solution bitwise and of numbers range given a range [m  n] where 0 <= m <= n <= 2147483647  return the bitwise and of all numbers in this range  inclusive  medium bit manipulation 
2 line solution with detailed explanation bitwise and of numbers range given a range [m  n] where 0 <= m <= n <= 2147483647  return the bitwise and of all numbers in this range  inclusive  medium bit manipulation 
java python easy solution with explanation bitwise and of numbers range given a range [m  n] where 0 <= m <= n <= 2147483647  return the bitwise and of all numbers in this range  inclusive  medium bit manipulation 
my simple java solution(3 lines) bitwise and of numbers range given a range [m  n] where 0 <= m <= n <= 2147483647  return the bitwise and of all numbers in this range  inclusive  medium bit manipulation 
3 line recursive solution remove linked list elements remove all elements from a linked list of integers that have value val  easy linked list 
ac java solution remove linked list elements remove all elements from a linked list of integers that have value val  easy linked list 
iterative short java solution remove linked list elements remove all elements from a linked list of integers that have value val  easy linked list 
accepted 7 line clean java solution remove linked list elements remove all elements from a linked list of integers that have value val  easy linked list 
simple and elegant solution in c++ remove linked list elements remove all elements from a linked list of integers that have value val  easy linked list 
my simple java solution count primes count the number of prime numbers less than a non-negative number  n  easy hash table math 
fast python solution count primes count the number of prime numbers less than a non-negative number  n  easy hash table math 
my easy one round c++ code count primes count the number of prime numbers less than a non-negative number  n  easy hash table math 
12 ms java solution modified from the hint method  beats 99 95% count primes count the number of prime numbers less than a non-negative number  n  easy hash table math 
short c++ sieve of eratosthenes solution count primes count the number of prime numbers less than a non-negative number  n  easy hash table math 
my 6 lines solution isomorphic strings given two strings s and t  determine if they are isomorphic  two strings are isomorphic if the characters in s can be replaced to get t  all occurrences of a character must be replaced with another character while preserving the order of characters  no two characters may map to the same character but a character may map to itself  easy hash table 
python different solutions (dictionary  etc)  isomorphic strings given two strings s and t  determine if they are isomorphic  two strings are isomorphic if the characters in s can be replaced to get t  all occurrences of a character must be replaced with another character while preserving the order of characters  no two characters may map to the same character but a character may map to itself  easy hash table 
short java solution without maps isomorphic strings given two strings s and t  determine if they are isomorphic  two strings are isomorphic if the characters in s can be replaced to get t  all occurrences of a character must be replaced with another character while preserving the order of characters  no two characters may map to the same character but a character may map to itself  easy hash table 
java solution using hashmap isomorphic strings given two strings s and t  determine if they are isomorphic  two strings are isomorphic if the characters in s can be replaced to get t  all occurrences of a character must be replaced with another character while preserving the order of characters  no two characters may map to the same character but a character may map to itself  easy hash table 
java solution with 1 line core code isomorphic strings given two strings s and t  determine if they are isomorphic  two strings are isomorphic if the characters in s can be replaced to get t  all occurrences of a character must be replaced with another character while preserving the order of characters  no two characters may map to the same character but a character may map to itself  easy hash table 
in-place iterative and recursive java solution reverse linked list reverse a singly linked list  easy linked list 
c++ iterative and recursive reverse linked list reverse a singly linked list  easy linked list 
python iterative and recursive solution reverse linked list reverse a singly linked list  easy linked list 
my java recursive solution reverse linked list reverse a singly linked list  easy linked list 
accepted c solutions both iteratively and recursively reverse linked list reverse a singly linked list  easy linked list 
18-22 lines c++ bfs dfs solutions course schedule there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
easy bfs topological sort  java course schedule there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
java dfs and bfs solution course schedule there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
python 20 lines dfs solution sharing with explanation course schedule there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
java---------easy version to understand!!!!!!!!!!!!!!!!! course schedule there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
ac java solution simple using single array implement trie (prefix tree) implement a trie with insert  search  and startswith methods  medium design trie 
maybe the code is not too much by using "next[26]"  c++ implement trie (prefix tree) implement a trie with insert  search  and startswith methods  medium design trie 
ac python solution implement trie (prefix tree) implement a trie with insert  search  and startswith methods  medium design trie 
my python solution implement trie (prefix tree) implement a trie with insert  search  and startswith methods  medium design trie 
c++  my solution   easy to understand:) implement trie (prefix tree) implement a trie with insert  search  and startswith methods  medium design trie 
accepted clean java o(n) solution (two pointers) minimum size subarray sum given an array of n positive integers and a positive integer s  find the minimal length of a contiguous subarray of which the sum ≥ s  if there isn't one  return 0 instead  medium array two pointers binary search 
two ac solutions in java with time complexity of n and nlogn with explanation minimum size subarray sum given an array of n positive integers and a positive integer s  find the minimal length of a contiguous subarray of which the sum ≥ s  if there isn't one  return 0 instead  medium array two pointers binary search 
4ms o(n)   8ms o(nlogn) c++ minimum size subarray sum given an array of n positive integers and a positive integer s  find the minimal length of a contiguous subarray of which the sum ≥ s  if there isn't one  return 0 instead  medium array two pointers binary search 
o(n) o(nlogn) solutions  both o(1) space minimum size subarray sum given an array of n positive integers and a positive integer s  find the minimal length of a contiguous subarray of which the sum ≥ s  if there isn't one  return 0 instead  medium array two pointers binary search 
o(n)  template for minimum size subarray sum & minimum window substring & longest substring without repeating characters minimum size subarray sum given an array of n positive integers and a positive integer s  find the minimal length of a contiguous subarray of which the sum ≥ s  if there isn't one  return 0 instead  medium array two pointers binary search 
two ac solution in java using bfs and dfs with explanation course schedule ii there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
20+ lines c++ bfs dfs solutions course schedule ii there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
concise java solution based on bfs with comments course schedule ii there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
python dfs  bfs solutions with comments  course schedule ii there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
java dfs double cache visiting each vertex once 433ms course schedule ii there are a total of n courses you have to take  labeled from 0 to n-1  some courses may have prerequisites  for medium depth-first search breadth-first search graph topological sort 
my simple and clean java code add and search word - data structure design design a data structure that supports the following two operations: void addword(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or    a   means it can represent any one letter  medium backtracking design trie 
80ms clear c++ code with detailed explanations add and search word - data structure design design a data structure that supports the following two operations: void addword(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or    a   means it can represent any one letter  medium backtracking design trie 
python 168ms-beat-100% solution add and search word - data structure design design a data structure that supports the following two operations: void addword(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or    a   means it can represent any one letter  medium backtracking design trie 
tree solutions  18-20 lines add and search word - data structure design design a data structure that supports the following two operations: void addword(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or    a   means it can represent any one letter  medium backtracking design trie 
my java trie based solution add and search word - data structure design design a data structure that supports the following two operations: void addword(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or    a   means it can represent any one letter  medium backtracking design trie 
java 15ms easiest solution (100 00%) word search ii given a 2d board and a list of words from the dictionary  find all words in the board  each word must be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once in a word  hard backtracking trie 
my simple and clean java code using dfs and trie word search ii given a 2d board and a list of words from the dictionary  find all words in the board  each word must be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once in a word  hard backtracking trie 
test case [a]  [a  a] doesn't make sense? word search ii given a 2d board and a list of words from the dictionary  find all words in the board  each word must be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once in a word  hard backtracking trie 
python code use trie and dfs 380ms word search ii given a 2d board and a list of words from the dictionary  find all words in the board  each word must be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once in a word  hard backtracking trie 
27 lines  uses complex numbers word search ii given a 2d board and a list of words from the dictionary  find all words in the board  each word must be constructed from letters of sequentially adjacent cell  where "adjacent" cells are those horizontally or vertically neighboring  the same letter cell may not be used more than once in a word  hard backtracking trie 
simple ac solution in java in o(n) with explanation house robber ii you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  all houses at this place are arranged in a circle  that means the first house is the neighbor of the last one  meanwhile  adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  medium dynamic programming 
9-lines 0ms o(1)-space c++ solution house robber ii you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  all houses at this place are arranged in a circle  that means the first house is the neighbor of the last one  meanwhile  adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  medium dynamic programming 
twice pass solution  c++ house robber ii you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  all houses at this place are arranged in a circle  that means the first house is the neighbor of the last one  meanwhile  adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  medium dynamic programming 
[c++] super simple 0ms solution with explanation house robber ii you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  all houses at this place are arranged in a circle  that means the first house is the neighbor of the last one  meanwhile  adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  medium dynamic programming 
good performance dp solution using java house robber ii you are a professional robber planning to rob houses along a street  each house has a certain amount of money stashed  all houses at this place are arranged in a circle  that means the first house is the neighbor of the last one  meanwhile  adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night  given a list of non-negative integers representing the amount of money of each house  determine the maximum amount of money you can rob tonight without alerting the police  medium dynamic programming 
clean kmp solution with super detailed explanation shortest palindrome given a string s  you are allowed to convert it to a palindrome by adding characters in front of it  find and return the shortest palindrome you can find by performing this transformation  hard string 
my 7-lines recursive java solution shortest palindrome given a string s  you are allowed to convert it to a palindrome by adding characters in front of it  find and return the shortest palindrome you can find by performing this transformation  hard string 
c++ 8 ms kmp-based o(n) time & o(n) memory solution shortest palindrome given a string s  you are allowed to convert it to a palindrome by adding characters in front of it  find and return the shortest palindrome you can find by performing this transformation  hard string 
ac in 288 ms  simple brute force shortest palindrome given a string s  you are allowed to convert it to a palindrome by adding characters in front of it  find and return the shortest palindrome you can find by performing this transformation  hard string 
my 9-lines three pointers java solution with explanation shortest palindrome given a string s  you are allowed to convert it to a palindrome by adding characters in front of it  find and return the shortest palindrome you can find by performing this transformation  hard string 
solution explained kth largest element in an array find the kth largest element in an unsorted array  note that it is the kth largest element in the sorted order  not the kth distinct element  medium divide and conquer heap 
c++ partition max-heap priority_queue multiset kth largest element in an array find the kth largest element in an unsorted array  note that it is the kth largest element in the sorted order  not the kth distinct element  medium divide and conquer heap 
ac clean quickselect java solution avg  o(n) time kth largest element in an array find the kth largest element in an unsorted array  note that it is the kth largest element in the sorted order  not the kth distinct element  medium divide and conquer heap 
python different solutions with comments (bubble sort  selection sort  heap sort and quick sort)  kth largest element in an array find the kth largest element in an unsorted array  note that it is the kth largest element in the sorted order  not the kth distinct element  medium divide and conquer heap 
concise java solution based on quick select kth largest element in an array find the kth largest element in an unsorted array  note that it is the kth largest element in the sorted order  not the kth distinct element  medium divide and conquer heap 
simple and clean java code  backtracking  combination sum iii find all possible combinations of k numbers that add up to a number n  given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers  note: all numbers will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
my c++ solution  backtracking  combination sum iii find all possible combinations of k numbers that add up to a number n  given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers  note: all numbers will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
fast  easy java code  with explanation! combination sum iii find all possible combinations of k numbers that add up to a number n  given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers  note: all numbers will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
use backtrack c++ solution  easy to understand  combination sum iii find all possible combinations of k numbers that add up to a number n  given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers  note: all numbers will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
clean 1 6 7-liners (ac) combination sum iii find all possible combinations of k numbers that add up to a number n  given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers  note: all numbers will be positive integers  the solution set must not contain duplicate combinations  medium array backtracking 
possible solutions  contains duplicate given an array of integers  find if the array contains any duplicates  your function should return true if any value appears at least twice in the array  and it should return false if every element is distinct  easy array hash table 
single line c++ solution 60ms contains duplicate given an array of integers  find if the array contains any duplicates  your function should return true if any value appears at least twice in the array  and it should return false if every element is distinct  easy array hash table 
one line solution in python contains duplicate given an array of integers  find if the array contains any duplicates  your function should return true if any value appears at least twice in the array  and it should return false if every element is distinct  easy array hash table 
5 lines in java contains duplicate given an array of integers  find if the array contains any duplicates  your function should return true if any value appears at least twice in the array  and it should return false if every element is distinct  easy array hash table 
c++ solution  simply one line  contains duplicate given an array of integers  find if the array contains any duplicates  your function should return true if any value appears at least twice in the array  and it should return false if every element is distinct  easy array hash table 
(guaranteed) really detailed and good (perfect) explanation of the skyline problem the skyline problem a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance  now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (figure a)  write a program to output the skyline formed by these buildings collectively (figure b)  the geometric information of each building is represented by a triplet of integers [li  ri  hi]  where li and ri are the x coordinates of the left and right edge of the ith building  respectively  and hi is its height  it is guaranteed that 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  and ri - li > 0  you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0  for instance  the dimensions of all buildings in figure a are recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   the output is a list of "key points" (red dots in figure b) in the format of [ [x1 y1]  [x2  y2]  [x3  y3]      ] that uniquely defines a skyline  a key point is the left endpoint of a horizontal line segment  note that the last key point  where the rightmost building ends  is merely used to mark the termination of the skyline  and always has zero height  also  the ground in between any two adjacent buildings should be considered part of the skyline contour  for instance  the skyline in figure b should be represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: the number of buildings in any input list is guaranteed to be in the range [0  10000]  the input list is already sorted in ascending order by the left x position li  the output list must be sorted by the x position  there must be no consecutive horizontal lines of equal height in the output skyline  for instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
short java solution the skyline problem a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance  now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (figure a)  write a program to output the skyline formed by these buildings collectively (figure b)  the geometric information of each building is represented by a triplet of integers [li  ri  hi]  where li and ri are the x coordinates of the left and right edge of the ith building  respectively  and hi is its height  it is guaranteed that 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  and ri - li > 0  you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0  for instance  the dimensions of all buildings in figure a are recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   the output is a list of "key points" (red dots in figure b) in the format of [ [x1 y1]  [x2  y2]  [x3  y3]      ] that uniquely defines a skyline  a key point is the left endpoint of a horizontal line segment  note that the last key point  where the rightmost building ends  is merely used to mark the termination of the skyline  and always has zero height  also  the ground in between any two adjacent buildings should be considered part of the skyline contour  for instance  the skyline in figure b should be represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: the number of buildings in any input list is guaranteed to be in the range [0  10000]  the input list is already sorted in ascending order by the left x position li  the output list must be sorted by the x position  there must be no consecutive horizontal lines of equal height in the output skyline  for instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
once for all  explanation with clean java code(o(n^2)time  o(n) space) the skyline problem a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance  now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (figure a)  write a program to output the skyline formed by these buildings collectively (figure b)  the geometric information of each building is represented by a triplet of integers [li  ri  hi]  where li and ri are the x coordinates of the left and right edge of the ith building  respectively  and hi is its height  it is guaranteed that 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  and ri - li > 0  you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0  for instance  the dimensions of all buildings in figure a are recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   the output is a list of "key points" (red dots in figure b) in the format of [ [x1 y1]  [x2  y2]  [x3  y3]      ] that uniquely defines a skyline  a key point is the left endpoint of a horizontal line segment  note that the last key point  where the rightmost building ends  is merely used to mark the termination of the skyline  and always has zero height  also  the ground in between any two adjacent buildings should be considered part of the skyline contour  for instance  the skyline in figure b should be represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: the number of buildings in any input list is guaranteed to be in the range [0  10000]  the input list is already sorted in ascending order by the left x position li  the output list must be sorted by the x position  there must be no consecutive horizontal lines of equal height in the output skyline  for instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
my c++ code using one priority queue (812 ms) the skyline problem a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance  now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (figure a)  write a program to output the skyline formed by these buildings collectively (figure b)  the geometric information of each building is represented by a triplet of integers [li  ri  hi]  where li and ri are the x coordinates of the left and right edge of the ith building  respectively  and hi is its height  it is guaranteed that 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  and ri - li > 0  you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0  for instance  the dimensions of all buildings in figure a are recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   the output is a list of "key points" (red dots in figure b) in the format of [ [x1 y1]  [x2  y2]  [x3  y3]      ] that uniquely defines a skyline  a key point is the left endpoint of a horizontal line segment  note that the last key point  where the rightmost building ends  is merely used to mark the termination of the skyline  and always has zero height  also  the ground in between any two adjacent buildings should be considered part of the skyline contour  for instance  the skyline in figure b should be represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: the number of buildings in any input list is guaranteed to be in the range [0  10000]  the input list is already sorted in ascending order by the left x position li  the output list must be sorted by the x position  there must be no consecutive horizontal lines of equal height in the output skyline  for instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
share my divide and conquer java solution  464 ms the skyline problem a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance  now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (figure a)  write a program to output the skyline formed by these buildings collectively (figure b)  the geometric information of each building is represented by a triplet of integers [li  ri  hi]  where li and ri are the x coordinates of the left and right edge of the ith building  respectively  and hi is its height  it is guaranteed that 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  and ri - li > 0  you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0  for instance  the dimensions of all buildings in figure a are recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   the output is a list of "key points" (red dots in figure b) in the format of [ [x1 y1]  [x2  y2]  [x3  y3]      ] that uniquely defines a skyline  a key point is the left endpoint of a horizontal line segment  note that the last key point  where the rightmost building ends  is merely used to mark the termination of the skyline  and always has zero height  also  the ground in between any two adjacent buildings should be considered part of the skyline contour  for instance  the skyline in figure b should be represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: the number of buildings in any input list is guaranteed to be in the range [0  10000]  the input list is already sorted in ascending order by the left x position li  the output list must be sorted by the x position  there must be no consecutive horizontal lines of equal height in the output skyline  for instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
simple java solution contains duplicate ii given an array of integers and an integer k  find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k  easy array hash table 
c++ solution with unordered_set contains duplicate ii given an array of integers and an integer k  find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k  easy array hash table 
short ac java solution contains duplicate ii given an array of integers and an integer k  find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k  easy array hash table 
python concise solution with dictionary  contains duplicate ii given an array of integers and an integer k  find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k  easy array hash table 
c++ 6 line solution  simple code and easy understanding contains duplicate ii given an array of integers and an integer k  find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k  easy array hash table 
ac o(n) solution in java using buckets with explanation contains duplicate iii given an array of integers  find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k  medium binary search tree 
java o(n lg k) solution contains duplicate iii given an array of integers  find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k  medium binary search tree 
java python one pass solution  o(n) time o(n) space using buckets contains duplicate iii given an array of integers  find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k  medium binary search tree 
c++ using set (less 10 lines)  with simple explanation  contains duplicate iii given an array of integers  find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k  medium binary search tree 
o(n) python using buckets with explanation  10 lines  contains duplicate iii given an array of integers  find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k  medium binary search tree 
c++ dynamic programming maximal square given a 2d binary matrix filled with 0's and 1's  find the largest square containing only 1's and return its area  medium dynamic programming 
extremely simple java solution :) maximal square given a 2d binary matrix filled with 0's and 1's  find the largest square containing only 1's and return its area  medium dynamic programming 
accepted clean java dp solution maximal square given a 2d binary matrix filled with 0's and 1's  find the largest square containing only 1's and return its area  medium dynamic programming 
6 lines  visual explanation  o(mn) maximal square given a 2d binary matrix filled with 0's and 1's  find the largest square containing only 1's and return its area  medium dynamic programming 
clear c++ solution  no extra space  12 ms  maximal square given a 2d binary matrix filled with 0's and 1's  find the largest square containing only 1's and return its area  medium dynamic programming 
concise java solutions o(log(n)^2) count complete tree nodes given a complete binary tree  count the number of nodes  note: definition of a complete binary tree from wikipedia: in a complete binary tree every level  except possibly the last  is completely filled  and all nodes in the last level are as far left as possible  it can have between 1 and 2h nodes inclusive at the last level h  medium binary search tree 
easy short c++ recursive solution count complete tree nodes given a complete binary tree  count the number of nodes  note: definition of a complete binary tree from wikipedia: in a complete binary tree every level  except possibly the last  is completely filled  and all nodes in the last level are as far left as possible  it can have between 1 and 2h nodes inclusive at the last level h  medium binary search tree 
accepted easy understand java solution count complete tree nodes given a complete binary tree  count the number of nodes  note: definition of a complete binary tree from wikipedia: in a complete binary tree every level  except possibly the last  is completely filled  and all nodes in the last level are as far left as possible  it can have between 1 and 2h nodes inclusive at the last level h  medium binary search tree 
my java solution with explanation which beats 99% count complete tree nodes given a complete binary tree  count the number of nodes  note: definition of a complete binary tree from wikipedia: in a complete binary tree every level  except possibly the last  is completely filled  and all nodes in the last level are as far left as possible  it can have between 1 and 2h nodes inclusive at the last level h  medium binary search tree 
a very clear recursive solution  isn't it? count complete tree nodes given a complete binary tree  count the number of nodes  note: definition of a complete binary tree from wikipedia: in a complete binary tree every level  except possibly the last  is completely filled  and all nodes in the last level are as far left as possible  it can have between 1 and 2h nodes inclusive at the last level h  medium binary search tree 
if you want to laugh  look at my solution rectangle area find the total area covered by two rectilinear rectangles in a 2d plane  each rectangle is defined by its bottom left corner and top right corner as shown in the figure  medium math 
just another short way rectangle area find the total area covered by two rectilinear rectangles in a 2d plane  each rectangle is defined by its bottom left corner and top right corner as shown in the figure  medium math 
my java solution [sum of areas - overlapped area] rectangle area find the total area covered by two rectilinear rectangles in a 2d plane  each rectangle is defined by its bottom left corner and top right corner as shown in the figure  medium math 
python concise solution  rectangle area find the total area covered by two rectilinear rectangles in a 2d plane  each rectangle is defined by its bottom left corner and top right corner as shown in the figure  medium math 
an explanation in plain language rectangle area find the total area covered by two rectilinear rectangles in a 2d plane  each rectangle is defined by its bottom left corner and top right corner as shown in the figure  medium math 
iterative java solution with stack basic calculator implement a basic calculator to evaluate a simple expression string  the expression string may contain open ( and closing parentheses )  the plus + or minus sign -  non-negative integers and empty spaces   hard math stack 
java-----------easy version to understand!!!!! basic calculator implement a basic calculator to evaluate a simple expression string  the expression string may contain open ( and closing parentheses )  the plus + or minus sign -  non-negative integers and empty spaces   hard math stack 
16 ms solution in c++ with stacks basic calculator implement a basic calculator to evaluate a simple expression string  the expression string may contain open ( and closing parentheses )  the plus + or minus sign -  non-negative integers and empty spaces   hard math stack 
easy 18 lines c++  16 lines python basic calculator implement a basic calculator to evaluate a simple expression string  the expression string may contain open ( and closing parentheses )  the plus + or minus sign -  non-negative integers and empty spaces   hard math stack 
java solution stack basic calculator implement a basic calculator to evaluate a simple expression string  the expression string may contain open ( and closing parentheses )  the plus + or minus sign -  non-negative integers and empty spaces   hard math stack 
a simple c++ solution implement stack using queues implement the following operations of a stack using queues  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  empty() -- return whether the stack is empty  easy stack design 
only push is o(n)  others are o(1)  using one queue  combination of two shared solutions implement stack using queues implement the following operations of a stack using queues  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  empty() -- return whether the stack is empty  easy stack design 
java solutions about three ways one of which utilizes one queue  and the others utilize two queues implement stack using queues implement the following operations of a stack using queues  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  empty() -- return whether the stack is empty  easy stack design 
concise 1 queue - java  c++  python implement stack using queues implement the following operations of a stack using queues  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  empty() -- return whether the stack is empty  easy stack design 
o(1) purely with queues implement stack using queues implement the following operations of a stack using queues  push(x) -- push element x onto stack  pop() -- removes the element on top of the stack  top() -- get the top element  empty() -- return whether the stack is empty  easy stack design 
straightforward dfs recursive  iterative  bfs solutions invert binary tree invert a binary tree  easy tree 
3-4 lines python invert binary tree invert a binary tree  easy tree 
recursive and non-recursive c++ both 4ms invert binary tree invert a binary tree  easy tree 
python solutions (recursively  dfs  bfs)  invert binary tree invert a binary tree  easy tree 
my simple recursion java solution invert binary tree invert a binary tree  easy tree 
share my  java solution basic calculator ii implement a basic calculator to evaluate a simple expression string  the expression string contains only non-negative integers  +  -       operators and empty spaces   the integer division should truncate toward zero  medium string 
17 lines c++  easy  20 ms basic calculator ii implement a basic calculator to evaluate a simple expression string  the expression string contains only non-negative integers  +  -       operators and empty spaces   the integer division should truncate toward zero  medium string 
java straight forward iteration solution with comments  no stack  o(n) & o(1) basic calculator ii implement a basic calculator to evaluate a simple expression string  the expression string contains only non-negative integers  +  -       operators and empty spaces   the integer division should truncate toward zero  medium string 
my 16 ms no stack one pass short c++ solution basic calculator ii implement a basic calculator to evaluate a simple expression string  the expression string contains only non-negative integers  +  -       operators and empty spaces   the integer division should truncate toward zero  medium string 
python short solution with stack  basic calculator ii implement a basic calculator to evaluate a simple expression string  the expression string contains only non-negative integers  +  -       operators and empty spaces   the integer division should truncate toward zero  medium string 
accepted java solution--easy to understand summary ranges given a sorted integer array without duplicates  return the summary of its ranges  medium array 
6 lines in python summary ranges given a sorted integer array without duplicates  return the summary of its ranges  medium array 
10 line c++ easy understand summary ranges given a sorted integer array without duplicates  return the summary of its ranges  medium array 
my concise java solution summary ranges given a sorted integer array without duplicates  return the summary of its ranges  medium array 
idea + 1-liner: group by number-index summary ranges given a sorted integer array without duplicates  return the summary of its ranges  medium array 
boyer-moore majority vote algorithm and my elaboration majority element ii given an integer array of size n  find all elements that appear more than ⌊ n 3 ⌋ times  note: the algorithm should run in linear time and in o(1) space  medium array 
java-------------------easy version to understand!!!!!!!!!!!! majority element ii given an integer array of size n  find all elements that appear more than ⌊ n 3 ⌋ times  note: the algorithm should run in linear time and in o(1) space  medium array 
6 lines  general case o(n) time and o(k) space majority element ii given an integer array of size n  find all elements that appear more than ⌊ n 3 ⌋ times  note: the algorithm should run in linear time and in o(1) space  medium array 
boyer-moore majority vote algorithm generalization majority element ii given an integer array of size n  find all elements that appear more than ⌊ n 3 ⌋ times  note: the algorithm should run in linear time and in o(1) space  medium array 
my c++ solution majority element ii given an integer array of size n  find all elements that appear more than ⌊ n 3 ⌋ times  note: the algorithm should run in linear time and in o(1) space  medium array 
3 ways implemented in java (python): binary search  in-order iterative & recursive kth smallest element in a bst given a binary search tree  write a function kthsmallest to find the kth smallest element in it  note: you may assume k is always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
what if you could modify the bst node's structure? kth smallest element in a bst given a binary search tree  write a function kthsmallest to find the kth smallest element in it  note: you may assume k is always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
two easiest in order traverse (java) kth smallest element in a bst given a binary search tree  write a function kthsmallest to find the kth smallest element in it  note: you may assume k is always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
4 lines in c++  kth smallest element in a bst given a binary search tree  write a function kthsmallest to find the kth smallest element in it  note: you may assume k is always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
python easy iterative and recursive solution kth smallest element in a bst given a binary search tree  write a function kthsmallest to find the kth smallest element in it  note: you may assume k is always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
using n&(n-1) trick power of two given an integer  write a function to determine if it is a power of two  easy math bit manipulation 
4 different ways to solve -- iterative   recursive   bit operation   math power of two given an integer  write a function to determine if it is a power of two  easy math bit manipulation 
one line java solution using bitcount power of two given an integer  write a function to determine if it is a power of two  easy math bit manipulation 
one line of c++ power of two given an integer  write a function to determine if it is a power of two  easy math bit manipulation 
python one line solution power of two given an integer  write a function to determine if it is a power of two  easy math bit manipulation 
short o(1) amortized  c++   java   ruby implement queue using stacks implement the following operations of a queue using stacks  push(x) -- push element x to the back of queue  pop() -- removes the element from in front of queue  peek() -- get the front element  empty() -- return whether the queue is empty  easy stack design 
easy java solution  just edit push() method implement queue using stacks implement the following operations of a queue using stacks  push(x) -- push element x to the back of queue  pop() -- removes the element from in front of queue  peek() -- get the front element  empty() -- return whether the queue is empty  easy stack design 
0 ms c++ solution using one stack w  explanation  implement queue using stacks implement the following operations of a queue using stacks  push(x) -- push element x to the back of queue  pop() -- removes the element from in front of queue  peek() -- get the front element  empty() -- return whether the queue is empty  easy stack design 
share my python solution (32ms) implement queue using stacks implement the following operations of a queue using stacks  push(x) -- push element x to the back of queue  pop() -- removes the element from in front of queue  peek() -- get the front element  empty() -- return whether the queue is empty  easy stack design 
do you know when we should use two stacks to implement a queue? implement queue using stacks implement the following operations of a queue using stacks  push(x) -- push element x to the back of queue  pop() -- removes the element from in front of queue  peek() -- get the front element  empty() -- return whether the queue is empty  easy stack design 
4+ lines  o(log n)  c++ java python number of digit one given an integer n  count the total number of digit 1 appearing in all non-negative integers less than or equal to n  hard math 
ac short java solution number of digit one given an integer n  count the total number of digit 1 appearing in all non-negative integers less than or equal to n  hard math 
java python one pass solution easy to understand number of digit one given an integer n  count the total number of digit 1 appearing in all non-negative integers less than or equal to n  hard math 
0ms o(lgn) accepted c++ solution using counting principle with explanation number of digit one given an integer n  count the total number of digit 1 appearing in all non-negative integers less than or equal to n  hard math 
0 ms recursive solution number of digit one given an integer n  count the total number of digit 1 appearing in all non-negative integers less than or equal to n  hard math 
reversing a list is not considered "o(1) space" palindrome linked list given a singly linked list  determine if it is a palindrome  easy linked list two pointers 
java  easy to understand palindrome linked list given a singly linked list  determine if it is a palindrome  easy linked list two pointers 
11 lines  12 with restore  o(n) time  o(1) space palindrome linked list given a singly linked list  determine if it is a palindrome  easy linked list two pointers 
share my c++ solution  o(n) time and o(1) memory palindrome linked list given a singly linked list  determine if it is a palindrome  easy linked list two pointers 
my easy understand c++ solution palindrome linked list given a singly linked list  determine if it is a palindrome  easy linked list two pointers 
3 lines with o(1) space  1-liners  alternatives lowest common ancestor of a binary search tree given a binary search tree (bst)  find the lowest common ancestor (lca) of two given nodes in the bst  according to the definition of lca on wikipedia: “the lowest common ancestor is defined between two nodes p and q as the lowest node in t that has both p and q as descendants (where we allow a node to be a descendant of itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
my java solution lowest common ancestor of a binary search tree given a binary search tree (bst)  find the lowest common ancestor (lca) of two given nodes in the bst  according to the definition of lca on wikipedia: “the lowest common ancestor is defined between two nodes p and q as the lowest node in t that has both p and q as descendants (where we allow a node to be a descendant of itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
c++ recursive and iterative lowest common ancestor of a binary search tree given a binary search tree (bst)  find the lowest common ancestor (lca) of two given nodes in the bst  according to the definition of lca on wikipedia: “the lowest common ancestor is defined between two nodes p and q as the lowest node in t that has both p and q as descendants (where we allow a node to be a descendant of itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
python iterative solution lowest common ancestor of a binary search tree given a binary search tree (bst)  find the lowest common ancestor (lca) of two given nodes in the bst  according to the definition of lca on wikipedia: “the lowest common ancestor is defined between two nodes p and q as the lowest node in t that has both p and q as descendants (where we allow a node to be a descendant of itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
11ms java solution  3 lines lowest common ancestor of a binary search tree given a binary search tree (bst)  find the lowest common ancestor (lca) of two given nodes in the bst  according to the definition of lca on wikipedia: “the lowest common ancestor is defined between two nodes p and q as the lowest node in t that has both p and q as descendants (where we allow a node to be a descendant of itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
why leetcode accepted such stupid question? delete node in a linked list write a function to delete a node (except the tail) in a singly linked list  given only access to that node  given linked list -- head = [4 5 1 9]  which looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
1-3 lines  c++ java python c c# javascript ruby delete node in a linked list write a function to delete a node (except the tail) in a singly linked list  given only access to that node  given linked list -- head = [4 5 1 9]  which looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
easy solution in java delete node in a linked list write a function to delete a node (except the tail) in a singly linked list  given only access to that node  given linked list -- head = [4 5 1 9]  which looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
this question is wrong you cannot delete the node delete node in a linked list write a function to delete a node (except the tail) in a singly linked list  given only access to that node  given linked list -- head = [4 5 1 9]  which looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
easy question  easy solution(java) delete node in a linked list write a function to delete a node (except the tail) in a singly linked list  given only access to that node  given linked list -- head = [4 5 1 9]  which looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
simple java solution in o(n) without extra space product of array except self given an array nums of n integers where n > 1  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]  medium array 
python solution (accepted)  o(n) time  o(1) space product of array except self given an array nums of n integers where n > 1  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]  medium array 
my simple java solution product of array except self given an array nums of n integers where n > 1  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]  medium array 
o(n) time and o(1) space c++ solution with explanation product of array except self given an array nums of n integers where n > 1  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]  medium array 
my solution beats 100% java solutions product of array except self given an array nums of n integers where n > 1  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]  medium array 
java o(n) solution using deque with explanation sliding window maximum given an array nums  there is a sliding window of size k which is moving from the very left of the array to the very right  you can only see the k numbers in the window  each time the sliding window moves right by one position  return the max sliding window  hard heap 
o(n) solution in java with two simple pass in the array sliding window maximum given an array nums  there is a sliding window of size k which is moving from the very left of the array to the very right  you can only see the k numbers in the window  each time the sliding window moves right by one position  return the max sliding window  hard heap 
this is a typical monotonic queue problem sliding window maximum given an array nums  there is a sliding window of size k which is moving from the very left of the array to the very right  you can only see the k numbers in the window  each time the sliding window moves right by one position  return the max sliding window  hard heap 
clean c++ o(n) solution using a deque sliding window maximum given an array nums  there is a sliding window of size k which is moving from the very left of the array to the very right  you can only see the k numbers in the window  each time the sliding window moves right by one position  return the max sliding window  hard heap 
my c++ o(n) deque based solution with explanation sliding window maximum given an array nums  there is a sliding window of size k which is moving from the very left of the array to the very right  you can only see the k numbers in the window  each time the sliding window moves right by one position  return the max sliding window  hard heap 
my concise o(m+n) java solution search a 2d matrix ii write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted in ascending from left to right  integers in each column are sorted in ascending from top to bottom  medium binary search divide and conquer 
c++ with o(m+n) complexity search a 2d matrix ii write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted in ascending from left to right  integers in each column are sorted in ascending from top to bottom  medium binary search divide and conquer 
 java  an easy-to-understand divide and conquer method search a 2d matrix ii write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted in ascending from left to right  integers in each column are sorted in ascending from top to bottom  medium binary search divide and conquer 
6-9 lines c++ python solutions with explanations search a 2d matrix ii write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted in ascending from left to right  integers in each column are sorted in ascending from top to bottom  medium binary search divide and conquer 
java short code  o(m+n) search a 2d matrix ii write an efficient algorithm that searches for a value in an m x n matrix  this matrix has the following properties: integers in each row are sorted in ascending from left to right  integers in each column are sorted in ascending from top to bottom  medium binary search divide and conquer 
a recursive java solution (284 ms) different ways to add parentheses given a string of numbers and operators  return all possible results from computing all the different possible ways to group numbers and operators  the valid operators are +  - and    medium divide and conquer 
c++ 4ms recursive & dp solution with brief explanation different ways to add parentheses given a string of numbers and operators  return all possible results from computing all the different possible ways to group numbers and operators  the valid operators are +  - and    medium divide and conquer 
1-11 lines python  9 lines c++ different ways to add parentheses given a string of numbers and operators  return all possible results from computing all the different possible ways to group numbers and operators  the valid operators are +  - and    medium divide and conquer 
python easy to understand solution (divide and conquer)  different ways to add parentheses given a string of numbers and operators  return all possible results from computing all the different possible ways to group numbers and operators  the valid operators are +  - and    medium divide and conquer 
share a clean and short java solution different ways to add parentheses given a string of numbers and operators  return all possible results from computing all the different possible ways to group numbers and operators  the valid operators are +  - and    medium divide and conquer 
accepted java o(n) solution in 5 lines valid anagram given two strings s and t   write a function to determine if t is an anagram of s  easy hash table sort 
2 c++ solutions with explanations valid anagram given two strings s and t   write a function to determine if t is an anagram of s  easy hash table sort 
python solutions (sort and dictionary)  valid anagram given two strings s and t   write a function to determine if t is an anagram of s  easy hash table sort 
share my java solution valid anagram given two strings s and t   write a function to determine if t is an anagram of s  easy hash table sort 
simple fast java solution (beats 97%) valid anagram given two strings s and t   write a function to determine if t is an anagram of s  easy hash table sort 
accepted java simple solution in 8 lines binary tree paths given a binary tree  return all root-to-leaf paths  note: a leaf is a node with no children  easy tree depth-first search 
python solutions (dfs+stack  bfs+queue  dfs recursively)  binary tree paths given a binary tree  return all root-to-leaf paths  note: a leaf is a node with no children  easy tree depth-first search 
clean java solution (accepted) without any helper recursive function binary tree paths given a binary tree  return all root-to-leaf paths  note: a leaf is a node with no children  easy tree depth-first search 
c++ simple 4ms recursive solution binary tree paths given a binary tree  return all root-to-leaf paths  note: a leaf is a node with no children  easy tree depth-first search 
my java solution in dfs  bfs  recursion binary tree paths given a binary tree  return all root-to-leaf paths  note: a leaf is a node with no children  easy tree depth-first search 
accepted c++ o(1)-time o(1)-space 1-line solution with detail explanations add digits given a non-negative integer num  repeatedly add all its digits until the result has only one digit  easy math 
3 methods for python with explains add digits given a non-negative integer num  repeatedly add all its digits until the result has only one digit  easy math 
two lines c code  with explanation add digits given a non-negative integer num  repeatedly add all its digits until the result has only one digit  easy math 
simple java solution no recursion  loop add digits given a non-negative integer num  repeatedly add all its digits until the result has only one digit  easy math 
1 line java solution add digits given a non-negative integer num  repeatedly add all its digits until the result has only one digit  easy math 
accepted c++ java o(n)-time o(1)-space easy solution with detail explanations single number iii given an array of numbers nums  in which exactly two elements appear only once and all the other elements appear exactly twice  find the two elements that appear only once  medium bit manipulation 
sharing explanation of the solution single number iii given an array of numbers nums  in which exactly two elements appear only once and all the other elements appear exactly twice  find the two elements that appear only once  medium bit manipulation 
c++ solution o(n) time and o(1) space  easy-understaning with simple explanation single number iii given an array of numbers nums  in which exactly two elements appear only once and all the other elements appear exactly twice  find the two elements that appear only once  medium bit manipulation 
bit manipulation beats 99 62% single number iii given an array of numbers nums  in which exactly two elements appear only once and all the other elements appear exactly twice  find the two elements that appear only once  medium bit manipulation 
share my c++ solution  single number iii given an array of numbers nums  in which exactly two elements appear only once and all the other elements appear exactly twice  find the two elements that appear only once  medium bit manipulation 
solution without join trips and users sql schemathe trips table holds all taxi trips  each trip has a unique id  while client_id and driver_id are both foreign keys to the users_id at the users table  status is an enum type of (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ the users table holds all users  each user has an unique users_id  and role is an enum type of (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | no | client | | 2 | yes | client | | 3 | no | client | | 4 | no | client | | 10 | no | driver | | 11 | no | driver | | 12 | no | driver | | 13 | no | driver | +----------+--------+--------+ write a sql query to find the cancellation rate of requests made by unbanned users between oct 1  2013 and oct 3  2013  for the above tables  your sql query should return the following rows with the cancellation rate being rounded to two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks to @cak1erlizhou for contributing this question  writing the problem description and adding part of the test cases  hard 
sharing my solution  trips and users sql schemathe trips table holds all taxi trips  each trip has a unique id  while client_id and driver_id are both foreign keys to the users_id at the users table  status is an enum type of (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ the users table holds all users  each user has an unique users_id  and role is an enum type of (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | no | client | | 2 | yes | client | | 3 | no | client | | 4 | no | client | | 10 | no | driver | | 11 | no | driver | | 12 | no | driver | | 13 | no | driver | +----------+--------+--------+ write a sql query to find the cancellation rate of requests made by unbanned users between oct 1  2013 and oct 3  2013  for the above tables  your sql query should return the following rows with the cancellation rate being rounded to two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks to @cak1erlizhou for contributing this question  writing the problem description and adding part of the test cases  hard 
question towards problem description trips and users sql schemathe trips table holds all taxi trips  each trip has a unique id  while client_id and driver_id are both foreign keys to the users_id at the users table  status is an enum type of (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ the users table holds all users  each user has an unique users_id  and role is an enum type of (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | no | client | | 2 | yes | client | | 3 | no | client | | 4 | no | client | | 10 | no | driver | | 11 | no | driver | | 12 | no | driver | | 13 | no | driver | +----------+--------+--------+ write a sql query to find the cancellation rate of requests made by unbanned users between oct 1  2013 and oct 3  2013  for the above tables  your sql query should return the following rows with the cancellation rate being rounded to two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks to @cak1erlizhou for contributing this question  writing the problem description and adding part of the test cases  hard 
sharing my solution trips and users sql schemathe trips table holds all taxi trips  each trip has a unique id  while client_id and driver_id are both foreign keys to the users_id at the users table  status is an enum type of (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ the users table holds all users  each user has an unique users_id  and role is an enum type of (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | no | client | | 2 | yes | client | | 3 | no | client | | 4 | no | client | | 10 | no | driver | | 11 | no | driver | | 12 | no | driver | | 13 | no | driver | +----------+--------+--------+ write a sql query to find the cancellation rate of requests made by unbanned users between oct 1  2013 and oct 3  2013  for the above tables  your sql query should return the following rows with the cancellation rate being rounded to two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks to @cak1erlizhou for contributing this question  writing the problem description and adding part of the test cases  hard 
my solution share trips and users sql schemathe trips table holds all taxi trips  each trip has a unique id  while client_id and driver_id are both foreign keys to the users_id at the users table  status is an enum type of (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ the users table holds all users  each user has an unique users_id  and role is an enum type of (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | no | client | | 2 | yes | client | | 3 | no | client | | 4 | no | client | | 10 | no | driver | | 11 | no | driver | | 12 | no | driver | | 13 | no | driver | +----------+--------+--------+ write a sql query to find the cancellation rate of requests made by unbanned users between oct 1  2013 and oct 3  2013  for the above tables  your sql query should return the following rows with the cancellation rate being rounded to two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks to @cak1erlizhou for contributing this question  writing the problem description and adding part of the test cases  hard 
2-4 lines  every language ugly number write a program to check whether a given number is an ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  easy math 
my 2ms java solution ugly number write a program to check whether a given number is an ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  easy math 
simple java solution with explanation ugly number write a program to check whether a given number is an ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  easy math 
my python solution ugly number write a program to check whether a given number is an ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  easy math 
java solution  greatest divide by 2  3  5 ugly number write a program to check whether a given number is an ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  easy math 
my 16ms c++ dp solution with short explanation ugly number ii write a program to find the n-th ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  medium math dynamic programming heap 
o(n) java solution ugly number ii write a program to find the n-th ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  medium math dynamic programming heap 
elegant c++ solution o(n) space time with detailed explanation  ugly number ii write a program to find the n-th ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  medium math dynamic programming heap 
my expressive python solution ugly number ii write a program to find the n-th ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  medium math dynamic programming heap 
java solution -- using priorityqueue ugly number ii write a program to find the n-th ugly number  ugly numbers are positive numbers whose prime factors only include 2  3  5  medium math dynamic programming heap 
4 line simple java bit manipulate solution with explaination missing number given an array containing n distinct numbers taken from 0  1  2       n  find the one that is missing from the array  easy array math bit manipulation 
3 different ideas: xor  sum  binary search  java code missing number given an array containing n distinct numbers taken from 0  1  2       n  find the one that is missing from the array  easy array math bit manipulation 
c++ solution using bit manipulation missing number given an array containing n distinct numbers taken from 0  1  2       n  find the one that is missing from the array  easy array math bit manipulation 
1+ lines ruby  python  java  c++ missing number given an array containing n distinct numbers taken from 0  1  2       n  find the one that is missing from the array  easy array math bit manipulation 
java solution o(1) space and o(n) in time missing number given an array containing n distinct numbers taken from 0  1  2       n  find the one that is missing from the array  easy array math bit manipulation 
my clean java solution  very easy to understand integer to english words convert a non-negative integer to its english words representation  given input is guaranteed to be less than 231 - 1  hard math string 
short clean java solution integer to english words convert a non-negative integer to its english words representation  given input is guaranteed to be less than 231 - 1  hard math string 
fairly clear 4ms c++ solution integer to english words convert a non-negative integer to its english words representation  given input is guaranteed to be less than 231 - 1  hard math string 
recursive python integer to english words convert a non-negative integer to its english words representation  given input is guaranteed to be less than 231 - 1  hard math string 
python clean solution integer to english words convert a non-negative integer to its english words representation  given input is guaranteed to be less than 231 - 1  hard math string 
my o(n) time solution use java h-index given an array of citations (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium hash table sort 
java bucket sort o(n) solution with detail explanation h-index given an array of citations (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium hash table sort 
a clean o(n) solution in java h-index given an array of citations (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium hash table sort 
java  o(n) time  with easy explanation  h-index given an array of citations (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium hash table sort 
my easy solution h-index given an array of citations (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium hash table sort 
standard binary search h-index ii given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium binary search 
java binary search  simple and clean h-index ii given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium binary search 
o(logn)-time o(1)-space easy solution with detailed explanations (c++ java python) h-index ii given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium binary search 
very standard binary search using (start + 1 < end) h-index ii given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium binary search 
share my c o(logn) solution with explanation  h-index ii given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher  write a function to compute the researcher's h-index  according to the definition of h-index on wikipedia: "a scientist has index h if h of his her n papers have at least h citations each  and the other n − h papers have no more than h citations each " medium binary search 
o(lgn) simple java solution first bad version you are a product manager and currently leading a team to develop a new product  unfortunately  the latest version of your product fails the quality check  since each version is developed based on the previous version  all the versions after a bad version are also bad  suppose you have n versions [1  2       n] and you want to find out the first bad one  which causes all the following ones to be bad  you are given an api bool isbadversion(version) which will return whether version is bad  implement a function to find the first bad version  you should minimize the number of calls to the api  easy binary search 
a good warning to me to use  start+(end-start) 2 to avoid overflow first bad version you are a product manager and currently leading a team to develop a new product  unfortunately  the latest version of your product fails the quality check  since each version is developed based on the previous version  all the versions after a bad version are also bad  suppose you have n versions [1  2       n] and you want to find out the first bad one  which causes all the following ones to be bad  you are given an api bool isbadversion(version) which will return whether version is bad  implement a function to find the first bad version  you should minimize the number of calls to the api  easy binary search 
time limit exceed first bad version you are a product manager and currently leading a team to develop a new product  unfortunately  the latest version of your product fails the quality check  since each version is developed based on the previous version  all the versions after a bad version are also bad  suppose you have n versions [1  2       n] and you want to find out the first bad one  which causes all the following ones to be bad  you are given an api bool isbadversion(version) which will return whether version is bad  implement a function to find the first bad version  you should minimize the number of calls to the api  easy binary search 
short c++ answer and minimize api calls first bad version you are a product manager and currently leading a team to develop a new product  unfortunately  the latest version of your product fails the quality check  since each version is developed based on the previous version  all the versions after a bad version are also bad  suppose you have n versions [1  2       n] and you want to find out the first bad one  which causes all the following ones to be bad  you are given an api bool isbadversion(version) which will return whether version is bad  implement a function to find the first bad version  you should minimize the number of calls to the api  easy binary search 
1-liner in ruby   python first bad version you are a product manager and currently leading a team to develop a new product  unfortunately  the latest version of your product fails the quality check  since each version is developed based on the previous version  all the versions after a bad version are also bad  suppose you have n versions [1  2       n] and you want to find out the first bad one  which causes all the following ones to be bad  you are given an api bool isbadversion(version) which will return whether version is bad  implement a function to find the first bad version  you should minimize the number of calls to the api  easy binary search 
summary of 4 different solutions (bfs  dp  static dp and mathematics) perfect squares given a positive integer n  find the least number of perfect square numbers (for medium math dynamic programming breadth-first search 
an easy understanding dp solution in java perfect squares given a positive integer n  find the least number of perfect square numbers (for medium math dynamic programming breadth-first search 
short python solution using bfs perfect squares given a positive integer n  find the least number of perfect square numbers (for medium math dynamic programming breadth-first search 
static dp  c++ 12 ms  python 172 ms  ruby 384 ms perfect squares given a positive integer n  find the least number of perfect square numbers (for medium math dynamic programming breadth-first search 
o(sqrt(n)) in ruby  c++  c perfect squares given a positive integer n  find the least number of perfect square numbers (for medium math dynamic programming breadth-first search 
java standard backtrace ac solutoin  short and clear expression add operators given a string that contains only digits 0-9 and a target value  return all possibilities to add binary operators (not unary) +  -  or   between the digits so they evaluate to the target value  hard divide and conquer 
17 lines solution  dfs (c++) expression add operators given a string that contains only digits 0-9 and a target value  return all possibilities to add binary operators (not unary) +  -  or   between the digits so they evaluate to the target value  hard divide and conquer 
java ac solution  19ms  beat 100 00%  expression add operators given a string that contains only digits 0-9 and a target value  return all possibilities to add binary operators (not unary) +  -  or   between the digits so they evaluate to the target value  hard divide and conquer 
clean python dfs with comments expression add operators given a string that contains only digits 0-9 and a target value  return all possibilities to add binary operators (not unary) +  -  or   between the digits so they evaluate to the target value  hard divide and conquer 
accepted c++ solution expression add operators given a string that contains only digits 0-9 and a target value  return all possibilities to add binary operators (not unary) +  -  or   between the digits so they evaluate to the target value  hard divide and conquer 
simple o(n) java solution using insert index move zeroes given an array nums  write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements  easy array two pointers 
my simple c++ solution move zeroes given an array nums  write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements  easy array two pointers 
1ms java solution move zeroes given an array nums  write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements  easy array two pointers 
python short in-place solution with comments  move zeroes given an array nums  write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements  easy array two pointers 
c++ accepted code move zeroes given an array nums  write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements  easy array two pointers 
concise java solution peeking iterator given an iterator class interface with methods: next() and hasnext()  design and implement a peekingiterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next()  medium design 
simple c++ solution (1 line per method) without extra member variables peeking iterator given an iterator class interface with methods: next() and hasnext()  design and implement a peekingiterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next()  medium design 
simple python solution peeking iterator given an iterator class interface with methods: next() and hasnext()  design and implement a peekingiterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next()  medium design 
another c++ solution with one line in peek() and hasnext()  ac peeking iterator given an iterator class interface with methods: next() and hasnext()  design and implement a peekingiterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next()  medium design 
simple java solution by caching next element peeking iterator given an iterator class interface with methods: next() and hasnext()  design and implement a peekingiterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next()  medium design 
my easy understood solution with o(n) time and o(1) space without modifying the array  with clear explanation  find the duplicate number given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)  prove that at least one duplicate number must exist  assume that there is only one duplicate number  find the duplicate one  medium array two pointers binary search 
two solutions (with explanation): o(nlog(n)) and o(n) time   o(1) space  without changing the input array find the duplicate number given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)  prove that at least one duplicate number must exist  assume that there is only one duplicate number  find the duplicate one  medium array two pointers binary search 
java o(n) time and o(1) space solution  similar to find loop in linkedlist  find the duplicate number given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)  prove that at least one duplicate number must exist  assume that there is only one duplicate number  find the duplicate one  medium array two pointers binary search 
simple c++ code with o(1) space and o(nlogn) time complexity find the duplicate number given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)  prove that at least one duplicate number must exist  assume that there is only one duplicate number  find the duplicate one  medium array two pointers binary search 
java o(1)space using binary-search find the duplicate number given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)  prove that at least one duplicate number must exist  assume that there is only one duplicate number  find the duplicate one  medium array two pointers binary search 
easiest java solution with explanation game of life according to the wikipedia's article: "the game of life  also known simply as life  is a cellular automaton devised by the british mathematician john horton conway in 1970 " given a board with m by n cells  each cell has an initial state live (1) or dead (0)  each cell interacts with its eight neighbors (horizontal  vertical  diagonal) using the following four rules (taken from the above wikipedia article): any live cell with fewer than two live neighbors dies  as if caused by under-population  any live cell with two or three live neighbors lives on to the next generation  any live cell with more than three live neighbors dies  as if by over-population   any dead cell with exactly three live neighbors becomes a live cell  as if by reproduction  write a function to compute the next state (after one update) of the board given its current state  the next state is created by applying the above rules simultaneously to every cell in the current state  where births and deaths occur simultaneously  medium array 
c++ o(1) space  o(mn) time game of life according to the wikipedia's article: "the game of life  also known simply as life  is a cellular automaton devised by the british mathematician john horton conway in 1970 " given a board with m by n cells  each cell has an initial state live (1) or dead (0)  each cell interacts with its eight neighbors (horizontal  vertical  diagonal) using the following four rules (taken from the above wikipedia article): any live cell with fewer than two live neighbors dies  as if caused by under-population  any live cell with two or three live neighbors lives on to the next generation  any live cell with more than three live neighbors dies  as if by over-population   any dead cell with exactly three live neighbors becomes a live cell  as if by reproduction  write a function to compute the next state (after one update) of the board given its current state  the next state is created by applying the above rules simultaneously to every cell in the current state  where births and deaths occur simultaneously  medium array 
infinite board solution game of life according to the wikipedia's article: "the game of life  also known simply as life  is a cellular automaton devised by the british mathematician john horton conway in 1970 " given a board with m by n cells  each cell has an initial state live (1) or dead (0)  each cell interacts with its eight neighbors (horizontal  vertical  diagonal) using the following four rules (taken from the above wikipedia article): any live cell with fewer than two live neighbors dies  as if caused by under-population  any live cell with two or three live neighbors lives on to the next generation  any live cell with more than three live neighbors dies  as if by over-population   any dead cell with exactly three live neighbors becomes a live cell  as if by reproduction  write a function to compute the next state (after one update) of the board given its current state  the next state is created by applying the above rules simultaneously to every cell in the current state  where births and deaths occur simultaneously  medium array 
c++ ac code  o(1) space  o(mn) time game of life according to the wikipedia's article: "the game of life  also known simply as life  is a cellular automaton devised by the british mathematician john horton conway in 1970 " given a board with m by n cells  each cell has an initial state live (1) or dead (0)  each cell interacts with its eight neighbors (horizontal  vertical  diagonal) using the following four rules (taken from the above wikipedia article): any live cell with fewer than two live neighbors dies  as if caused by under-population  any live cell with two or three live neighbors lives on to the next generation  any live cell with more than three live neighbors dies  as if by over-population   any dead cell with exactly three live neighbors becomes a live cell  as if by reproduction  write a function to compute the next state (after one update) of the board given its current state  the next state is created by applying the above rules simultaneously to every cell in the current state  where births and deaths occur simultaneously  medium array 
clean o(1) space o(mn) time java solution game of life according to the wikipedia's article: "the game of life  also known simply as life  is a cellular automaton devised by the british mathematician john horton conway in 1970 " given a board with m by n cells  each cell has an initial state live (1) or dead (0)  each cell interacts with its eight neighbors (horizontal  vertical  diagonal) using the following four rules (taken from the above wikipedia article): any live cell with fewer than two live neighbors dies  as if caused by under-population  any live cell with two or three live neighbors lives on to the next generation  any live cell with more than three live neighbors dies  as if by over-population   any dead cell with exactly three live neighbors becomes a live cell  as if by reproduction  write a function to compute the next state (after one update) of the board given its current state  the next state is created by applying the above rules simultaneously to every cell in the current state  where births and deaths occur simultaneously  medium array 
8 lines simple java word pattern given a pattern and a string str  find if str follows the same pattern  here follow means a full match  such that there is a bijection between a letter in pattern and a non-empty word in str  easy hash table 
short c++  read words on the fly word pattern given a pattern and a string str  find if str follows the same pattern  here follow means a full match  such that there is a bijection between a letter in pattern and a non-empty word in str  easy hash table 
very fast (3ms) java solution using hashmap word pattern given a pattern and a string str  find if str follows the same pattern  here follow means a full match  such that there is a bijection between a letter in pattern and a non-empty word in str  easy hash table 
short in python word pattern given a pattern and a string str  find if str follows the same pattern  here follow means a full match  such that there is a bijection between a letter in pattern and a non-empty word in str  easy hash table 
0ms c++ solution using istringstream and double maps word pattern given a pattern and a string str  find if str follows the same pattern  here follow means a full match  such that there is a bijection between a letter in pattern and a non-empty word in str  easy hash table 
theorem: all 4s shall be false nim game you are playing the following nim game with your friend: there is a heap of stones on the table  each time one of you take turns to remove 1 to 3 stones  the one who removes the last stone will be the winner  you will take the first turn to remove the stones  both of you are very clever and have optimal strategies for the game  write a function to determine whether you can win the game given the number of stones in the heap  easy brainteaser 
one line o(1) solution and explanation nim game you are playing the following nim game with your friend: there is a heap of stones on the table  each time one of you take turns to remove 1 to 3 stones  the one who removes the last stone will be the winner  you will take the first turn to remove the stones  both of you are very clever and have optimal strategies for the game  write a function to determine whether you can win the game given the number of stones in the heap  easy brainteaser 
o(1) efficient single-line java using bit checking nim game you are playing the following nim game with your friend: there is a heap of stones on the table  each time one of you take turns to remove 1 to 3 stones  the one who removes the last stone will be the winner  you will take the first turn to remove the stones  both of you are very clever and have optimal strategies for the game  write a function to determine whether you can win the game given the number of stones in the heap  easy brainteaser 
two java solution  nim game you are playing the following nim game with your friend: there is a heap of stones on the table  each time one of you take turns to remove 1 to 3 stones  the one who removes the last stone will be the winner  you will take the first turn to remove the stones  both of you are very clever and have optimal strategies for the game  write a function to determine whether you can win the game given the number of stones in the heap  easy brainteaser 
1 line 0 ms c++ solution with explanation nim game you are playing the following nim game with your friend: there is a heap of stones on the table  each time one of you take turns to remove 1 to 3 stones  the one who removes the last stone will be the winner  you will take the first turn to remove the stones  both of you are very clever and have optimal strategies for the game  write a function to determine whether you can win the game given the number of stones in the heap  easy brainteaser 
short simple java c++ python  o(log n) + o(1) find median from data stream median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  for hard heap design 
share my java solution logn to insert  o(1) to query find median from data stream median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  for hard heap design 
java python two heap solution  o(log n) add  o(1) find find median from data stream median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  for hard heap design 
easy to understand double-heap solution in java find median from data stream median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  for hard heap design 
very short  o(log n) + o(1) find median from data stream median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  for hard heap design 
easy to understand java solution serialize and deserialize binary tree serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure  hard tree design 
recursive preorder  python and c++  o(n) serialize and deserialize binary tree serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure  hard tree design 
short and straight forward bfs java code with a queue serialize and deserialize binary tree serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure  hard tree design 
clean c++ solution serialize and deserialize binary tree serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure  hard tree design 
recursive dfs  iterative dfs and bfs serialize and deserialize binary tree serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure  hard tree design 
one pass java solution bulls and cows you are playing the following bulls and cows game with your friend: you write down a number and ask your friend to guess what the number is  each time your friend makes a guess  you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows")  your friend will use successive guesses and hints to eventually derive the secret number  write a function to return a hint according to the secret number and friend's guess  use a to indicate the bulls and b to indicate the cows  please note that both secret number and friend's guess may contain duplicate digits  medium hash table 
[c++] 4ms straight forward solution two pass o(n) time bulls and cows you are playing the following bulls and cows game with your friend: you write down a number and ask your friend to guess what the number is  each time your friend makes a guess  you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows")  your friend will use successive guesses and hints to eventually derive the secret number  write a function to return a hint according to the secret number and friend's guess  use a to indicate the bulls and b to indicate the cows  please note that both secret number and friend's guess may contain duplicate digits  medium hash table 
my 3ms java solution may help u bulls and cows you are playing the following bulls and cows game with your friend: you write down a number and ask your friend to guess what the number is  each time your friend makes a guess  you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows")  your friend will use successive guesses and hints to eventually derive the secret number  write a function to return a hint according to the secret number and friend's guess  use a to indicate the bulls and b to indicate the cows  please note that both secret number and friend's guess may contain duplicate digits  medium hash table 
python 3 lines solution bulls and cows you are playing the following bulls and cows game with your friend: you write down a number and ask your friend to guess what the number is  each time your friend makes a guess  you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows")  your friend will use successive guesses and hints to eventually derive the secret number  write a function to return a hint according to the secret number and friend's guess  use a to indicate the bulls and b to indicate the cows  please note that both secret number and friend's guess may contain duplicate digits  medium hash table 
3 lines in python bulls and cows you are playing the following bulls and cows game with your friend: you write down a number and ask your friend to guess what the number is  each time your friend makes a guess  you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows")  your friend will use successive guesses and hints to eventually derive the secret number  write a function to return a hint according to the secret number and friend's guess  use a to indicate the bulls and b to indicate the cows  please note that both secret number and friend's guess may contain duplicate digits  medium hash table 
java python binary search o(nlogn) time with explanation longest increasing subsequence given an unsorted array of integers  find the length of longest increasing subsequence  medium binary search dynamic programming 
short java solution using dp o(n log n) longest increasing subsequence given an unsorted array of integers  find the length of longest increasing subsequence  medium binary search dynamic programming 
9 lines c++ code with o(nlogn) complexity longest increasing subsequence given an unsorted array of integers  find the length of longest increasing subsequence  medium binary search dynamic programming 
my easy to understand o(n^2) solution using dp with video explanation longest increasing subsequence given an unsorted array of integers  find the length of longest increasing subsequence  medium binary search dynamic programming 
[c++] typical dp n^2 solution and nlogn solution from geekforgeek longest increasing subsequence given an unsorted array of integers  find the length of longest increasing subsequence  medium binary search dynamic programming 
easy  short  concise and fast java dfs 3 ms solution remove invalid parentheses remove the minimum number of invalid parentheses in order to make the input string valid  return all possible results  note: the input string may contain letters other than the parentheses ( and )  hard depth-first search breadth-first search 
share my java bfs solution remove invalid parentheses remove the minimum number of invalid parentheses in order to make the input string valid  return all possible results  note: the input string may contain letters other than the parentheses ( and )  hard depth-first search breadth-first search 
easiest 9ms java solution remove invalid parentheses remove the minimum number of invalid parentheses in order to make the input string valid  return all possible results  note: the input string may contain letters other than the parentheses ( and )  hard depth-first search breadth-first search 
short python bfs remove invalid parentheses remove the minimum number of invalid parentheses in order to make the input string valid  return all possible results  note: the input string may contain letters other than the parentheses ( and )  hard depth-first search breadth-first search 
my c++ dfs solution - 16ms remove invalid parentheses remove the minimum number of invalid parentheses in order to make the input string valid  return all possible results  note: the input string may contain letters other than the parentheses ( and )  hard depth-first search breadth-first search 
java simple o(n) init and o(1) query solution range sum query - immutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  easy dynamic programming 
5-lines c++  4-lines python range sum query - immutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  easy dynamic programming 
c++ o(1) queries - just 2 extra lines of code range sum query - immutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  easy dynamic programming 
a very short python solution range sum query - immutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  easy dynamic programming 
my java 3ms solution range sum query - immutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  easy dynamic programming 
clean c++ solution and explaination - o(mn) space with o(1) time range sum query 2d - immutable given a 2d matrix matrix  find the sum of the elements inside the rectangle defined by its upper left corner (row1  col1) and lower right corner (row2  col2)  the above rectangle (with the red border) is defined by (row1  col1) = (2  1) and (row2  col2) = (4  3)  which contains sum = 8  medium dynamic programming 
clean and easy to understand java solution range sum query 2d - immutable given a 2d matrix matrix  find the sum of the elements inside the rectangle defined by its upper left corner (row1  col1) and lower right corner (row2  col2)  the above rectangle (with the red border) is defined by (row1  col1) = (2  1) and (row2  col2) = (4  3)  which contains sum = 8  medium dynamic programming 
sharing my python solution range sum query 2d - immutable given a 2d matrix matrix  find the sum of the elements inside the rectangle defined by its upper left corner (row1  col1) and lower right corner (row2  col2)  the above rectangle (with the red border) is defined by (row1  col1) = (2  1) and (row2  col2) = (4  3)  which contains sum = 8  medium dynamic programming 
c++ with helper range sum query 2d - immutable given a 2d matrix matrix  find the sum of the elements inside the rectangle defined by its upper left corner (row1  col1) and lower right corner (row2  col2)  the above rectangle (with the red border) is defined by (row1  col1) = (2  1) and (row2  col2) = (4  3)  which contains sum = 8  medium dynamic programming 
very clean and fast java solution range sum query 2d - immutable given a 2d matrix matrix  find the sum of the elements inside the rectangle defined by its upper left corner (row1  col1) and lower right corner (row2  col2)  the above rectangle (with the red border) is defined by (row1  col1) = (2  1) and (row2  col2) = (4  3)  which contains sum = 8  medium dynamic programming 
java recursive and iterative solutions additive number additive number is a string whose digits can form additive sequence  a valid additive sequence should contain at least three numbers  except for the first two numbers  each subsequent number in the sequence must be the sum of the preceding two  given a string containing only digits '0'-'9'  write a function to determine if it's an additive number  note: numbers in the additive sequence cannot have leading zeros  so sequence 1  2  03 or 1  02  3 is invalid  medium backtracking 
0ms concise c++ solution (perfectly handles the follow-up and leading 0s) additive number additive number is a string whose digits can form additive sequence  a valid additive sequence should contain at least three numbers  except for the first two numbers  each subsequent number in the sequence must be the sum of the preceding two  given a string containing only digits '0'-'9'  write a function to determine if it's an additive number  note: numbers in the additive sequence cannot have leading zeros  so sequence 1  2  03 or 1  02  3 is invalid  medium backtracking 
 java  very straightforward solution with detailed explanation additive number additive number is a string whose digits can form additive sequence  a valid additive sequence should contain at least three numbers  except for the first two numbers  each subsequent number in the sequence must be the sum of the preceding two  given a string containing only digits '0'-'9'  write a function to determine if it's an additive number  note: numbers in the additive sequence cannot have leading zeros  so sequence 1  2  03 or 1  02  3 is invalid  medium backtracking 
python solution additive number additive number is a string whose digits can form additive sequence  a valid additive sequence should contain at least three numbers  except for the first two numbers  each subsequent number in the sequence must be the sum of the preceding two  given a string containing only digits '0'-'9'  write a function to determine if it's an additive number  note: numbers in the additive sequence cannot have leading zeros  so sequence 1  2  03 or 1  02  3 is invalid  medium backtracking 
java easy understand dfs additive number additive number is a string whose digits can form additive sequence  a valid additive sequence should contain at least three numbers  except for the first two numbers  each subsequent number in the sequence must be the sum of the preceding two  given a string containing only digits '0'-'9'  write a function to determine if it's an additive number  note: numbers in the additive sequence cannot have leading zeros  so sequence 1  2  03 or 1  02  3 is invalid  medium backtracking 
17 ms java solution with segment tree range sum query - mutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  the update(i  val) function modifies nums by updating the element at index i to val  medium binary indexed tree segment tree 
java using binary indexed tree with clear explanation range sum query - mutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  the update(i  val) function modifies nums by updating the element at index i to val  medium binary indexed tree segment tree 
"0 lines" python range sum query - mutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  the update(i  val) function modifies nums by updating the element at index i to val  medium binary indexed tree segment tree 
c++ solution using "buckets"  o(1) for updating and o(n^0 5) for query in the worst case (not the fast)  range sum query - mutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  the update(i  val) function modifies nums by updating the element at index i to val  medium binary indexed tree segment tree 
python: well commented solution using segment trees range sum query - mutable given an integer array nums  find the sum of the elements between indices i and j (i ≤ j)  inclusive  the update(i  val) function modifies nums by updating the element at index i to val  medium binary indexed tree segment tree 
share my thinking process best time to buy and sell stock with cooldown say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (ie  buy one and sell one share of the stock multiple times) with the following restrictions: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  after you sell your stock  you cannot buy stock on next day  (ie  cooldown 1 day) medium dynamic programming 
share my dp solution (by state machine thinking) best time to buy and sell stock with cooldown say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (ie  buy one and sell one share of the stock multiple times) with the following restrictions: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  after you sell your stock  you cannot buy stock on next day  (ie  cooldown 1 day) medium dynamic programming 
easiest java solution with explanations best time to buy and sell stock with cooldown say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (ie  buy one and sell one share of the stock multiple times) with the following restrictions: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  after you sell your stock  you cannot buy stock on next day  (ie  cooldown 1 day) medium dynamic programming 
7-line java: only consider sell and cooldown best time to buy and sell stock with cooldown say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (ie  buy one and sell one share of the stock multiple times) with the following restrictions: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  after you sell your stock  you cannot buy stock on next day  (ie  cooldown 1 day) medium dynamic programming 
very easy to understand one pass o(n) solution with no extra space best time to buy and sell stock with cooldown say you have an array for which the ith element is the price of a given stock on day i  design an algorithm to find the maximum profit  you may complete as many transactions as you like (ie  buy one and sell one share of the stock multiple times) with the following restrictions: you may not engage in multiple transactions at the same time (ie  you must sell the stock before you buy again)  after you sell your stock  you cannot buy stock on next day  (ie  cooldown 1 day) medium dynamic programming 
share some thoughts minimum height trees for an undirected graph with tree characteristics  we can choose any node as the root  the result graph is then a rooted tree  among all possible rooted trees  those with minimum height are called minimum height trees (mhts)  given such a graph  write a function to find all the mhts and return a list of their root labels  format the graph contains n nodes which are labeled from 0 to n - 1  you will be given the number n and a list of undirected edges (each edge is a pair of labels)  you can assume that no duplicate edges will appear in edges  since all edges are undirected  [0  1] is the same as [1  0] and thus will not appear together in edges  medium breadth-first search graph 
two o(n) solutions minimum height trees for an undirected graph with tree characteristics  we can choose any node as the root  the result graph is then a rooted tree  among all possible rooted trees  those with minimum height are called minimum height trees (mhts)  given such a graph  write a function to find all the mhts and return a list of their root labels  format the graph contains n nodes which are labeled from 0 to n - 1  you will be given the number n and a list of undirected edges (each edge is a pair of labels)  you can assume that no duplicate edges will appear in edges  since all edges are undirected  [0  1] is the same as [1  0] and thus will not appear together in edges  medium breadth-first search graph 
c++ solution  o(n)-time  o(n)-space minimum height trees for an undirected graph with tree characteristics  we can choose any node as the root  the result graph is then a rooted tree  among all possible rooted trees  those with minimum height are called minimum height trees (mhts)  given such a graph  write a function to find all the mhts and return a list of their root labels  format the graph contains n nodes which are labeled from 0 to n - 1  you will be given the number n and a list of undirected edges (each edge is a pair of labels)  you can assume that no duplicate edges will appear in edges  since all edges are undirected  [0  1] is the same as [1  0] and thus will not appear together in edges  medium breadth-first search graph 
c++ bfs short clean solution with explanation minimum height trees for an undirected graph with tree characteristics  we can choose any node as the root  the result graph is then a rooted tree  among all possible rooted trees  those with minimum height are called minimum height trees (mhts)  given such a graph  write a function to find all the mhts and return a list of their root labels  format the graph contains n nodes which are labeled from 0 to n - 1  you will be given the number n and a list of undirected edges (each edge is a pair of labels)  you can assume that no duplicate edges will appear in edges  since all edges are undirected  [0  1] is the same as [1  0] and thus will not appear together in edges  medium breadth-first search graph 
share my bfs java code using degree with explanation  which beats more than 95% minimum height trees for an undirected graph with tree characteristics  we can choose any node as the root  the result graph is then a rooted tree  among all possible rooted trees  those with minimum height are called minimum height trees (mhts)  given such a graph  write a function to find all the mhts and return a list of their root labels  format the graph contains n nodes which are labeled from 0 to n - 1  you will be given the number n and a list of undirected edges (each edge is a pair of labels)  you can assume that no duplicate edges will appear in edges  since all edges are undirected  [0  1] is the same as [1  0] and thus will not appear together in edges  medium breadth-first search graph 
share some analysis and explanations burst balloons given n balloons  indexed from 0 to n-1  each balloon is painted with a number on it represented by array nums  you are asked to burst all the balloons  if the you burst balloon i you will get nums[left]   nums[i]   nums[right] coins  here left and right are adjacent indices of i  after the burst  the left and right then becomes adjacent  find the maximum coins you can collect by bursting the balloons wisely  note: you may imagine nums[-1] = nums[n] = 1  they are not real therefore you can not burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
c++ dynamic programming  o(n^3)  32 ms  with comments burst balloons given n balloons  indexed from 0 to n-1  each balloon is painted with a number on it represented by array nums  you are asked to burst all the balloons  if the you burst balloon i you will get nums[left]   nums[i]   nums[right] coins  here left and right are adjacent indices of i  after the burst  the left and right then becomes adjacent  find the maximum coins you can collect by bursting the balloons wisely  note: you may imagine nums[-1] = nums[n] = 1  they are not real therefore you can not burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
for anyone that is still confused after reading all kinds of explanations    burst balloons given n balloons  indexed from 0 to n-1  each balloon is painted with a number on it represented by array nums  you are asked to burst all the balloons  if the you burst balloon i you will get nums[left]   nums[i]   nums[right] coins  here left and right are adjacent indices of i  after the burst  the left and right then becomes adjacent  find the maximum coins you can collect by bursting the balloons wisely  note: you may imagine nums[-1] = nums[n] = 1  they are not real therefore you can not burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
java dp solution with detailed explanation  o(n^3) burst balloons given n balloons  indexed from 0 to n-1  each balloon is painted with a number on it represented by array nums  you are asked to burst all the balloons  if the you burst balloon i you will get nums[left]   nums[i]   nums[right] coins  here left and right are adjacent indices of i  after the burst  the left and right then becomes adjacent  find the maximum coins you can collect by bursting the balloons wisely  note: you may imagine nums[-1] = nums[n] = 1  they are not real therefore you can not burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
easiest java solution burst balloons given n balloons  indexed from 0 to n-1  each balloon is painted with a number on it represented by array nums  you are asked to burst all the balloons  if the you burst balloon i you will get nums[left]   nums[i]   nums[right] coins  here left and right are adjacent indices of i  after the burst  the left and right then becomes adjacent  find the maximum coins you can collect by bursting the balloons wisely  note: you may imagine nums[-1] = nums[n] = 1  they are not real therefore you can not burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
java three methods  23ms  36 ms  58ms(with heap)  performance explained super ugly number write a program to find the nth super ugly number  super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k  medium math heap 
7 line consice o(kn) c++ solution super ugly number write a program to find the nth super ugly number  super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k  medium math heap 
108ms easy to understand java solution super ugly number write a program to find the nth super ugly number  super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k  medium math heap 
python  generators on a heap super ugly number write a program to find the nth super ugly number  super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k  medium math heap 
java solution uff0c21ms uff0c u8be6 u7ec6 u7684 u4e2d u6587 u89e3 u91ca super ugly number write a program to find the nth super ugly number  super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k  medium math heap 
9ms  short java bst solution get answer when building bst count of smaller numbers after self you are given an integer array nums and you have to return a new counts array  the counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
mergesort solution count of smaller numbers after self you are given an integer array nums and you have to return a new counts array  the counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
11ms java solution using merge sort with explanation count of smaller numbers after self you are given an integer array nums and you have to return a new counts array  the counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
my simple ac java binary search code count of smaller numbers after self you are given an integer array nums and you have to return a new counts array  the counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
c++ o(nlogn)-time o(n)-space mergesort solution with detail explanation count of smaller numbers after self you are given an integer array nums and you have to return a new counts array  the counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
a short o(n) recursive greedy solution remove duplicate letters given a string which contains only lowercase letters  remove duplicate letters so that every letter appear once and only once  you must make sure your result is the smallest in lexicographical order among all possible results  hard stack greedy 
java solution using stack with comments remove duplicate letters given a string which contains only lowercase letters  remove duplicate letters so that every letter appear once and only once  you must make sure your result is the smallest in lexicographical order among all possible results  hard stack greedy 
easy to understand iterative java solution remove duplicate letters given a string which contains only lowercase letters  remove duplicate letters so that every letter appear once and only once  you must make sure your result is the smallest in lexicographical order among all possible results  hard stack greedy 
c++ simple solution easy understanding remove duplicate letters given a string which contains only lowercase letters  remove duplicate letters so that every letter appear once and only once  you must make sure your result is the smallest in lexicographical order among all possible results  hard stack greedy 
java o(n) solution using stack with detail explanation remove duplicate letters given a string which contains only lowercase letters  remove duplicate letters so that every letter appear once and only once  you must make sure your result is the smallest in lexicographical order among all possible results  hard stack greedy 
java----------easy version to understand!!!!!!!!!!!!!!!!! maximum product of word lengths given a string array words  find the maximum value of length(word[i])   length(word[j]) where the two words do not share common letters  you may assume that each word will contain only lower case letters  if no such two words exist  return 0  medium bit manipulation 
32ms java ac solution maximum product of word lengths given a string array words  find the maximum value of length(word[i])   length(word[j]) where the two words do not share common letters  you may assume that each word will contain only lower case letters  if no such two words exist  return 0  medium bit manipulation 
bit shorter c++ maximum product of word lengths given a string array words  find the maximum value of length(word[i])   length(word[j]) where the two words do not share common letters  you may assume that each word will contain only lower case letters  if no such two words exist  return 0  medium bit manipulation 
python solution  beats 99 67% maximum product of word lengths given a string array words  find the maximum value of length(word[i])   length(word[j]) where the two words do not share common letters  you may assume that each word will contain only lower case letters  if no such two words exist  return 0  medium bit manipulation 
java solution with comments maximum product of word lengths given a string array words  find the maximum value of length(word[i])   length(word[j]) where the two words do not share common letters  you may assume that each word will contain only lower case letters  if no such two words exist  return 0  medium bit manipulation 
math solution   bulb switcher there are n bulbs that are initially off  you first turn on all the bulbs  then  you turn off every second bulb  on the third round  you toggle every third bulb (turning on if it's off or turning off if it's on)  for the i-th round  you toggle every i bulb  for the n-th round  you only toggle the last bulb  find how many bulbs are on after n rounds  medium math brainteaser 
share my o(1) solution with explanation bulb switcher there are n bulbs that are initially off  you first turn on all the bulbs  then  you turn off every second bulb  on the third round  you toggle every third bulb (turning on if it's off or turning off if it's on)  for the i-th round  you toggle every i bulb  for the n-th round  you only toggle the last bulb  find how many bulbs are on after n rounds  medium math brainteaser 
my 0 ms c++ solution with explanation bulb switcher there are n bulbs that are initially off  you first turn on all the bulbs  then  you turn off every second bulb  on the third round  you toggle every third bulb (turning on if it's off or turning off if it's on)  for the i-th round  you toggle every i bulb  for the n-th round  you only toggle the last bulb  find how many bulbs are on after n rounds  medium math brainteaser 
the simplest and most efficient solution well-explained bulb switcher there are n bulbs that are initially off  you first turn on all the bulbs  then  you turn off every second bulb  on the third round  you toggle every third bulb (turning on if it's off or turning off if it's on)  for the i-th round  you toggle every i bulb  for the n-th round  you only toggle the last bulb  find how many bulbs are on after n rounds  medium math brainteaser 
one line java with explanation bulb switcher there are n bulbs that are initially off  you first turn on all the bulbs  then  you turn off every second bulb  on the third round  you toggle every third bulb (turning on if it's off or turning off if it's on)  for the i-th round  you toggle every i bulb  for the n-th round  you only toggle the last bulb  find how many bulbs are on after n rounds  medium math brainteaser 
share my greedy solution create maximum number given two arrays of length m and n with digits 0-9 representing two numbers  create the maximum number of length k <= m + n from digits of the two  the relative order of the digits from the same array must be preserved  return an array of the k digits  note: you should try to optimize your time and space complexity  hard dynamic programming greedy 
c++ 16ms  fastest  beats 97%  create maximum number given two arrays of length m and n with digits 0-9 representing two numbers  create the maximum number of length k <= m + n from digits of the two  the relative order of the digits from the same array must be preserved  return an array of the k digits  note: you should try to optimize your time and space complexity  hard dynamic programming greedy 
short python   ruby   c++ create maximum number given two arrays of length m and n with digits 0-9 representing two numbers  create the maximum number of length k <= m + n from digits of the two  the relative order of the digits from the same array must be preserved  return an array of the k digits  note: you should try to optimize your time and space complexity  hard dynamic programming greedy 
share my 21ms java solution with comments create maximum number given two arrays of length m and n with digits 0-9 representing two numbers  create the maximum number of length k <= m + n from digits of the two  the relative order of the digits from the same array must be preserved  return an array of the k digits  note: you should try to optimize your time and space complexity  hard dynamic programming greedy 
share my python solution with explanation create maximum number given two arrays of length m and n with digits 0-9 representing two numbers  create the maximum number of length k <= m + n from digits of the two  the relative order of the digits from the same array must be preserved  return an array of the k digits  note: you should try to optimize your time and space complexity  hard dynamic programming greedy 
[c++] o(n amount) time o(amount) space dp solution coin change you are given coins of different denominations and a total amount of money amount  write a function to compute the fewest number of coins that you need to make up that amount  if that amount of money cannot be made up by any combination of the coins  return -1  medium dynamic programming 
 java  both iterative and recursive solutions with explanations coin change you are given coins of different denominations and a total amount of money amount  write a function to compute the fewest number of coins that you need to make up that amount  if that amount of money cannot be made up by any combination of the coins  return -1  medium dynamic programming 
easy-to-understand recursive dp solution using java (with explanations) coin change you are given coins of different denominations and a total amount of money amount  write a function to compute the fewest number of coins that you need to make up that amount  if that amount of money cannot be made up by any combination of the coins  return -1  medium dynamic programming 
clean dp python code coin change you are given coins of different denominations and a total amount of money amount  write a function to compute the fewest number of coins that you need to make up that amount  if that amount of money cannot be made up by any combination of the coins  return -1  medium dynamic programming 
fast python bfs solution coin change you are given coins of different denominations and a total amount of money amount  write a function to compute the fewest number of coins that you need to make up that amount  if that amount of money cannot be made up by any combination of the coins  return -1  medium dynamic programming 
o(n)+o(1) after median --- virtual indexing wiggle sort ii given an unsorted array nums  reorder it such that nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
step by step explanation of index mapping in java wiggle sort ii given an unsorted array nums  reorder it such that nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
3 lines python  with explanation   proof wiggle sort ii given an unsorted array nums  reorder it such that nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
summary of the various solutions to wiggle sort for your reference wiggle sort ii given an unsorted array nums  reorder it such that nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
o(n)-time o(1)-space solution with detail explanations wiggle sort ii given an unsorted array nums  reorder it such that nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
1 line java solution without loop   recursion power of three given an integer  write a function to determine if it is a power of three  easy math 
   a summary of `all` solutions (new method included at 15:30pm jan-8th) power of three given an integer  write a function to determine if it is a power of three  easy math 
without log and o(1)  power of three given an integer  write a function to determine if it is a power of three  easy math 
1 line c++ no recursion loop power of three given an integer  write a function to determine if it is a power of three  easy math 
one line (cheating) power of three given an integer  write a function to determine if it is a power of three  easy math 
share my solution count of range sum given an integer array nums  return the number of range sums that lie in [lower  upper] inclusive  range sum s(i  j) is defined as the sum of the elements in nums between indices i and j (i ≤ j)  inclusive  note: a naive algorithm of o(n2) is trivial  you must do better than that  hard divide and conquer binary search tree 
summary of the divide and conquer based and binary indexed tree based solutions count of range sum given an integer array nums  return the number of range sums that lie in [lower  upper] inclusive  range sum s(i  j) is defined as the sum of the elements in nums between indices i and j (i ≤ j)  inclusive  note: a naive algorithm of o(n2) is trivial  you must do better than that  hard divide and conquer binary search tree 
short & simple o(n log n) count of range sum given an integer array nums  return the number of range sums that lie in [lower  upper] inclusive  range sum s(i  j) is defined as the sum of the elements in nums between indices i and j (i ≤ j)  inclusive  note: a naive algorithm of o(n2) is trivial  you must do better than that  hard divide and conquer binary search tree 
java segmenttree solution  36ms count of range sum given an integer array nums  return the number of range sums that lie in [lower  upper] inclusive  range sum s(i  j) is defined as the sum of the elements in nums between indices i and j (i ≤ j)  inclusive  note: a naive algorithm of o(n2) is trivial  you must do better than that  hard divide and conquer binary search tree 
c++ merge sort solution  very short count of range sum given an integer array nums  return the number of range sums that lie in [lower  upper] inclusive  range sum s(i  j) is defined as the sum of the elements in nums between indices i and j (i ≤ j)  inclusive  note: a naive algorithm of o(n2) is trivial  you must do better than that  hard divide and conquer binary search tree 
simple o(n) time  o(1)  space java solution  odd even linked list given a singly linked list  group all odd nodes together followed by the even nodes  please note here we are talking about the node number and not the value in the nodes  you should try to do it in place  the program should run in o(1) space complexity and o(nodes) time complexity  medium linked list 
straigntforward java solution  o(1) space  o(n) time odd even linked list given a singly linked list  group all odd nodes together followed by the even nodes  please note here we are talking about the node number and not the value in the nodes  you should try to do it in place  the program should run in o(1) space complexity and o(nodes) time complexity  medium linked list 
simple c++ solution  o(n) time  o(1) space odd even linked list given a singly linked list  group all odd nodes together followed by the even nodes  please note here we are talking about the node number and not the value in the nodes  you should try to do it in place  the program should run in o(1) space complexity and o(nodes) time complexity  medium linked list 
clear python solution odd even linked list given a singly linked list  group all odd nodes together followed by the even nodes  please note here we are talking about the node number and not the value in the nodes  you should try to do it in place  the program should run in o(1) space complexity and o(nodes) time complexity  medium linked list 
1ms java solution odd even linked list given a singly linked list  group all odd nodes together followed by the even nodes  please note here we are talking about the node number and not the value in the nodes  you should try to do it in place  the program should run in o(1) space complexity and o(nodes) time complexity  medium linked list 
15ms concise java solution longest increasing path in a matrix given an integer matrix  find the length of the longest increasing path  from each cell  you can either move to four directions: left  right  up or down  you may not move diagonally or move outside of the boundary (i e  wrap-around is not allowed)  hard depth-first search topological sort memoization 
python solution  memoization dp  288ms longest increasing path in a matrix given an integer matrix  find the length of the longest increasing path  from each cell  you can either move to four directions: left  right  up or down  you may not move diagonally or move outside of the boundary (i e  wrap-around is not allowed)  hard depth-first search topological sort memoization 
graph theory  java solution  o(v^2)  no dfs longest increasing path in a matrix given an integer matrix  find the length of the longest increasing path  from each cell  you can either move to four directions: left  right  up or down  you may not move diagonally or move outside of the boundary (i e  wrap-around is not allowed)  hard depth-first search topological sort memoization 
java 14ms relative short & easy to code solution with explanation  o(mn) time o(mn) space  dfs + dp longest increasing path in a matrix given an integer matrix  find the length of the longest increasing path  from each cell  you can either move to four directions: left  right  up or down  you may not move diagonally or move outside of the boundary (i e  wrap-around is not allowed)  hard depth-first search topological sort memoization 
c++ dp   dfs solution sharing longest increasing path in a matrix given an integer matrix  find the length of the longest increasing path  from each cell  you can either move to four directions: left  right  up or down  you may not move diagonally or move outside of the boundary (i e  wrap-around is not allowed)  hard depth-first search topological sort memoization 
solution + explanation patching array given a sorted positive integer array nums and an integer n  add patch elements to the array such that any number in range [1  n] inclusive can be formed by the sum of some elements in the array  return the minimum number of patches required  hard greedy 
share my thinking process patching array given a sorted positive integer array nums and an integer n  add patch elements to the array such that any number in range [1  n] inclusive can be formed by the sum of some elements in the array  return the minimum number of patches required  hard greedy 
c++  8ms  greedy solution with explanation patching array given a sorted positive integer array nums and an integer n  add patch elements to the array such that any number in range [1  n] inclusive can be formed by the sum of some elements in the array  return the minimum number of patches required  hard greedy 
share my greedy solution by java with simple explanation (time: 1 ms) patching array given a sorted positive integer array nums and an integer n  add patch elements to the array such that any number in range [1  n] inclusive can be formed by the sum of some elements in the array  return the minimum number of patches required  hard greedy 
my simple accepted c++ solution patching array given a sorted positive integer array nums and an integer n  add patch elements to the array such that any number in range [1  n] inclusive can be formed by the sum of some elements in the array  return the minimum number of patches required  hard greedy 
7 lines easy java solution verify preorder serialization of a binary tree one way to serialize a binary tree is to use pre-order traversal  when we encounter a non-null node  we record the node's value  if it is a null node  we record using a sentinel value such as #  _9_     3 2         4 1 # 6             # # # # # # for medium stack 
java intuitive 22ms solution with stack verify preorder serialization of a binary tree one way to serialize a binary tree is to use pre-order traversal  when we encounter a non-null node  we record the node's value  if it is a null node  we record using a sentinel value such as #  _9_     3 2         4 1 # 6             # # # # # # for medium stack 
the simplest python solution with explanation (no stack  no recursion) verify preorder serialization of a binary tree one way to serialize a binary tree is to use pre-order traversal  when we encounter a non-null node  we record the node's value  if it is a null node  we record using a sentinel value such as #  _9_     3 2         4 1 # 6             # # # # # # for medium stack 
java  counting indegree and outdegree  simple & clear! verify preorder serialization of a binary tree one way to serialize a binary tree is to use pre-order traversal  when we encounter a non-null node  we record the node's value  if it is a null node  we record using a sentinel value such as #  _9_     3 2         4 1 # 6             # # # # # # for medium stack 
simple python solution using stack  with explanation  verify preorder serialization of a binary tree one way to serialize a binary tree is to use pre-order traversal  when we encounter a non-null node  we record the node's value  if it is a null node  we record using a sentinel value such as #  _9_     3 2         4 1 # 6             # # # # # # for medium stack 
short ruby   python   java   c++ reconstruct itinerary given a list of airline tickets represented by pairs of departure and arrival airports [from  to]  reconstruct the itinerary in order  all of the tickets belong to a man who departs from jfk  thus  the itinerary must begin with jfk  note: if there are multiple valid itineraries  you should return the itinerary that has the smallest lexical order when read as a single string  for medium depth-first search graph 
share my solution reconstruct itinerary given a list of airline tickets represented by pairs of departure and arrival airports [from  to]  reconstruct the itinerary in order  all of the tickets belong to a man who departs from jfk  thus  the itinerary must begin with jfk  note: if there are multiple valid itineraries  you should return the itinerary that has the smallest lexical order when read as a single string  for medium depth-first search graph 
short c++ dfs iterative 44ms solution with explanation   no recursive calls  no backtracking  reconstruct itinerary given a list of airline tickets represented by pairs of departure and arrival airports [from  to]  reconstruct the itinerary in order  all of the tickets belong to a man who departs from jfk  thus  the itinerary must begin with jfk  note: if there are multiple valid itineraries  you should return the itinerary that has the smallest lexical order when read as a single string  for medium depth-first search graph 
[share solution] java  greedy  stack  15ms with explanation reconstruct itinerary given a list of airline tickets represented by pairs of departure and arrival airports [from  to]  reconstruct the itinerary in order  all of the tickets belong to a man who departs from jfk  thus  the itinerary must begin with jfk  note: if there are multiple valid itineraries  you should return the itinerary that has the smallest lexical order when read as a single string  for medium depth-first search graph 
very straightforward dfs solution with detailed explanations reconstruct itinerary given a list of airline tickets represented by pairs of departure and arrival airports [from  to]  reconstruct the itinerary in order  all of the tickets belong to a man who departs from jfk  thus  the itinerary must begin with jfk  note: if there are multiple valid itineraries  you should return the itinerary that has the smallest lexical order when read as a single string  for medium depth-first search graph 
concise java solution with comments  increasing triplet subsequence given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array  formally the function should: return true if there exists i  j  k such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false  note: your algorithm should run in o(n) time complexity and o(1) space complexity  medium 
clean and short  with comments  c++ increasing triplet subsequence given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array  formally the function should: return true if there exists i  j  k such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false  note: your algorithm should run in o(n) time complexity and o(1) space complexity  medium 
python easy o(n) solution increasing triplet subsequence given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array  formally the function should: return true if there exists i  j  k such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false  note: your algorithm should run in o(n) time complexity and o(1) space complexity  medium 
my accepted java solution for this question  only 7-lines  clear and concise  increasing triplet subsequence given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array  formally the function should: return true if there exists i  j  k such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false  note: your algorithm should run in o(n) time complexity and o(1) space complexity  medium 
simple java solution   easy to understand!!!! increasing triplet subsequence given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array  formally the function should: return true if there exists i  j  k such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false  note: your algorithm should run in o(n) time complexity and o(1) space complexity  medium 
java oms with explanation self crossing you are given an array x of n positive numbers  you start at point (0 0) and moves x[0] metres to the north  then x[1] metres to the west  x[2] metres to the south  x[3] metres to the east and so on  in other words  after each move your direction changes counter-clockwise  write a one-pass algorithm with o(1) extra space to determine  if your path crosses itself  or not  hard math 
another python    self crossing you are given an array x of n positive numbers  you start at point (0 0) and moves x[0] metres to the north  then x[1] metres to the west  x[2] metres to the south  x[3] metres to the east and so on  in other words  after each move your direction changes counter-clockwise  write a one-pass algorithm with o(1) extra space to determine  if your path crosses itself  or not  hard math 
simple java solution self crossing you are given an array x of n positive numbers  you start at point (0 0) and moves x[0] metres to the north  then x[1] metres to the west  x[2] metres to the south  x[3] metres to the east and so on  in other words  after each move your direction changes counter-clockwise  write a one-pass algorithm with o(1) extra space to determine  if your path crosses itself  or not  hard math 
the best submission in c searching for the crossing patterns is the key self crossing you are given an array x of n positive numbers  you start at point (0 0) and moves x[0] metres to the north  then x[1] metres to the west  x[2] metres to the south  x[3] metres to the east and so on  in other words  after each move your direction changes counter-clockwise  write a one-pass algorithm with o(1) extra space to determine  if your path crosses itself  or not  hard math 
c++ simple solution self crossing you are given an array x of n positive numbers  you start at point (0 0) and moves x[0] metres to the north  then x[1] metres to the west  x[2] metres to the south  x[3] metres to the east and so on  in other words  after each move your direction changes counter-clockwise  write a one-pass algorithm with o(1) extra space to determine  if your path crosses itself  or not  hard math 
o(n   k^2) java solution with trie structure palindrome pairs given a list of unique words  find all pairs of distinct indices (i  j) in the given list  so that the concatenation of the two words  i e  words[i] + words[j] is a palindrome  hard hash table string trie 
150 ms 45 lines java solution palindrome pairs given a list of unique words  find all pairs of distinct indices (i  j) in the given list  so that the concatenation of the two words  i e  words[i] + words[j] is a palindrome  hard hash table string trie 
the easy-to-unserstand java solution palindrome pairs given a list of unique words  find all pairs of distinct indices (i  j) in the given list  so that the concatenation of the two words  i e  words[i] + words[j] is a palindrome  hard hash table string trie 
accepted python solution with explanation palindrome pairs given a list of unique words  find all pairs of distinct indices (i  j) in the given list  so that the concatenation of the two words  i e  words[i] + words[j] is a palindrome  hard hash table string trie 
easy to understand ac c++ solution o(n k^2) using map palindrome pairs given a list of unique words  find all pairs of distinct indices (i  j) in the given list  so that the concatenation of the two words  i e  words[i] + words[j] is a palindrome  hard hash table string trie 
step by step tackling of the problem house robber iii the thief has found himself a new place for his thievery again  there is only one entrance to this area  called the "root " besides the root  each house has one and only one parent house  after a tour  the smart thief realized that "all houses in this place forms a binary tree"  it will automatically contact the police if two directly-linked houses were broken into on the same night  determine the maximum amount of money the thief can rob tonight without alerting the police  medium tree depth-first search 
easy understanding solution with dfs house robber iii the thief has found himself a new place for his thievery again  there is only one entrance to this area  called the "root " besides the root  each house has one and only one parent house  after a tour  the smart thief realized that "all houses in this place forms a binary tree"  it will automatically contact the police if two directly-linked houses were broken into on the same night  determine the maximum amount of money the thief can rob tonight without alerting the police  medium tree depth-first search 
simple c++ solution house robber iii the thief has found himself a new place for his thievery again  there is only one entrance to this area  called the "root " besides the root  each house has one and only one parent house  after a tour  the smart thief realized that "all houses in this place forms a binary tree"  it will automatically contact the police if two directly-linked houses were broken into on the same night  determine the maximum amount of money the thief can rob tonight without alerting the police  medium tree depth-first search 
easy to understand(java) house robber iii the thief has found himself a new place for his thievery again  there is only one entrance to this area  called the "root " besides the root  each house has one and only one parent house  after a tour  the smart thief realized that "all houses in this place forms a binary tree"  it will automatically contact the police if two directly-linked houses were broken into on the same night  determine the maximum amount of money the thief can rob tonight without alerting the police  medium tree depth-first search 
c++  java  python &  explanation house robber iii the thief has found himself a new place for his thievery again  there is only one entrance to this area  called the "root " besides the root  each house has one and only one parent house  after a tour  the smart thief realized that "all houses in this place forms a binary tree"  it will automatically contact the police if two directly-linked houses were broken into on the same night  determine the maximum amount of money the thief can rob tonight without alerting the police  medium tree depth-first search 
three-line java solution counting bits given a non negative integer number num  for every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array  medium dynamic programming bit manipulation 
four lines  c++  time o(n)  space o(n) counting bits given a non negative integer number num  for every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array  medium dynamic programming bit manipulation 
how we handle this question on interview [thinking process + dp solution] counting bits given a non negative integer number num  for every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array  medium dynamic programming bit manipulation 
simple java o(n) solution using two pointers counting bits given a non negative integer number num  for every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array  medium dynamic programming bit manipulation 
simple java dynamic programming without any bitwise operation counting bits given a non negative integer number num  for every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array  medium dynamic programming bit manipulation 
simple java solution using a stack with explanation flatten nested list iterator given a nested list of integers  implement an iterator to flatten it  each element is either an integer  or a list -- whose elements may also be integers or other lists  medium stack design 
real iterator in python  java  c++ flatten nested list iterator given a nested list of integers  implement an iterator to flatten it  each element is either an integer  or a list -- whose elements may also be integers or other lists  medium stack design 
share my java neat solution  8ms flatten nested list iterator given a nested list of integers  implement an iterator to flatten it  each element is either an integer  or a list -- whose elements may also be integers or other lists  medium stack design 
8-line python solution flatten nested list iterator given a nested list of integers  implement an iterator to flatten it  each element is either an integer  or a list -- whose elements may also be integers or other lists  medium stack design 
concise c++ without storing all values at initialization flatten nested list iterator given a nested list of integers  implement an iterator to flatten it  each element is either an integer  or a list -- whose elements may also be integers or other lists  medium stack design 
java 1-line (cheating for the purpose of not using loops) power of four given an integer (signed 32 bits)  write a function to check whether it is a power of 4  easy bit manipulation 
1 line c++ solution without confusing bit manipulations power of four given an integer (signed 32 bits)  write a function to check whether it is a power of 4  easy bit manipulation 
o(1) one-line solution without loops power of four given an integer (signed 32 bits)  write a function to check whether it is a power of 4  easy bit manipulation 
python one line solution with explanations power of four given an integer (signed 32 bits)  write a function to check whether it is a power of 4  easy bit manipulation 
simple c++ o(1) solution without 0x55555555 power of four given an integer (signed 32 bits)  write a function to check whether it is a power of 4  easy bit manipulation 
why factor 2 or 3? the math behind this problem  integer break given a positive integer n  break it into the sum of at least two positive integers and maximize the product of those integers  return the maximum product you can get  medium math dynamic programming 
a simple explanation of the math part and a o(n) solution integer break given a positive integer n  break it into the sum of at least two positive integers and maximize the product of those integers  return the maximum product you can get  medium math dynamic programming 
java dp solution integer break given a positive integer n  break it into the sum of at least two positive integers and maximize the product of those integers  return the maximum product you can get  medium math dynamic programming 
o(log(n)) time solution with explanation integer break given a positive integer n  break it into the sum of at least two positive integers and maximize the product of those integers  return the maximum product you can get  medium math dynamic programming 
easy to understand c++ with explanation integer break given a positive integer n  break it into the sum of at least two positive integers and maximize the product of those integers  return the maximum product you can get  medium math dynamic programming 
[java] simple and clean with explanations [6 solutions] reverse string write a function that takes a string as input and returns the string reversed  easy two pointers string 
python2 7 (3 solutions: recursive  classic  pythonic) reverse string write a function that takes a string as input and returns the string reversed  easy two pointers string 
simple c++ solution reverse string write a function that takes a string as input and returns the string reversed  easy two pointers string 
python solution reverse string write a function that takes a string as input and returns the string reversed  easy two pointers string 
c solution sharing reverse string write a function that takes a string as input and returns the string reversed  easy two pointers string 
java standard two pointer solution reverse vowels of a string write a function that takes a string as input and reverse only the vowels of a string  easy two pointers string 
super clean c++ solution using find_first_of and find_last_of reverse vowels of a string write a function that takes a string as input and reverse only the vowels of a string  easy two pointers string 
1-2 lines python ruby reverse vowels of a string write a function that takes a string as input and reverse only the vowels of a string  easy two pointers string 
python 2 pointers solution reverse vowels of a string write a function that takes a string as input and reverse only the vowels of a string  easy two pointers string 
one pass java solution 13ms reverse vowels of a string write a function that takes a string as input and reverse only the vowels of a string  easy two pointers string 
java o(n) solution - bucket sort top k frequent elements given a non-empty array of integers  return the k most frequent elements  medium hash table heap 
3 java solution using array  maxheap  treemap top k frequent elements given a non-empty array of integers  return the k most frequent elements  medium hash table heap 
c++ o(n log(n-k)) unordered_map and priority_queue(maxheap) solution top k frequent elements given a non-empty array of integers  return the k most frequent elements  medium hash table heap 
3 ways to solve this problem top k frequent elements given a non-empty array of integers  return the k most frequent elements  medium hash table heap 
simple c++ solution using hash table and bucket sort top k frequent elements given a non-empty array of integers  return the k most frequent elements  medium hash table heap 
three java solutions intersection of two arrays given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
8ms concise c++ using unordered_set intersection of two arrays given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
small c++ solution intersection of two arrays given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
5ms java using 1 hashset and time complexity of o(m+n) intersection of two arrays given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
python code  3 lines using set intersection of two arrays given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
solution to 3rd follow-up question intersection of two arrays ii given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
ac solution using java hashmap intersection of two arrays ii given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
c++ hash table solution and sort + two pointers solution with time and space complexity intersection of two arrays ii given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
short python   c++ intersection of two arrays ii given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
2 lines in python intersection of two arrays ii given two arrays  write a function to compute their intersection  easy hash table two pointers binary search sort 
java solution using treemap  real o(logn) per adding  data stream as disjoint intervals given a data stream input of non-negative integers a1  a2       an       summarize the numbers seen so far as a list of disjoint intervals  for hard binary search tree 
very concise c++ solution  data stream as disjoint intervals given a data stream input of non-negative integers a1  a2       an       summarize the numbers seen so far as a list of disjoint intervals  for hard binary search tree 
share my python solution using heap data stream as disjoint intervals given a data stream input of non-negative integers a1  a2       an       summarize the numbers seen so far as a list of disjoint intervals  for hard binary search tree 
java fast log (n) solution (186ms) without using the treemap but a customized bst data stream as disjoint intervals given a data stream input of non-negative integers a1  a2       an       summarize the numbers seen so far as a list of disjoint intervals  for hard binary search tree 
i can not understand the question description  can any one explain it? data stream as disjoint intervals given a data stream input of non-negative integers a1  a2       an       summarize the numbers seen so far as a list of disjoint intervals  for hard binary search tree 
java nlogn solution with explanation russian doll envelopes you have a number of envelopes with widths and heights given as a pair of integers (w  h)  one envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope  what is the maximum number of envelopes can you russian doll? (put one inside other) note: rotation is not allowed  hard binary search dynamic programming 
simple dp solution russian doll envelopes you have a number of envelopes with widths and heights given as a pair of integers (w  h)  one envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope  what is the maximum number of envelopes can you russian doll? (put one inside other) note: rotation is not allowed  hard binary search dynamic programming 
[[1 3] [3 5] [6 7] [6 8] [8 4] [9 5]] should be 4 not 3 russian doll envelopes you have a number of envelopes with widths and heights given as a pair of integers (w  h)  one envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope  what is the maximum number of envelopes can you russian doll? (put one inside other) note: rotation is not allowed  hard binary search dynamic programming 
c++ 9-line short and clean o(nlogn) solution (plus classic o(n^2) dp solution)  russian doll envelopes you have a number of envelopes with widths and heights given as a pair of integers (w  h)  one envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope  what is the maximum number of envelopes can you russian doll? (put one inside other) note: rotation is not allowed  hard binary search dynamic programming 
a trick to solve this problem  russian doll envelopes you have a number of envelopes with widths and heights given as a pair of integers (w  h)  one envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope  what is the maximum number of envelopes can you russian doll? (put one inside other) note: rotation is not allowed  hard binary search dynamic programming 
java oo design with most efficient function getnewsfeed design twitter design a simplified version of twitter where users can post tweets  follow unfollow another user and is able to see the 10 most recent tweets in the user's news feed  your design should support the following methods: posttweet(userid  tweetid): compose a new tweet  getnewsfeed(userid): retrieve the 10 most recent tweet ids in the user's news feed  each item in the news feed must be posted by users who the user followed or by the user herself  tweets must be ordered from most recent to least recent  follow(followerid  followeeid): follower follows a followee  unfollow(followerid  followeeid): follower unfollows a followee  medium hash table heap design 
python solution design twitter design a simplified version of twitter where users can post tweets  follow unfollow another user and is able to see the 10 most recent tweets in the user's news feed  your design should support the following methods: posttweet(userid  tweetid): compose a new tweet  getnewsfeed(userid): retrieve the 10 most recent tweet ids in the user's news feed  each item in the news feed must be posted by users who the user followed or by the user herself  tweets must be ordered from most recent to least recent  follow(followerid  followeeid): follower follows a followee  unfollow(followerid  followeeid): follower unfollows a followee  medium hash table heap design 
java solutions with two maps and priorityqueue design twitter design a simplified version of twitter where users can post tweets  follow unfollow another user and is able to see the 10 most recent tweets in the user's news feed  your design should support the following methods: posttweet(userid  tweetid): compose a new tweet  getnewsfeed(userid): retrieve the 10 most recent tweet ids in the user's news feed  each item in the news feed must be posted by users who the user followed or by the user herself  tweets must be ordered from most recent to least recent  follow(followerid  followeeid): follower follows a followee  unfollow(followerid  followeeid): follower unfollows a followee  medium hash table heap design 
72ms c++ solution design twitter design a simplified version of twitter where users can post tweets  follow unfollow another user and is able to see the 10 most recent tweets in the user's news feed  your design should support the following methods: posttweet(userid  tweetid): compose a new tweet  getnewsfeed(userid): retrieve the 10 most recent tweet ids in the user's news feed  each item in the news feed must be posted by users who the user followed or by the user herself  tweets must be ordered from most recent to least recent  follow(followerid  followeeid): follower follows a followee  unfollow(followerid  followeeid): follower unfollows a followee  medium hash table heap design 
java ood solution with detailed explanation design twitter design a simplified version of twitter where users can post tweets  follow unfollow another user and is able to see the 10 most recent tweets in the user's news feed  your design should support the following methods: posttweet(userid  tweetid): compose a new tweet  getnewsfeed(userid): retrieve the 10 most recent tweet ids in the user's news feed  each item in the news feed must be posted by users who the user followed or by the user herself  tweets must be ordered from most recent to least recent  follow(followerid  followeeid): follower follows a followee  unfollow(followerid  followeeid): follower unfollows a followee  medium hash table heap design 
java dp o(1) solution  count numbers with unique digits given a non-negative integer n  count all numbers with unique digits  x  where 0 ≤ x < 10n  medium math dynamic programming backtracking 
java  o(1)  with explanation count numbers with unique digits given a non-negative integer n  count all numbers with unique digits  x  where 0 ≤ x < 10n  medium math dynamic programming backtracking 
share my 0ms c++ solution with proof and explanation count numbers with unique digits given a non-negative integer n  count all numbers with unique digits  x  where 0 ≤ x < 10n  medium math dynamic programming backtracking 
backtracking solution count numbers with unique digits given a non-negative integer n  count all numbers with unique digits  x  where 0 ≤ x < 10n  medium math dynamic programming backtracking 
simple python solution  90% count numbers with unique digits given a non-negative integer n  count all numbers with unique digits  x  where 0 ≤ x < 10n  medium math dynamic programming backtracking 
accepted c++ codes with explanation and references max sum of rectangle no larger than k given a non-empty 2d matrix matrix and an integer k  find the max sum of a rectangle in the matrix such that its sum is no larger than k  hard binary search dynamic programming queue 
java binary search solution time complexity min(m n)^2 max(m n) log(max(m n)) max sum of rectangle no larger than k given a non-empty 2d matrix matrix and an integer k  find the max sum of a rectangle in the matrix such that its sum is no larger than k  hard binary search dynamic programming queue 
2 accepted java solution max sum of rectangle no larger than k given a non-empty 2d matrix matrix and an integer k  find the max sum of a rectangle in the matrix such that its sum is no larger than k  hard binary search dynamic programming queue 
java 117ms  beat 99 81%  merge sort max sum of rectangle no larger than k given a non-empty 2d matrix matrix and an integer k  find the max sum of a rectangle in the matrix such that its sum is no larger than k  hard binary search dynamic programming queue 
any accepted python solution? max sum of rectangle no larger than k given a non-empty 2d matrix matrix and an integer k  find the max sum of a rectangle in the matrix such that its sum is no larger than k  hard binary search dynamic programming queue 
math solution - java solution water and jug problem you are given two jugs with capacities x and y litres  there is an infinite amount of water supply available  you need to determine whether it is possible to measure exactly z litres using these two jugs  if z liters of water is measurable  you must have z liters of water contained within one or both buckets by the end  operations allowed: fill any of the jugs completely with water  empty any of the jugs  pour water from one jug into another till the other jug is completely full or the first jug itself is empty  medium math 
this problem should be classified as hard water and jug problem you are given two jugs with capacities x and y litres  there is an infinite amount of water supply available  you need to determine whether it is possible to measure exactly z litres using these two jugs  if z liters of water is measurable  you must have z liters of water contained within one or both buckets by the end  operations allowed: fill any of the jugs completely with water  empty any of the jugs  pour water from one jug into another till the other jug is completely full or the first jug itself is empty  medium math 
a little explanation on gcd method  c++ java python water and jug problem you are given two jugs with capacities x and y litres  there is an infinite amount of water supply available  you need to determine whether it is possible to measure exactly z litres using these two jugs  if z liters of water is measurable  you must have z liters of water contained within one or both buckets by the end  operations allowed: fill any of the jugs completely with water  empty any of the jugs  pour water from one jug into another till the other jug is completely full or the first jug itself is empty  medium math 
breadth-first search with explanation  water and jug problem you are given two jugs with capacities x and y litres  there is an infinite amount of water supply available  you need to determine whether it is possible to measure exactly z litres using these two jugs  if z liters of water is measurable  you must have z liters of water contained within one or both buckets by the end  operations allowed: fill any of the jugs completely with water  empty any of the jugs  pour water from one jug into another till the other jug is completely full or the first jug itself is empty  medium math 
clear explanation of why using gcd water and jug problem you are given two jugs with capacities x and y litres  there is an infinite amount of water supply available  you need to determine whether it is possible to measure exactly z litres using these two jugs  if z liters of water is measurable  you must have z liters of water contained within one or both buckets by the end  operations allowed: fill any of the jugs completely with water  empty any of the jugs  pour water from one jug into another till the other jug is completely full or the first jug itself is empty  medium math 
a square number is 1+3+5+7+     java code valid perfect square given a positive integer num  write a function which returns true if num is a perfect square else false  note: do not use any built-in library function such as sqrt  easy math binary search 
3-4 short lines  integer newton  most languages valid perfect square given a positive integer num  write a function which returns true if num is a perfect square else false  note: do not use any built-in library function such as sqrt  easy math binary search 
java three solutions 1 3 5    sequence binary search newton valid perfect square given a positive integer num  write a function which returns true if num is a perfect square else false  note: do not use any built-in library function such as sqrt  easy math binary search 
o(1) time c++ solution inspired by q_rsqrt valid perfect square given a positive integer num  write a function which returns true if num is a perfect square else false  note: do not use any built-in library function such as sqrt  easy math binary search 
o(logn) bisection method valid perfect square given a positive integer num  write a function which returns true if num is a perfect square else false  note: do not use any built-in library function such as sqrt  easy math binary search 
classic dp solution similar to lis  o(n^2) largest divisible subset given a set of distinct positive integers  find the largest subset such that every pair (si  sj) of elements in this subset satisfies: si % sj = 0 or sj % si = 0  if there are multiple solutions  return any subset is fine  medium math dynamic programming 
c++ solution with explanations largest divisible subset given a set of distinct positive integers  find the largest subset such that every pair (si  sj) of elements in this subset satisfies: si % sj = 0 or sj % si = 0  if there are multiple solutions  return any subset is fine  medium math dynamic programming 
4 lines in python largest divisible subset given a set of distinct positive integers  find the largest subset such that every pair (si  sj) of elements in this subset satisfies: si % sj = 0 or sj % si = 0  if there are multiple solutions  return any subset is fine  medium math dynamic programming 
easy understood java dp solution in 28ms with o(n^2) time largest divisible subset given a set of distinct positive integers  find the largest subset such that every pair (si  sj) of elements in this subset satisfies: si % sj = 0 or sj % si = 0  if there are multiple solutions  return any subset is fine  medium math dynamic programming 
java solution in 32ms o(n^2) time  o(n) space largest divisible subset given a set of distinct positive integers  find the largest subset such that every pair (si  sj) of elements in this subset satisfies: si % sj = 0 or sj % si = 0  if there are multiple solutions  return any subset is fine  medium math dynamic programming 
a summary: how to use bit manipulation to solve problems easily and efficiently sum of two integers calculate the sum of two integers a and b  but you are not allowed to use the operator + and -  easy bit manipulation 
java simple easy understand solution with explanation sum of two integers calculate the sum of two integers a and b  but you are not allowed to use the operator + and -  easy bit manipulation 
python solution with no "+-  %"  completely bit manipulation guaranteed sum of two integers calculate the sum of two integers a and b  but you are not allowed to use the operator + and -  easy bit manipulation 
share my c++ solutions easy to understand sum of two integers calculate the sum of two integers a and b  but you are not allowed to use the operator + and -  easy bit manipulation 
simple explanation on how to arrive at the solution  sum of two integers calculate the sum of two integers a and b  but you are not allowed to use the operator + and -  easy bit manipulation 
c++ clean and short solution super pow your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array  medium math 
math solusion based on euler's theorem  power called only once  c++ java 1-line-python super pow your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array  medium math 
what's the point of this kind of question? super pow your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array  medium math 
java 4ms solution using the remainder repeat pattern super pow your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array  medium math 
fermat and chinese remainder super pow your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array  medium math 
simple java o(klogk) solution with explanation find k pairs with smallest sums you are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k  define a pair (u v) which consists of one element from the first array and one element from the second array  find the k pairs (u1 v1) (u2 v2)    (uk vk) with the smallest sums  medium heap 
slow 1-liner to fast solutions find k pairs with smallest sums you are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k  define a pair (u v) which consists of one element from the first array and one element from the second array  find the k pairs (u1 v1) (u2 v2)    (uk vk) with the smallest sums  medium heap 
share my solution which beat 96 42% find k pairs with smallest sums you are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k  define a pair (u v) which consists of one element from the first array and one element from the second array  find the k pairs (u1 v1) (u2 v2)    (uk vk) with the smallest sums  medium heap 
java 9ms heap queue solution  k log(k) find k pairs with smallest sums you are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k  define a pair (u v) which consists of one element from the first array and one element from the second array  find the k pairs (u1 v1) (u2 v2)    (uk vk) with the smallest sums  medium heap 
clean 16ms c++ o(n) space o(klogn) time solution using priority queue find k pairs with smallest sums you are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k  define a pair (u v) which consists of one element from the first array and one element from the second array  find the k pairs (u1 v1) (u2 v2)    (uk vk) with the smallest sums  medium heap 
the key point is to read the problem carefully  guess number higher or lower we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number is higher or lower  you call a pre-defined api guess(int num) which returns 3 possible results (-1  1  or 0): -1 : my number is lower 1 : my number is higher 0 : congrats! you got it! easy binary search 
2 lines as usual guess number higher or lower we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number is higher or lower  you call a pre-defined api guess(int num) which returns 3 possible results (-1  1  or 0): -1 : my number is lower 1 : my number is higher 0 : congrats! you got it! easy binary search 
0ms c++ binary search guess number higher or lower we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number is higher or lower  you call a pre-defined api guess(int num) which returns 3 possible results (-1  1  or 0): -1 : my number is lower 1 : my number is higher 0 : congrats! you got it! easy binary search 
short java code using binary search guess number higher or lower we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number is higher or lower  you call a pre-defined api guess(int num) which returns 3 possible results (-1  1  or 0): -1 : my number is lower 1 : my number is higher 0 : congrats! you got it! easy binary search 
i hope developers of leetcode can make the question definition more clear  guess number higher or lower we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number is higher or lower  you call a pre-defined api guess(int num) which returns 3 possible results (-1  1  or 0): -1 : my number is lower 1 : my number is higher 0 : congrats! you got it! easy binary search 
simple dp solution with explanation~~ guess number higher or lower ii we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number i picked is higher or lower  however  when you guess a particular number x  and you guess wrong  you pay $x  you win the game when you guess the number i picked  medium dynamic programming minimax 
improve the question and example guess number higher or lower ii we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number i picked is higher or lower  however  when you guess a particular number x  and you guess wrong  you pay $x  you win the game when you guess the number i picked  medium dynamic programming minimax 
clarification on the problem description  [problem description need to be updated !!! ] guess number higher or lower ii we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number i picked is higher or lower  however  when you guess a particular number x  and you guess wrong  you pay $x  you win the game when you guess the number i picked  medium dynamic programming minimax 
java dp solution guess number higher or lower ii we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number i picked is higher or lower  however  when you guess a particular number x  and you guess wrong  you pay $x  you win the game when you guess the number i picked  medium dynamic programming minimax 
java commented dp solution guess number higher or lower ii we are playing the guess game  the game is as follows: i pick a number from 1 to n  you have to guess which number i picked  every time you guess wrong  i'll tell you whether the number i picked is higher or lower  however  when you guess a particular number x  and you guess wrong  you pay $x  you win the game when you guess the number i picked  medium dynamic programming minimax 
easy understanding dp solution with o(n)  java version wiggle subsequence a sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative  the first difference (if one exists) may be either positive or negative  a sequence with fewer than two elements is trivially a wiggle sequence  for medium dynamic programming greedy 
very simple java solution with detail explanation wiggle subsequence a sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative  the first difference (if one exists) may be either positive or negative  a sequence with fewer than two elements is trivially a wiggle sequence  for medium dynamic programming greedy 
c++ 0ms o(n) dynamic programming solution wiggle subsequence a sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative  the first difference (if one exists) may be either positive or negative  a sequence with fewer than two elements is trivially a wiggle sequence  for medium dynamic programming greedy 
two solutions  one is dp  the other is greedy (8 lines)  wiggle subsequence a sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative  the first difference (if one exists) may be either positive or negative  a sequence with fewer than two elements is trivially a wiggle sequence  for medium dynamic programming greedy 
3 lines o(n) python with explanation proof wiggle subsequence a sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative  the first difference (if one exists) may be either positive or negative  a sequence with fewer than two elements is trivially a wiggle sequence  for medium dynamic programming greedy 
1ms java dp solution with detailed explanation combination sum iv given an integer array with all positive numbers and no duplicates  find the number of possible combinations that add up to a positive integer target  medium dynamic programming 
my 3ms java dp solution combination sum iv given an integer array with all positive numbers and no duplicates  find the number of possible combinations that add up to a positive integer target  medium dynamic programming 
are you kidding me? it is combination?? combination sum iv given an integer array with all positive numbers and no duplicates  find the number of possible combinations that add up to a positive integer target  medium dynamic programming 
c++ template for all combination problem set combination sum iv given an integer array with all positive numbers and no duplicates  find the number of possible combinations that add up to a positive integer target  medium dynamic programming 
java recursion solution using hashmap as memory  combination sum iv given an integer array with all positive numbers and no duplicates  find the number of possible combinations that add up to a positive integer target  medium dynamic programming 
share my thoughts and clean java code kth smallest element in a sorted matrix given a n x n matrix where each of the rows and columns are sorted in ascending order  find the kth smallest element in the matrix  note that it is the kth smallest element in the sorted order  not the kth distinct element  medium binary search heap 
java 1ms nlog(max -min) solution kth smallest element in a sorted matrix given a n x n matrix where each of the rows and columns are sorted in ascending order  find the kth smallest element in the matrix  note that it is the kth smallest element in the sorted order  not the kth distinct element  medium binary search heap 
o(n) from paper  yes  o(#rows)  kth smallest element in a sorted matrix given a n x n matrix where each of the rows and columns are sorted in ascending order  find the kth smallest element in the matrix  note that it is the kth smallest element in the sorted order  not the kth distinct element  medium binary search heap 
my solution using binary search in c++ kth smallest element in a sorted matrix given a n x n matrix where each of the rows and columns are sorted in ascending order  find the kth smallest element in the matrix  note that it is the kth smallest element in the sorted order  not the kth distinct element  medium binary search heap 
binary search  heap and sorting comparison  with concise code and 1-liners  python 72 ms kth smallest element in a sorted matrix given a n x n matrix where each of the rows and columns are sorted in ascending order  find the kth smallest element in the matrix  note that it is the kth smallest element in the sorted order  not the kth distinct element  medium binary search heap 
java solution using a hashmap and an arraylist along with a follow-up  (131 ms) insert delete getrandom o(1) design a data structure that supports all following operations in average o(1) time  insert(val): inserts an item val to the set if not already present  remove(val): removes an item val from the set if present  getrandom: returns a random element from current set of elements  each element must have the same probability of being returned  medium array hash table design 
simple solution in python insert delete getrandom o(1) design a data structure that supports all following operations in average o(1) time  insert(val): inserts an item val to the set if not already present  remove(val): removes an item val from the set if present  getrandom: returns a random element from current set of elements  each element must have the same probability of being returned  medium array hash table design 
ac c++ solution  unordered_map + vector insert delete getrandom o(1) design a data structure that supports all following operations in average o(1) time  insert(val): inserts an item val to the set if not already present  remove(val): removes an item val from the set if present  getrandom: returns a random element from current set of elements  each element must have the same probability of being returned  medium array hash table design 
java solution  concise code with hashmap and arraylist  easy to understand insert delete getrandom o(1) design a data structure that supports all following operations in average o(1) time  insert(val): inserts an item val to the set if not already present  remove(val): removes an item val from the set if present  getrandom: returns a random element from current set of elements  each element must have the same probability of being returned  medium array hash table design 
java solution with two hashmaps: easy to understand insert delete getrandom o(1) design a data structure that supports all following operations in average o(1) time  insert(val): inserts an item val to the set if not already present  remove(val): removes an item val from the set if present  getrandom: returns a random element from current set of elements  each element must have the same probability of being returned  medium array hash table design 
c++ 128m solution  real o(1) solution insert delete getrandom o(1) - duplicates allowed design a data structure that supports all following operations in average o(1) time  note: duplicate elements are allowed  insert(val): inserts an item val to the collection  remove(val): removes an item val from the collection if present  getrandom: returns a random element from current collection of elements  the probability of each element being returned is linearly related to the number of same value the collection contains  hard array hash table design 
java haspmap  linkedhashset  arraylist (155 ms) insert delete getrandom o(1) - duplicates allowed design a data structure that supports all following operations in average o(1) time  note: duplicate elements are allowed  insert(val): inserts an item val to the collection  remove(val): removes an item val from the collection if present  getrandom: returns a random element from current collection of elements  the probability of each element being returned is linearly related to the number of same value the collection contains  hard array hash table design 
frugal python code insert delete getrandom o(1) - duplicates allowed design a data structure that supports all following operations in average o(1) time  note: duplicate elements are allowed  insert(val): inserts an item val to the collection  remove(val): removes an item val from the collection if present  getrandom: returns a random element from current collection of elements  the probability of each element being returned is linearly related to the number of same value the collection contains  hard array hash table design 
clean o(1) java solution with hashmap and set insert delete getrandom o(1) - duplicates allowed design a data structure that supports all following operations in average o(1) time  note: duplicate elements are allowed  insert(val): inserts an item val to the collection  remove(val): removes an item val from the collection if present  getrandom: returns a random element from current collection of elements  the probability of each element being returned is linearly related to the number of same value the collection contains  hard array hash table design 
easy understanding java solution using hashset insert delete getrandom o(1) - duplicates allowed design a data structure that supports all following operations in average o(1) time  note: duplicate elements are allowed  insert(val): inserts an item val to the collection  remove(val): removes an item val from the collection if present  getrandom: returns a random element from current collection of elements  the probability of each element being returned is linearly related to the number of same value the collection contains  hard array hash table design 
brief explanation for reservoir sampling linked list random node given a singly linked list  return a random node's value from the linked list  each node must have the same probability of being chosen  follow up: what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? medium reservoir sampling 
java solution with cases explain linked list random node given a singly linked list  return a random node's value from the linked list  each node must have the same probability of being chosen  follow up: what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? medium reservoir sampling 
using "reservoir sampling" o(1) space  o(n) time complexity uff0cc++ linked list random node given a singly linked list  return a random node's value from the linked list  each node must have the same probability of being chosen  follow up: what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? medium reservoir sampling 
o(n) time & o(1) space java solution linked list random node given a singly linked list  return a random node's value from the linked list  each node must have the same probability of being chosen  follow up: what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? medium reservoir sampling 
"buffered" reservoir sampling linked list random node given a singly linked list  return a random node's value from the linked list  each node must have the same probability of being chosen  follow up: what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? medium reservoir sampling 
java o(n) solution---easy to understand ransom note given an arbitrary ransom note string and another string containing letters from all the magazines  write a function that will return true if the ransom note can be constructed from the magazines ; otherwise  it will return false  each letter in the magazine string can only be used once in your ransom note  note: you may assume that both strings contain only lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
o(m+n) one-liner python ransom note given an arbitrary ransom note string and another string containing letters from all the magazines  write a function that will return true if the ransom note can be constructed from the magazines ; otherwise  it will return false  each letter in the magazine string can only be used once in your ransom note  note: you may assume that both strings contain only lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
java map solution ransom note given an arbitrary ransom note string and another string containing letters from all the magazines  write a function that will return true if the ransom note can be constructed from the magazines ; otherwise  it will return false  each letter in the magazine string can only be used once in your ransom note  note: you may assume that both strings contain only lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
share my easy to understand 5 lines of java code  13ms beats 96% ransom note given an arbitrary ransom note string and another string containing letters from all the magazines  write a function that will return true if the ransom note can be constructed from the magazines ; otherwise  it will return false  each letter in the magazine string can only be used once in your ransom note  note: you may assume that both strings contain only lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
two ac c++ solutions (unordered_map vector) ransom note given an arbitrary ransom note string and another string containing letters from all the magazines  write a function that will return true if the ransom note can be constructed from the magazines ; otherwise  it will return false  each letter in the magazine string can only be used once in your ransom note  note: you may assume that both strings contain only lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
first accepted solution - java shuffle an array shuffle a set of numbers without duplicates  medium 
python hack shuffle an array shuffle a set of numbers without duplicates  medium 
simple java solution shuffle an array shuffle a set of numbers without duplicates  medium 
straight-forward c++ solution shuffle an array shuffle a set of numbers without duplicates  medium 
easy python solution based on generating random index and swapping shuffle an array shuffle a set of numbers without duplicates  medium 
an java iterative solution mini parser given a nested list of integers represented as a string  implement a parser to deserialize it  each element is either an integer  or a list -- whose elements may also be integers or other lists  note: you may assume that the string is well-formed: string is non-empty  string does not contain white spaces  string contains only digits 0-9  [  -    ]  medium string stack 
clarification mini parser given a nested list of integers represented as a string  implement a parser to deserialize it  each element is either an integer  or a list -- whose elements may also be integers or other lists  note: you may assume that the string is well-formed: string is non-empty  string does not contain white spaces  string contains only digits 0-9  [  -    ]  medium string stack 
python & c++ solutions mini parser given a nested list of integers represented as a string  implement a parser to deserialize it  each element is either an integer  or a list -- whose elements may also be integers or other lists  note: you may assume that the string is well-formed: string is non-empty  string does not contain white spaces  string contains only digits 0-9  [  -    ]  medium string stack 
c++ non-recursive one-pass solution (using stack) || a possible implementation of nestedinteger mini parser given a nested list of integers represented as a string  implement a parser to deserialize it  each element is either an integer  or a list -- whose elements may also be integers or other lists  note: you may assume that the string is well-formed: string is non-empty  string does not contain white spaces  string contains only digits 0-9  [  -    ]  medium string stack 
short java recursive solution mini parser given a nested list of integers represented as a string  implement a parser to deserialize it  each element is either an integer  or a list -- whose elements may also be integers or other lists  note: you may assume that the string is well-formed: string is non-empty  string does not contain white spaces  string contains only digits 0-9  [  -    ]  medium string stack 
java o(n) time  o(1) space iterative solution 130ms lexicographical numbers given an integer n  return 1 - n in lexicographical order  for medium 
simple java dfs solution lexicographical numbers given an integer n  return 1 - n in lexicographical order  for medium 
ac 200ms c++ solution  beats 98% lexicographical numbers given an integer n  return 1 - n in lexicographical order  for medium 
the most elegant python solution so far  10 liner  iterative  o(n) time  o(1) space  lexicographical numbers given an integer n  return 1 - n in lexicographical order  for medium 
python with sorting lexicographical numbers given an integer n  return 1 - n in lexicographical order  for medium 
java 7 lines solution 29ms first unique character in a string given a string  find the first non-repeating character in it and return it's index  if it doesn't exist  return -1  easy hash table string 
python 3 lines beats 100% (~ 60ms) ! first unique character in a string given a string  find the first non-repeating character in it and return it's index  if it doesn't exist  return -1  easy hash table string 
java one pass solution with linkedhashmap first unique character in a string given a string  find the first non-repeating character in it and return it's index  if it doesn't exist  return -1  easy hash table string 
javascript solution first unique character in a string given a string  find the first non-repeating character in it and return it's index  if it doesn't exist  return -1  easy hash table string 
c++ 2 solutions first unique character in a string given a string  find the first non-repeating character in it and return it's index  if it doesn't exist  return -1  easy hash table string 
9 lines 4ms java solution longest absolute file path suppose we abstract our file system by a string in the following manner: the string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext the directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file ext  the string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext the directory dir contains two sub-directories subdir1 and subdir2  subdir1 contains a file file1 ext and an empty second-level sub-directory subsubdir1  subdir2 contains a second-level sub-directory subsubdir2 containing a file file2 ext  we are interested in finding the longest (number of characters) absolute path to a file within our file system  for medium 
simple python solution longest absolute file path suppose we abstract our file system by a string in the following manner: the string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext the directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file ext  the string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext the directory dir contains two sub-directories subdir1 and subdir2  subdir1 contains a file file1 ext and an empty second-level sub-directory subsubdir1  subdir2 contains a second-level sub-directory subsubdir2 containing a file file2 ext  we are interested in finding the longest (number of characters) absolute path to a file within our file system  for medium 
this problem is not well-defined  it should state that 4-space is considered as a tab under certain situation  longest absolute file path suppose we abstract our file system by a string in the following manner: the string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext the directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file ext  the string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext the directory dir contains two sub-directories subdir1 and subdir2  subdir1 contains a file file1 ext and an empty second-level sub-directory subsubdir1  subdir2 contains a second-level sub-directory subsubdir2 containing a file file2 ext  we are interested in finding the longest (number of characters) absolute path to a file within our file system  for medium 
simple c++ o(n) solution 0ms longest absolute file path suppose we abstract our file system by a string in the following manner: the string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext the directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file ext  the string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext the directory dir contains two sub-directories subdir1 and subdir2  subdir1 contains a file file1 ext and an empty second-level sub-directory subsubdir1  subdir2 contains a second-level sub-directory subsubdir2 containing a file file2 ext  we are interested in finding the longest (number of characters) absolute path to a file within our file system  for medium 
java o(n) solution using stack longest absolute file path suppose we abstract our file system by a string in the following manner: the string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext the directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file ext  the string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext the directory dir contains two sub-directories subdir1 and subdir2  subdir1 contains a file file1 ext and an empty second-level sub-directory subsubdir1  subdir2 contains a second-level sub-directory subsubdir2 containing a file file2 ext  we are interested in finding the longest (number of characters) absolute path to a file within our file system  for medium 
java solution using bit manipulation find the difference given two strings s and t which consist of only lowercase letters  string t is generated by random shuffling string s and then add one more letter at a random position  find the letter that was added in t  easy hash table bit manipulation 
simple java 8ms solution  4 lines find the difference given two strings s and t which consist of only lowercase letters  string t is generated by random shuffling string s and then add one more letter at a random position  find the letter that was added in t  easy hash table bit manipulation 
concise c++ solution using xor find the difference given two strings s and t which consist of only lowercase letters  string t is generated by random shuffling string s and then add one more letter at a random position  find the letter that was added in t  easy hash table bit manipulation 
3 different python solutions (dictionary  difference  xor) find the difference given two strings s and t which consist of only lowercase letters  string t is generated by random shuffling string s and then add one more letter at a random position  find the letter that was added in t  easy hash table bit manipulation 
1-liners and 2-liner in python find the difference given two strings s and t which consist of only lowercase letters  string t is generated by random shuffling string s and then add one more letter at a random position  find the letter that was added in t  easy hash table bit manipulation 
java: easiest solution o(logn) with explanation elimination game there is a list of sorted integers from 1 to n  starting from left to right  remove the first number and every other number afterward until you reach the end of the list  repeat the previous step again  but this time from right to left  remove the right most number and every other number from the remaining numbers  we keep repeating the steps again  alternating left to right and right to left  until a single number remains  find the last number that remains starting with a list of length n  medium 
c 1 line solution with explanation elimination game there is a list of sorted integers from 1 to n  starting from left to right  remove the first number and every other number afterward until you reach the end of the list  repeat the previous step again  but this time from right to left  remove the right most number and every other number from the remaining numbers  we keep repeating the steps again  alternating left to right and right to left  until a single number remains  find the last number that remains starting with a list of length n  medium 
o(logn) solution  clear break down elimination game there is a list of sorted integers from 1 to n  starting from left to right  remove the first number and every other number afterward until you reach the end of the list  repeat the previous step again  but this time from right to left  remove the right most number and every other number from the remaining numbers  we keep repeating the steps again  alternating left to right and right to left  until a single number remains  find the last number that remains starting with a list of length n  medium 
one line java solution based on josephus problem elimination game there is a list of sorted integers from 1 to n  starting from left to right  remove the first number and every other number afterward until you reach the end of the list  repeat the previous step again  but this time from right to left  remove the right most number and every other number from the remaining numbers  we keep repeating the steps again  alternating left to right and right to left  until a single number remains  find the last number that remains starting with a list of length n  medium 
c++ 29ms with complexity of log4(n) and explanation elimination game there is a list of sorted integers from 1 to n  starting from left to right  remove the first number and every other number afterward until you reach the end of the list  repeat the previous step again  but this time from right to left  remove the right most number and every other number from the remaining numbers  we keep repeating the steps again  alternating left to right and right to left  until a single number remains  find the last number that remains starting with a list of length n  medium 
really easy understanding solution(o(n)  java) perfect rectangle given n axis-aligned rectangles where n > 0  determine if they all together form an exact cover of a rectangular region  each rectangle is represented as a bottom-left point and a top-right point  for hard 
o(n) solution by counting corners with detailed explaination perfect rectangle given n axis-aligned rectangles where n > 0  determine if they all together form an exact cover of a rectangular region  each rectangle is represented as a bottom-left point and a top-right point  for hard 
o(n log n) sweep line solution perfect rectangle given n axis-aligned rectangles where n > 0  determine if they all together form an exact cover of a rectangular region  each rectangle is represented as a bottom-left point and a top-right point  for hard 
short java solution with explanation (updated) perfect rectangle given n axis-aligned rectangles where n > 0  determine if they all together form an exact cover of a rectangular region  each rectangle is represented as a bottom-left point and a top-right point  for hard 
easy understanding o(n) python solution perfect rectangle given n axis-aligned rectangles where n > 0  determine if they all together form an exact cover of a rectangular region  each rectangle is represented as a bottom-left point and a top-right point  for hard 
binary search solution for follow-up with detailed comments is subsequence given a string s and a string t  check if s is subsequence of t  you may assume that there is only lower case english letters in both s and t  t is potentially a very long (length ~= 500 000) string  and s is a short string (<=100)  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  medium binary search dynamic programming greedy 
straight forward java simple solution is subsequence given a string s and a string t  check if s is subsequence of t  you may assume that there is only lower case english letters in both s and t  t is potentially a very long (length ~= 500 000) string  and s is a short string (<=100)  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  medium binary search dynamic programming greedy 
3 lines c is subsequence given a string s and a string t  check if s is subsequence of t  you may assume that there is only lower case english letters in both s and t  t is potentially a very long (length ~= 500 000) string  and s is a short string (<=100)  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  medium binary search dynamic programming greedy 
2 lines python is subsequence given a string s and a string t  check if s is subsequence of t  you may assume that there is only lower case english letters in both s and t  t is potentially a very long (length ~= 500 000) string  and s is a short string (<=100)  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  medium binary search dynamic programming greedy 
java code for the follow-up question is subsequence given a string s and a string t  check if s is subsequence of t  you may assume that there is only lower case english letters in both s and t  t is potentially a very long (length ~= 500 000) string  and s is a short string (<=100)  a subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters  (ie  "ace" is a subsequence of "abcde" while "aec" is not)  medium binary search dynamic programming greedy 
concise c++ implementation utf-8 validation a character in utf8 can be from 1 to 4 bytes long  subjected to the following rules: for 1-byte character  the first bit is a 0  followed by its unicode code  for n-bytes character  the first n-bits are all one's  the n+1 bit is 0  followed by n-1 bytes with most significant 2 bits being 10  this is how the utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given an array of integers representing the data  return whether it is a valid utf-8 encoding  note: the input is an array of integers  only the least significant 8 bits of each integer is used to store the data  this means each integer represents only 1 byte of data  medium bit manipulation 
feeling like an english reading comprehension problem utf-8 validation a character in utf8 can be from 1 to 4 bytes long  subjected to the following rules: for 1-byte character  the first bit is a 0  followed by its unicode code  for n-bytes character  the first n-bits are all one's  the n+1 bit is 0  followed by n-1 bytes with most significant 2 bits being 10  this is how the utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given an array of integers representing the data  return whether it is a valid utf-8 encoding  note: the input is an array of integers  only the least significant 8 bits of each integer is used to store the data  this means each integer represents only 1 byte of data  medium bit manipulation 
bit manipulation  java  6ms utf-8 validation a character in utf8 can be from 1 to 4 bytes long  subjected to the following rules: for 1-byte character  the first bit is a 0  followed by its unicode code  for n-bytes character  the first n-bits are all one's  the n+1 bit is 0  followed by n-1 bytes with most significant 2 bits being 10  this is how the utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given an array of integers representing the data  return whether it is a valid utf-8 encoding  note: the input is an array of integers  only the least significant 8 bits of each integer is used to store the data  this means each integer represents only 1 byte of data  medium bit manipulation 
one pass simple solution utf-8 validation a character in utf8 can be from 1 to 4 bytes long  subjected to the following rules: for 1-byte character  the first bit is a 0  followed by its unicode code  for n-bytes character  the first n-bits are all one's  the n+1 bit is 0  followed by n-1 bytes with most significant 2 bits being 10  this is how the utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given an array of integers representing the data  return whether it is a valid utf-8 encoding  note: the input is an array of integers  only the least significant 8 bits of each integer is used to store the data  this means each integer represents only 1 byte of data  medium bit manipulation 
short'n'clean 12-lines python solution utf-8 validation a character in utf8 can be from 1 to 4 bytes long  subjected to the following rules: for 1-byte character  the first bit is a 0  followed by its unicode code  for n-bytes character  the first n-bits are all one's  the n+1 bit is 0  followed by n-1 bytes with most significant 2 bits being 10  this is how the utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given an array of integers representing the data  return whether it is a valid utf-8 encoding  note: the input is an array of integers  only the least significant 8 bits of each integer is used to store the data  this means each integer represents only 1 byte of data  medium bit manipulation 
0ms simple c++ solution decode string given an encoded string  return it's decoded string  the encoding rule is: k[encoded_string]  where the encoded_string inside the square brackets is being repeated exactly k times  note that k is guaranteed to be a positive integer  you may assume that the input string is always valid; no extra white spaces  square brackets are well-formed  etc  furthermore  you may assume that the original data does not contain any digits and that digits are only for those repeat numbers  k  for medium stack depth-first search 
simple java solution using stack decode string given an encoded string  return it's decoded string  the encoding rule is: k[encoded_string]  where the encoded_string inside the square brackets is being repeated exactly k times  note that k is guaranteed to be a positive integer  you may assume that the input string is always valid; no extra white spaces  square brackets are well-formed  etc  furthermore  you may assume that the original data does not contain any digits and that digits are only for those repeat numbers  k  for medium stack depth-first search 
share my python stack simple solution (easy to understand) decode string given an encoded string  return it's decoded string  the encoding rule is: k[encoded_string]  where the encoded_string inside the square brackets is being repeated exactly k times  note that k is guaranteed to be a positive integer  you may assume that the input string is always valid; no extra white spaces  square brackets are well-formed  etc  furthermore  you may assume that the original data does not contain any digits and that digits are only for those repeat numbers  k  for medium stack depth-first search 
java short and easy-understanding solution using stack decode string given an encoded string  return it's decoded string  the encoding rule is: k[encoded_string]  where the encoded_string inside the square brackets is being repeated exactly k times  note that k is guaranteed to be a positive integer  you may assume that the input string is always valid; no extra white spaces  square brackets are well-formed  etc  furthermore  you may assume that the original data does not contain any digits and that digits are only for those repeat numbers  k  for medium stack depth-first search 
python solution using stack decode string given an encoded string  return it's decoded string  the encoding rule is: k[encoded_string]  where the encoded_string inside the square brackets is being repeated exactly k times  note that k is guaranteed to be a positive integer  you may assume that the input string is always valid; no extra white spaces  square brackets are well-formed  etc  furthermore  you may assume that the original data does not contain any digits and that digits are only for those repeat numbers  k  for medium stack depth-first search 
java strict o(n) two-pointer solution longest substring with at least k repeating characters find the length of the longest substring t of a given string (consists of lowercase letters only) such that every character in t appears no less than k times  medium 
4 lines python longest substring with at least k repeating characters find the length of the longest substring t of a given string (consists of lowercase letters only) such that every character in t appears no less than k times  medium 
java divide and conquer(recursion) solution longest substring with at least k repeating characters find the length of the longest substring t of a given string (consists of lowercase letters only) such that every character in t appears no less than k times  medium 
c++ recursive solution longest substring with at least k repeating characters find the length of the longest substring t of a given string (consists of lowercase letters only) such that every character in t appears no less than k times  medium 
java 20 lines very easy solution 7ms with explanation longest substring with at least k repeating characters find the length of the longest substring t of a given string (consists of lowercase letters only) such that every character in t appears no less than k times  medium 
java o(n) solution with explanation rotate function given an array of integers a and let n to be its length  assume bk to be an array obtained by rotating the array a k positions clock-wise  we define a "rotation function" f on a as follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate the maximum value of f(0)  f(1)       f(n-1)  note: n is guaranteed to be less than 105  medium math 
java solution o(n) with non mathametical explaination rotate function given an array of integers a and let n to be its length  assume bk to be an array obtained by rotating the array a k positions clock-wise  we define a "rotation function" f on a as follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate the maximum value of f(0)  f(1)       f(n-1)  note: n is guaranteed to be less than 105  medium math 
java solution rotate function given an array of integers a and let n to be its length  assume bk to be an array obtained by rotating the array a k positions clock-wise  we define a "rotation function" f on a as follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate the maximum value of f(0)  f(1)       f(n-1)  note: n is guaranteed to be less than 105  medium math 
c++ solution rotate function given an array of integers a and let n to be its length  assume bk to be an array obtained by rotating the array a k positions clock-wise  we define a "rotation function" f on a as follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate the maximum value of f(0)  f(1)       f(n-1)  note: n is guaranteed to be less than 105  medium math 
my o(n) simple c++ solution rotate function given an array of integers a and let n to be its length  assume bk to be an array obtained by rotating the array a k positions clock-wise  we define a "rotation function" f on a as follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate the maximum value of f(0)  f(1)       f(n-1)  note: n is guaranteed to be less than 105  medium math 
a couple of java solutions with explanations integer replacement given a positive integer n and you can do operations as follow: if n is even  replace n with n 2  if n is odd  you can replace n with either n + 1 or n - 1  what is the minimum number of replacements needed for n to become 1? medium math bit manipulation 
java 12 line 4(5)ms iterative solution with explanations  no other data structures  integer replacement given a positive integer n and you can do operations as follow: if n is even  replace n with n 2  if n is odd  you can replace n with either n + 1 or n - 1  what is the minimum number of replacements needed for n to become 1? medium math bit manipulation 
python o(log n) time  o(1) space with explanation and proof integer replacement given a positive integer n and you can do operations as follow: if n is even  replace n with n 2  if n is odd  you can replace n with either n + 1 or n - 1  what is the minimum number of replacements needed for n to become 1? medium math bit manipulation 
c++ 0ms 11 lines "dp" solution integer replacement given a positive integer n and you can do operations as follow: if n is even  replace n with n 2  if n is odd  you can replace n with either n + 1 or n - 1  what is the minimum number of replacements needed for n to become 1? medium math bit manipulation 
0 ms c++ recursion solution with explanation integer replacement given a positive integer n and you can do operations as follow: if n is even  replace n with n 2  if n is odd  you can replace n with either n + 1 or n - 1  what is the minimum number of replacements needed for n to become 1? medium math bit manipulation 
simple reservoir sampling solution random pick index given an array of integers with possible duplicates  randomly output the index of a given target number  you can assume that the given target number must exist in the array  note: the array size can be very large  solution that uses too much extra space will not pass the judge  medium reservoir sampling 
what on earth is meant by too much memory? random pick index given an array of integers with possible duplicates  randomly output the index of a given target number  you can assume that the given target number must exist in the array  note: the array size can be very large  solution that uses too much extra space will not pass the judge  medium reservoir sampling 
c++_time: o(n)  space: o(n)_116ms_96 41%_with clear explanation by probability random pick index given an array of integers with possible duplicates  randomly output the index of a given target number  you can assume that the given target number must exist in the array  note: the array size can be very large  solution that uses too much extra space will not pass the judge  medium reservoir sampling 
clean  understandable  o(1) momery  o(n) time  java solution random pick index given an array of integers with possible duplicates  randomly output the index of a given target number  you can assume that the given target number must exist in the array  note: the array size can be very large  solution that uses too much extra space will not pass the judge  medium reservoir sampling 
simple python solution random pick index given an array of integers with possible duplicates  randomly output the index of a given target number  you can assume that the given target number must exist in the array  note: the array size can be very large  solution that uses too much extra space will not pass the judge  medium reservoir sampling 
java ac solution using graph evaluate division equations are given in the format a   b = k  where a and b are variables represented as strings  and k is a real number (floating point number)  given some queries  return the answers  if the answer does not exist  return -1 0  medium graph 
9 lines "floyd u2013warshall" in python evaluate division equations are given in the format a   b = k  where a and b are variables represented as strings  and k is a real number (floating point number)  given some queries  return the answers  if the answer does not exist  return -1 0  medium graph 
0ms c++ union-find solution [easy to understand] evaluate division equations are given in the format a   b = k  where a and b are variables represented as strings  and k is a real number (floating point number)  given some queries  return the answers  if the answer does not exist  return -1 0  medium graph 
python fast bfs solution with detailed explantion evaluate division equations are given in the format a   b = k  where a and b are variables represented as strings  and k is a real number (floating point number)  given some queries  return the answers  if the answer does not exist  return -1 0  medium graph 
esay understand java solution  3ms evaluate division equations are given in the format a   b = k  where a and b are variables represented as strings  and k is a real number (floating point number)  given some queries  return the answers  if the answer does not exist  return -1 0  medium graph 
java solution nth digit find the nth digit of the infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n is positive and will fit within the range of a 32-bit signed integer (n < 231)  easy math 
0ms c++ solution with detail-explanation nth digit find the nth digit of the infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n is positive and will fit within the range of a 32-bit signed integer (n < 231)  easy math 
short python+java nth digit find the nth digit of the infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n is positive and will fit within the range of a 32-bit signed integer (n < 231)  easy math 
4-liner in python  and complexity analysis nth digit find the nth digit of the infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n is positive and will fit within the range of a 32-bit signed integer (n < 231)  easy math 
sharing my thinking process nth digit find the nth digit of the infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n is positive and will fit within the range of a 32-bit signed integer (n < 231)  easy math 
simple python+java binary watch a binary watch has 4 leds on the top which represent the hours (0-11)  and the 6 leds on the bottom represent the minutes (0-59)  each led represents a zero or one  with the least significant bit on the right  for easy backtracking bit manipulation 
straight-forward 6-line c++ solution  no need to explain binary watch a binary watch has 4 leds on the top which represent the hours (0-11)  and the 6 leds on the bottom represent the minutes (0-59)  each led represents a zero or one  with the least significant bit on the right  for easy backtracking bit manipulation 
3ms java solution using backtracking and idea of "permutation and combination" binary watch a binary watch has 4 leds on the top which represent the hours (0-11)  and the 6 leds on the bottom represent the minutes (0-59)  each led represents a zero or one  with the least significant bit on the right  for easy backtracking bit manipulation 
just for fun!!!!!!!   java 1ms  beats 100% binary watch a binary watch has 4 leds on the top which represent the hours (0-11)  and the 6 leds on the bottom represent the minutes (0-59)  each led represents a zero or one  with the least significant bit on the right  for easy backtracking bit manipulation 
straightforward java answer binary watch a binary watch has 4 leds on the top which represent the hours (0-11)  and the 6 leds on the bottom represent the minutes (0-59)  each led represents a zero or one  with the least significant bit on the right  for easy backtracking bit manipulation 
straightforward java solution using stack remove k digits given a non-negative integer num represented as a string  remove k digits from the number so that the new number is the smallest possible  note: the length of num is less than 10002 and will be ≥ k  the given num does not contain any leading zero  medium stack greedy 
a greedy method using stack  o(n) time and o(n) space remove k digits given a non-negative integer num represented as a string  remove k digits from the number so that the new number is the smallest possible  note: the length of num is less than 10002 and will be ≥ k  the given num does not contain any leading zero  medium stack greedy 
two algorithms with detailed explaination remove k digits given a non-negative integer num represented as a string  remove k digits from the number so that the new number is the smallest possible  note: the length of num is less than 10002 and will be ≥ k  the given num does not contain any leading zero  medium stack greedy 
short python  one o(n) and one regex remove k digits given a non-negative integer num represented as a string  remove k digits from the number so that the new number is the smallest possible  note: the length of num is less than 10002 and will be ≥ k  the given num does not contain any leading zero  medium stack greedy 
my easy understandable c++ solution remove k digits given a non-negative integer num represented as a string  remove k digits from the number so that the new number is the smallest possible  note: the length of num is less than 10002 and will be ≥ k  the given num does not contain any leading zero  medium stack greedy 
java iterative and recursive solutions sum of left leaves find the sum of all left leaves in a given binary tree  easy tree 
java solution using bfs sum of left leaves find the sum of all left leaves in a given binary tree  easy tree 
3-line c++ solution sum of left leaves find the sum of all left leaves in a given binary tree  easy tree 
3 line recursive c++ solution  no need to explain sum of left leaves find the sum of all left leaves in a given binary tree  easy tree 
4 lines python recursive ac solution sum of left leaves find the sum of all left leaves in a given binary tree  easy tree 
simple java solution with comment convert a number to hexadecimal given an integer  write an algorithm to convert it to hexadecimal  for negative integer  two’s complement method is used  note: all letters in hexadecimal (a-f) must be in lowercase  the hexadecimal string must not contain extra leading 0s  if the number is zero  it is represented by a single zero character '0'; otherwise  the first character in the hexadecimal string will not be the zero character  the given number is guaranteed to fit within the range of a 32-bit signed integer  you must not use any method provided by the library which converts formats the number to hex directly  easy bit manipulation 
concise c++ solution convert a number to hexadecimal given an integer  write an algorithm to convert it to hexadecimal  for negative integer  two’s complement method is used  note: all letters in hexadecimal (a-f) must be in lowercase  the hexadecimal string must not contain extra leading 0s  if the number is zero  it is represented by a single zero character '0'; otherwise  the first character in the hexadecimal string will not be the zero character  the given number is guaranteed to fit within the range of a 32-bit signed integer  you must not use any method provided by the library which converts formats the number to hex directly  easy bit manipulation 
easy 10-line python solution with inline explanation convert a number to hexadecimal given an integer  write an algorithm to convert it to hexadecimal  for negative integer  two’s complement method is used  note: all letters in hexadecimal (a-f) must be in lowercase  the hexadecimal string must not contain extra leading 0s  if the number is zero  it is represented by a single zero character '0'; otherwise  the first character in the hexadecimal string will not be the zero character  the given number is guaranteed to fit within the range of a 32-bit signed integer  you must not use any method provided by the library which converts formats the number to hex directly  easy bit manipulation 
1-liner in python convert a number to hexadecimal given an integer  write an algorithm to convert it to hexadecimal  for negative integer  two’s complement method is used  note: all letters in hexadecimal (a-f) must be in lowercase  the hexadecimal string must not contain extra leading 0s  if the number is zero  it is represented by a single zero character '0'; otherwise  the first character in the hexadecimal string will not be the zero character  the given number is guaranteed to fit within the range of a 32-bit signed integer  you must not use any method provided by the library which converts formats the number to hex directly  easy bit manipulation 
python solution convert a number to hexadecimal given an integer  write an algorithm to convert it to hexadecimal  for negative integer  two’s complement method is used  note: all letters in hexadecimal (a-f) must be in lowercase  the hexadecimal string must not contain extra leading 0s  if the number is zero  it is represented by a single zero character '0'; otherwise  the first character in the hexadecimal string will not be the zero character  the given number is guaranteed to fit within the range of a 32-bit signed integer  you must not use any method provided by the library which converts formats the number to hex directly  easy bit manipulation 
easy concept with python c++ java solution queue reconstruction by height suppose you have a random list of people standing in a queue  each person is described by a pair of integers (h  k)  where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h  write an algorithm to reconstruct the queue  note: the number of people is less than 1 100  medium greedy 
explanation of the neat sort+insert solution queue reconstruction by height suppose you have a random list of people standing in a queue  each person is described by a pair of integers (h  k)  where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h  write an algorithm to reconstruct the queue  note: the number of people is less than 1 100  medium greedy 
6 lines  concise c++ queue reconstruction by height suppose you have a random list of people standing in a queue  each person is described by a pair of integers (h  k)  where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h  write an algorithm to reconstruct the queue  note: the number of people is less than 1 100  medium greedy 
i don't understand the question  reconstruct the queue to what? queue reconstruction by height suppose you have a random list of people standing in a queue  each person is described by a pair of integers (h  k)  where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h  write an algorithm to reconstruct the queue  note: the number of people is less than 1 100  medium greedy 
java solution using arrays sort() and "insert sorting" idea queue reconstruction by height suppose you have a random list of people standing in a queue  each person is described by a pair of integers (h  k)  where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h  write an algorithm to reconstruct the queue  note: the number of people is less than 1 100  medium greedy 
java solution using priorityqueue trapping rain water ii given an m x n matrix of positive integers representing the height of each unit cell in a 2d elevation map  compute the volume of water it is able to trap after raining  note: both m and n are less than 110  the height of each unit cell is greater than 0 and is less than 20 000  hard heap breadth-first search 
visualization - no code trapping rain water ii given an m x n matrix of positive integers representing the height of each unit cell in a 2d elevation map  compute the volume of water it is able to trap after raining  note: both m and n are less than 110  the height of each unit cell is greater than 0 and is less than 20 000  hard heap breadth-first search 
python solution with heap trapping rain water ii given an m x n matrix of positive integers representing the height of each unit cell in a 2d elevation map  compute the volume of water it is able to trap after raining  note: both m and n are less than 110  the height of each unit cell is greater than 0 and is less than 20 000  hard heap breadth-first search 
how to get the solution to 2-d "trapping rain water" problem from 1-d case trapping rain water ii given an m x n matrix of positive integers representing the height of each unit cell in a 2d elevation map  compute the volume of water it is able to trap after raining  note: both m and n are less than 110  the height of each unit cell is greater than 0 and is less than 20 000  hard heap breadth-first search 
alternative approach using dijkstra in o(rc max(log r  log c)) time trapping rain water ii given an m x n matrix of positive integers representing the height of each unit cell in a 2d elevation map  compute the volume of water it is able to trap after raining  note: both m and n are less than 110  the height of each unit cell is greater than 0 and is less than 20 000  hard heap breadth-first search 
simple hashset solution java longest palindrome given a string which consists of lowercase or uppercase letters  find the length of the longest palindromes that can be built with those letters  this is case sensitive  for easy hash table 
what are the odds? (python & c++) longest palindrome given a string which consists of lowercase or uppercase letters  find the length of the longest palindromes that can be built with those letters  this is case sensitive  for easy hash table 
java solution  simple and clear  using int[26] longest palindrome given a string which consists of lowercase or uppercase letters  find the length of the longest palindromes that can be built with those letters  this is case sensitive  for easy hash table 
simple java solution in one pass longest palindrome given a string which consists of lowercase or uppercase letters  find the length of the longest palindromes that can be built with those letters  this is case sensitive  for easy hash table 
easy to understand accepted solution with explanation longest palindrome given a string which consists of lowercase or uppercase letters  find the length of the longest palindromes that can be built with those letters  this is case sensitive  for easy hash table 
clear explanation: 8ms binary search java split array largest sum given an array which consists of non-negative integers and an integer m  you can split the array into m non-empty continuous subarrays  write an algorithm to minimize the largest sum among these m subarrays  note: if n is the length of array  assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50  n) hard binary search dynamic programming 
[c++   fast   very clear explanation   clean code] solution with greedy algorithm and binary search split array largest sum given an array which consists of non-negative integers and an integer m  you can split the array into m non-empty continuous subarrays  write an algorithm to minimize the largest sum among these m subarrays  note: if n is the length of array  assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50  n) hard binary search dynamic programming 
dp java split array largest sum given an array which consists of non-negative integers and an integer m  you can split the array into m non-empty continuous subarrays  write an algorithm to minimize the largest sum among these m subarrays  note: if n is the length of array  assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50  n) hard binary search dynamic programming 
java easy binary search solution 8ms split array largest sum given an array which consists of non-negative integers and an integer m  you can split the array into m non-empty continuous subarrays  write an algorithm to minimize the largest sum among these m subarrays  note: if n is the length of array  assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50  n) hard binary search dynamic programming 
python solution dp and binary search split array largest sum given an array which consists of non-negative integers and an integer m  you can split the array into m non-empty continuous subarrays  write an algorithm to minimize the largest sum among these m subarrays  note: if n is the length of array  assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50  n) hard binary search dynamic programming 
java 4ms solution   not using "%" operation fizz buzz write a program that outputs the string representation of numbers from 1 to n  but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz”  for numbers which are multiples of both three and five output “fizzbuzz”  easy 
python golf fizz buzz write a program that outputs the string representation of numbers from 1 to n  but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz”  for numbers which are multiples of both three and five output “fizzbuzz”  easy 
java easy iterative solution fizz buzz write a program that outputs the string representation of numbers from 1 to n  but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz”  for numbers which are multiples of both three and five output “fizzbuzz”  easy 
java  fuzz buzz--follow up(no if else  and extendable) fizz buzz write a program that outputs the string representation of numbers from 1 to n  but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz”  for numbers which are multiples of both three and five output “fizzbuzz”  easy 
one-line c# solution fizz buzz write a program that outputs the string representation of numbers from 1 to n  but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz”  for numbers which are multiples of both three and five output “fizzbuzz”  easy 
simple java solution 9 lines  2ms arithmetic slices a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for medium math dynamic programming 
3ms c++ standard dp solution with very detailed explanation arithmetic slices a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for medium math dynamic programming 
2ms java o(n) time  o(1) space solution arithmetic slices a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for medium math dynamic programming 
python dp solution arithmetic slices a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for medium math dynamic programming 
java 2ms o(n) solution using dp with detail explanation arithmetic slices a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for medium math dynamic programming 
java neat and easy understand solution  o(n) time  o(1) space third maximum number given a non-empty array of integers  return the third maximum number in this array  if it does not exist  return the maximum number  the time complexity must be in o(n)  easy array 
short easy c++ using set third maximum number given a non-empty array of integers  return the third maximum number in this array  if it does not exist  return the maximum number  the time complexity must be in o(n)  easy array 
intuitive and short python solution third maximum number given a non-empty array of integers  return the third maximum number in this array  if it does not exist  return the maximum number  the time complexity must be in o(n)  easy array 
a python amusing solution  which actually beats 98%    third maximum number given a non-empty array of integers  return the third maximum number in this array  if it does not exist  return the maximum number  the time complexity must be in o(n)  easy array 
java priorityqueue o(n) + o(1) third maximum number given a non-empty array of integers  return the third maximum number in this array  if it does not exist  return the maximum number  the time complexity must be in o(n)  easy array 
0 1 knapsack detailed explanation partition equal subset sum given a non-empty array containing only positive integers  find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal  note: each of the array element will not exceed 100  the array size will not exceed 200  medium dynamic programming 
java solution similar to backpack problem - easy to understand partition equal subset sum given a non-empty array containing only positive integers  find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal  note: each of the array element will not exceed 100  the array size will not exceed 200  medium dynamic programming 
simple c++ 4-line solution using a bitset partition equal subset sum given a non-empty array containing only positive integers  find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal  note: each of the array element will not exceed 100  the array size will not exceed 200  medium dynamic programming 
concise c++ solution summary with dfs  dp  bit partition equal subset sum given a non-empty array containing only positive integers  find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal  note: each of the array element will not exceed 100  the array size will not exceed 200  medium dynamic programming 
java solution similar to 'subset sum problem' partition equal subset sum given a non-empty array containing only positive integers  find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal  note: each of the array element will not exceed 100  the array size will not exceed 200  medium dynamic programming 
java bfs & dfs from ocean pacific atlantic water flow given an m x n matrix of non-negative integers representing the height of each unit cell in a continent  the "pacific ocean" touches the left and top edges of the matrix and the "atlantic ocean" touches the right and bottom edges  water can only flow in four directions (up  down  left  or right) from a cell to another one with height equal or lower  find the list of grid coordinates where water can flow to both the pacific and atlantic ocean  note: the order of returned grid coordinates does not matter  both m and n are less than 150  medium depth-first search breadth-first search 
python dfs bests 85%  tips for all dfs in matrix question  pacific atlantic water flow given an m x n matrix of non-negative integers representing the height of each unit cell in a continent  the "pacific ocean" touches the left and top edges of the matrix and the "atlantic ocean" touches the right and bottom edges  water can only flow in four directions (up  down  left  or right) from a cell to another one with height equal or lower  find the list of grid coordinates where water can flow to both the pacific and atlantic ocean  note: the order of returned grid coordinates does not matter  both m and n are less than 150  medium depth-first search breadth-first search 
not understanding the problem  could someone please explain? pacific atlantic water flow given an m x n matrix of non-negative integers representing the height of each unit cell in a continent  the "pacific ocean" touches the left and top edges of the matrix and the "atlantic ocean" touches the right and bottom edges  water can only flow in four directions (up  down  left  or right) from a cell to another one with height equal or lower  find the list of grid coordinates where water can flow to both the pacific and atlantic ocean  note: the order of returned grid coordinates does not matter  both m and n are less than 150  medium depth-first search breadth-first search 
very concise c++ solution using dfs and bit mask pacific atlantic water flow given an m x n matrix of non-negative integers representing the height of each unit cell in a continent  the "pacific ocean" touches the left and top edges of the matrix and the "atlantic ocean" touches the right and bottom edges  water can only flow in four directions (up  down  left  or right) from a cell to another one with height equal or lower  find the list of grid coordinates where water can flow to both the pacific and atlantic ocean  note: the order of returned grid coordinates does not matter  both m and n are less than 150  medium depth-first search breadth-first search 
simple commented java solution with thinking progress o(n) pacific atlantic water flow given an m x n matrix of non-negative integers representing the height of each unit cell in a continent  the "pacific ocean" touches the left and top edges of the matrix and the "atlantic ocean" touches the right and bottom edges  water can only flow in four directions (up  down  left  or right) from a cell to another one with height equal or lower  find the list of grid coordinates where water can flow to both the pacific and atlantic ocean  note: the order of returned grid coordinates does not matter  both m and n are less than 150  medium depth-first search breadth-first search 
simple java solution battleships in a board given an 2d board  count how many battleships are in it  the battleships are represented with 'x's  empty slots are represented with ' 's  you may assume the following rules: you receive a valid board  made of only battleships or empty slots  battleships can only be placed horizontally or vertically  in other words  they can only be made of the shape 1xn (1 row  n columns) or nx1 (n rows  1 column)  where n can be of any size  at least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships  medium 
share my 7-line code  1-line core code  3ms  super easy battleships in a board given an 2d board  count how many battleships are in it  the battleships are represented with 'x's  empty slots are represented with ' 's  you may assume the following rules: you receive a valid board  made of only battleships or empty slots  battleships can only be placed horizontally or vertically  in other words  they can only be made of the shape 1xn (1 row  n columns) or nx1 (n rows  1 column)  where n can be of any size  at least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships  medium 
python solution battleships in a board given an 2d board  count how many battleships are in it  the battleships are represented with 'x's  empty slots are represented with ' 's  you may assume the following rules: you receive a valid board  made of only battleships or empty slots  battleships can only be placed horizontally or vertically  in other words  they can only be made of the shape 1xn (1 row  n columns) or nx1 (n rows  1 column)  where n can be of any size  at least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships  medium 
4ms java optimized code battleships in a board given an 2d board  count how many battleships are in it  the battleships are represented with 'x's  empty slots are represented with ' 's  you may assume the following rules: you receive a valid board  made of only battleships or empty slots  battleships can only be placed horizontally or vertically  in other words  they can only be made of the shape 1xn (1 row  n columns) or nx1 (n rows  1 column)  where n can be of any size  at least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships  medium 
confused with test cases battleships in a board given an 2d board  count how many battleships are in it  the battleships are represented with 'x's  empty slots are represented with ' 's  you may assume the following rules: you receive a valid board  made of only battleships or empty slots  battleships can only be placed horizontally or vertically  in other words  they can only be made of the shape 1xn (1 row  n columns) or nx1 (n rows  1 column)  where n can be of any size  at least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships  medium 
c++ 0ms o(n) 35 lines solution with detailed explanation strong password checker a password is considered strong if below conditions are all met: it has at least 6 characters and at most 20 characters  it must contain at least one lowercase letter  at least one uppercase letter  and at least one digit  it must not contain three repeating characters in a row ("   aaa   " is weak  but "   aa   a   " is strong  assuming other conditions are met)  write a function strongpasswordchecker(s)  that takes a string s as input  and return the minimum change required to make s a strong password  if s is already strong  return 0  insertion  deletion or replace of any one character are all considered as one change  hard 
o(n) java solution by analyzing changes allowed to fix each problem strong password checker a password is considered strong if below conditions are all met: it has at least 6 characters and at most 20 characters  it must contain at least one lowercase letter  at least one uppercase letter  and at least one digit  it must not contain three repeating characters in a row ("   aaa   " is weak  but "   aa   a   " is strong  assuming other conditions are met)  write a function strongpasswordchecker(s)  that takes a string s as input  and return the minimum change required to make s a strong password  if s is already strong  return 0  insertion  deletion or replace of any one character are all considered as one change  hard 
simple python solution strong password checker a password is considered strong if below conditions are all met: it has at least 6 characters and at most 20 characters  it must contain at least one lowercase letter  at least one uppercase letter  and at least one digit  it must not contain three repeating characters in a row ("   aaa   " is weak  but "   aa   a   " is strong  assuming other conditions are met)  write a function strongpasswordchecker(s)  that takes a string s as input  and return the minimum change required to make s a strong password  if s is already strong  return 0  insertion  deletion or replace of any one character are all considered as one change  hard 
java easy solution with explanation strong password checker a password is considered strong if below conditions are all met: it has at least 6 characters and at most 20 characters  it must contain at least one lowercase letter  at least one uppercase letter  and at least one digit  it must not contain three repeating characters in a row ("   aaa   " is weak  but "   aa   a   " is strong  assuming other conditions are met)  write a function strongpasswordchecker(s)  that takes a string s as input  and return the minimum change required to make s a strong password  if s is already strong  return 0  insertion  deletion or replace of any one character are all considered as one change  hard 
java o(n) greedy solution with super clear explanation strong password checker a password is considered strong if below conditions are all met: it has at least 6 characters and at most 20 characters  it must contain at least one lowercase letter  at least one uppercase letter  and at least one digit  it must not contain three repeating characters in a row ("   aaa   " is weak  but "   aa   a   " is strong  assuming other conditions are met)  write a function strongpasswordchecker(s)  that takes a string s as input  and return the minimum change required to make s a strong password  if s is already strong  return 0  insertion  deletion or replace of any one character are all considered as one change  hard 
java o(n) solution using bit manipulation and hashmap maximum xor of two numbers in an array given a non-empty array of numbers  a0  a1  a2  …   an-1  where 0 ≤ ai < 231  find the maximum result of ai xor aj  where 0 ≤ i  j < n  could you do this in o(n) runtime? medium bit manipulation trie 
java o(n) solution using trie maximum xor of two numbers in an array given a non-empty array of numbers  a0  a1  a2  …   an-1  where 0 ≤ ai < 231  find the maximum result of ai xor aj  where 0 ≤ i  j < n  could you do this in o(n) runtime? medium bit manipulation trie 
python 6 lines  bit by bit maximum xor of two numbers in an array given a non-empty array of numbers  a0  a1  a2  …   an-1  where 0 ≤ ai < 231  find the maximum result of ai xor aj  where 0 ≤ i  j < n  could you do this in o(n) runtime? medium bit manipulation trie 
使用前缀树(二叉树表示) 打败 92% maximum xor of two numbers in an array given a non-empty array of numbers  a0  a1  a2  …   an-1  where 0 ≤ ai < 231  find the maximum result of ai xor aj  where 0 ≤ i  j < n  could you do this in o(n) runtime? medium bit manipulation trie 
c++  o(n) solution  explanation added maximum xor of two numbers in an array given a non-empty array of numbers  a0  a1  a2  …   an-1  where 0 ≤ ai < 231  find the maximum result of ai xor aj  where 0 ≤ i  j < n  could you do this in o(n) runtime? medium bit manipulation trie 
one pass o(n) java solution  simple and clear reconstruct original digits from english given a non-empty string containing an out-of-order english representation of digits 0-9  output the digits in ascending order  note: input contains only lowercase english letters  input is guaranteed to be valid and can be transformed to its original digits  that means invalid inputs such as "abc" or "zerone" are not permitted  input length is less than 50 000  medium math 
fun fact reconstruct original digits from english given a non-empty string containing an out-of-order english representation of digits 0-9  output the digits in ascending order  note: input contains only lowercase english letters  input is guaranteed to be valid and can be transformed to its original digits  that means invalid inputs such as "abc" or "zerone" are not permitted  input length is less than 50 000  medium math 
share my simple and easy o(n) solution reconstruct original digits from english given a non-empty string containing an out-of-order english representation of digits 0-9  output the digits in ascending order  note: input contains only lowercase english letters  input is guaranteed to be valid and can be transformed to its original digits  that means invalid inputs such as "abc" or "zerone" are not permitted  input length is less than 50 000  medium math 
straightforward c++ accepted solution reconstruct original digits from english given a non-empty string containing an out-of-order english representation of digits 0-9  output the digits in ascending order  note: input contains only lowercase english letters  input is guaranteed to be valid and can be transformed to its original digits  that means invalid inputs such as "abc" or "zerone" are not permitted  input length is less than 50 000  medium math 
short matrix solution reconstruct original digits from english given a non-empty string containing an out-of-order english representation of digits 0-9  output the digits in ascending order  note: input contains only lowercase english letters  input is guaranteed to be valid and can be transformed to its original digits  that means invalid inputs such as "abc" or "zerone" are not permitted  input length is less than 50 000  medium math 
java 12 lines o(n) sliding window solution with explanation longest repeating character replacement given a string that consists of only uppercase english letters  you can replace any letter in the string with another letter at most k times  find the length of a longest substring containing all repeating letters you can get after performing the above operations  note: both the string's length and k will not exceed 104  medium 
sliding window  similar to finding longest substring with k distinct characters longest repeating character replacement given a string that consists of only uppercase english letters  you can replace any letter in the string with another letter at most k times  find the length of a longest substring containing all repeating letters you can get after performing the above operations  note: both the string's length and k will not exceed 104  medium 
7 lines c++ longest repeating character replacement given a string that consists of only uppercase english letters  you can replace any letter in the string with another letter at most k times  find the length of a longest substring containing all repeating letters you can get after performing the above operations  note: both the string's length and k will not exceed 104  medium 
consise python sliding window longest repeating character replacement given a string that consists of only uppercase english letters  you can replace any letter in the string with another letter at most k times  find the length of a longest substring containing all repeating letters you can get after performing the above operations  note: both the string's length and k will not exceed 104  medium 
java sliding window easy to understand longest repeating character replacement given a string that consists of only uppercase english letters  you can replace any letter in the string with another letter at most k times  find the length of a longest substring containing all repeating letters you can get after performing the above operations  note: both the string's length and k will not exceed 104  medium 
please correct your example illustration !!! construct quad tree we want to use quad trees to store an n x n boolean grid  each cell in the grid can only be true or false  the root node represents the whole grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  your task is to use a quad tree to represent a given grid  the following easy 
recursive java solution construct quad tree we want to use quad trees to store an n x n boolean grid  each cell in the grid can only be true or false  the root node represents the whole grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  your task is to use a quad tree to represent a given grid  the following easy 
python short & readable dfs solution construct quad tree we want to use quad trees to store an n x n boolean grid  each cell in the grid can only be true or false  the root node represents the whole grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  your task is to use a quad tree to represent a given grid  the following easy 
java recursive solution construct quad tree we want to use quad trees to store an n x n boolean grid  each cell in the grid can only be true or false  the root node represents the whole grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  your task is to use a quad tree to represent a given grid  the following easy 
non-leaf nodes seems have to be true value construct quad tree we want to use quad trees to store an n x n boolean grid  each cell in the grid can only be true or false  the root node represents the whole grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  your task is to use a quad tree to represent a given grid  the following easy 
python 5 lines bfs solution  n-ary tree level order traversal given an n-ary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for easy tree breadth-first search 
basic c++ solution using queue  super easy for beginners  n-ary tree level order traversal given an n-ary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for easy tree breadth-first search 
java solution n-ary tree level order traversal given an n-ary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for easy tree breadth-first search 
python iterative solution beat 96% n-ary tree level order traversal given an n-ary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for easy tree breadth-first search 
beat 100% of java -  dfs (recursive) n-ary tree level order traversal given an n-ary tree  return the level order traversal of its nodes' values  (ie  from left to right  level by level)  for easy tree breadth-first search 
easy understanding java beat 95 7% with explanation flatten a multilevel doubly linked list you are given a doubly linked list which in addition to the next and previous pointers  it could have a child pointer  which may or may not point to a separate doubly linked list  these child lists may have one or more children of their own  and so on  to produce a multilevel data structure  as shown in the medium linked list depth-first search 
java recursive solution flatten a multilevel doubly linked list you are given a doubly linked list which in addition to the next and previous pointers  it could have a child pointer  which may or may not point to a separate doubly linked list  these child lists may have one or more children of their own  and so on  to produce a multilevel data structure  as shown in the medium linked list depth-first search 
python easy solution using stack  flatten a multilevel doubly linked list you are given a doubly linked list which in addition to the next and previous pointers  it could have a child pointer  which may or may not point to a separate doubly linked list  these child lists may have one or more children of their own  and so on  to produce a multilevel data structure  as shown in the medium linked list depth-first search 
c++  about 10 lines solution flatten a multilevel doubly linked list you are given a doubly linked list which in addition to the next and previous pointers  it could have a child pointer  which may or may not point to a separate doubly linked list  these child lists may have one or more children of their own  and so on  to produce a multilevel data structure  as shown in the medium linked list depth-first search 
python solution with explanation flatten a multilevel doubly linked list you are given a doubly linked list which in addition to the next and previous pointers  it could have a child pointer  which may or may not point to a separate doubly linked list  these child lists may have one or more children of their own  and so on  to produce a multilevel data structure  as shown in the medium linked list depth-first search 
java ac all strict o(1) not average o(1)  easy to read all o`one data structure implement a data structure supporting the following operations: inc(key) - inserts a new key with value 1  or increments an existing key by 1  key is guaranteed to be a non-empty string  dec(key) - if key's value is 1  remove it from the data structure  otherwise decrements an existing key by 1  if the key does not exist  this function does nothing  key is guaranteed to be a non-empty string  getmaxkey() - returns one of the keys with maximal value  if no element exists  return an empty string ""  getminkey() - returns one of the keys with minimal value  if no element exists  return an empty string ""  challenge: perform all these in o(1) time complexity  hard design 
all in o(1)  with detailed explantation all o`one data structure implement a data structure supporting the following operations: inc(key) - inserts a new key with value 1  or increments an existing key by 1  key is guaranteed to be a non-empty string  dec(key) - if key's value is 1  remove it from the data structure  otherwise decrements an existing key by 1  if the key does not exist  this function does nothing  key is guaranteed to be a non-empty string  getmaxkey() - returns one of the keys with maximal value  if no element exists  return an empty string ""  getminkey() - returns one of the keys with minimal value  if no element exists  return an empty string ""  challenge: perform all these in o(1) time complexity  hard design 
c++ solution with comments all o`one data structure implement a data structure supporting the following operations: inc(key) - inserts a new key with value 1  or increments an existing key by 1  key is guaranteed to be a non-empty string  dec(key) - if key's value is 1  remove it from the data structure  otherwise decrements an existing key by 1  if the key does not exist  this function does nothing  key is guaranteed to be a non-empty string  getmaxkey() - returns one of the keys with maximal value  if no element exists  return an empty string ""  getminkey() - returns one of the keys with minimal value  if no element exists  return an empty string ""  challenge: perform all these in o(1) time complexity  hard design 
an accepted java solution  detailed explanation (hashmap + double linked list) all o`one data structure implement a data structure supporting the following operations: inc(key) - inserts a new key with value 1  or increments an existing key by 1  key is guaranteed to be a non-empty string  dec(key) - if key's value is 1  remove it from the data structure  otherwise decrements an existing key by 1  if the key does not exist  this function does nothing  key is guaranteed to be a non-empty string  getmaxkey() - returns one of the keys with maximal value  if no element exists  return an empty string ""  getminkey() - returns one of the keys with minimal value  if no element exists  return an empty string ""  challenge: perform all these in o(1) time complexity  hard design 
python solution with detailed comments all o`one data structure implement a data structure supporting the following operations: inc(key) - inserts a new key with value 1  or increments an existing key by 1  key is guaranteed to be a non-empty string  dec(key) - if key's value is 1  remove it from the data structure  otherwise decrements an existing key by 1  if the key does not exist  this function does nothing  key is guaranteed to be a non-empty string  getmaxkey() - returns one of the keys with maximal value  if no element exists  return an empty string ""  getminkey() - returns one of the keys with minimal value  if no element exists  return an empty string ""  challenge: perform all these in o(1) time complexity  hard design 
java solution using bfs minimum genetic mutation a gene string can be represented by an 8-character long string  with choices from "a"  "c"  "g"  "t"  suppose we need to investigate about a mutation (mutation from "start" to "end")  where one mutation is defined as one single character changed in the gene string  for medium 
c++ two end bfs solution  exactly same as 127 word ladder minimum genetic mutation a gene string can be represented by an 8-character long string  with choices from "a"  "c"  "g"  "t"  suppose we need to investigate about a mutation (mutation from "start" to "end")  where one mutation is defined as one single character changed in the gene string  for medium 
python solution using bfs minimum genetic mutation a gene string can be represented by an 8-character long string  with choices from "a"  "c"  "g"  "t"  suppose we need to investigate about a mutation (mutation from "start" to "end")  where one mutation is defined as one single character changed in the gene string  for medium 
clear java solution based on bfs (similar to word ladder) minimum genetic mutation a gene string can be represented by an 8-character long string  with choices from "a"  "c"  "g"  "t"  suppose we need to investigate about a mutation (mutation from "start" to "end")  where one mutation is defined as one single character changed in the gene string  for medium 
c++ bfs (0ms) minimum genetic mutation a gene string can be represented by an 8-character long string  with choices from "a"  "c"  "g"  "t"  suppose we need to investigate about a mutation (mutation from "start" to "end")  where one mutation is defined as one single character changed in the gene string  for medium 
clean java solution o(n) number of segments in a string count the number of segments in a string  where a segment is defined to be a contiguous sequence of non-space characters  please note that the string does not contain any non-printable characters  easy string 
one-liners number of segments in a string count the number of segments in a string  where a segment is defined to be a contiguous sequence of non-space characters  please note that the string does not contain any non-printable characters  easy string 
o(n) sentinel value concise solution  c++ number of segments in a string count the number of segments in a string  where a segment is defined to be a contiguous sequence of non-space characters  please note that the string does not contain any non-printable characters  easy string 
2-line c++ solution simply using stringstream >> operator number of segments in a string count the number of segments in a string  where a segment is defined to be a contiguous sequence of non-space characters  please note that the string does not contain any non-printable characters  easy string 
ac solution java with trim() and split() number of segments in a string count the number of segments in a string  where a segment is defined to be a contiguous sequence of non-space characters  please note that the string does not contain any non-printable characters  easy string 
java: least is most non-overlapping intervals given a collection of intervals  find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping  note: you may assume the interval's end point is always bigger than its start point  intervals like [1 2] and [2 3] have borders "touching" but they don't overlap each other  medium greedy 
short ruby and python non-overlapping intervals given a collection of intervals  find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping  note: you may assume the interval's end point is always bigger than its start point  intervals like [1 2] and [2 3] have borders "touching" but they don't overlap each other  medium greedy 
concise c++ solution non-overlapping intervals given a collection of intervals  find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping  note: you may assume the interval's end point is always bigger than its start point  intervals like [1 2] and [2 3] have borders "touching" but they don't overlap each other  medium greedy 
java solution with clear explain non-overlapping intervals given a collection of intervals  find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping  note: you may assume the interval's end point is always bigger than its start point  intervals like [1 2] and [2 3] have borders "touching" but they don't overlap each other  medium greedy 
python greedy solution with explanation non-overlapping intervals given a collection of intervals  find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping  note: you may assume the interval's end point is always bigger than its start point  intervals like [1 2] and [2 3] have borders "touching" but they don't overlap each other  medium greedy 
java clear o(n logn) solution based on treemap find right interval given a set of intervals  for each of the interval i  check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i  which can be called that j is on the "right" of i  for any interval i  you need to store the minimum interval j's index  which means that the interval j has the minimum start point to build the "right" relationship for interval i  if the interval j doesn't exist  store -1 for the interval i  finally  you need output the stored value of each interval as an array  note: you may assume the interval's end point is always bigger than its start point  you may assume none of these intervals have the same start point  medium binary search 
c++ map solution find right interval given a set of intervals  for each of the interval i  check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i  which can be called that j is on the "right" of i  for any interval i  you need to store the minimum interval j's index  which means that the interval j has the minimum start point to build the "right" relationship for interval i  if the interval j doesn't exist  store -1 for the interval i  finally  you need output the stored value of each interval as an array  note: you may assume the interval's end point is always bigger than its start point  you may assume none of these intervals have the same start point  medium binary search 
python o(nlogn) short solution with explanation find right interval given a set of intervals  for each of the interval i  check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i  which can be called that j is on the "right" of i  for any interval i  you need to store the minimum interval j's index  which means that the interval j has the minimum start point to build the "right" relationship for interval i  if the interval j doesn't exist  store -1 for the interval i  finally  you need output the stored value of each interval as an array  note: you may assume the interval's end point is always bigger than its start point  you may assume none of these intervals have the same start point  medium binary search 
java concise binary search find right interval given a set of intervals  for each of the interval i  check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i  which can be called that j is on the "right" of i  for any interval i  you need to store the minimum interval j's index  which means that the interval j has the minimum start point to build the "right" relationship for interval i  if the interval j doesn't exist  store -1 for the interval i  finally  you need output the stored value of each interval as an array  note: you may assume the interval's end point is always bigger than its start point  you may assume none of these intervals have the same start point  medium binary search 
2 lines python   ruby find right interval given a set of intervals  for each of the interval i  check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i  which can be called that j is on the "right" of i  for any interval i  you need to store the minimum interval j's index  which means that the interval j has the minimum start point to build the "right" relationship for interval i  if the interval j doesn't exist  store -1 for the interval i  finally  you need output the stored value of each interval as an array  note: you may assume the interval's end point is always bigger than its start point  you may assume none of these intervals have the same start point  medium binary search 
17 ms o(n) java prefix sum method path sum iii you are given a binary tree in which each node contains an integer value  find the number of paths that sum to a given value  the path does not need to start or end at the root or a leaf  but it must go downwards (traveling only from parent nodes to child nodes)  the tree has no more than 1 000 nodes and the values are in the range -1 000 000 to 1 000 000  easy tree 
simple java dfs path sum iii you are given a binary tree in which each node contains an integer value  find the number of paths that sum to a given value  the path does not need to start or end at the root or a leaf  but it must go downwards (traveling only from parent nodes to child nodes)  the tree has no more than 1 000 nodes and the values are in the range -1 000 000 to 1 000 000  easy tree 
simple ac java solution dfs path sum iii you are given a binary tree in which each node contains an integer value  find the number of paths that sum to a given value  the path does not need to start or end at the root or a leaf  but it must go downwards (traveling only from parent nodes to child nodes)  the tree has no more than 1 000 nodes and the values are in the range -1 000 000 to 1 000 000  easy tree 
python solution with detailed explanation path sum iii you are given a binary tree in which each node contains an integer value  find the number of paths that sum to a given value  the path does not need to start or end at the root or a leaf  but it must go downwards (traveling only from parent nodes to child nodes)  the tree has no more than 1 000 nodes and the values are in the range -1 000 000 to 1 000 000  easy tree 
python step-by-step walk through  easy to understand  two solutions comparison  : ) path sum iii you are given a binary tree in which each node contains an integer value  find the number of paths that sum to a given value  the path does not need to start or end at the root or a leaf  but it must go downwards (traveling only from parent nodes to child nodes)  the tree has no more than 1 000 nodes and the values are in the range -1 000 000 to 1 000 000  easy tree 
sliding window algorithm template to solve all the leetcode substring search problem  find all anagrams in a string given a string s and a non-empty string p  find all the start indices of p's anagrams in s  strings consists of lowercase english letters only and the length of both strings s and p will not be larger than 20 100  the order of output does not matter  easy hash table 
shortest concise java o(n) sliding window solution find all anagrams in a string given a string s and a non-empty string p  find all the start indices of p's anagrams in s  strings consists of lowercase english letters only and the length of both strings s and p will not be larger than 20 100  the order of output does not matter  easy hash table 
o(n) sliding window java solution  extremely detailed explanation find all anagrams in a string given a string s and a non-empty string p  find all the start indices of p's anagrams in s  strings consists of lowercase english letters only and the length of both strings s and p will not be larger than 20 100  the order of output does not matter  easy hash table 
python sliding window solution using counter find all anagrams in a string given a string s and a non-empty string p  find all the start indices of p's anagrams in s  strings consists of lowercase english letters only and the length of both strings s and p will not be larger than 20 100  the order of output does not matter  easy hash table 
c++ o(n) sliding window concise solution with explanation find all anagrams in a string given a string s and a non-empty string p  find all the start indices of p's anagrams in s  strings consists of lowercase english letters only and the length of both strings s and p will not be larger than 20 100  the order of output does not matter  easy hash table 
concise easy-to-understand java 5ms solution with explaination k-th smallest in lexicographical order given integers n and k  find the lexicographically k-th smallest integer in the range from 1 to n  note: 1 ≤ k ≤ n ≤ 109  hard 
c++ python 0ms o((log n)^2)-time o(1)-space super easy solution with detailed explanations k-th smallest in lexicographical order given integers n and k  find the lexicographically k-th smallest integer in the range from 1 to n  note: 1 ≤ k ≤ n ≤ 109  hard 
java 7ms denary(trie?) tree solution with detailed explanation k-th smallest in lexicographical order given integers n and k  find the lexicographically k-th smallest integer in the range from 1 to n  note: 1 ≤ k ≤ n ≤ 109  hard 
it's a denary tree k-th smallest in lexicographical order given integers n and k  find the lexicographically k-th smallest integer in the range from 1 to n  note: 1 ≤ k ≤ n ≤ 109  hard 
what's wrong with my answer??? i am definitely right k-th smallest in lexicographical order given integers n and k  find the lexicographically k-th smallest integer in the range from 1 to n  note: 1 ≤ k ≤ n ≤ 109  hard 
[java] clean code with explanations and running time [2 solutions] arranging coins you have a total of n coins that you want to form in a staircase shape  where every k-th row must have exactly k coins  given n  find the total number of full staircase rows that can be formed  n is a non-negative integer and fits within the range of a 32-bit signed integer  easy math binary search 
java o(1) solution - math problem arranging coins you have a total of n coins that you want to form in a staircase shape  where every k-th row must have exactly k coins  given n  find the total number of full staircase rows that can be formed  n is a non-negative integer and fits within the range of a 32-bit signed integer  easy math binary search 
c++ 1 line code arranging coins you have a total of n coins that you want to form in a staircase shape  where every k-th row must have exactly k coins  given n  find the total number of full staircase rows that can be formed  n is a non-negative integer and fits within the range of a 32-bit signed integer  easy math binary search 
[java] cleaner and easier to understand solution  arranging coins you have a total of n coins that you want to form in a staircase shape  where every k-th row must have exactly k coins  given n  find the total number of full staircase rows that can be formed  n is a non-negative integer and fits within the range of a 32-bit signed integer  easy math binary search 
o(logn) binary search java solution arranging coins you have a total of n coins that you want to form in a staircase shape  where every k-th row must have exactly k coins  given n  find the total number of full staircase rows that can be formed  n is a non-negative integer and fits within the range of a 32-bit signed integer  easy math binary search 
java simple solution find all duplicates in an array given an array of integers  1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements that appear twice in this array  could you do it without extra space and in o(n) runtime? medium array 
python o(n) time o(1) space find all duplicates in an array given an array of integers  1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements that appear twice in this array  could you do it without extra space and in o(n) runtime? medium array 
very simple c++ solution find all duplicates in an array given an array of integers  1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements that appear twice in this array  could you do it without extra space and in o(n) runtime? medium array 
c++ beats 98% find all duplicates in an array given an array of integers  1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements that appear twice in this array  could you do it without extra space and in o(n) runtime? medium array 
java solution without destroying the input array  o(n) time  o(1) space  find all duplicates in an array given an array of integers  1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements that appear twice in this array  could you do it without extra space and in o(n) runtime? medium array 
simple easy to understand java solution string compression given an array of characters  compress it in-place  the length after compression must always be smaller than or equal to the original array  every element of the array should be a character (not int) of length 1  after you are done modifying the input array in-place  return the new length of the array  follow up: could you solve it using only o(1) extra space? easy string 
python two pointers - o(n) time o(1) space string compression given an array of characters  compress it in-place  the length after compression must always be smaller than or equal to the original array  every element of the array should be a character (not int) of length 1  after you are done modifying the input array in-place  return the new length of the array  follow up: could you solve it using only o(1) extra space? easy string 
java o(n)  two pointers and a counter string compression given an array of characters  compress it in-place  the length after compression must always be smaller than or equal to the original array  every element of the array should be a character (not int) of length 1  after you are done modifying the input array in-place  return the new length of the array  follow up: could you solve it using only o(1) extra space? easy string 
python 5-liner  o(n) time  no pointers! string compression given an array of characters  compress it in-place  the length after compression must always be smaller than or equal to the original array  every element of the array should be a character (not int) of length 1  after you are done modifying the input array in-place  return the new length of the array  follow up: could you solve it using only o(1) extra space? easy string 
python solution with detailed explanation string compression given an array of characters  compress it in-place  the length after compression must always be smaller than or equal to the original array  every element of the array should be a character (not int) of length 1  after you are done modifying the input array in-place  return the new length of the array  follow up: could you solve it using only o(1) extra space? easy string 
easy o(n) java solution using stack add two numbers ii you are given two non-empty linked lists representing two non-negative integers  the most significant digit comes first and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  follow up: what if you cannot modify the input lists? in other words  reversing the lists is not allowed  medium linked list 
c++ o(1) extra space except for output  reverse output instead  is this cheating? add two numbers ii you are given two non-empty linked lists representing two non-negative integers  the most significant digit comes first and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  follow up: what if you cannot modify the input lists? in other words  reversing the lists is not allowed  medium linked list 
java o(n) recursive solution by counting the difference of length add two numbers ii you are given two non-empty linked lists representing two non-negative integers  the most significant digit comes first and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  follow up: what if you cannot modify the input lists? in other words  reversing the lists is not allowed  medium linked list 
there is no maximum of int in python  so      add two numbers ii you are given two non-empty linked lists representing two non-negative integers  the most significant digit comes first and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  follow up: what if you cannot modify the input lists? in other words  reversing the lists is not allowed  medium linked list 
concise c++ solution without reverse add two numbers ii you are given two non-empty linked lists representing two non-negative integers  the most significant digit comes first and each of their nodes contain a single digit  add the two numbers and return it as a linked list  you may assume the two numbers do not contain any leading zero  except the number 0 itself  follow up: what if you cannot modify the input lists? in other words  reversing the lists is not allowed  medium linked list 
detailed explanation for java o(n^2) solution arithmetic slices ii - subsequence a sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for hard dynamic programming 
java 15 lines solution arithmetic slices ii - subsequence a sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for hard dynamic programming 
11 line python o(n^2) solution arithmetic slices ii - subsequence a sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for hard dynamic programming 
c++_dp_accepted arithmetic slices ii - subsequence a sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for hard dynamic programming 
o(n^2) mle tle in c++? try this one  concise and fast  arithmetic slices ii - subsequence a sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same  for hard dynamic programming 
clean java solution: o(n^2) 166ms number of boomerangs given n points in the plane that are all pairwise distinct  a "boomerang" is a tuple of points (i  j  k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters)  find the number of boomerangs  you may assume that n will be at most 500 and coordinates of points are all in the range [-10000  10000] (inclusive)  easy hash table 
short python o(n^2) hashmap solution number of boomerangs given n points in the plane that are all pairwise distinct  a "boomerang" is a tuple of points (i  j  k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters)  find the number of boomerangs  you may assume that n will be at most 500 and coordinates of points are all in the range [-10000  10000] (inclusive)  easy hash table 
7 lines ~1050 ms c++ number of boomerangs given n points in the plane that are all pairwise distinct  a "boomerang" is a tuple of points (i  j  k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters)  find the number of boomerangs  you may assume that n will be at most 500 and coordinates of points are all in the range [-10000  10000] (inclusive)  easy hash table 
c++ clean solution o(n^2)  fully commented and explained  number of boomerangs given n points in the plane that are all pairwise distinct  a "boomerang" is a tuple of points (i  j  k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters)  find the number of boomerangs  you may assume that n will be at most 500 and coordinates of points are all in the range [-10000  10000] (inclusive)  easy hash table 
share my straightforward solution with hashmap  o(n^2) number of boomerangs given n points in the plane that are all pairwise distinct  a "boomerang" is a tuple of points (i  j  k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters)  find the number of boomerangs  you may assume that n will be at most 500 and coordinates of points are all in the range [-10000  10000] (inclusive)  easy hash table 
java accepted simple solution find all numbers disappeared in an array given an array of integers where 1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements of [1  n] inclusive that do not appear in this array  could you do it without extra space and in o(n) runtime? you may assume the returned list does not count as extra space  easy array 
python 4 lines with short explanation find all numbers disappeared in an array given an array of integers where 1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements of [1  n] inclusive that do not appear in this array  could you do it without extra space and in o(n) runtime? you may assume the returned list does not count as extra space  easy array 
5-line java easy-understanding find all numbers disappeared in an array given an array of integers where 1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements of [1  n] inclusive that do not appear in this array  could you do it without extra space and in o(n) runtime? you may assume the returned list does not count as extra space  easy array 
c++ solution o(1) space find all numbers disappeared in an array given an array of integers where 1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements of [1  n] inclusive that do not appear in this array  could you do it without extra space and in o(n) runtime? you may assume the returned list does not count as extra space  easy array 
simple java in-place sort solution find all numbers disappeared in an array given an array of integers where 1 ≤ a[i] ≤ n (n = size of array)  some elements appear twice and others appear once  find all the elements of [1  n] inclusive that do not appear in this array  could you do it without extra space and in o(n) runtime? you may assume the returned list does not count as extra space  easy array 
java preorder + queue solution serialize and deserialize bst serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary search tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure  the encoded string should be as compact as possible  note: do not use class member global static variables to store states  your serialize and deserialize algorithms should be stateless  medium tree 
concise c++ 19ms solution beating 99 4% serialize and deserialize bst serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary search tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure  the encoded string should be as compact as possible  note: do not use class member global static variables to store states  your serialize and deserialize algorithms should be stateless  medium tree 
deserialize from preorder and computed inorder  reusing old solution serialize and deserialize bst serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary search tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure  the encoded string should be as compact as possible  note: do not use class member global static variables to store states  your serialize and deserialize algorithms should be stateless  medium tree 
what's the difference between this and #297 ? serialize and deserialize bst serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary search tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure  the encoded string should be as compact as possible  note: do not use class member global static variables to store states  your serialize and deserialize algorithms should be stateless  medium tree 
using lower bound and upper bound to deserialize bst serialize and deserialize bst serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer  or transmitted across a network connection link to be reconstructed later in the same or another computer environment  design an algorithm to serialize and deserialize a binary search tree  there is no restriction on how your serialization deserialization algorithm should work  you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure  the encoded string should be as compact as possible  note: do not use class member global static variables to store states  your serialize and deserialize algorithms should be stateless  medium tree 
recursive easy to understand java solution delete node in a bst given a root node reference of a bst and a key  delete the node with the given key in the bst  return the root node reference (possibly updated) of the bst  basically  the deletion can be divided into two stages: search for a node to remove  if the node is found  delete the node  note: time complexity should be o(height of tree)  medium tree 
iterative solution in java  o(h) time and o(1) space delete node in a bst given a root node reference of a bst and a key  delete the node with the given key in the bst  return the root node reference (possibly updated) of the bst  basically  the deletion can be divided into two stages: search for a node to remove  if the node is found  delete the node  note: time complexity should be o(height of tree)  medium tree 
very concise c++ solution for general binary tree not only bst delete node in a bst given a root node reference of a bst and a key  delete the node with the given key in the bst  return the root node reference (possibly updated) of the bst  basically  the deletion can be divided into two stages: search for a node to remove  if the node is found  delete the node  note: time complexity should be o(height of tree)  medium tree 
simple python solution with explanation delete node in a bst given a root node reference of a bst and a key  delete the node with the given key in the bst  return the root node reference (possibly updated) of the bst  basically  the deletion can be divided into two stages: search for a node to remove  if the node is found  delete the node  note: time complexity should be o(height of tree)  medium tree 
java easy to understand solution delete node in a bst given a root node reference of a bst and a key  delete the node with the given key in the bst  return the root node reference (possibly updated) of the bst  basically  the deletion can be divided into two stages: search for a node to remove  if the node is found  delete the node  note: time complexity should be o(height of tree)  medium tree 
java o(n) bucket sort solution   o(nlogm) priorityqueue solution  easy to understand sort characters by frequency given a string  sort it in decreasing order based on the frequency of characters  medium hash table heap 
c++ o(n) solution without sort() sort characters by frequency given a string  sort it in decreasing order based on the frequency of characters  medium hash table heap 
o(n) easy to understand java solution sort characters by frequency given a string  sort it in decreasing order based on the frequency of characters  medium hash table heap 
concise c++ solution using stl sort sort characters by frequency given a string  sort it in decreasing order based on the frequency of characters  medium hash table heap 
1 line python code  sort characters by frequency given a string  sort it in decreasing order based on the frequency of characters  medium hash table heap 
share my explained greedy solution minimum number of arrows to burst balloons there are a number of spherical balloons spread in two-dimensional space  for each balloon  provided input is the start and end coordinates of the horizontal diameter  since it's horizontal  y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice  start is always smaller than end  there will be at most 104 balloons  an arrow can be shot up exactly vertically from different points along the x-axis  a balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend  there is no limit to the number of arrows that can be shot  an arrow once shot keeps travelling up infinitely  the problem is to find the minimum number of arrows that must be shot to burst all balloons  medium greedy 
greedy  python (132 ms) minimum number of arrows to burst balloons there are a number of spherical balloons spread in two-dimensional space  for each balloon  provided input is the start and end coordinates of the horizontal diameter  since it's horizontal  y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice  start is always smaller than end  there will be at most 104 balloons  an arrow can be shot up exactly vertically from different points along the x-axis  a balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend  there is no limit to the number of arrows that can be shot  an arrow once shot keeps travelling up infinitely  the problem is to find the minimum number of arrows that must be shot to burst all balloons  medium greedy 
java greedy soution minimum number of arrows to burst balloons there are a number of spherical balloons spread in two-dimensional space  for each balloon  provided input is the start and end coordinates of the horizontal diameter  since it's horizontal  y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice  start is always smaller than end  there will be at most 104 balloons  an arrow can be shot up exactly vertically from different points along the x-axis  a balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend  there is no limit to the number of arrows that can be shot  an arrow once shot keeps travelling up infinitely  the problem is to find the minimum number of arrows that must be shot to burst all balloons  medium greedy 
c++ easy understood solution (sort) minimum number of arrows to burst balloons there are a number of spherical balloons spread in two-dimensional space  for each balloon  provided input is the start and end coordinates of the horizontal diameter  since it's horizontal  y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice  start is always smaller than end  there will be at most 104 balloons  an arrow can be shot up exactly vertically from different points along the x-axis  a balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend  there is no limit to the number of arrows that can be shot  an arrow once shot keeps travelling up infinitely  the problem is to find the minimum number of arrows that must be shot to burst all balloons  medium greedy 
a concise template for "overlapping interval problem" minimum number of arrows to burst balloons there are a number of spherical balloons spread in two-dimensional space  for each balloon  provided input is the start and end coordinates of the horizontal diameter  since it's horizontal  y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice  start is always smaller than end  there will be at most 104 balloons  an arrow can be shot up exactly vertically from different points along the x-axis  a balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend  there is no limit to the number of arrows that can be shot  an arrow once shot keeps travelling up infinitely  the problem is to find the minimum number of arrows that must be shot to burst all balloons  medium greedy 
it is a math question minimum moves to equal array elements given a non-empty integer array of size n  find the minimum number of moves required to make all array elements equal  where a move is incrementing n - 1 elements by 1  easy math 
java o(n) solution  short  minimum moves to equal array elements given a non-empty integer array of size n  find the minimum number of moves required to make all array elements equal  where a move is incrementing n - 1 elements by 1  easy math 
simple one-liners minimum moves to equal array elements given a non-empty integer array of size n  find the minimum number of moves required to make all array elements equal  where a move is incrementing n - 1 elements by 1  easy math 
what if we are not smart enough to come up with decrease 1  here is how we do it  minimum moves to equal array elements given a non-empty integer array of size n  find the minimum number of moves required to make all array elements equal  where a move is incrementing n - 1 elements by 1  easy math 
four python solutions with detailed explanation minimum moves to equal array elements given a non-empty integer array of size n  find the minimum number of moves required to make all array elements equal  where a move is incrementing n - 1 elements by 1  easy math 
clean java solution o(n^2) 4sum ii given four lists a  b  c  d of integer values  compute how many tuples (i  j  k  l) there are such that a[i] + b[j] + c[k] + d[l] is zero  to make problem a bit easier  all a  b  c  d have same length of n where 0 ≤ n ≤ 500  all integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1  medium hash table binary search 
easy 2 lines o(n^2) python 4sum ii given four lists a  b  c  d of integer values  compute how many tuples (i  j  k  l) there are such that a[i] + b[j] + c[k] + d[l] is zero  to make problem a bit easier  all a  b  c  d have same length of n where 0 ≤ n ≤ 500  all integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1  medium hash table binary search 
simple java solution with explanation 4sum ii given four lists a  b  c  d of integer values  compute how many tuples (i  j  k  l) there are such that a[i] + b[j] + c[k] + d[l] is zero  to make problem a bit easier  all a  b  c  d have same length of n where 0 ≤ n ≤ 500  all integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1  medium hash table binary search 
concise c++ 11 code beat 99 5% 4sum ii given four lists a  b  c  d of integer values  compute how many tuples (i  j  k  l) there are such that a[i] + b[j] + c[k] + d[l] is zero  to make problem a bit easier  all a  b  c  d have same length of n where 0 ≤ n ≤ 500  all integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1  medium hash table binary search 
python o(n^2) solution with hashtable 4sum ii given four lists a  b  c  d of integer values  compute how many tuples (i  j  k  l) there are such that a[i] + b[j] + c[k] + d[l] is zero  to make problem a bit easier  all a  b  c  d have same length of n where 0 ≤ n ≤ 500  all integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1  medium hash table binary search 
simple greedy java solution assign cookies assume you are an awesome parent and want to give your children some cookies  but  you should give each child at most one cookie  each child i has a greed factor gi  which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj  if sj >= gi  we can assign the cookie j to the child i  and the child i will be content  your goal is to maximize the number of your content children and output the maximum number  note: you may assume the greed factor is always positive  you cannot assign more than one cookie to one child  easy greedy 
array sort + two pointer greedy solution o(nlogn) assign cookies assume you are an awesome parent and want to give your children some cookies  but  you should give each child at most one cookie  each child i has a greed factor gi  which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj  if sj >= gi  we can assign the cookie j to the child i  and the child i will be content  your goal is to maximize the number of your content children and output the maximum number  note: you may assume the greed factor is always positive  you cannot assign more than one cookie to one child  easy greedy 
simple python o(nlogn) assign cookies assume you are an awesome parent and want to give your children some cookies  but  you should give each child at most one cookie  each child i has a greed factor gi  which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj  if sj >= gi  we can assign the cookie j to the child i  and the child i will be content  your goal is to maximize the number of your content children and output the maximum number  note: you may assume the greed factor is always positive  you cannot assign more than one cookie to one child  easy greedy 
easy understanding c++ solution o(nlogn) assign cookies assume you are an awesome parent and want to give your children some cookies  but  you should give each child at most one cookie  each child i has a greed factor gi  which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj  if sj >= gi  we can assign the cookie j to the child i  and the child i will be content  your goal is to maximize the number of your content children and output the maximum number  note: you may assume the greed factor is always positive  you cannot assign more than one cookie to one child  easy greedy 
simple python solution assign cookies assume you are an awesome parent and want to give your children some cookies  but  you should give each child at most one cookie  each child i has a greed factor gi  which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj  if sj >= gi  we can assign the cookie j to the child i  and the child i will be content  your goal is to maximize the number of your content children and output the maximum number  note: you may assume the greed factor is always positive  you cannot assign more than one cookie to one child  easy greedy 
single pass c++ o(n) space and time solution (8 lines) with detailed explanation  132 pattern given a sequence of n integers a1  a2       an  a 132 pattern is a subsequence ai  aj  ak such that i < j < k and ai < ak < aj  design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list  note: n will be less than 15 000  medium stack 
java solutions from o(n^3) to o(n) for "132" pattern (updated with one-pass slution) 132 pattern given a sequence of n integers a1  a2       an  a 132 pattern is a subsequence ai  aj  ak such that i < j < k and ai < ak < aj  design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list  note: n will be less than 15 000  medium stack 
java o(n) solution using stack in detail explanation 132 pattern given a sequence of n integers a1  a2       an  a 132 pattern is a subsequence ai  aj  ak such that i < j < k and ai < ak < aj  design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list  note: n will be less than 15 000  medium stack 
10-line python solution 132 pattern given a sequence of n integers a1  a2       an  a 132 pattern is a subsequence ai  aj  ak such that i < j < k and ai < ak < aj  design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list  note: n will be less than 15 000  medium stack 
share my easy and simple solution 132 pattern given a sequence of n integers a1  a2       an  a 132 pattern is a subsequence ai  aj  ak such that i < j < k and ai < ak < aj  design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list  note: n will be less than 15 000  medium stack 
i cannot understand why test case [-2  1  -1  -2  -2] gives false? circular array loop you are given an array of positive and negative integers  if a number n at an index is positive  then move forward n steps  conversely  if it's negative (-n)  move backward n steps  assume the first element of the array is forward next to the last element  and the last element is backward next to the first element  determine if there is a loop in this array  a loop starts and ends at a particular index with more than 1 element along the loop  the loop must be "forward" or "backward'  medium 
java slow fast pointer solution circular array loop you are given an array of positive and negative integers  if a number n at an index is positive  then move forward n steps  conversely  if it's negative (-n)  move backward n steps  assume the first element of the array is forward next to the last element  and the last element is backward next to the first element  determine if there is a loop in this array  a loop starts and ends at a particular index with more than 1 element along the loop  the loop must be "forward" or "backward'  medium 
why {3  1  2} is a loop and {-1  -2  -3  -4  -5} is not? circular array loop you are given an array of positive and negative integers  if a number n at an index is positive  then move forward n steps  conversely  if it's negative (-n)  move backward n steps  assume the first element of the array is forward next to the last element  and the last element is backward next to the first element  determine if there is a loop in this array  a loop starts and ends at a particular index with more than 1 element along the loop  the loop must be "forward" or "backward'  medium 
python 1 pointer o(n) time o(1) space circular array loop you are given an array of positive and negative integers  if a number n at an index is positive  then move forward n steps  conversely  if it's negative (-n)  move backward n steps  assume the first element of the array is forward next to the last element  and the last element is backward next to the first element  determine if there is a loop in this array  a loop starts and ends at a particular index with more than 1 element along the loop  the loop must be "forward" or "backward'  medium 
two pass o(n) solution by marking failed loop by zero circular array loop you are given an array of positive and negative integers  if a number n at an index is positive  then move forward n steps  conversely  if it's negative (-n)  move backward n steps  assume the first element of the array is forward next to the last element  and the last element is backward next to the first element  determine if there is a loop in this array  a loop starts and ends at a particular index with more than 1 element along the loop  the loop must be "forward" or "backward'  medium 
another explanation and solution poor pigs there are 1000 buckets  one and only one of them contains poison  the rest are filled with water  they all look the same  if a pig drinks that poison it will die within 15 minutes  what is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour  answer this question  and write an algorithm for the follow-up general case  follow-up: if there are n buckets and a pig drinking poison will die within m minutes  how many pigs (x) you need to figure out the "poison" bucket within p minutes? there is exact one bucket with poison  easy 
solution with detailed explanation poor pigs there are 1000 buckets  one and only one of them contains poison  the rest are filled with water  they all look the same  if a pig drinks that poison it will die within 15 minutes  what is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour  answer this question  and write an algorithm for the follow-up general case  follow-up: if there are n buckets and a pig drinking poison will die within m minutes  how many pigs (x) you need to figure out the "poison" bucket within p minutes? there is exact one bucket with poison  easy 
why is the difficulty of this problem easy? poor pigs there are 1000 buckets  one and only one of them contains poison  the rest are filled with water  they all look the same  if a pig drinks that poison it will die within 15 minutes  what is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour  answer this question  and write an algorithm for the follow-up general case  follow-up: if there are n buckets and a pig drinking poison will die within m minutes  how many pigs (x) you need to figure out the "poison" bucket within p minutes? there is exact one bucket with poison  easy 
why should pig die? poor pigs there are 1000 buckets  one and only one of them contains poison  the rest are filled with water  they all look the same  if a pig drinks that poison it will die within 15 minutes  what is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour  answer this question  and write an algorithm for the follow-up general case  follow-up: if there are n buckets and a pig drinking poison will die within m minutes  how many pigs (x) you need to figure out the "poison" bucket within p minutes? there is exact one bucket with poison  easy 
major flaw in current algorithm [fixed] poor pigs there are 1000 buckets  one and only one of them contains poison  the rest are filled with water  they all look the same  if a pig drinks that poison it will die within 15 minutes  what is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour  answer this question  and write an algorithm for the follow-up general case  follow-up: if there are n buckets and a pig drinking poison will die within m minutes  how many pigs (x) you need to figure out the "poison" bucket within p minutes? there is exact one bucket with poison  easy 
easy python solution with explaination repeated substring pattern given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together  you may assume the given string consists of lowercase english letters only and its length will not exceed 10000  easy string 
java simple solution with explanation repeated substring pattern given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together  you may assume the given string consists of lowercase english letters only and its length will not exceed 10000  easy string 
simple java solution  2 lines repeated substring pattern given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together  you may assume the given string consists of lowercase english letters only and its length will not exceed 10000  easy string 
c++ o(n) using kmp  32ms  8 lines of code with brief explanation  repeated substring pattern given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together  you may assume the given string consists of lowercase english letters only and its length will not exceed 10000  easy string 
java & o(n) repeated substring pattern given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together  you may assume the given string consists of lowercase english letters only and its length will not exceed 10000  easy string 
java o(1) very easy solution using 3 hashmaps and linkedhashset lfu cache design and implement a data structure for least frequently used (lfu) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reaches its capacity  it should invalidate the least frequently used item before inserting a new item  for the purpose of this problem  when there is a tie (i e   two or more keys that have the same frequency)  the least recently used key would be evicted  follow up: could you do both operations in o(1) time complexity? hard design 
java o(1) accept solution using hashmap  doublelinkedlist and linkedhashset lfu cache design and implement a data structure for least frequently used (lfu) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reaches its capacity  it should invalidate the least frequently used item before inserting a new item  for the purpose of this problem  when there is a tie (i e   two or more keys that have the same frequency)  the least recently used key would be evicted  follow up: could you do both operations in o(1) time complexity? hard design 
concise c++ o(1) solution using 3 hash maps with explanation lfu cache design and implement a data structure for least frequently used (lfu) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reaches its capacity  it should invalidate the least frequently used item before inserting a new item  for the purpose of this problem  when there is a tie (i e   two or more keys that have the same frequency)  the least recently used key would be evicted  follow up: could you do both operations in o(1) time complexity? hard design 
java o(1) solution using two hashmap and one doublelinkedlist lfu cache design and implement a data structure for least frequently used (lfu) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reaches its capacity  it should invalidate the least frequently used item before inserting a new item  for the purpose of this problem  when there is a tie (i e   two or more keys that have the same frequency)  the least recently used key would be evicted  follow up: could you do both operations in o(1) time complexity? hard design 
java solutions of three different ways  priorityqueue : o(capacity)  treemap : o(log(capacity)) doublelinkedlist  : o(1) lfu cache design and implement a data structure for least frequently used (lfu) cache  it should support the following operations: get and put  get(key) - get the value (will always be positive) of the key if the key exists in the cache  otherwise return -1  put(key  value) - set or insert the value if the key is not already present  when the cache reaches its capacity  it should invalidate the least frequently used item before inserting a new item  for the purpose of this problem  when there is a tie (i e   two or more keys that have the same frequency)  the least recently used key would be evicted  follow up: could you do both operations in o(1) time complexity? hard design 
java 1 line solution :d hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  given two integers x and y  calculate the hamming distance  note: 0 ≤ x  y < 231  easy bit manipulation 
my c++ solution using bit manipulation hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  given two integers x and y  calculate the hamming distance  note: 0 ≤ x  y < 231  easy bit manipulation 
python 1 line 49ms hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  given two integers x and y  calculate the hamming distance  note: 0 ≤ x  y < 231  easy bit manipulation 
java 3-line solution hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  given two integers x and y  calculate the hamming distance  note: 0 ≤ x  y < 231  easy bit manipulation 
javascript one line solution hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  given two integers x and y  calculate the hamming distance  note: 0 ≤ x  y < 231  easy bit manipulation 
java(just like meeting point problem) minimum moves to equal array elements ii given a non-empty integer array  find the minimum number of moves required to make all array elements equal  where a move is incrementing a selected element by 1 or decrementing a selected element by 1  you may assume the array's length is at most 10 000  medium math 
2 lines python  2 ways minimum moves to equal array elements ii given a non-empty integer array  find the minimum number of moves required to make all array elements equal  where a move is incrementing a selected element by 1 or decrementing a selected element by 1  you may assume the array's length is at most 10 000  medium math 
java o(n) time using quickselect minimum moves to equal array elements ii given a non-empty integer array  find the minimum number of moves required to make all array elements equal  where a move is incrementing a selected element by 1 or decrementing a selected element by 1  you may assume the array's length is at most 10 000  medium math 
o(n) solution with detailed explanation  minimum moves to equal array elements ii given a non-empty integer array  find the minimum number of moves required to make all array elements equal  where a move is incrementing a selected element by 1 or decrementing a selected element by 1  you may assume the array's length is at most 10 000  medium math 
why median is better than average? minimum moves to equal array elements ii given a non-empty integer array  find the minimum number of moves required to make all array elements equal  where a move is incrementing a selected element by 1 or decrementing a selected element by 1  you may assume the array's length is at most 10 000  medium math 
clear and easy java solution island perimeter you are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water  grid cells are connected horizontally vertically (not diagonally)  the grid is completely surrounded by water  and there is exactly one island (i e   one or more connected land cells)  the island doesn't have "lakes" (water inside that isn't connected to the water around the island)  one cell is a square with side length 1  the grid is rectangular  width and height don't exceed 100  determine the perimeter of the island  easy hash table 
short python island perimeter you are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water  grid cells are connected horizontally vertically (not diagonally)  the grid is completely surrounded by water  and there is exactly one island (i e   one or more connected land cells)  the island doesn't have "lakes" (water inside that isn't connected to the water around the island)  one cell is a square with side length 1  the grid is rectangular  width and height don't exceed 100  determine the perimeter of the island  easy hash table 
java 9 line solution  add 4 for each land and remove 2 for each internal edge island perimeter you are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water  grid cells are connected horizontally vertically (not diagonally)  the grid is completely surrounded by water  and there is exactly one island (i e   one or more connected land cells)  the island doesn't have "lakes" (water inside that isn't connected to the water around the island)  one cell is a square with side length 1  the grid is rectangular  width and height don't exceed 100  determine the perimeter of the island  easy hash table 
c++ solution with explanation island perimeter you are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water  grid cells are connected horizontally vertically (not diagonally)  the grid is completely surrounded by water  and there is exactly one island (i e   one or more connected land cells)  the island doesn't have "lakes" (water inside that isn't connected to the water around the island)  one cell is a square with side length 1  the grid is rectangular  width and height don't exceed 100  determine the perimeter of the island  easy hash table 
easy to read python solution island perimeter you are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water  grid cells are connected horizontally vertically (not diagonally)  the grid is completely surrounded by water  and there is exactly one island (i e   one or more connected land cells)  the island doesn't have "lakes" (water inside that isn't connected to the water around the island)  one cell is a square with side length 1  the grid is rectangular  width and height don't exceed 100  determine the perimeter of the island  easy hash table 
java solution using hashmap with detailed explanation can i win in the "100 game " two players take turns adding  to a running total  any integer from 1  10  the player who first causes the running total to reach or exceed 100 wins  what if we change the game so that players cannot re-use integers? for medium dynamic programming minimax 
python solution  easy to understand can i win in the "100 game " two players take turns adding  to a running total  any integer from 1  10  the player who first causes the running total to reach or exceed 100 wins  what if we change the game so that players cannot re-use integers? for medium dynamic programming minimax 
7-liner c++ beat 98 4%  dfs with early termination check (detailed explanation) can i win in the "100 game " two players take turns adding  to a running total  any integer from 1  10  the player who first causes the running total to reach or exceed 100 wins  what if we change the game so that players cannot re-use integers? for medium dynamic programming minimax 
brute force and memoization can i win in the "100 game " two players take turns adding  to a running total  any integer from 1  10  the player who first causes the running total to reach or exceed 100 wins  what if we change the game so that players cannot re-use integers? for medium dynamic programming minimax 
java easy strightforward solution with explanation can i win in the "100 game " two players take turns adding  to a running total  any integer from 1  10  the player who first causes the running total to reach or exceed 100 wins  what if we change the game so that players cannot re-use integers? for medium dynamic programming minimax 
ugly java brute force solution  but accepted  1088ms  count the repetitions define s = [s n] as the string s which consists of n connected strings s  for hard dynamic programming 
c++ solution inspired by @70664914 with organized explanation count the repetitions define s = [s n] as the string s which consists of n connected strings s  for hard dynamic programming 
c++ 0ms o(str1 length str2 length) count the repetitions define s = [s n] as the string s which consists of n connected strings s  for hard dynamic programming 
easy-understanding java solution with detailed explanation  21ms! count the repetitions define s = [s n] as the string s which consists of n connected strings s  for hard dynamic programming 
very clean and short 7ms java solution based on @70664914 's idea count the repetitions define s = [s n] as the string s which consists of n connected strings s  for hard dynamic programming 
concise java solution using dp unique substrings in wraparound string consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz"  so s will look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  now we have another string p  your job is to find out how many unique non-empty substrings of p are present in s  in particular  your input is the string p and you need to output the number of different non-empty substrings of p in the string s  note: p consists of only lowercase english letters and the size of p might be over 10000  medium dynamic programming 
c++ concise solution unique substrings in wraparound string consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz"  so s will look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  now we have another string p  your job is to find out how many unique non-empty substrings of p are present in s  in particular  your input is the string p and you need to output the number of different non-empty substrings of p in the string s  note: p consists of only lowercase english letters and the size of p might be over 10000  medium dynamic programming 
python concise solution unique substrings in wraparound string consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz"  so s will look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  now we have another string p  your job is to find out how many unique non-empty substrings of p are present in s  in particular  your input is the string p and you need to output the number of different non-empty substrings of p in the string s  note: p consists of only lowercase english letters and the size of p might be over 10000  medium dynamic programming 
evolve from brute force to optimal unique substrings in wraparound string consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz"  so s will look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  now we have another string p  your job is to find out how many unique non-empty substrings of p are present in s  in particular  your input is the string p and you need to output the number of different non-empty substrings of p in the string s  note: p consists of only lowercase english letters and the size of p might be over 10000  medium dynamic programming 
concise o(n) 6-liner in python unique substrings in wraparound string consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz"  so s will look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  now we have another string p  your job is to find out how many unique non-empty substrings of p are present in s  in particular  your input is the string p and you need to output the number of different non-empty substrings of p in the string s  note: p consists of only lowercase english letters and the size of p might be over 10000  medium dynamic programming 
java simple solution validate ip address write a function to check whether an input string is a valid ipv4 address or ipv6 address or neither  ipv4 addresses are canonically represented in dot-decimal notation  which consists of four decimal numbers  each ranging from 0 to 255  separated by dots (" ")  e g  172 16 254 1; besides  leading zeros in the ipv4 is invalid  for medium string 
python easy understand solution validate ip address write a function to check whether an input string is a valid ipv4 address or ipv6 address or neither  ipv4 addresses are canonically represented in dot-decimal notation  which consists of four decimal numbers  each ranging from 0 to 255  separated by dots (" ")  e g  172 16 254 1; besides  leading zeros in the ipv4 is invalid  for medium string 
c++ solution straightforward string processing validate ip address write a function to check whether an input string is a valid ipv4 address or ipv6 address or neither  ipv4 addresses are canonically represented in dot-decimal notation  which consists of four decimal numbers  each ranging from 0 to 255  separated by dots (" ")  e g  172 16 254 1; besides  leading zeros in the ipv4 is invalid  for medium string 
java simple solution with regexp validate ip address write a function to check whether an input string is a valid ipv4 address or ipv6 address or neither  ipv4 addresses are canonically represented in dot-decimal notation  which consists of four decimal numbers  each ranging from 0 to 255  separated by dots (" ")  e g  172 16 254 1; besides  leading zeros in the ipv4 is invalid  for medium string 
short regexp solution validate ip address write a function to check whether an input string is a valid ipv4 address or ipv6 address or neither  ipv4 addresses are canonically represented in dot-decimal notation  which consists of four decimal numbers  each ranging from 0 to 255  separated by dots (" ")  e g  172 16 254 1; besides  leading zeros in the ipv4 is invalid  for medium string 
java dp solution concatenated words given a list of words (without duplicates)  please write a program that returns all concatenated words in the given list of words  a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array  hard dynamic programming depth-first search trie 
102ms java trie + dfs solution  with explanation  easy to understand  concatenated words given a list of words (without duplicates)  please write a program that returns all concatenated words in the given list of words  a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array  hard dynamic programming depth-first search trie 
simple java trie + dfs solution 144ms concatenated words given a list of words (without duplicates)  please write a program that returns all concatenated words in the given list of words  a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array  hard dynamic programming depth-first search trie 
c++ 772 ms dp solution concatenated words given a list of words (without duplicates)  please write a program that returns all concatenated words in the given list of words  a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array  hard dynamic programming depth-first search trie 
20 line c++ 169 ms beats 100% & why i think this problem is not properly judged  concatenated words given a list of words (without duplicates)  please write a program that returns all concatenated words in the given list of words  a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array  hard dynamic programming depth-first search trie 
java dfs solution with explanation matchsticks to square remember the story of little match girl? by now  you know exactly what matchsticks the little match girl has  please find out a way you can make one square by using up all those matchsticks  you should not break any stick  but you can link them up  and each matchstick must be used exactly one time  your input will be several matchsticks the girl has  represented with their stick length  your output will either be true or false  to represent whether you could make one square using all the matchsticks the little match girl has  medium depth-first search 
cpp 6ms solution with dfs matchsticks to square remember the story of little match girl? by now  you know exactly what matchsticks the little match girl has  please find out a way you can make one square by using up all those matchsticks  you should not break any stick  but you can link them up  and each matchstick must be used exactly one time  your input will be several matchsticks the girl has  represented with their stick length  your output will either be true or false  to represent whether you could make one square using all the matchsticks the little match girl has  medium depth-first search 
java dfs solution with various optimizations (sorting  sequential-partition  dp) matchsticks to square remember the story of little match girl? by now  you know exactly what matchsticks the little match girl has  please find out a way you can make one square by using up all those matchsticks  you should not break any stick  but you can link them up  and each matchstick must be used exactly one time  your input will be several matchsticks the girl has  represented with their stick length  your output will either be true or false  to represent whether you could make one square using all the matchsticks the little match girl has  medium depth-first search 
c++ bit masking + dp solution with detailed comments matchsticks to square remember the story of little match girl? by now  you know exactly what matchsticks the little match girl has  please find out a way you can make one square by using up all those matchsticks  you should not break any stick  but you can link them up  and each matchstick must be used exactly one time  your input will be several matchsticks the girl has  represented with their stick length  your output will either be true or false  to represent whether you could make one square using all the matchsticks the little match girl has  medium depth-first search 
python dfs solution matchsticks to square remember the story of little match girl? by now  you know exactly what matchsticks the little match girl has  please find out a way you can make one square by using up all those matchsticks  you should not break any stick  but you can link them up  and each matchstick must be used exactly one time  your input will be several matchsticks the girl has  represented with their stick length  your output will either be true or false  to represent whether you could make one square using all the matchsticks the little match girl has  medium depth-first search 
c++ dp solution with comments ones and zeroes in the computer world  use restricted resource you have to generate maximum benefit is what we always want to pursue  for now  suppose you are a dominator of m 0s and n 1s respectively  on the other hand  there is an array with strings consisting of only 0s and 1s  now your task is to find the maximum number of strings that you can form with given m 0s and n 1s  each 0 and 1 can be used at most once  note: the given numbers of 0s and 1s will both not exceed 100 the size of given string array won't exceed 600  medium dynamic programming 
0-1 knapsack detailed explanation  ones and zeroes in the computer world  use restricted resource you have to generate maximum benefit is what we always want to pursue  for now  suppose you are a dominator of m 0s and n 1s respectively  on the other hand  there is an array with strings consisting of only 0s and 1s  now your task is to find the maximum number of strings that you can form with given m 0s and n 1s  each 0 and 1 can be used at most once  note: the given numbers of 0s and 1s will both not exceed 100 the size of given string array won't exceed 600  medium dynamic programming 
have you graduated from primary school? ones and zeroes in the computer world  use restricted resource you have to generate maximum benefit is what we always want to pursue  for now  suppose you are a dominator of m 0s and n 1s respectively  on the other hand  there is an array with strings consisting of only 0s and 1s  now your task is to find the maximum number of strings that you can form with given m 0s and n 1s  each 0 and 1 can be used at most once  note: the given numbers of 0s and 1s will both not exceed 100 the size of given string array won't exceed 600  medium dynamic programming 
java iterative dp solution - o(mn) space ones and zeroes in the computer world  use restricted resource you have to generate maximum benefit is what we always want to pursue  for now  suppose you are a dominator of m 0s and n 1s respectively  on the other hand  there is an array with strings consisting of only 0s and 1s  now your task is to find the maximum number of strings that you can form with given m 0s and n 1s  each 0 and 1 can be used at most once  note: the given numbers of 0s and 1s will both not exceed 100 the size of given string array won't exceed 600  medium dynamic programming 
0-1 knapsack in python ones and zeroes in the computer world  use restricted resource you have to generate maximum benefit is what we always want to pursue  for now  suppose you are a dominator of m 0s and n 1s respectively  on the other hand  there is an array with strings consisting of only 0s and 1s  now your task is to find the maximum number of strings that you can form with given m 0s and n 1s  each 0 and 1 can be used at most once  note: the given numbers of 0s and 1s will both not exceed 100 the size of given string array won't exceed 600  medium dynamic programming 
short and clean java binary search solution heaters winter is coming! your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses  now  you are given positions of houses and heaters on a horizontal line  find out minimum radius of heaters so that all houses could be covered by those heaters  so  your input will be the positions of houses and heaters seperately  and your expected output will be the minimum radius standard of heaters  note: numbers of houses and heaters you are given are non-negative and will not exceed 25000  positions of houses and heaters you are given are non-negative and will not exceed 10^9  as long as a house is in the heaters' warm radius range  it can be warmed  all the heaters follow your radius standard and the warm radius will the same  easy binary search 
simple java solution with 2 pointers heaters winter is coming! your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses  now  you are given positions of houses and heaters on a horizontal line  find out minimum radius of heaters so that all houses could be covered by those heaters  so  your input will be the positions of houses and heaters seperately  and your expected output will be the minimum radius standard of heaters  note: numbers of houses and heaters you are given are non-negative and will not exceed 25000  positions of houses and heaters you are given are non-negative and will not exceed 10^9  as long as a house is in the heaters' warm radius range  it can be warmed  all the heaters follow your radius standard and the warm radius will the same  easy binary search 
short python heaters winter is coming! your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses  now  you are given positions of houses and heaters on a horizontal line  find out minimum radius of heaters so that all houses could be covered by those heaters  so  your input will be the positions of houses and heaters seperately  and your expected output will be the minimum radius standard of heaters  note: numbers of houses and heaters you are given are non-negative and will not exceed 25000  positions of houses and heaters you are given are non-negative and will not exceed 10^9  as long as a house is in the heaters' warm radius range  it can be warmed  all the heaters follow your radius standard and the warm radius will the same  easy binary search 
c++ clean solution with explanation heaters winter is coming! your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses  now  you are given positions of houses and heaters on a horizontal line  find out minimum radius of heaters so that all houses could be covered by those heaters  so  your input will be the positions of houses and heaters seperately  and your expected output will be the minimum radius standard of heaters  note: numbers of houses and heaters you are given are non-negative and will not exceed 25000  positions of houses and heaters you are given are non-negative and will not exceed 10^9  as long as a house is in the heaters' warm radius range  it can be warmed  all the heaters follow your radius standard and the warm radius will the same  easy binary search 
10 lines python with easy understanding heaters winter is coming! your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses  now  you are given positions of houses and heaters on a horizontal line  find out minimum radius of heaters so that all houses could be covered by those heaters  so  your input will be the positions of houses and heaters seperately  and your expected output will be the minimum radius standard of heaters  note: numbers of houses and heaters you are given are non-negative and will not exceed 25000  positions of houses and heaters you are given are non-negative and will not exceed 10^9  as long as a house is in the heaters' warm radius range  it can be warmed  all the heaters follow your radius standard and the warm radius will the same  easy binary search 
3 line c++ number complement given a positive integer  output its complement number  the complement strategy is to flip the bits of its binary representation  note: the given integer is guaranteed to fit within the range of a 32-bit signed integer  you could assume no leading zero bit in the integer’s binary representation  easy bit manipulation 
java 1 line bit manipulation solution number complement given a positive integer  output its complement number  the complement strategy is to flip the bits of its binary representation  note: the given integer is guaranteed to fit within the range of a 32-bit signed integer  you could assume no leading zero bit in the integer’s binary representation  easy bit manipulation 
java  very simple code and self-evident  explanation number complement given a positive integer  output its complement number  the complement strategy is to flip the bits of its binary representation  note: the given integer is guaranteed to fit within the range of a 32-bit signed integer  you could assume no leading zero bit in the integer’s binary representation  easy bit manipulation 
simple python number complement given a positive integer  output its complement number  the complement strategy is to flip the bits of its binary representation  note: the given integer is guaranteed to fit within the range of a 32-bit signed integer  you could assume no leading zero bit in the integer’s binary representation  easy bit manipulation 
maybe fewest operations number complement given a positive integer  output its complement number  the complement strategy is to flip the bits of its binary representation  note: the given integer is guaranteed to fit within the range of a 32-bit signed integer  you could assume no leading zero bit in the integer’s binary representation  easy bit manipulation 
java o(n) time o(1) space total hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  now your job is to find the total hamming distance between all pairs of the given numbers  medium bit manipulation 
share my o(n) c++ bitwise solution with thinking process and explanation total hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  now your job is to find the total hamming distance between all pairs of the given numbers  medium bit manipulation 
python via strings total hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  now your job is to find the total hamming distance between all pairs of the given numbers  medium bit manipulation 
java solution with explanation total hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  now your job is to find the total hamming distance between all pairs of the given numbers  medium bit manipulation 
python explanation total hamming distance the hamming distance between two integers is the number of positions at which the corresponding bits are different  now your job is to find the total hamming distance between all pairs of the given numbers  medium bit manipulation 
polar coordinates 10 lines generate random point in a circle given the radius and x-y positions of the center of a circle  write a function randpoint which generates a uniform random point in the circle  note: input and output values are in floating-point  radius and x-y position of the center of the circle is passed into the class constructor  a point on the circumference of the circle is considered to be in the circle  randpoint returns a size 2 array containing x-position and y-position of the random point  in that order  medium math random rejection sampling 
how is the solution verified? generate random point in a circle given the radius and x-y positions of the center of a circle  write a function randpoint which generates a uniform random point in the circle  note: input and output values are in floating-point  radius and x-y position of the center of the circle is passed into the class constructor  a point on the circumference of the circle is considered to be in the circle  randpoint returns a size 2 array containing x-position and y-position of the random point  in that order  medium math random rejection sampling 
explanation with graphs why using math sqrt() generate random point in a circle given the radius and x-y positions of the center of a circle  write a function randpoint which generates a uniform random point in the circle  note: input and output values are in floating-point  radius and x-y position of the center of the circle is passed into the class constructor  a point on the circumference of the circle is considered to be in the circle  randpoint returns a size 2 array containing x-position and y-position of the random point  in that order  medium math random rejection sampling 
very simple python solution generate random point in a circle given the radius and x-y positions of the center of a circle  write a function randpoint which generates a uniform random point in the circle  note: input and output values are in floating-point  radius and x-y position of the center of the circle is passed into the class constructor  a point on the circumference of the circle is considered to be in the circle  randpoint returns a size 2 array containing x-position and y-position of the random point  in that order  medium math random rejection sampling 
python solution without using rejection sampling generate random point in a circle given the radius and x-y positions of the center of a circle  write a function randpoint which generates a uniform random point in the circle  note: input and output values are in floating-point  radius and x-y position of the center of the circle is passed into the class constructor  a point on the circumference of the circle is considered to be in the circle  randpoint returns a size 2 array containing x-position and y-position of the random point  in that order  medium math random rejection sampling 
i don't feel like this is a easy question largest palindrome product find the largest palindrome made from the product of two n-digit numbers  since the result could be very large  you should return the largest palindrome mod 1337  easy 
java solution using assumed max palindrom largest palindrome product find the largest palindrome made from the product of two n-digit numbers  since the result could be very large  you should return the largest palindrome mod 1337  easy 
java solutions with two different approaches largest palindrome product find the largest palindrome made from the product of two n-digit numbers  since the result could be very large  you should return the largest palindrome mod 1337  easy 
trickiness depending on language you use largest palindrome product find the largest palindrome made from the product of two n-digit numbers  since the result could be very large  you should return the largest palindrome mod 1337  easy 
java solution with explanation largest palindrome product find the largest palindrome made from the product of two n-digit numbers  since the result could be very large  you should return the largest palindrome mod 1337  easy 
o(n log k) c++ using multiset and updating middle-iterator sliding window median median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  hard 
java solution using two priorityqueues sliding window median median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  hard 
easy to understand o(nlogk) java solution using treemap sliding window median median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  hard 
java using two tree sets - o(n logk) sliding window median median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  hard 
easy python o(nk) sliding window median median is the middle value in an ordered integer list  if the size of the list is even  there is no middle value  so the median is the mean of the two middle value  hard 
simple java solution using one array and two pointers magical string a magical string s consists of only '1' and '2' and obeys the following rules: the string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself  the first few elements of string s is the following: s = "1221121221221121122……" if we group the consecutive '1's and '2's in s  it will be: 1 22 11 2 1 22 1 22 11 2 11 22        and the occurrences of '1's or '2's in each group are: 1 2 2 1 1 2 1 2 2 1 2 2        you can see that the occurrence sequence above is the s itself  given an integer n as input  return the number of '1's in the first n number in the magical string s  note: n will not exceed 100 000  medium 
short c++ magical string a magical string s consists of only '1' and '2' and obeys the following rules: the string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself  the first few elements of string s is the following: s = "1221121221221121122……" if we group the consecutive '1's and '2's in s  it will be: 1 22 11 2 1 22 1 22 11 2 11 22        and the occurrences of '1's or '2's in each group are: 1 2 2 1 1 2 1 2 2 1 2 2        you can see that the occurrence sequence above is the s itself  given an integer n as input  return the number of '1's in the first n number in the magical string s  note: n will not exceed 100 000  medium 
is the magical string unique? magical string a magical string s consists of only '1' and '2' and obeys the following rules: the string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself  the first few elements of string s is the following: s = "1221121221221121122……" if we group the consecutive '1's and '2's in s  it will be: 1 22 11 2 1 22 1 22 11 2 11 22        and the occurrences of '1's or '2's in each group are: 1 2 2 1 1 2 1 2 2 1 2 2        you can see that the occurrence sequence above is the s itself  given an integer n as input  return the number of '1's in the first n number in the magical string s  note: n will not exceed 100 000  medium 
o(log n) space using recursive generators magical string a magical string s consists of only '1' and '2' and obeys the following rules: the string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself  the first few elements of string s is the following: s = "1221121221221121122……" if we group the consecutive '1's and '2's in s  it will be: 1 22 11 2 1 22 1 22 11 2 11 22        and the occurrences of '1's or '2's in each group are: 1 2 2 1 1 2 1 2 2 1 2 2        you can see that the occurrence sequence above is the s itself  given an integer n as input  return the number of '1's in the first n number in the magical string s  note: n will not exceed 100 000  medium 
very straightforward and simple java solution o(n) magical string a magical string s consists of only '1' and '2' and obeys the following rules: the string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself  the first few elements of string s is the following: s = "1221121221221121122……" if we group the consecutive '1's and '2's in s  it will be: 1 22 11 2 1 22 1 22 11 2 11 22        and the occurrences of '1's or '2's in each group are: 1 2 2 1 1 2 1 2 2 1 2 2        you can see that the occurrence sequence above is the s itself  given an integer n as input  return the number of '1's in the first n number in the magical string s  note: n will not exceed 100 000  medium 
java 5 lines clean solution license key formatting you are given a license key represented as a string s which consists only alphanumeric character and dashes  the string is separated into n+1 groups by n dashes  given a number k  we would want to reformat the strings such that each group contains exactly k characters  except for the first group which could be shorter than k  but still must contain at least one character  furthermore  there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase  given a non-empty string s and a number k  format the string according to the rules described above  easy 
python solution license key formatting you are given a license key represented as a string s which consists only alphanumeric character and dashes  the string is separated into n+1 groups by n dashes  given a number k  we would want to reformat the strings such that each group contains exactly k characters  except for the first group which could be shorter than k  but still must contain at least one character  furthermore  there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase  given a non-empty string s and a number k  format the string according to the rules described above  easy 
easy to understand using stringbuilder license key formatting you are given a license key represented as a string s which consists only alphanumeric character and dashes  the string is separated into n+1 groups by n dashes  given a number k  we would want to reformat the strings such that each group contains exactly k characters  except for the first group which could be shorter than k  but still must contain at least one character  furthermore  there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase  given a non-empty string s and a number k  format the string according to the rules described above  easy 
4-line c++ concise solution to scan string backward license key formatting you are given a license key represented as a string s which consists only alphanumeric character and dashes  the string is separated into n+1 groups by n dashes  given a number k  we would want to reformat the strings such that each group contains exactly k characters  except for the first group which could be shorter than k  but still must contain at least one character  furthermore  there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase  given a non-empty string s and a number k  format the string according to the rules described above  easy 
beats 100% python3 submission license key formatting you are given a license key represented as a string s which consists only alphanumeric character and dashes  the string is separated into n+1 groups by n dashes  given a number k  we would want to reformat the strings such that each group contains exactly k characters  except for the first group which could be shorter than k  but still must contain at least one character  furthermore  there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase  given a non-empty string s and a number k  format the string according to the rules described above  easy 
python solution with detailed mathematical explanation and derivation smallest good base for an integer n  we call k>=2 a good base of n  if all digits of n base k are 1  now given a string representing n  you should return the smallest good base of n in string format  hard math binary search 
3ms  ac  c++  long long int + binary search smallest good base for an integer n  we call k>=2 a good base of n  if all digits of n base k are 1  now given a string representing n  you should return the smallest good base of n in string format  hard math binary search 
java solution with hand-writing explain smallest good base for an integer n  we call k>=2 a good base of n  if all digits of n base k are 1  now given a string representing n  you should return the smallest good base of n in string format  hard math binary search 
java o((logn)^2) binary search solution smallest good base for an integer n  we call k>=2 a good base of n  if all digits of n base k are 1  now given a string representing n  you should return the smallest good base of n in string format  hard math binary search 
short python o(log(n)) smallest good base for an integer n  we call k>=2 a good base of n  if all digits of n base k are 1  now given a string representing n  you should return the smallest good base of n in string format  hard math binary search 
java 4 lines concise solution with explanation max consecutive ones given a binary array  find the maximum number of consecutive 1s in this array  easy array 
easy java solution max consecutive ones given a binary array  find the maximum number of consecutive 1s in this array  easy array 
simple c solution with easy explanation max consecutive ones given a binary array  find the maximum number of consecutive 1s in this array  easy array 
simple python max consecutive ones given a binary array  find the maximum number of consecutive 1s in this array  easy array 
simple c++ code max consecutive ones given a binary array  find the maximum number of consecutive 1s in this array  easy array 
java 9 lines dp solution  easy to understand with improvement to o(n) space complexity  predict the winner given an array of scores that are non-negative integers  player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on  each time a player picks a number  that number will not be available for the next player  this continues until all the scores have been chosen  the player with the maximum score wins  given an array of scores  predict whether player 1 is the winner  you can assume each player plays to maximize his score  medium dynamic programming minimax 
java '1 line' recursive solution o(n^2) time and o(n) space predict the winner given an array of scores that are non-negative integers  player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on  each time a player picks a number  that number will not be available for the next player  this continues until all the scores have been chosen  the player with the maximum score wins  given an array of scores  predict whether player 1 is the winner  you can assume each player plays to maximize his score  medium dynamic programming minimax 
dp o(n^2)  + mit ocw solution explanation predict the winner given an array of scores that are non-negative integers  player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on  each time a player picks a number  that number will not be available for the next player  this continues until all the scores have been chosen  the player with the maximum score wins  given an array of scores  predict whether player 1 is the winner  you can assume each player plays to maximize his score  medium dynamic programming minimax 
c++ dp solution with explanation predict the winner given an array of scores that are non-negative integers  player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on  each time a player picks a number  that number will not be available for the next player  this continues until all the scores have been chosen  the player with the maximum score wins  given an array of scores  predict whether player 1 is the winner  you can assume each player plays to maximize his score  medium dynamic programming minimax 
java dp solution with explanation predict the winner given an array of scores that are non-negative integers  player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on  each time a player picks a number  that number will not be available for the next player  this continues until all the scores have been chosen  the player with the maximum score wins  given an array of scores  predict whether player 1 is the winner  you can assume each player plays to maximize his score  medium dynamic programming minimax 
standard test program is wrong? zuma game think about zuma game  you have a row of balls on the table  colored red(r)  yellow(y)  blue(b)  green(g)  and white(w)  you also have several balls in your hand  each time  you may choose a ball in your hand  and insert it into the row (including the leftmost place and rightmost place)  then  if there is a group of 3 or more balls in the same color touching  remove these balls  keep doing this until no more balls can be removed  find the minimal balls you have to insert to remove all the balls on the table  if you cannot remove all the balls  output -1  hard depth-first search 
"short" java solution  beats 98% zuma game think about zuma game  you have a row of balls on the table  colored red(r)  yellow(y)  blue(b)  green(g)  and white(w)  you also have several balls in your hand  each time  you may choose a ball in your hand  and insert it into the row (including the leftmost place and rightmost place)  then  if there is a group of 3 or more balls in the same color touching  remove these balls  keep doing this until no more balls can be removed  find the minimal balls you have to insert to remove all the balls on the table  if you cannot remove all the balls  output -1  hard depth-first search 
straightforward recursive java solution beat 97% zuma game think about zuma game  you have a row of balls on the table  colored red(r)  yellow(y)  blue(b)  green(g)  and white(w)  you also have several balls in your hand  each time  you may choose a ball in your hand  and insert it into the row (including the leftmost place and rightmost place)  then  if there is a group of 3 or more balls in the same color touching  remove these balls  keep doing this until no more balls can be removed  find the minimal balls you have to insert to remove all the balls on the table  if you cannot remove all the balls  output -1  hard depth-first search 
concise 3ms c++ solution zuma game think about zuma game  you have a row of balls on the table  colored red(r)  yellow(y)  blue(b)  green(g)  and white(w)  you also have several balls in your hand  each time  you may choose a ball in your hand  and insert it into the row (including the leftmost place and rightmost place)  then  if there is a group of 3 or more balls in the same color touching  remove these balls  keep doing this until no more balls can be removed  find the minimal balls you have to insert to remove all the balls on the table  if you cannot remove all the balls  output -1  hard depth-first search 
recursive java solution zuma game think about zuma game  you have a row of balls on the table  colored red(r)  yellow(y)  blue(b)  green(g)  and white(w)  you also have several balls in your hand  each time  you may choose a ball in your hand  and insert it into the row (including the leftmost place and rightmost place)  then  if there is a group of 3 or more balls in the same color touching  remove these balls  keep doing this until no more balls can be removed  find the minimal balls you have to insert to remove all the balls on the table  if you cannot remove all the balls  output -1  hard depth-first search 
java solution beats 100% increasing subsequences given an integer array  your task is to find all the different possible increasing subsequences of the given array  and the length of an increasing subsequence should be at least 2   medium depth-first search 
java 20 lines backtracking solution using set  beats 100%  increasing subsequences given an integer array  your task is to find all the different possible increasing subsequences of the given array  and the length of an increasing subsequence should be at least 2   medium depth-first search 
simple python increasing subsequences given an integer array  your task is to find all the different possible increasing subsequences of the given array  and the length of an increasing subsequence should be at least 2   medium depth-first search 
c++ dfs solution using unordered_set increasing subsequences given an integer array  your task is to find all the different possible increasing subsequences of the given array  and the length of an increasing subsequence should be at least 2   medium depth-first search 
clean 20ms solution increasing subsequences given an integer array  your task is to find all the different possible increasing subsequences of the given array  and the length of an increasing subsequence should be at least 2   medium depth-first search 
3 line clean and easy understand solution construct the rectangle for a web developer  it is very important to know how to design a web page's size  so  given a specific rectangular web page’s area  your job by now is to design a rectangular web page  whose length l and width w satisfy the following requirements:1  the area of the rectangular web page you designed must equal to the given target area  2  the width w should not be larger than the length l  which means l >= w  3  the difference between length l and width w should be as small as possible  you need to output the length l and the width w of the web page you designed in sequence  easy 
simple java solution  beats 100% construct the rectangle for a web developer  it is very important to know how to design a web page's size  so  given a specific rectangular web page’s area  your job by now is to design a rectangular web page  whose length l and width w satisfy the following requirements:1  the area of the rectangular web page you designed must equal to the given target area  2  the width w should not be larger than the length l  which means l >= w  3  the difference between length l and width w should be as small as possible  you need to output the length l and the width w of the web page you designed in sequence  easy 
simple python construct the rectangle for a web developer  it is very important to know how to design a web page's size  so  given a specific rectangular web page’s area  your job by now is to design a rectangular web page  whose length l and width w satisfy the following requirements:1  the area of the rectangular web page you designed must equal to the given target area  2  the width w should not be larger than the length l  which means l >= w  3  the difference between length l and width w should be as small as possible  you need to output the length l and the width w of the web page you designed in sequence  easy 
3 line c++ clean solution with explanation construct the rectangle for a web developer  it is very important to know how to design a web page's size  so  given a specific rectangular web page’s area  your job by now is to design a rectangular web page  whose length l and width w satisfy the following requirements:1  the area of the rectangular web page you designed must equal to the given target area  2  the width w should not be larger than the length l  which means l >= w  3  the difference between length l and width w should be as small as possible  you need to output the length l and the width w of the web page you designed in sequence  easy 
python solution (linear time  constant space) with explanation construct the rectangle for a web developer  it is very important to know how to design a web page's size  so  given a specific rectangular web page’s area  your job by now is to design a rectangular web page  whose length l and width w satisfy the following requirements:1  the area of the rectangular web page you designed must equal to the given target area  2  the width w should not be larger than the length l  which means l >= w  3  the difference between length l and width w should be as small as possible  you need to output the length l and the width w of the web page you designed in sequence  easy 
general principles behind problems similar to "reverse pairs" reverse pairs given an array nums  we call (i  j) an important reverse pair if i < j and nums[i] > 2 nums[j]  you need to return the number of important reverse pairs in the given array  hard divide and conquer binary indexed tree segment tree binary search tree 
very short and clear mergesort & bst java solutions reverse pairs given an array nums  we call (i  j) an important reverse pair if i < j and nums[i] > 2 nums[j]  you need to return the number of important reverse pairs in the given array  hard divide and conquer binary indexed tree segment tree binary search tree 
c++ with iterators reverse pairs given an array nums  we call (i  j) an important reverse pair if i < j and nums[i] > 2 nums[j]  you need to return the number of important reverse pairs in the given array  hard divide and conquer binary indexed tree segment tree binary search tree 
clean java solution using enhanced binary search tree reverse pairs given an array nums  we call (i  j) an important reverse pair if i < j and nums[i] > 2 nums[j]  you need to return the number of important reverse pairs in the given array  hard divide and conquer binary indexed tree segment tree binary search tree 
java merge sort solution  o(nlog(n)) reverse pairs given an array nums  we call (i  j) an important reverse pair if i < j and nums[i] > 2 nums[j]  you need to return the number of important reverse pairs in the given array  hard divide and conquer binary indexed tree segment tree binary search tree 
java (15 ms) c++ (3 ms) o(ns) iterative dp solution using subset sum with explanation target sum you are given a list of non-negative integers  a1  a2       an  and a target  s  now you have 2 symbols + and -  for each integer  you should choose one from + and - as its new symbol  find out how many ways to assign symbols to make sum of integers equal to target s  medium dynamic programming depth-first search 
short java dp solution with explanation target sum you are given a list of non-negative integers  a1  a2       an  and a target  s  now you have 2 symbols + and -  for each integer  you should choose one from + and - as its new symbol  find out how many ways to assign symbols to make sum of integers equal to target s  medium dynamic programming depth-first search 
java simple dfs with memorization target sum you are given a list of non-negative integers  a1  a2       an  and a target  s  now you have 2 symbols + and -  for each integer  you should choose one from + and - as its new symbol  find out how many ways to assign symbols to make sum of integers equal to target s  medium dynamic programming depth-first search 
python dp target sum you are given a list of non-negative integers  a1  a2       an  and a target  s  now you have 2 symbols + and -  for each integer  you should choose one from + and - as its new symbol  find out how many ways to assign symbols to make sum of integers equal to target s  medium dynamic programming depth-first search 
java short dfs solution target sum you are given a list of non-negative integers  a1  a2       an  and a target  s  now you have 2 symbols + and -  for each integer  you should choose one from + and - as its new symbol  find out how many ways to assign symbols to make sum of integers equal to target s  medium dynamic programming depth-first search 
java 10 lines linear time complexity o(n) with explanation next greater element i you are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2  find all the next greater numbers for nums1's elements in the corresponding places of nums2  the next greater number of a number x in nums1 is the first greater number to its right in nums2  if it does not exist  output -1 for this number  easy stack 
c++ stack + unordered_map next greater element i you are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2  find all the next greater numbers for nums1's elements in the corresponding places of nums2  the next greater number of a number x in nums1 is the first greater number to its right in nums2  if it does not exist  output -1 for this number  easy stack 
python solution with o(n) next greater element i you are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2  find all the next greater numbers for nums1's elements in the corresponding places of nums2  the next greater number of a number x in nums1 is the first greater number to its right in nums2  if it does not exist  output -1 for this number  easy stack 
meh  1000 is small next greater element i you are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2  find all the next greater numbers for nums1's elements in the corresponding places of nums2  the next greater number of a number x in nums1 is the first greater number to its right in nums2  if it does not exist  output -1 for this number  easy stack 
whys is it -1 for findnums[2] = 2 instead of 4  next greater element i you are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2  find all the next greater numbers for nums1's elements in the corresponding places of nums2  the next greater number of a number x in nums1 is the first greater number to its right in nums2  if it does not exist  output -1 for this number  easy stack 
java randomly pick a rectangle then pick a point inside random point in non-overlapping rectangles given a list of non-overlapping axis-aligned rectangles rects  write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles  note: an integer point is a point that has integer coordinates  a point on the perimeter of a rectangle is included in the space covered by the rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  where [x1  y1] are the integer coordinates of the bottom-left corner  and [x2  y2] are the integer coordinates of the top-right corner  length and width of each rectangle does not exceed 2000  1 <= rects length <= 100 pick return a point as an array of integer coordinates [p_x  p_y] pick is called at most 10000 times  medium binary search random 
python weighted probability solution random point in non-overlapping rectangles given a list of non-overlapping axis-aligned rectangles rects  write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles  note: an integer point is a point that has integer coordinates  a point on the perimeter of a rectangle is included in the space covered by the rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  where [x1  y1] are the integer coordinates of the bottom-left corner  and [x2  y2] are the integer coordinates of the top-right corner  length and width of each rectangle does not exceed 2000  1 <= rects length <= 100 pick return a point as an array of integer coordinates [p_x  p_y] pick is called at most 10000 times  medium binary search random 
java treemap solution only one random per pick random point in non-overlapping rectangles given a list of non-overlapping axis-aligned rectangles rects  write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles  note: an integer point is a point that has integer coordinates  a point on the perimeter of a rectangle is included in the space covered by the rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  where [x1  y1] are the integer coordinates of the bottom-left corner  and [x2  y2] are the integer coordinates of the top-right corner  length and width of each rectangle does not exceed 2000  1 <= rects length <= 100 pick return a point as an array of integer coordinates [p_x  p_y] pick is called at most 10000 times  medium binary search random 
c++ solution using reservoir sampling with explanation - concise and easy to understand random point in non-overlapping rectangles given a list of non-overlapping axis-aligned rectangles rects  write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles  note: an integer point is a point that has integer coordinates  a point on the perimeter of a rectangle is included in the space covered by the rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  where [x1  y1] are the integer coordinates of the bottom-left corner  and [x2  y2] are the integer coordinates of the top-right corner  length and width of each rectangle does not exceed 2000  1 <= rects length <= 100 pick return a point as an array of integer coordinates [p_x  p_y] pick is called at most 10000 times  medium binary search random 
is [1 0 3 0] a valid rectangle? random point in non-overlapping rectangles given a list of non-overlapping axis-aligned rectangles rects  write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles  note: an integer point is a point that has integer coordinates  a point on the perimeter of a rectangle is included in the space covered by the rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  where [x1  y1] are the integer coordinates of the bottom-left corner  and [x2  y2] are the integer coordinates of the top-right corner  length and width of each rectangle does not exceed 2000  1 <= rects length <= 100 pick return a point as an array of integer coordinates [p_x  p_y] pick is called at most 10000 times  medium binary search random 
java 15 lines without using boolean diagonal traverse given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in diagonal order as shown in the below image  medium 
concise java solution diagonal traverse given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in diagonal order as shown in the below image  medium 
simply python solution diagonal traverse given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in diagonal order as shown in the below image  medium 
c++ without paying too much attention on direction switch diagonal traverse given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in diagonal order as shown in the below image  medium 
sorting and normal python diagonal traverse given a matrix of m x n elements (m rows  n columns)  return all elements of the matrix in diagonal order as shown in the below image  medium 
java 1-line solution via regex and stream keyboard row given a list of words  return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below  easy hash table 
easy understand solution in 7 lines for everyone keyboard row given a list of words  return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below  easy hash table 
short easy java with explanation keyboard row given a list of words  return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below  easy hash table 
one-liner ruby + python keyboard row given a list of words  return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below  easy hash table 
solution in python using set keyboard row given a list of words  return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below  easy hash table 
proper o(1) space find mode in binary search tree given a binary search tree (bst) with duplicates  find all the mode(s) (the most frequently occurred element) in the given bst  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than or equal to the node's key  the right subtree of a node contains only nodes with keys greater than or equal to the node's key  both the left and right subtrees must also be binary search trees  for easy tree 
java 4ms beats 100% extra o(1) solution - no map find mode in binary search tree given a binary search tree (bst) with duplicates  find all the mode(s) (the most frequently occurred element) in the given bst  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than or equal to the node's key  the right subtree of a node contains only nodes with keys greater than or equal to the node's key  both the left and right subtrees must also be binary search trees  for easy tree 
11-liner c++ o(n) time o(1) extra space in-order traversal (detailed explanation) find mode in binary search tree given a binary search tree (bst) with duplicates  find all the mode(s) (the most frequently occurred element) in the given bst  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than or equal to the node's key  the right subtree of a node contains only nodes with keys greater than or equal to the node's key  both the left and right subtrees must also be binary search trees  for easy tree 
what does "mode" mean? find mode in binary search tree given a binary search tree (bst) with duplicates  find all the mode(s) (the most frequently occurred element) in the given bst  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than or equal to the node's key  the right subtree of a node contains only nodes with keys greater than or equal to the node's key  both the left and right subtrees must also be binary search trees  for easy tree 
java ac solution find mode in binary search tree given a binary search tree (bst) with duplicates  find all the mode(s) (the most frequently occurred element) in the given bst  assume a bst is defined as follows: the left subtree of a node contains only nodes with keys less than or equal to the node's key  the right subtree of a node contains only nodes with keys greater than or equal to the node's key  both the left and right subtrees must also be binary search trees  for easy tree 
very simple (greedy) java solution using two priorityqueues ipo suppose leetcode will start its ipo soon  in order to sell a good price of its shares to venture capital  leetcode would like to work on some projects to increase its capital before the ipo  since it has limited resources  it can only finish at most k distinct projects before the ipo  help leetcode design the best way to maximize its total capital after finishing at most k distinct projects  you are given several projects  for each project i  it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project  initially  you have w capital  when you finish a project  you will obtain its pure profit and the profit will be added to your total capital  to sum up  pick a list of at most k distinct projects from given projects to maximize your final capital  and output your final maximized capital  hard heap greedy 
python solution by priority queue with explanation ipo suppose leetcode will start its ipo soon  in order to sell a good price of its shares to venture capital  leetcode would like to work on some projects to increase its capital before the ipo  since it has limited resources  it can only finish at most k distinct projects before the ipo  help leetcode design the best way to maximize its total capital after finishing at most k distinct projects  you are given several projects  for each project i  it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project  initially  you have w capital  when you finish a project  you will obtain its pure profit and the profit will be added to your total capital  to sum up  pick a list of at most k distinct projects from given projects to maximize your final capital  and output your final maximized capital  hard heap greedy 
8-liner c++ 42ms beat 98% greedy algorithm (detailed explanation) ipo suppose leetcode will start its ipo soon  in order to sell a good price of its shares to venture capital  leetcode would like to work on some projects to increase its capital before the ipo  since it has limited resources  it can only finish at most k distinct projects before the ipo  help leetcode design the best way to maximize its total capital after finishing at most k distinct projects  you are given several projects  for each project i  it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project  initially  you have w capital  when you finish a project  you will obtain its pure profit and the profit will be added to your total capital  to sum up  pick a list of at most k distinct projects from given projects to maximize your final capital  and output your final maximized capital  hard heap greedy 
python solution ipo suppose leetcode will start its ipo soon  in order to sell a good price of its shares to venture capital  leetcode would like to work on some projects to increase its capital before the ipo  since it has limited resources  it can only finish at most k distinct projects before the ipo  help leetcode design the best way to maximize its total capital after finishing at most k distinct projects  you are given several projects  for each project i  it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project  initially  you have w capital  when you finish a project  you will obtain its pure profit and the profit will be added to your total capital  to sum up  pick a list of at most k distinct projects from given projects to maximize your final capital  and output your final maximized capital  hard heap greedy 
why does greedy solution work for this; why not dynamic programming ? ipo suppose leetcode will start its ipo soon  in order to sell a good price of its shares to venture capital  leetcode would like to work on some projects to increase its capital before the ipo  since it has limited resources  it can only finish at most k distinct projects before the ipo  help leetcode design the best way to maximize its total capital after finishing at most k distinct projects  you are given several projects  for each project i  it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project  initially  you have w capital  when you finish a project  you will obtain its pure profit and the profit will be added to your total capital  to sum up  pick a list of at most k distinct projects from given projects to maximize your final capital  and output your final maximized capital  hard heap greedy 
java 10 lines and c++ 12 lines linear time complexity o(n) with explanation next greater element ii given a circular array (the next element of the last element is the first element of the array)  print the next greater number for every element  the next greater number of a number x is the first greater number to its traversing-order next in the array  which means you could search circularly to find its next greater number  if it doesn't exist  output -1 for this number  medium stack 
typical ways to solve circular array problems  java solution  next greater element ii given a circular array (the next element of the last element is the first element of the array)  print the next greater number for every element  the next greater number of a number x is the first greater number to its traversing-order next in the array  which means you could search circularly to find its next greater number  if it doesn't exist  output -1 for this number  medium stack 
python 6 lines solution using stack next greater element ii given a circular array (the next element of the last element is the first element of the array)  print the next greater number for every element  the next greater number of a number x is the first greater number to its traversing-order next in the array  which means you could search circularly to find its next greater number  if it doesn't exist  output -1 for this number  medium stack 
no stack: o(n) time complexity and o(1) space complexity using dp next greater element ii given a circular array (the next element of the last element is the first element of the array)  print the next greater number for every element  the next greater number of a number x is the first greater number to its traversing-order next in the array  which means you could search circularly to find its next greater number  if it doesn't exist  output -1 for this number  medium stack 
python solution with detailed explanation next greater element ii given a circular array (the next element of the last element is the first element of the array)  print the next greater number for every element  the next greater number of a number x is the first greater number to its traversing-order next in the array  which means you could search circularly to find its next greater number  if it doesn't exist  output -1 for this number  medium stack 
simple java  oneliner ruby base 7 given an integer  return its base 7 string representation  easy 
python easy understand solution base 7 given an integer  return its base 7 string representation  easy 
3-liner c++ to build string backward + 1-liner recursive solutions base 7 given an integer  return its base 7 string representation  easy 
verbose java solution base 7 given an integer  return its base 7 string representation  easy 
3ms c++ 3 lines solution base 7 given an integer  return its base 7 string representation  easy 
easy java solution  sorting  relative ranks given scores of n athletes  find their relative ranks and the people with the top three highest scores  who will be awarded medals: "gold medal"  "silver medal" and "bronze medal"  easy 
python solution relative ranks given scores of n athletes  find their relative ranks and the people with the top three highest scores  who will be awarded medals: "gold medal"  "silver medal" and "bronze medal"  easy 
simple sorting o(n log n) solution relative ranks given scores of n athletes  find their relative ranks and the people with the top three highest scores  who will be awarded medals: "gold medal"  "silver medal" and "bronze medal"  easy 
c++ easy to understand relative ranks given scores of n athletes  find their relative ranks and the people with the top three highest scores  who will be awarded medals: "gold medal"  "silver medal" and "bronze medal"  easy 
java 6ms solution o(n) without sorting relative ranks given scores of n athletes  find their relative ranks and the people with the top three highest scores  who will be awarded medals: "gold medal"  "silver medal" and "bronze medal"  easy 
verbose java solution  postorder traverse  hashmap (18ms) most frequent subtree sum given the root of a tree  you are asked to find the most frequent subtree sum  the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)  so what is the most frequent subtree sum value? if there is a tie  return all the values with the highest frequency in any order  medium hash table tree 
python easy understand solution most frequent subtree sum given the root of a tree  you are asked to find the most frequent subtree sum  the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)  so what is the most frequent subtree sum value? if there is a tie  return all the values with the highest frequency in any order  medium hash table tree 
short clean c++ o(n)  solution most frequent subtree sum given the root of a tree  you are asked to find the most frequent subtree sum  the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)  so what is the most frequent subtree sum value? if there is a tie  return all the values with the highest frequency in any order  medium hash table tree 
java divide and conquer most frequent subtree sum given the root of a tree  you are asked to find the most frequent subtree sum  the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)  so what is the most frequent subtree sum value? if there is a tie  return all the values with the highest frequency in any order  medium hash table tree 
short easy java most frequent subtree sum given the root of a tree  you are asked to find the most frequent subtree sum  the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)  so what is the most frequent subtree sum value? if there is a tie  return all the values with the highest frequency in any order  medium hash table tree 
right-to-left bfs (python + java) find bottom left tree value given a binary tree  find the leftmost value in the last row of the tree  medium tree depth-first search breadth-first search 
simple java solution  beats 100 0%! find bottom left tree value given a binary tree  find the leftmost value in the last row of the tree  medium tree depth-first search breadth-first search 
verbose java solution  binary tree level order traversal find bottom left tree value given a binary tree  find the leftmost value in the last row of the tree  medium tree depth-first search breadth-first search 
c++ recursive solution (beats 100%) with basic explanation find bottom left tree value given a binary tree  find the leftmost value in the last row of the tree  medium tree depth-first search breadth-first search 
my bfs solution for python find bottom left tree value given a binary tree  find the leftmost value in the last row of the tree  medium tree depth-first search breadth-first search 
concise java dp solution freedom trail in the video game fallout 4  the quest "road to freedom" requires players to reach a metal dial called the "freedom trail ring"  and use the dial to spell a specific keyword in order to open the door  given a string ring  which represents the code engraved on the outer ring and another string key  which represents the keyword needs to be spelled  you need to find the minimum number of steps in order to spell all the characters in the keyword  initially  the first character of the ring is aligned at 12:00 direction  you need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button  at the stage of rotating the ring to spell the key character key[i]: you can rotate the ring clockwise or anticlockwise one place  which counts as 1 step  the final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction  where this character must equal to the character key[i]  if the character key[i] has been aligned at the 12:00 direction  you need to press the center button to spell  which also counts as 1 step  after the pressing  you could begin to spell the next character in the key (next stage)  otherwise  you've finished all the spelling  hard divide and conquer dynamic programming depth-first search 
evolve from brute force to dp freedom trail in the video game fallout 4  the quest "road to freedom" requires players to reach a metal dial called the "freedom trail ring"  and use the dial to spell a specific keyword in order to open the door  given a string ring  which represents the code engraved on the outer ring and another string key  which represents the keyword needs to be spelled  you need to find the minimum number of steps in order to spell all the characters in the keyword  initially  the first character of the ring is aligned at 12:00 direction  you need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button  at the stage of rotating the ring to spell the key character key[i]: you can rotate the ring clockwise or anticlockwise one place  which counts as 1 step  the final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction  where this character must equal to the character key[i]  if the character key[i] has been aligned at the 12:00 direction  you need to press the center button to spell  which also counts as 1 step  after the pressing  you could begin to spell the next character in the key (next stage)  otherwise  you've finished all the spelling  hard divide and conquer dynamic programming depth-first search 
shared my c++ dp solution  19ms freedom trail in the video game fallout 4  the quest "road to freedom" requires players to reach a metal dial called the "freedom trail ring"  and use the dial to spell a specific keyword in order to open the door  given a string ring  which represents the code engraved on the outer ring and another string key  which represents the keyword needs to be spelled  you need to find the minimum number of steps in order to spell all the characters in the keyword  initially  the first character of the ring is aligned at 12:00 direction  you need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button  at the stage of rotating the ring to spell the key character key[i]: you can rotate the ring clockwise or anticlockwise one place  which counts as 1 step  the final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction  where this character must equal to the character key[i]  if the character key[i] has been aligned at the 12:00 direction  you need to press the center button to spell  which also counts as 1 step  after the pressing  you could begin to spell the next character in the key (next stage)  otherwise  you've finished all the spelling  hard divide and conquer dynamic programming depth-first search 
java clear solution  dfs+memoization freedom trail in the video game fallout 4  the quest "road to freedom" requires players to reach a metal dial called the "freedom trail ring"  and use the dial to spell a specific keyword in order to open the door  given a string ring  which represents the code engraved on the outer ring and another string key  which represents the keyword needs to be spelled  you need to find the minimum number of steps in order to spell all the characters in the keyword  initially  the first character of the ring is aligned at 12:00 direction  you need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button  at the stage of rotating the ring to spell the key character key[i]: you can rotate the ring clockwise or anticlockwise one place  which counts as 1 step  the final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction  where this character must equal to the character key[i]  if the character key[i] has been aligned at the 12:00 direction  you need to press the center button to spell  which also counts as 1 step  after the pressing  you could begin to spell the next character in the key (next stage)  otherwise  you've finished all the spelling  hard divide and conquer dynamic programming depth-first search 
super clear dfs + memorization solution freedom trail in the video game fallout 4  the quest "road to freedom" requires players to reach a metal dial called the "freedom trail ring"  and use the dial to spell a specific keyword in order to open the door  given a string ring  which represents the code engraved on the outer ring and another string key  which represents the keyword needs to be spelled  you need to find the minimum number of steps in order to spell all the characters in the keyword  initially  the first character of the ring is aligned at 12:00 direction  you need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button  at the stage of rotating the ring to spell the key character key[i]: you can rotate the ring clockwise or anticlockwise one place  which counts as 1 step  the final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction  where this character must equal to the character key[i]  if the character key[i] has been aligned at the 12:00 direction  you need to press the center button to spell  which also counts as 1 step  after the pressing  you could begin to spell the next character in the key (next stage)  otherwise  you've finished all the spelling  hard divide and conquer dynamic programming depth-first search 
9ms java dfs solution find largest value in each tree row you need to find the largest value in each row of a binary tree  medium tree depth-first search breadth-first search 
python bfs find largest value in each tree row you need to find the largest value in each row of a binary tree  medium tree depth-first search breadth-first search 
java bfs find largest value in each tree row you need to find the largest value in each row of a binary tree  medium tree depth-first search breadth-first search 
1-liner python  divide and conquer find largest value in each tree row you need to find the largest value in each row of a binary tree  medium tree depth-first search breadth-first search 
c++ a different approach (12ms beats 100%) find largest value in each tree row you need to find the largest value in each row of a binary tree  medium tree depth-first search breadth-first search 
straight forward java dp solution longest palindromic subsequence given a string s  find the longest palindromic subsequence's length in s  you may assume that the maximum length of s is 1000  medium dynamic programming 
evolve from brute force to dp longest palindromic subsequence given a string s  find the longest palindromic subsequence's length in s  you may assume that the maximum length of s is 1000  medium dynamic programming 
what is the meaning of example 1? longest palindromic subsequence given a string s  find the longest palindromic subsequence's length in s  you may assume that the maximum length of s is 1000  medium dynamic programming 
python dp o(n) space o(n^2) time longest palindromic subsequence given a string s  find the longest palindromic subsequence's length in s  you may assume that the maximum length of s is 1000  medium dynamic programming 
fast and concise python solution that actually gets ac longest palindromic subsequence given a string s  find the longest palindromic subsequence's length in s  you may assume that the maximum length of s is 1000  medium dynamic programming 
super short & easy java o(n) solution super washing machines you have n super washing machines on a line  initially  each washing machine has some dresses or is empty  for each move  you could choose any m (1 ≤ m ≤ n) washing machines  and pass one dress of each washing machine to one of its adjacent washing machines at the same time   given an integer array representing the number of dresses in each washing machine from left to right on the line  you should find the minimum number of moves to make all the washing machines have the same number of dresses  if it is not possible to do it  return -1  hard math dynamic programming 
c++ 16ms o(n) solution (with trivial proof) super washing machines you have n super washing machines on a line  initially  each washing machine has some dresses or is empty  for each move  you could choose any m (1 ≤ m ≤ n) washing machines  and pass one dress of each washing machine to one of its adjacent washing machines at the same time   given an integer array representing the number of dresses in each washing machine from left to right on the line  you should find the minimum number of moves to make all the washing machines have the same number of dresses  if it is not possible to do it  return -1  hard math dynamic programming 
very intuitive o(n) solution super washing machines you have n super washing machines on a line  initially  each washing machine has some dresses or is empty  for each move  you could choose any m (1 ≤ m ≤ n) washing machines  and pass one dress of each washing machine to one of its adjacent washing machines at the same time   given an integer array representing the number of dresses in each washing machine from left to right on the line  you should find the minimum number of moves to make all the washing machines have the same number of dresses  if it is not possible to do it  return -1  hard math dynamic programming 
java o(n) dp solution super washing machines you have n super washing machines on a line  initially  each washing machine has some dresses or is empty  for each move  you could choose any m (1 ≤ m ≤ n) washing machines  and pass one dress of each washing machine to one of its adjacent washing machines at the same time   given an integer array representing the number of dresses in each washing machine from left to right on the line  you should find the minimum number of moves to make all the washing machines have the same number of dresses  if it is not possible to do it  return -1  hard math dynamic programming 
easy understand solution o(n) time and o(1) space super washing machines you have n super washing machines on a line  initially  each washing machine has some dresses or is empty  for each move  you could choose any m (1 ≤ m ≤ n) washing machines  and pass one dress of each washing machine to one of its adjacent washing machines at the same time   given an integer array representing the number of dresses in each washing machine from left to right on the line  you should find the minimum number of moves to make all the washing machines have the same number of dresses  if it is not possible to do it  return -1  hard math dynamic programming 
knapsack problem - java solution with thinking process o(nm) time and o(m) space coin change 2 you are given coins of different denominations and a total amount of money  write a function to compute the number of combinations that make up that amount  you may assume that you have infinite number of each kind of coin  note: you can assume that 0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer medium 
video explaining how dynamic programming works with the coin change problem coin change 2 you are given coins of different denominations and a total amount of money  write a function to compute the number of combinations that make up that amount  you may assume that you have infinite number of each kind of coin  note: you can assume that 0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer medium 
logical thinking with clear java code coin change 2 you are given coins of different denominations and a total amount of money  write a function to compute the number of combinations that make up that amount  you may assume that you have infinite number of each kind of coin  note: you can assume that 0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer medium 
python o(n) space dp solution coin change 2 you are given coins of different denominations and a total amount of money  write a function to compute the number of combinations that make up that amount  you may assume that you have infinite number of each kind of coin  note: you can assume that 0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer medium 
c# - dfs with memorization - of course dp is better coin change 2 you are given coins of different denominations and a total amount of money  write a function to compute the number of combinations that make up that amount  you may assume that you have infinite number of each kind of coin  note: you can assume that 0 <= amount <= 5000 1 <= coin <= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer medium 
java ac solution  call least times of random nextint() function random flip matrix you are given the number of rows n_rows and number of columns n_cols of a 2d binary matrix where all values are initially 0  write a function flip which chooses a 0 value uniformly at random  changes it to 1  and then returns the position [row id  col id] of that value  also  write a function reset which sets all values back to 0  try to minimize the number of calls to system's math random() and optimize the time and space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows and 0 <= col id < n_cols flip will not be called when the matrix has no 0 values left  the total number of calls to flip and reset will not exceed 1000  medium random 
step by step algorithm explanation random flip matrix you are given the number of rows n_rows and number of columns n_cols of a 2d binary matrix where all values are initially 0  write a function flip which chooses a 0 value uniformly at random  changes it to 1  and then returns the position [row id  col id] of that value  also  write a function reset which sets all values back to 0  try to minimize the number of calls to system's math random() and optimize the time and space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows and 0 <= col id < n_cols flip will not be called when the matrix has no 0 values left  the total number of calls to flip and reset will not exceed 1000  medium random 
python solution based on random shuffle with explanation random flip matrix you are given the number of rows n_rows and number of columns n_cols of a 2d binary matrix where all values are initially 0  write a function flip which chooses a 0 value uniformly at random  changes it to 1  and then returns the position [row id  col id] of that value  also  write a function reset which sets all values back to 0  try to minimize the number of calls to system's math random() and optimize the time and space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows and 0 <= col id < n_cols flip will not be called when the matrix has no 0 values left  the total number of calls to flip and reset will not exceed 1000  medium random 
shuffle random flip matrix you are given the number of rows n_rows and number of columns n_cols of a 2d binary matrix where all values are initially 0  write a function flip which chooses a 0 value uniformly at random  changes it to 1  and then returns the position [row id  col id] of that value  also  write a function reset which sets all values back to 0  try to minimize the number of calls to system's math random() and optimize the time and space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows and 0 <= col id < n_cols flip will not be called when the matrix has no 0 values left  the total number of calls to flip and reset will not exceed 1000  medium random 
c++ solution random flip matrix you are given the number of rows n_rows and number of columns n_cols of a 2d binary matrix where all values are initially 0  write a function flip which chooses a 0 value uniformly at random  changes it to 1  and then returns the position [row id  col id] of that value  also  write a function reset which sets all values back to 0  try to minimize the number of calls to system's math random() and optimize the time and space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows and 0 <= col id < n_cols flip will not be called when the matrix has no 0 values left  the total number of calls to flip and reset will not exceed 1000  medium random 
3 lines detect capital given a word  you need to judge whether the usage of capitals in it is right or not  we define the usage of capitals in a word to be right when one of the following cases holds: all letters in this word are capitals  like "usa"  all letters in this word are not capitals  like "leetcode"  only the first letter in this word is capital if it has more than one letter  like "google"  otherwise  we define that this word doesn't use capitals in a right way  easy string 
python has useful methods    detect capital given a word  you need to judge whether the usage of capitals in it is right or not  we define the usage of capitals in a word to be right when one of the following cases holds: all letters in this word are capitals  like "usa"  all letters in this word are not capitals  like "leetcode"  only the first letter in this word is capital if it has more than one letter  like "google"  otherwise  we define that this word doesn't use capitals in a right way  easy string 
java 1-liner detect capital given a word  you need to judge whether the usage of capitals in it is right or not  we define the usage of capitals in a word to be right when one of the following cases holds: all letters in this word are capitals  like "usa"  all letters in this word are not capitals  like "leetcode"  only the first letter in this word is capital if it has more than one letter  like "google"  otherwise  we define that this word doesn't use capitals in a right way  easy string 
simple java solution o(n) time o(1) space detect capital given a word  you need to judge whether the usage of capitals in it is right or not  we define the usage of capitals in a word to be right when one of the following cases holds: all letters in this word are capitals  like "usa"  all letters in this word are not capitals  like "leetcode"  only the first letter in this word is capital if it has more than one letter  like "google"  otherwise  we define that this word doesn't use capitals in a right way  easy string 
java short solution using built-in string methods detect capital given a word  you need to judge whether the usage of capitals in it is right or not  we define the usage of capitals in a word to be right when one of the following cases holds: all letters in this word are capitals  like "usa"  all letters in this word are not capitals  like "leetcode"  only the first letter in this word is capital if it has more than one letter  like "google"  otherwise  we define that this word doesn't use capitals in a right way  easy string 
i feel this problem is just perfect for april fools' day longest uncommon subsequence i  given a group of two strings  you need to find the longest uncommon subsequence of this group of two strings  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be two strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  easy string 
java 1-liner longest uncommon subsequence i  given a group of two strings  you need to find the longest uncommon subsequence of this group of two strings  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be two strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  easy string 
python  simple explanation longest uncommon subsequence i  given a group of two strings  you need to find the longest uncommon subsequence of this group of two strings  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be two strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  easy string 
this is a silly question longest uncommon subsequence i  given a group of two strings  you need to find the longest uncommon subsequence of this group of two strings  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be two strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  easy string 
this is a boring word game longest uncommon subsequence i  given a group of two strings  you need to find the longest uncommon subsequence of this group of two strings  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be two strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  easy string 
python  simple explanation longest uncommon subsequence ii given a list of strings  you need to find the longest uncommon subsequence among them  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be a list of strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  medium string 
java(15ms) - sort + check subsequence longest uncommon subsequence ii given a list of strings  you need to find the longest uncommon subsequence among them  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be a list of strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  medium string 
java hashing solution longest uncommon subsequence ii given a list of strings  you need to find the longest uncommon subsequence among them  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be a list of strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  medium string 
hashmap + sort solution  c++ longest uncommon subsequence ii given a list of strings  you need to find the longest uncommon subsequence among them  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be a list of strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  medium string 
java 13 lines 5ms beats 100% with explaination longest uncommon subsequence ii given a list of strings  you need to find the longest uncommon subsequence among them  the longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings  a subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements  trivially  any string is a subsequence of itself and an empty string is a subsequence of any string  the input will be a list of strings  and the output needs to be the length of the longest uncommon subsequence  if the longest uncommon subsequence doesn't exist  return -1  medium string 
java o(n) time o(k) space continuous subarray sum given a list of non-negative numbers and a target integer k  write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k  that is  sums up to n k where n is also an integer  medium math dynamic programming 
need to pay attention to a lot of corner cases    continuous subarray sum given a list of non-negative numbers and a target integer k  write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k  that is  sums up to n k where n is also an integer  medium math dynamic programming 
concise c++ solution  use set instead of map continuous subarray sum given a list of non-negative numbers and a target integer k  write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k  that is  sums up to n k where n is also an integer  medium math dynamic programming 
share my o(n) c++ accumulation-modulo solution with thinking process and explanation continuous subarray sum given a list of non-negative numbers and a target integer k  write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k  that is  sums up to n k where n is also an integer  medium math dynamic programming 
math behind the solutions continuous subarray sum given a list of non-negative numbers and a target integer k  write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k  that is  sums up to n k where n is also an integer  medium math dynamic programming 
short java solutions - sorting dictionary and without sorting longest word in dictionary through deleting given a string and a string dictionary  find the longest string in the dictionary that can be formed by deleting some characters of the given string  if there are more than one possible results  return the longest word with the smallest lexicographical order  if there is no possible result  return the empty string  medium two pointers sort 
short python solutions longest word in dictionary through deleting given a string and a string dictionary  find the longest string in the dictionary that can be formed by deleting some characters of the given string  if there are more than one possible results  return the longest word with the smallest lexicographical order  if there is no possible result  return the empty string  medium two pointers sort 
python simple (two pointer) longest word in dictionary through deleting given a string and a string dictionary  find the longest string in the dictionary that can be formed by deleting some characters of the given string  if there are more than one possible results  return the longest word with the smallest lexicographical order  if there is no possible result  return the empty string  medium two pointers sort 
10 lines solutions for c++ longest word in dictionary through deleting given a string and a string dictionary  find the longest string in the dictionary that can be formed by deleting some characters of the given string  if there are more than one possible results  return the longest word with the smallest lexicographical order  if there is no possible result  return the empty string  medium two pointers sort 
easy java solution  issubsequence longest word in dictionary through deleting given a string and a string dictionary  find the longest string in the dictionary that can be formed by deleting some characters of the given string  if there are more than one possible results  return the longest word with the smallest lexicographical order  if there is no possible result  return the empty string  medium two pointers sort 
easy java o(n) solution  presum + hashmap contiguous array given a binary array  find the maximum length of a contiguous subarray with equal number of 0 and 1  medium hash table 
python o(n) solution with visual explanation contiguous array given a binary array  find the maximum length of a contiguous subarray with equal number of 0 and 1  medium hash table 
one pass use a hashmap to record 0-1 count difference contiguous array given a binary array  find the maximum length of a contiguous subarray with equal number of 0 and 1  medium hash table 
python and java with little tricks (incl  a oneliner :-) contiguous array given a binary array  find the maximum length of a contiguous subarray with equal number of 0 and 1  medium hash table 
share my dp&map solution  one pass contiguous array given a binary array  find the maximum length of a contiguous subarray with equal number of 0 and 1  medium hash table 
java solution  backtracking beautiful arrangement suppose you have n integers from 1 to n  we define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 <= i <= n) in this array: the number at the ith position is divisible by i  i is divisible by the number at the ith position  now given n  how many beautiful arrangements can you construct? medium backtracking 
java 6ms beats 98% back tracking (swap) starting from the back beautiful arrangement suppose you have n integers from 1 to n  we define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 <= i <= n) in this array: the number at the ith position is divisible by i  i is divisible by the number at the ith position  now given n  how many beautiful arrangements can you construct? medium backtracking 
my c++ elegant solution with back-tracking beautiful arrangement suppose you have n integers from 1 to n  we define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 <= i <= n) in this array: the number at the ith position is divisible by i  i is divisible by the number at the ith position  now given n  how many beautiful arrangements can you construct? medium backtracking 
python recursion + dp 66ms beautiful arrangement suppose you have n integers from 1 to n  we define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 <= i <= n) in this array: the number at the ith position is divisible by i  i is divisible by the number at the ith position  now given n  how many beautiful arrangements can you construct? medium backtracking 
easy python  ~230ms beautiful arrangement suppose you have n integers from 1 to n  we define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 <= i <= n) in this array: the number at the ith position is divisible by i  i is divisible by the number at the ith position  now given n  how many beautiful arrangements can you construct? medium backtracking 
please someone explain this question? random pick with weight given an array w of positive integers  where w[i] describes the weight of index i  write a function pickindex which randomly picks an index in proportion to its weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex will be called at most 10000 times  medium binary search random 
java accumulated freq sum & binary search random pick with weight given an array w of positive integers  where w[i] describes the weight of index i  write a function pickindex which randomly picks an index in proportion to its weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex will be called at most 10000 times  medium binary search random 
java 8 lines treemap random pick with weight given an array w of positive integers  where w[i] describes the weight of index i  write a function pickindex which randomly picks an index in proportion to its weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex will be called at most 10000 times  medium binary search random 
very easy solution based on uniform sampling with explanation random pick with weight given an array w of positive integers  where w[i] describes the weight of index i  write a function pickindex which randomly picks an index in proportion to its weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex will be called at most 10000 times  medium binary search random 
c++ concise binary search solution random pick with weight given an array w of positive integers  where w[i] describes the weight of index i  write a function pickindex which randomly picks an index in proportion to its weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex will be called at most 10000 times  medium binary search random 
java solution  dfs + bfs minesweeper let's play the minesweeper game (wikipedia  online game)! you are given a 2d char matrix representing the game board  'm' represents an unrevealed mine  'e' represents an unrevealed empty square  'b' represents a revealed blank square that has no adjacent (above  below  left  right  and all 4 diagonals) mines  digit ('1' to '8') represents how many mines are adjacent to this revealed square  and finally 'x' represents a revealed mine  now given the next click position (row and column indices) among all the unrevealed squares ('m' or 'e')  return the board after revealing this position according to the following rules: if a mine ('m') is revealed  then the game is over - change it to 'x'  if an empty square ('e') with no adjacent mines is revealed  then change it to revealed blank ('b') and all of its adjacent unrevealed squares should be revealed recursively  if an empty square ('e') with at least one adjacent mine is revealed  then change it to a digit ('1' to '8') representing the number of adjacent mines  return the board when no more squares will be revealed  medium depth-first search breadth-first search 
straight forward java solution minesweeper let's play the minesweeper game (wikipedia  online game)! you are given a 2d char matrix representing the game board  'm' represents an unrevealed mine  'e' represents an unrevealed empty square  'b' represents a revealed blank square that has no adjacent (above  below  left  right  and all 4 diagonals) mines  digit ('1' to '8') represents how many mines are adjacent to this revealed square  and finally 'x' represents a revealed mine  now given the next click position (row and column indices) among all the unrevealed squares ('m' or 'e')  return the board after revealing this position according to the following rules: if a mine ('m') is revealed  then the game is over - change it to 'x'  if an empty square ('e') with no adjacent mines is revealed  then change it to revealed blank ('b') and all of its adjacent unrevealed squares should be revealed recursively  if an empty square ('e') with at least one adjacent mine is revealed  then change it to a digit ('1' to '8') representing the number of adjacent mines  return the board when no more squares will be revealed  medium depth-first search breadth-first search 
10 line python solution minesweeper let's play the minesweeper game (wikipedia  online game)! you are given a 2d char matrix representing the game board  'm' represents an unrevealed mine  'e' represents an unrevealed empty square  'b' represents a revealed blank square that has no adjacent (above  below  left  right  and all 4 diagonals) mines  digit ('1' to '8') represents how many mines are adjacent to this revealed square  and finally 'x' represents a revealed mine  now given the next click position (row and column indices) among all the unrevealed squares ('m' or 'e')  return the board after revealing this position according to the following rules: if a mine ('m') is revealed  then the game is over - change it to 'x'  if an empty square ('e') with no adjacent mines is revealed  then change it to revealed blank ('b') and all of its adjacent unrevealed squares should be revealed recursively  if an empty square ('e') with at least one adjacent mine is revealed  then change it to a digit ('1' to '8') representing the number of adjacent mines  return the board when no more squares will be revealed  medium depth-first search breadth-first search 
c++ dfs solution  easy to understand minesweeper let's play the minesweeper game (wikipedia  online game)! you are given a 2d char matrix representing the game board  'm' represents an unrevealed mine  'e' represents an unrevealed empty square  'b' represents a revealed blank square that has no adjacent (above  below  left  right  and all 4 diagonals) mines  digit ('1' to '8') represents how many mines are adjacent to this revealed square  and finally 'x' represents a revealed mine  now given the next click position (row and column indices) among all the unrevealed squares ('m' or 'e')  return the board after revealing this position according to the following rules: if a mine ('m') is revealed  then the game is over - change it to 'x'  if an empty square ('e') with no adjacent mines is revealed  then change it to revealed blank ('b') and all of its adjacent unrevealed squares should be revealed recursively  if an empty square ('e') with at least one adjacent mine is revealed  then change it to a digit ('1' to '8') representing the number of adjacent mines  return the board when no more squares will be revealed  medium depth-first search breadth-first search 
simple python (dfs) minesweeper let's play the minesweeper game (wikipedia  online game)! you are given a 2d char matrix representing the game board  'm' represents an unrevealed mine  'e' represents an unrevealed empty square  'b' represents a revealed blank square that has no adjacent (above  below  left  right  and all 4 diagonals) mines  digit ('1' to '8') represents how many mines are adjacent to this revealed square  and finally 'x' represents a revealed mine  now given the next click position (row and column indices) among all the unrevealed squares ('m' or 'e')  return the board after revealing this position according to the following rules: if a mine ('m') is revealed  then the game is over - change it to 'x'  if an empty square ('e') with no adjacent mines is revealed  then change it to revealed blank ('b') and all of its adjacent unrevealed squares should be revealed recursively  if an empty square ('e') with at least one adjacent mine is revealed  then change it to a digit ('1' to '8') representing the number of adjacent mines  return the board when no more squares will be revealed  medium depth-first search breadth-first search 
java o(n) solution - one hashmap  easy to understand k-diff pairs in an array given an array of integers and an integer k  you need to find the number of unique k-diff pairs in the array  here a k-diff pair is defined as an integer pair (i  j)  where i and j are both numbers in the array and their absolute difference is k  easy array two pointers 
1-liner in python  o(n) time k-diff pairs in an array given an array of integers and an integer k  you need to find the number of unique k-diff pairs in the array  here a k-diff pair is defined as an integer pair (i  j)  where i and j are both numbers in the array and their absolute difference is k  easy array two pointers 
two-pointer approach k-diff pairs in an array given an array of integers and an integer k  you need to find the number of unique k-diff pairs in the array  here a k-diff pair is defined as an integer pair (i  j)  where i and j are both numbers in the array and their absolute difference is k  easy array two pointers 
easy understood python solution k-diff pairs in an array given an array of integers and an integer k  you need to find the number of unique k-diff pairs in the array  here a k-diff pair is defined as an integer pair (i  j)  where i and j are both numbers in the array and their absolute difference is k  easy array two pointers 
[c++] [java] clean code with explanation [set] [map] k-diff pairs in an array given an array of integers and an integer k  you need to find the number of unique k-diff pairs in the array  here a k-diff pair is defined as an integer pair (i  j)  where i and j are both numbers in the array and their absolute difference is k  easy array two pointers 
c++ using stringstream complex number multiplication given two strings representing two complex numbers  you need to return a string representing their multiplication  note i2 = -1 according to the definition  medium math string 
java 3-liner complex number multiplication given two strings representing two complex numbers  you need to return a string representing their multiplication  note i2 = -1 according to the definition  medium math string 
java - (a1+b1) (a2+b2) = (a1a2 + b1b2 + (a1b2+b1a2)) complex number multiplication given two strings representing two complex numbers  you need to return a string representing their multiplication  note i2 = -1 according to the definition  medium math string 
python simple 3 lines solution complex number multiplication given two strings representing two complex numbers  you need to return a string representing their multiplication  note i2 = -1 according to the definition  medium math string 
2 lines python complex number multiplication given two strings representing two complex numbers  you need to return a string representing their multiplication  note i2 = -1 according to the definition  medium math string 
java recursive o(n) time convert bst to greater tree given a binary search tree (bst)  convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst  easy tree 
c++ solution beats 100% convert bst to greater tree given a binary search tree (bst)  convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst  easy tree 
java solution  7 liner  reversed traversal convert bst to greater tree given a binary search tree (bst)  convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst  easy tree 
java three o(n) methods: recursive  iterative  and morris traversal convert bst to greater tree given a binary search tree (bst)  convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst  easy tree 
python  simple with explanation convert bst to greater tree given a binary search tree (bst)  convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst  easy tree 
verbose java solution  bucket minimum time difference given a list of 24-hour clock time points in "hour:minutes" format  find the minimum minutes difference between any two time points in the list  medium string 
java 10 liner solution  simplest so far minimum time difference given a list of 24-hour clock time points in "hour:minutes" format  find the minimum minutes difference between any two time points in the list  medium string 
python  straightforward with explanation minimum time difference given a list of 24-hour clock time points in "hour:minutes" format  find the minimum minutes difference between any two time points in the list  medium string 
[c++] clean code minimum time difference given a list of 24-hour clock time points in "hour:minutes" format  find the minimum minutes difference between any two time points in the list  medium string 
java sorting with a sentinel node minimum time difference given a list of 24-hour clock time points in "hour:minutes" format  find the minimum minutes difference between any two time points in the list  medium string 
java binary search  short (7l)  o(log(n)) w  explanations single element in a sorted array given a sorted array consisting of only integers where every element appears twice except for one element which appears once  find this single element that appears only once  medium 
java binary search o(log(n)) shorter than others single element in a sorted array given a sorted array consisting of only integers where every element appears twice except for one element which appears once  find this single element that appears only once  medium 
short  compare nums[i] with nums[i^1] single element in a sorted array given a sorted array consisting of only integers where every element appears twice except for one element which appears once  find this single element that appears only once  medium 
java code by using binary search o(log(n)) single element in a sorted array given a sorted array consisting of only integers where every element appears twice except for one element which appears once  find this single element that appears only once  medium 
c++ binary search single element in a sorted array given a sorted array consisting of only integers where every element appears twice except for one element which appears once  find this single element that appears only once  medium 
java concise solution reverse string ii given a string and an integer k  you need to reverse the first k characters for every 2k characters counting from the start of the string  if there are less than k characters left  reverse all of them  if there are less than 2k but greater than or equal to k characters  then reverse the first k characters and left the other as original  easy string 
python  straightforward with explanation reverse string ii given a string and an integer k  you need to reverse the first k characters for every 2k characters counting from the start of the string  if there are less than k characters left  reverse all of them  if there are less than 2k but greater than or equal to k characters  then reverse the first k characters and left the other as original  easy string 
[c++][java] clean code reverse string ii given a string and an integer k  you need to reverse the first k characters for every 2k characters counting from the start of the string  if there are less than k characters left  reverse all of them  if there are less than 2k but greater than or equal to k characters  then reverse the first k characters and left the other as original  easy string 
1 line simple recursive python reverse string ii given a string and an integer k  you need to reverse the first k characters for every 2k characters counting from the start of the string  if there are less than k characters left  reverse all of them  if there are less than 2k but greater than or equal to k characters  then reverse the first k characters and left the other as original  easy string 
one line c++ reverse string ii given a string and an integer k  you need to reverse the first k characters for every 2k characters counting from the start of the string  if there are less than k characters left  reverse all of them  if there are less than 2k but greater than or equal to k characters  then reverse the first k characters and left the other as original  easy string 
java solution  bfs 01 matrix given a matrix consists of 0 and 1  find the distance of the nearest 0 for each cell  the distance between two adjacent cells is 1  medium depth-first search breadth-first search 
short solution - each path needs at most one turn 01 matrix given a matrix consists of 0 and 1  find the distance of the nearest 0 for each cell  the distance between two adjacent cells is 1  medium depth-first search breadth-first search 
java 33ms solution with two sweeps in o(n) 01 matrix given a matrix consists of 0 and 1  find the distance of the nearest 0 for each cell  the distance between two adjacent cells is 1  medium depth-first search breadth-first search 
simple java solution beat 99% (use dp) 01 matrix given a matrix consists of 0 and 1  find the distance of the nearest 0 for each cell  the distance between two adjacent cells is 1  medium depth-first search breadth-first search 
python  simple with explanation 01 matrix given a matrix consists of 0 and 1  find the distance of the nearest 0 for each cell  the distance between two adjacent cells is 1  medium depth-first search breadth-first search 
java solution  maxdepth diameter of binary tree given a binary tree  you need to compute the length of the diameter of the tree  the diameter of a binary tree is the length of the longest path between any two nodes in a tree  this path may or may not pass through the root  easy tree 
simple python diameter of binary tree given a binary tree  you need to compute the length of the diameter of the tree  the diameter of a binary tree is the length of the longest path between any two nodes in a tree  this path may or may not pass through the root  easy tree 
python  simple with explanation diameter of binary tree given a binary tree  you need to compute the length of the diameter of the tree  the diameter of a binary tree is the length of the longest path between any two nodes in a tree  this path may or may not pass through the root  easy tree 
[543  diameter of binary tree] c++_recursive_with brief explanation diameter of binary tree given a binary tree  you need to compute the length of the diameter of the tree  the diameter of a binary tree is the length of the longest path between any two nodes in a tree  this path may or may not pass through the root  easy tree 
java easy to understand solution diameter of binary tree given a binary tree  you need to compute the length of the diameter of the tree  the diameter of a binary tree is the length of the longest path between any two nodes in a tree  this path may or may not pass through the root  easy tree 
java top-down and bottom-up dp solutions remove boxes given several boxes with different colors represented by different positive numbers  you may experience several rounds to remove boxes until there is no box left  each time you can choose some continuous boxes with the same color (composed of k boxes  k >= 1)  remove them and get k k points  find the maximum points you can get  hard dynamic programming depth-first search 
memoization dfs c++ remove boxes given several boxes with different colors represented by different positive numbers  you may experience several rounds to remove boxes until there is no box left  each time you can choose some continuous boxes with the same color (composed of k boxes  k >= 1)  remove them and get k k points  find the maximum points you can get  hard dynamic programming depth-first search 
java dp + memorization 60ms remove boxes given several boxes with different colors represented by different positive numbers  you may experience several rounds to remove boxes until there is no box left  each time you can choose some continuous boxes with the same color (composed of k boxes  k >= 1)  remove them and get k k points  find the maximum points you can get  hard dynamic programming depth-first search 
python  fast dp with explanation remove boxes given several boxes with different colors represented by different positive numbers  you may experience several rounds to remove boxes until there is no box left  each time you can choose some continuous boxes with the same color (composed of k boxes  k >= 1)  remove them and get k k points  find the maximum points you can get  hard dynamic programming depth-first search 
c++ 29ms dp solution! remove boxes given several boxes with different colors represented by different positive numbers  you may experience several rounds to remove boxes until there is no box left  each time you can choose some continuous boxes with the same color (composed of k boxes  k >= 1)  remove them and get k k points  find the maximum points you can get  hard dynamic programming depth-first search 
neat dfs java solution friend circles there are n students in a class  some of them are friends  while some are not  their friendship is transitive in nature  for medium depth-first search union find 
java solution  union find friend circles there are n students in a class  some of them are friends  while some are not  their friendship is transitive in nature  for medium depth-first search union find 
python  simple explanation friend circles there are n students in a class  some of them are friends  while some are not  their friendship is transitive in nature  for medium depth-first search union find 
oneliners :-p friend circles there are n students in a class  some of them are friends  while some are not  their friendship is transitive in nature  for medium depth-first search union find 
[c++] clean code - dfs|unionfind friend circles there are n students in a class  some of them are friends  while some are not  their friendship is transitive in nature  for medium depth-first search union find 
java 1-liner student attendance record i you are given a string representing an attendance record for a student  the record only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a student could be rewarded if his attendance record doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  you need to return whether the student could be rewarded according to his attendance record  easy string 
c++ very simple solution student attendance record i you are given a string representing an attendance record for a student  the record only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a student could be rewarded if his attendance record doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  you need to return whether the student could be rewarded according to his attendance record  easy string 
java simple without regex 3 lines student attendance record i you are given a string representing an attendance record for a student  the record only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a student could be rewarded if his attendance record doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  you need to return whether the student could be rewarded according to his attendance record  easy string 
java o(n) solution - accepted student attendance record i you are given a string representing an attendance record for a student  the record only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a student could be rewarded if his attendance record doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  you need to return whether the student could be rewarded according to his attendance record  easy string 
python 1 liner without regex student attendance record i you are given a string representing an attendance record for a student  the record only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a student could be rewarded if his attendance record doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  you need to return whether the student could be rewarded according to his attendance record  easy string 
share my o(n) c++ dp solution with thinking process and explanation student attendance record ii given a positive integer n  return the number of all possible attendance records with length n  which will be regarded as rewardable  the answer may be very large  return it after mod 109 + 7  a student attendance record is a string that only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a record is regarded as rewardable if it doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  hard dynamic programming 
improving the runtime from o(n) to o(log n) student attendance record ii given a positive integer n  return the number of all possible attendance records with length n  which will be regarded as rewardable  the answer may be very large  return it after mod 109 + 7  a student attendance record is a string that only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a record is regarded as rewardable if it doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  hard dynamic programming 
simple java o(n) solution student attendance record ii given a positive integer n  return the number of all possible attendance records with length n  which will be regarded as rewardable  the answer may be very large  return it after mod 109 + 7  a student attendance record is a string that only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a record is regarded as rewardable if it doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  hard dynamic programming 
python dp with explanation student attendance record ii given a positive integer n  return the number of all possible attendance records with length n  which will be regarded as rewardable  the answer may be very large  return it after mod 109 + 7  a student attendance record is a string that only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a record is regarded as rewardable if it doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  hard dynamic programming 
o(n) time o(1) space solution student attendance record ii given a positive integer n  return the number of all possible attendance records with length n  which will be regarded as rewardable  the answer may be very large  return it after mod 109 + 7  a student attendance record is a string that only contains the following three characters: 'a' : absent  'l' : late  'p' : present  a record is regarded as rewardable if it doesn't contain more than one 'a' (absent) or more than two continuous 'l' (late)  hard dynamic programming 
easy to understand simple o(n) solution with explanation optimal division given a list of positive integers  the adjacent integers will perform the float division  for medium math string 
java solution  backtracking optimal division given a list of positive integers  the adjacent integers will perform the float division  for medium math string 
brute force with memory in case of your interviewer forbid tricky solution optimal division given a list of positive integers  the adjacent integers will perform the float division  for medium math string 
o(n) very easy java solution  optimal division given a list of positive integers  the adjacent integers will perform the float division  for medium math string 
python  straightforward with explanation (insightful approach) optimal division given a list of positive integers  the adjacent integers will perform the float division  for medium math string 
i don't think there is a better person than me to answer this question brick wall there is a brick wall in front of you  the wall is rectangular and has several rows of bricks  the bricks have the same height but different width  you want to draw a vertical line from the top to the bottom and cross the least bricks  the brick wall is represented by a list of rows  each row is a list of integers representing the width of each brick in this row from left to right  if your line go through the edge of a brick  then the brick is not considered as crossed  you need to find out how to draw the line to cross the least bricks and return the number of crossed bricks  you cannot draw a line just along one of the two vertical edges of the wall  in which case the line will obviously cross no bricks  medium hash table 
c++ 6 lines (hash map) brick wall there is a brick wall in front of you  the wall is rectangular and has several rows of bricks  the bricks have the same height but different width  you want to draw a vertical line from the top to the bottom and cross the least bricks  the brick wall is represented by a list of rows  each row is a list of integers representing the width of each brick in this row from left to right  if your line go through the edge of a brick  then the brick is not considered as crossed  you need to find out how to draw the line to cross the least bricks and return the number of crossed bricks  you cannot draw a line just along one of the two vertical edges of the wall  in which case the line will obviously cross no bricks  medium hash table 
clear python solution brick wall there is a brick wall in front of you  the wall is rectangular and has several rows of bricks  the bricks have the same height but different width  you want to draw a vertical line from the top to the bottom and cross the least bricks  the brick wall is represented by a list of rows  each row is a list of integers representing the width of each brick in this row from left to right  if your line go through the edge of a brick  then the brick is not considered as crossed  you need to find out how to draw the line to cross the least bricks and return the number of crossed bricks  you cannot draw a line just along one of the two vertical edges of the wall  in which case the line will obviously cross no bricks  medium hash table 
neat java solution o(n) using hashmap brick wall there is a brick wall in front of you  the wall is rectangular and has several rows of bricks  the bricks have the same height but different width  you want to draw a vertical line from the top to the bottom and cross the least bricks  the brick wall is represented by a list of rows  each row is a list of integers representing the width of each brick in this row from left to right  if your line go through the edge of a brick  then the brick is not considered as crossed  you need to find out how to draw the line to cross the least bricks and return the number of crossed bricks  you cannot draw a line just along one of the two vertical edges of the wall  in which case the line will obviously cross no bricks  medium hash table 
verbose java solution  priorityqueue brick wall there is a brick wall in front of you  the wall is rectangular and has several rows of bricks  the bricks have the same height but different width  you want to draw a vertical line from the top to the bottom and cross the least bricks  the brick wall is represented by a list of rows  each row is a list of integers representing the width of each brick in this row from left to right  if your line go through the edge of a brick  then the brick is not considered as crossed  you need to find out how to draw the line to cross the least bricks and return the number of crossed bricks  you cannot draw a line just along one of the two vertical edges of the wall  in which case the line will obviously cross no bricks  medium hash table 
simple java solution (4ms) with explanation  next greater element iii given a positive 32-bit integer n  you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n  if no such positive 32-bit integer exists  you need to return -1  medium string 
c++ 4 lines (next_permutation) next greater element iii given a positive 32-bit integer n  you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n  if no such positive 32-bit integer exists  you need to return -1  medium string 
[c++] solution with explanation next greater element iii given a positive 32-bit integer n  you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n  if no such positive 32-bit integer exists  you need to return -1  medium string 
java solution like next permutation problem o(n) next greater element iii given a positive 32-bit integer n  you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n  if no such positive 32-bit integer exists  you need to return -1  medium string 
easy python3 beats 100% next greater element iii given a positive 32-bit integer n  you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n  if no such positive 32-bit integer exists  you need to return -1  medium string 
1 line ruby   python reverse words in a string iii given a string  you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order  easy string 
short java code without explanation reverse words in a string iii given a string  you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order  easy string 
[c++] [java] clean code reverse words in a string iii given a string  you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order  easy string 
easiest java solution (9ms) - similar to reverse words in a string ii reverse words in a string iii given a string  you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order  easy string 
c++ solution reverse words in a string iii given a string  you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order  easy string 
python simple & short & readable ac solution quad tree intersection a quadtree is a tree data in which each internal node has exactly four children: topleft  topright  bottomleft and bottomright  quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions  we want to store true false information in our quad tree  the quad tree is used to represent a n   n boolean grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  for easy 
[fixed] incorrect test cases quad tree intersection a quadtree is a tree data in which each internal node has exactly four children: topleft  topright  bottomleft and bottomright  quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions  we want to store true false information in our quad tree  the quad tree is used to represent a n   n boolean grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  for easy 
c++ 10 line beat 100% quad tree intersection a quadtree is a tree data in which each internal node has exactly four children: topleft  topright  bottomleft and bottomright  quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions  we want to store true false information in our quad tree  the quad tree is used to represent a n   n boolean grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  for easy 
java concise code beat 100% quad tree intersection a quadtree is a tree data in which each internal node has exactly four children: topleft  topright  bottomleft and bottomright  quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions  we want to store true false information in our quad tree  the quad tree is used to represent a n   n boolean grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  for easy 
python solution to a badly worded question quad tree intersection a quadtree is a tree data in which each internal node has exactly four children: topleft  topright  bottomleft and bottomright  quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions  we want to store true false information in our quad tree  the quad tree is used to represent a n   n boolean grid  for each node  it will be subdivided into four children nodes until the values in the region it represents are all the same  each node has another two boolean attributes : isleaf and val  isleaf is true if and only if the node is a leaf node  the val attribute for a leaf node contains the value of the region it represents  for easy 
[solution] python  c++  simple  with explanation maximum depth of n-ary tree given a n-ary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  for easy tree depth-first search breadth-first search 
java top down dfs solutions maximum depth of n-ary tree given a n-ary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  for easy tree depth-first search breadth-first search 
java bfs iterative solution maximum depth of n-ary tree given a n-ary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  for easy tree depth-first search breadth-first search 
dfs & bfs solutions in c++  maximum depth of n-ary tree given a n-ary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  for easy tree depth-first search breadth-first search 
java solution with explain  same logic with maximum depth of binary tree maximum depth of n-ary tree given a n-ary tree  find its maximum depth  the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node  for easy tree depth-first search breadth-first search 
java solution  presum + hashmap subarray sum equals k given an array of integers and an integer k  you need to find the total number of continuous subarrays whose sum equals to k  medium array hash table 
python  simple with explanation subarray sum equals k given an array of integers and an integer k  you need to find the total number of continuous subarrays whose sum equals to k  medium array hash table 
c++ prefix sum + map subarray sum equals k given an array of integers and an integer k  you need to find the total number of continuous subarrays whose sum equals to k  medium array hash table 
three approaches with explanation subarray sum equals k given an array of integers and an integer k  you need to find the total number of continuous subarrays whose sum equals to k  medium array hash table 
super simple python subarray sum equals k given an array of integers and an integer k  you need to find the total number of continuous subarrays whose sum equals to k  medium array hash table 
java solution  sorting  and rough proof of algorithm  array partition i given an array of 2n integers  your task is to group these integers into n pairs of integer  say (a1  b1)  (a2  b2)       (an  bn) which makes sum of min(ai  bi) for all i from 1 to n as large as possible  easy array 
please explain: the question doesn't make sense  array partition i given an array of 2n integers  your task is to group these integers into n pairs of integer  say (a1  b1)  (a2  b2)       (an  bn) which makes sum of min(ai  bi) for all i from 1 to n as large as possible  easy array 
java o(n) beats 100% array partition i given an array of 2n integers  your task is to group these integers into n pairs of integer  say (a1  b1)  (a2  b2)       (an  bn) which makes sum of min(ai  bi) for all i from 1 to n as large as possible  easy array 
c++ code o(n) beats 100% array partition i given an array of 2n integers  your task is to group these integers into n pairs of integer  say (a1  b1)  (a2  b2)       (an  bn) which makes sum of min(ai  bi) for all i from 1 to n as large as possible  easy array 
python 1 line (sorting is accepted) array partition i given an array of 2n integers  your task is to group these integers into n pairs of integer  say (a1  b1)  (a2  b2)       (an  bn) which makes sum of min(ai  bi) for all i from 1 to n as large as possible  easy array 
java solution  post-order traversal binary tree tilt given a binary tree  return the tilt of the whole tree  the tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values  null node has tilt 0  the tilt of the whole tree is defined as the sum of all nodes' tilt  easy tree 
python  simple with explanation binary tree tilt given a binary tree  return the tilt of the whole tree  the tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values  null node has tilt 0  the tilt of the whole tree is defined as the sum of all nodes' tilt  easy tree 
simple java solution  -- without global variable binary tree tilt given a binary tree  return the tilt of the whole tree  the tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values  null node has tilt 0  the tilt of the whole tree is defined as the sum of all nodes' tilt  easy tree 
python straightforward solution binary tree tilt given a binary tree  return the tilt of the whole tree  the tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values  null node has tilt 0  the tilt of the whole tree is defined as the sum of all nodes' tilt  easy tree 
java solution  no globle varible  easy and clean binary tree tilt given a binary tree  return the tilt of the whole tree  the tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values  null node has tilt 0  the tilt of the whole tree is defined as the sum of all nodes' tilt  easy tree 
python  simple with explanation find the closest palindrome given an integer n  find the closest integer (not including itself)  which is a palindrome  the 'closest' is defined as absolute difference minimized between two integers  hard string 
java solution with full explaination find the closest palindrome given an integer n  find the closest integer (not including itself)  which is a palindrome  the 'closest' is defined as absolute difference minimized between two integers  hard string 
java solution with detailed proof find the closest palindrome given an integer n  find the closest integer (not including itself)  which is a palindrome  the 'closest' is defined as absolute difference minimized between two integers  hard string 
c++ short solution  only need to compare 5 numbers find the closest palindrome given an integer n  find the closest integer (not including itself)  which is a palindrome  the 'closest' is defined as absolute difference minimized between two integers  hard string 
concise java solution find the closest palindrome given an integer n  find the closest integer (not including itself)  which is a palindrome  the 'closest' is defined as absolute difference minimized between two integers  hard string 
[c++] [java] clean code - o(n) array nesting a zero-indexed array a of length n contains all integers from 0 to n-1  find and return the longest length of set s  where s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected to the rule below  suppose the first element in s starts with the selection of element a[i] of index = i  the next element in s should be a[a[i]]  and then a[a[a[i]]]… by that analogy  we stop adding right before a duplicate element occurs in s  medium array 
this is actually dfs array nesting a zero-indexed array a of length n contains all integers from 0 to n-1  find and return the longest length of set s  where s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected to the rule below  suppose the first element in s starts with the selection of element a[i] of index = i  the next element in s should be a[a[i]]  and then a[a[a[i]]]… by that analogy  we stop adding right before a duplicate element occurs in s  medium array 
python solution array nesting a zero-indexed array a of length n contains all integers from 0 to n-1  find and return the longest length of set s  where s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected to the rule below  suppose the first element in s starts with the selection of element a[i] of index = i  the next element in s should be a[a[i]]  and then a[a[a[i]]]… by that analogy  we stop adding right before a duplicate element occurs in s  medium array 
short python array nesting a zero-indexed array a of length n contains all integers from 0 to n-1  find and return the longest length of set s  where s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected to the rule below  suppose the first element in s starts with the selection of element a[i] of index = i  the next element in s should be a[a[i]]  and then a[a[a[i]]]… by that analogy  we stop adding right before a duplicate element occurs in s  medium array 
java o(n) time o(1) space array nesting a zero-indexed array a of length n contains all integers from 0 to n-1  find and return the longest length of set s  where s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected to the rule below  suppose the first element in s starts with the selection of element a[i] of index = i  the next element in s should be a[a[i]]  and then a[a[a[i]]]… by that analogy  we stop adding right before a duplicate element occurs in s  medium array 
java concise o(nm) time reshape the matrix in matlab  there is a very useful function called 'reshape'  which can reshape a matrix into a new one with different size but keep its original data  you're given a matrix represented by a two-dimensional array  and two positive integers r and c representing the row number and column number of the wanted reshaped matrix  respectively  the reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were  if the 'reshape' operation with given parameters is possible and legal  output the new reshaped matrix; otherwise  output the original matrix  easy array 
one loop reshape the matrix in matlab  there is a very useful function called 'reshape'  which can reshape a matrix into a new one with different size but keep its original data  you're given a matrix represented by a two-dimensional array  and two positive integers r and c representing the row number and column number of the wanted reshaped matrix  respectively  the reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were  if the 'reshape' operation with given parameters is possible and legal  output the new reshaped matrix; otherwise  output the original matrix  easy array 
python solutions reshape the matrix in matlab  there is a very useful function called 'reshape'  which can reshape a matrix into a new one with different size but keep its original data  you're given a matrix represented by a two-dimensional array  and two positive integers r and c representing the row number and column number of the wanted reshaped matrix  respectively  the reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were  if the 'reshape' operation with given parameters is possible and legal  output the new reshaped matrix; otherwise  output the original matrix  easy array 
easy java solution reshape the matrix in matlab  there is a very useful function called 'reshape'  which can reshape a matrix into a new one with different size but keep its original data  you're given a matrix represented by a two-dimensional array  and two positive integers r and c representing the row number and column number of the wanted reshaped matrix  respectively  the reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were  if the 'reshape' operation with given parameters is possible and legal  output the new reshaped matrix; otherwise  output the original matrix  easy array 
c solution reshape the matrix in matlab  there is a very useful function called 'reshape'  which can reshape a matrix into a new one with different size but keep its original data  you're given a matrix represented by a two-dimensional array  and two positive integers r and c representing the row number and column number of the wanted reshaped matrix  respectively  the reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were  if the 'reshape' operation with given parameters is possible and legal  output the new reshaped matrix; otherwise  output the original matrix  easy array 
java solution  sliding window permutation in string given two strings s1 and s2  write a function to return true if s2 contains the permutation of s1  in other words  one of the first string's permutations is the substring of the second string  medium two pointers 
8 lines slide window solution in java permutation in string given two strings s1 and s2  write a function to return true if s2 contains the permutation of s1  in other words  one of the first string's permutations is the substring of the second string  medium two pointers 
python  simple with explanation permutation in string given two strings s1 and s2  write a function to return true if s2 contains the permutation of s1  in other words  one of the first string's permutations is the substring of the second string  medium two pointers 
sliding window in java  very similar to find all anagrams in a string permutation in string given two strings s1 and s2  write a function to return true if s2 contains the permutation of s1  in other words  one of the first string's permutations is the substring of the second string  medium two pointers 
java solution two pointers permutation in string given two strings s1 and s2  write a function to return true if s2 contains the permutation of s1  in other words  one of the first string's permutations is the substring of the second string  medium two pointers 
java solution  tree traversal subtree of another tree given two non-empty binary trees s and t  check whether tree t has exactly the same structure and node values with a subtree of s  a subtree of s is a tree consists of a node in s and all of this node's descendants  the tree s could also be considered as a subtree of itself  easy tree 
easy o(n) java solution using preorder traversal subtree of another tree given two non-empty binary trees s and t  check whether tree t has exactly the same structure and node values with a subtree of s  a subtree of s is a tree consists of a node in s and all of this node's descendants  the tree s could also be considered as a subtree of itself  easy tree 
python  straightforward with explanation (o(st) and o(s+t) approaches) subtree of another tree given two non-empty binary trees s and t  check whether tree t has exactly the same structure and node values with a subtree of s  a subtree of s is a tree consists of a node in s and all of this node's descendants  the tree s could also be considered as a subtree of itself  easy tree 
short python by converting into strings subtree of another tree given two non-empty binary trees s and t  check whether tree t has exactly the same structure and node values with a subtree of s  a subtree of s is a tree consists of a node in s and all of this node's descendants  the tree s could also be considered as a subtree of itself  easy tree 
java concise o(n+m) time o(n+m) space subtree of another tree given two non-empty binary trees s and t  check whether tree t has exactly the same structure and node values with a subtree of s  a subtree of s is a tree consists of a node in s and all of this node's descendants  the tree s could also be considered as a subtree of itself  easy tree 
python  straightforward with explanation distribute candies given an integer array with even length  where different numbers in this array represent different kinds of candies  each number means one candy of the corresponding kind  you need to distribute these candies equally in number to brother and sister  return the maximum number of kinds of candies the sister could gain  easy hash table 
java solution  3 lines  hashset distribute candies given an integer array with even length  where different numbers in this array represent different kinds of candies  each number means one candy of the corresponding kind  you need to distribute these candies equally in number to brother and sister  return the maximum number of kinds of candies the sister could gain  easy hash table 
c++  bitset  beats 99 60% distribute candies given an integer array with even length  where different numbers in this array represent different kinds of candies  each number means one candy of the corresponding kind  you need to distribute these candies equally in number to brother and sister  return the maximum number of kinds of candies the sister could gain  easy hash table 
[c++] clean code - 2 solutions: set and sort distribute candies given an integer array with even length  where different numbers in this array represent different kinds of candies  each number means one candy of the corresponding kind  you need to distribute these candies equally in number to brother and sister  return the maximum number of kinds of candies the sister could gain  easy hash table 
1-line javascript o(n) solution using set distribute candies given an integer array with even length  where different numbers in this array represent different kinds of candies  each number means one candy of the corresponding kind  you need to distribute these candies equally in number to brother and sister  return the maximum number of kinds of candies the sister could gain  easy hash table 
java solution  dp with space compression out of boundary paths there is an m by n grid with a ball  given the start coordinate (i j) of the ball  you can move the ball to adjacent cell or cross the grid boundary in four directions (up  down  left  right)  however  you can at most move n times  find out the number of paths to move the ball out of grid boundary  the answer may be very large  return it after mod 109 + 7  medium dynamic programming depth-first search 
c++ 6 lines dp o(n   m   n)  6 ms out of boundary paths there is an m by n grid with a ball  given the start coordinate (i j) of the ball  you can move the ball to adjacent cell or cross the grid boundary in four directions (up  down  left  right)  however  you can at most move n times  find out the number of paths to move the ball out of grid boundary  the answer may be very large  return it after mod 109 + 7  medium dynamic programming depth-first search 
clean code - 8 solutions (6 c++ & 2 java) out of boundary paths there is an m by n grid with a ball  given the start coordinate (i j) of the ball  you can move the ball to adjacent cell or cross the grid boundary in four directions (up  down  left  right)  however  you can at most move n times  find out the number of paths to move the ball out of grid boundary  the answer may be very large  return it after mod 109 + 7  medium dynamic programming depth-first search 
java dfs with memorization out of boundary paths there is an m by n grid with a ball  given the start coordinate (i j) of the ball  you can move the ball to adjacent cell or cross the grid boundary in four directions (up  down  left  right)  however  you can at most move n times  find out the number of paths to move the ball out of grid boundary  the answer may be very large  return it after mod 109 + 7  medium dynamic programming depth-first search 
fast python solution using numpy out of boundary paths there is an m by n grid with a ball  given the start coordinate (i j) of the ball  you can move the ball to adjacent cell or cross the grid boundary in four directions (up  down  left  right)  however  you can at most move n times  find out the number of paths to move the ball out of grid boundary  the answer may be very large  return it after mod 109 + 7  medium dynamic programming depth-first search 
java o(n) time o(1) space shortest unsorted continuous subarray given an integer array  you need to find one continuous subarray that if you only sort this subarray in ascending order  then the whole array will be sorted in ascending order  too  you need to find the shortest such subarray and output its length  easy array 
ideas behind the o(n) two-pass and one-pass solutions shortest unsorted continuous subarray given an integer array  you need to find one continuous subarray that if you only sort this subarray in ascending order  then the whole array will be sorted in ascending order  too  you need to find the shortest such subarray and output its length  easy array 
java solution  sort  shortest unsorted continuous subarray given an integer array  you need to find one continuous subarray that if you only sort this subarray in ascending order  then the whole array will be sorted in ascending order  too  you need to find the shortest such subarray and output its length  easy array 
python 2 lines sort solution shortest unsorted continuous subarray given an integer array  you need to find one continuous subarray that if you only sort this subarray in ascending order  then the whole array will be sorted in ascending order  too  you need to find the shortest such subarray and output its length  easy array 
c++ o(n) solution shortest unsorted continuous subarray given an integer array  you need to find one continuous subarray that if you only sort this subarray in ascending order  then the whole array will be sorted in ascending order  too  you need to find the shortest such subarray and output its length  easy array 
java dp solution (longest common subsequence) delete operation for two strings given two words word1 and word2  find the minimum number of steps required to make word1 and word2 the same  where in each step you can delete one character in either string  medium string 
java dp solution  same as edit distance delete operation for two strings given two words word1 and word2  find the minimum number of steps required to make word1 and word2 the same  where in each step you can delete one character in either string  medium string 
longest common subsequence dp java solution delete operation for two strings given two words word1 and word2  find the minimum number of steps required to make word1 and word2 the same  where in each step you can delete one character in either string  medium string 
python dp solution delete operation for two strings given two words word1 and word2  find the minimum number of steps required to make word1 and word2 the same  where in each step you can delete one character in either string  medium string 
python  straightforward with explanation delete operation for two strings given two words word1 and word2  find the minimum number of steps required to make word1 and word2 the same  where in each step you can delete one character in either string  medium string 
java solution  convex hull algorithm - gift wrapping aka jarvis march erect the fence there are some trees  where each tree is represented by (x y) coordinate in a two-dimensional garden  your job is to fence the entire garden using the minimum length of rope as it is expensive  the garden is well fenced only if all the trees are enclosed  your task is to help find the coordinates of trees which are exactly located on the fence perimeter  hard geometry 
java graham scan with adapted sorting to deal with collinear points erect the fence there are some trees  where each tree is represented by (x y) coordinate in a two-dimensional garden  your job is to fence the entire garden using the minimum length of rope as it is expensive  the garden is well fenced only if all the trees are enclosed  your task is to help find the coordinates of trees which are exactly located on the fence perimeter  hard geometry 
c++ and python easy wiki solution erect the fence there are some trees  where each tree is represented by (x y) coordinate in a two-dimensional garden  your job is to fence the entire garden using the minimum length of rope as it is expensive  the garden is well fenced only if all the trees are enclosed  your task is to help find the coordinates of trees which are exactly located on the fence perimeter  hard geometry 
python  am chain with explanation erect the fence there are some trees  where each tree is represented by (x y) coordinate in a two-dimensional garden  your job is to fence the entire garden using the minimum length of rope as it is expensive  the garden is well fenced only if all the trees are enclosed  your task is to help find the coordinates of trees which are exactly located on the fence perimeter  hard geometry 
c++ graham scan monotone chain dealing with collinear cases erect the fence there are some trees  where each tree is represented by (x y) coordinate in a two-dimensional garden  your job is to fence the entire garden using the minimum length of rope as it is expensive  the garden is well fenced only if all the trees are enclosed  your task is to help find the coordinates of trees which are exactly located on the fence perimeter  hard geometry 
java iterative and recursive solutions n-ary tree preorder traversal given an n-ary tree  return the preorder traversal of its nodes' values  for easy tree 
python short iterative solution beats 100%    66 ms faster than fastest ! n-ary tree preorder traversal given an n-ary tree  return the preorder traversal of its nodes' values  for easy tree 
c++ simple 10-line iterative solution  beat 100%! n-ary tree preorder traversal given an n-ary tree  return the preorder traversal of its nodes' values  for easy tree 
c++ 44ms beats 100% both iterative and recursive n-ary tree preorder traversal given an n-ary tree  return the preorder traversal of its nodes' values  for easy tree 
java time o(n) and space o(n) recursive   iterative solution using helper method n-ary tree preorder traversal given an n-ary tree  return the preorder traversal of its nodes' values  for easy tree 
java solution: use startswith and indexof tag validator given a string representing a code snippet  you need to implement a tag validator to parse the code and return whether it is valid  a code snippet is valid if all the following rules hold: the code must be wrapped in a valid closed tag  otherwise  the code is invalid  a closed tag (not necessarily valid) has exactly the following format : <tag_name>tag_content< tag_name>  among them  <tag_name> is the start tag  and < tag_name> is the end tag  the tag_name in start and end tags should be the same  a closed tag is valid if and only if the tag_name and tag_content are valid  a valid tag_name only contain upper-case letters  and has length in range [1 9]  otherwise  the tag_name is invalid  a valid tag_content may contain other valid closed tags  cdata and any characters (see note1) except unmatched <  unmatched start and end tag  and unmatched or closed tags with invalid tag_name  otherwise  the tag_content is invalid  a start tag is unmatched if no end tag exists with the same tag_name  and vice versa  however  you also need to consider the issue of unbalanced when tags are nested  a < is unmatched if you cannot find a subsequent >  and when you find a < or <   all the subsequent characters until the next > should be parsed as tag_name (not necessarily valid)  the cdata has the following format : <![cdata[cdata_content]]>  the range of cdata_content is defined as the characters between <![cdata[ and the first subsequent ]]>  cdata_content may contain any characters  the function of cdata is to forbid the validator to parse cdata_content  so even it has some characters that can be parsed as tag (no matter valid or invalid)  you should treat it as regular characters  valid code hard string stack 
short python  accepted but not sure if correct tag validator given a string representing a code snippet  you need to implement a tag validator to parse the code and return whether it is valid  a code snippet is valid if all the following rules hold: the code must be wrapped in a valid closed tag  otherwise  the code is invalid  a closed tag (not necessarily valid) has exactly the following format : <tag_name>tag_content< tag_name>  among them  <tag_name> is the start tag  and < tag_name> is the end tag  the tag_name in start and end tags should be the same  a closed tag is valid if and only if the tag_name and tag_content are valid  a valid tag_name only contain upper-case letters  and has length in range [1 9]  otherwise  the tag_name is invalid  a valid tag_content may contain other valid closed tags  cdata and any characters (see note1) except unmatched <  unmatched start and end tag  and unmatched or closed tags with invalid tag_name  otherwise  the tag_content is invalid  a start tag is unmatched if no end tag exists with the same tag_name  and vice versa  however  you also need to consider the issue of unbalanced when tags are nested  a < is unmatched if you cannot find a subsequent >  and when you find a < or <   all the subsequent characters until the next > should be parsed as tag_name (not necessarily valid)  the cdata has the following format : <![cdata[cdata_content]]>  the range of cdata_content is defined as the characters between <![cdata[ and the first subsequent ]]>  cdata_content may contain any characters  the function of cdata is to forbid the validator to parse cdata_content  so even it has some characters that can be parsed as tag (no matter valid or invalid)  you should treat it as regular characters  valid code hard string stack 
java solution  7 lines  regular expression tag validator given a string representing a code snippet  you need to implement a tag validator to parse the code and return whether it is valid  a code snippet is valid if all the following rules hold: the code must be wrapped in a valid closed tag  otherwise  the code is invalid  a closed tag (not necessarily valid) has exactly the following format : <tag_name>tag_content< tag_name>  among them  <tag_name> is the start tag  and < tag_name> is the end tag  the tag_name in start and end tags should be the same  a closed tag is valid if and only if the tag_name and tag_content are valid  a valid tag_name only contain upper-case letters  and has length in range [1 9]  otherwise  the tag_name is invalid  a valid tag_content may contain other valid closed tags  cdata and any characters (see note1) except unmatched <  unmatched start and end tag  and unmatched or closed tags with invalid tag_name  otherwise  the tag_content is invalid  a start tag is unmatched if no end tag exists with the same tag_name  and vice versa  however  you also need to consider the issue of unbalanced when tags are nested  a < is unmatched if you cannot find a subsequent >  and when you find a < or <   all the subsequent characters until the next > should be parsed as tag_name (not necessarily valid)  the cdata has the following format : <![cdata[cdata_content]]>  the range of cdata_content is defined as the characters between <![cdata[ and the first subsequent ]]>  cdata_content may contain any characters  the function of cdata is to forbid the validator to parse cdata_content  so even it has some characters that can be parsed as tag (no matter valid or invalid)  you should treat it as regular characters  valid code hard string stack 
[c++] clean code - recursive parser tag validator given a string representing a code snippet  you need to implement a tag validator to parse the code and return whether it is valid  a code snippet is valid if all the following rules hold: the code must be wrapped in a valid closed tag  otherwise  the code is invalid  a closed tag (not necessarily valid) has exactly the following format : <tag_name>tag_content< tag_name>  among them  <tag_name> is the start tag  and < tag_name> is the end tag  the tag_name in start and end tags should be the same  a closed tag is valid if and only if the tag_name and tag_content are valid  a valid tag_name only contain upper-case letters  and has length in range [1 9]  otherwise  the tag_name is invalid  a valid tag_content may contain other valid closed tags  cdata and any characters (see note1) except unmatched <  unmatched start and end tag  and unmatched or closed tags with invalid tag_name  otherwise  the tag_content is invalid  a start tag is unmatched if no end tag exists with the same tag_name  and vice versa  however  you also need to consider the issue of unbalanced when tags are nested  a < is unmatched if you cannot find a subsequent >  and when you find a < or <   all the subsequent characters until the next > should be parsed as tag_name (not necessarily valid)  the cdata has the following format : <![cdata[cdata_content]]>  the range of cdata_content is defined as the characters between <![cdata[ and the first subsequent ]]>  cdata_content may contain any characters  the function of cdata is to forbid the validator to parse cdata_content  so even it has some characters that can be parsed as tag (no matter valid or invalid)  you should treat it as regular characters  valid code hard string stack 
clean c++ solution tag validator given a string representing a code snippet  you need to implement a tag validator to parse the code and return whether it is valid  a code snippet is valid if all the following rules hold: the code must be wrapped in a valid closed tag  otherwise  the code is invalid  a closed tag (not necessarily valid) has exactly the following format : <tag_name>tag_content< tag_name>  among them  <tag_name> is the start tag  and < tag_name> is the end tag  the tag_name in start and end tags should be the same  a closed tag is valid if and only if the tag_name and tag_content are valid  a valid tag_name only contain upper-case letters  and has length in range [1 9]  otherwise  the tag_name is invalid  a valid tag_content may contain other valid closed tags  cdata and any characters (see note1) except unmatched <  unmatched start and end tag  and unmatched or closed tags with invalid tag_name  otherwise  the tag_content is invalid  a start tag is unmatched if no end tag exists with the same tag_name  and vice versa  however  you also need to consider the issue of unbalanced when tags are nested  a < is unmatched if you cannot find a subsequent >  and when you find a < or <   all the subsequent characters until the next > should be parsed as tag_name (not necessarily valid)  the cdata has the following format : <![cdata[cdata_content]]>  the range of cdata_content is defined as the characters between <![cdata[ and the first subsequent ]]>  cdata_content may contain any characters  the function of cdata is to forbid the validator to parse cdata_content  so even it has some characters that can be parsed as tag (no matter valid or invalid)  you should treat it as regular characters  valid code hard string stack 
small simple c++ java python fraction addition and subtraction given a string representing an expression of fraction addition and subtraction  you need to return the calculation result in string format  the final result should be irreducible fraction  if your final result is an integer  say 2  you need to change it to the format of fraction that has denominator 1  so in this case  2 should be converted to 2 1  medium math 
concise java solution fraction addition and subtraction given a string representing an expression of fraction addition and subtraction  you need to return the calculation result in string format  the final result should be irreducible fraction  if your final result is an integer  say 2  you need to change it to the format of fraction that has denominator 1  so in this case  2 should be converted to 2 1  medium math 
python easy understood 2-line solution fraction addition and subtraction given a string representing an expression of fraction addition and subtraction  you need to return the calculation result in string format  the final result should be irreducible fraction  if your final result is an integer  say 2  you need to change it to the format of fraction that has denominator 1  so in this case  2 should be converted to 2 1  medium math 
java solution  fraction addition and gcd fraction addition and subtraction given a string representing an expression of fraction addition and subtraction  you need to return the calculation result in string format  the final result should be irreducible fraction  if your final result is an integer  say 2  you need to change it to the format of fraction that has denominator 1  so in this case  2 should be converted to 2 1  medium math 
c++ clean code fraction addition and subtraction given a string representing an expression of fraction addition and subtraction  you need to return the calculation result in string format  the final result should be irreducible fraction  if your final result is an integer  say 2  you need to change it to the format of fraction that has denominator 1  so in this case  2 should be converted to 2 1  medium math 
c++ 3 lines (unordered_set) valid square given the coordinates of four points in 2d space  return whether the four points could construct a square  the coordinate (x y) of a point is represented by an integer array with two integers  medium math 
simple java solution - square distances valid square given the coordinates of four points in 2d space  return whether the four points could construct a square  the coordinate (x y) of a point is represented by an integer array with two integers  medium math 
4 liner java valid square given the coordinates of four points in 2d space  return whether the four points could construct a square  the coordinate (x y) of a point is represented by an integer array with two integers  medium math 
a general solution to find combination of squares in n points in o(n^2) time valid square given the coordinates of four points in 2d space  return whether the four points could construct a square  the coordinate (x y) of a point is represented by an integer array with two integers  medium math 
share my simple python solution valid square given the coordinates of four points in 2d space  return whether the four points could construct a square  the coordinate (x y) of a point is represented by an integer array with two integers  medium math 
simple java hashmap solution longest harmonious subsequence we define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1  now  given an integer array  you need to find the length of its longest harmonious subsequence among all its possible subsequences  easy hash table 
python  straightforward with explanation longest harmonious subsequence we define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1  now  given an integer array  you need to find the length of its longest harmonious subsequence among all its possible subsequences  easy hash table 
three c++ solution run time with explanation longest harmonious subsequence we define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1  now  given an integer array  you need to find the length of its longest harmonious subsequence among all its possible subsequences  easy hash table 
short python using counter longest harmonious subsequence we define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1  now  given an integer array  you need to find the length of its longest harmonious subsequence among all its possible subsequences  easy hash table 
java solution  hashmap longest harmonious subsequence we define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1  now  given an integer array  you need to find the length of its longest harmonious subsequence among all its possible subsequences  easy hash table 
union and or and the explanation big countries sql schemathere is a table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ a country is big if it has an area of bigger than 3 million square km or a population of more than 25 million  write a sql solution to output big countries' name  population and area  for easy 
easy ac big countries sql schemathere is a table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ a country is big if it has an area of bigger than 3 million square km or a population of more than 25 million  write a sql solution to output big countries' name  population and area  for easy 
description and author's solution are inconsistent big countries sql schemathere is a table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ a country is big if it has an area of bigger than 3 million square km or a population of more than 25 million  write a sql solution to output big countries' name  population and area  for easy 
obvious solution: runtime: 1724 ms  faster than 92 81% of mysql online submissions big countries sql schemathere is a table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ a country is big if it has an area of bigger than 3 million square km or a population of more than 25 million  write a sql solution to output big countries' name  population and area  for easy 
for those wondering the units big countries sql schemathere is a table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ a country is big if it has an area of bigger than 3 million square km or a population of more than 25 million  write a sql solution to output big countries' name  population and area  for easy 
all the same classes more than 5 students sql schema there is a table courses with columns: student and class please list out all classes which have more than or equal to 5 students  for easy 
my solution classes more than 5 students sql schema there is a table courses with columns: student and class please list out all classes which have more than or equal to 5 students  for easy 
my first mysql solution   classes more than 5 students sql schema there is a table courses with columns: student and class please list out all classes which have more than or equal to 5 students  for easy 
can not be more simpler classes more than 5 students sql schema there is a table courses with columns: student and class please list out all classes which have more than or equal to 5 students  for easy 
concise solution using distinct and having  classes more than 5 students sql schema there is a table courses with columns: student and class please list out all classes which have more than or equal to 5 students  for easy 
java solution  find min range addition ii given an m   n matrix m initialized with all 0's and several update operations  operations are represented by a 2d array  and each operation is represented by an array with two positive integers a and b  which means m[i][j] should be added by one for all 0 <= i < a and 0 <= j < b  you need to count and return the number of maximum integers in the matrix after performing all the operations  easy math 
python solution   beat 100% range addition ii given an m   n matrix m initialized with all 0's and several update operations  operations are represented by a 2d array  and each operation is represented by an array with two positive integers a and b  which means m[i][j] should be added by one for all 0 <= i < a and 0 <= j < b  you need to count and return the number of maximum integers in the matrix after performing all the operations  easy math 
python  straightforward with explanation range addition ii given an m   n matrix m initialized with all 0's and several update operations  operations are represented by a 2d array  and each operation is represented by an array with two positive integers a and b  which means m[i][j] should be added by one for all 0 <= i < a and 0 <= j < b  you need to count and return the number of maximum integers in the matrix after performing all the operations  easy math 
java simple solution range addition ii given an m   n matrix m initialized with all 0's and several update operations  operations are represented by a 2d array  and each operation is represented by an array with two positive integers a and b  which means m[i][j] should be added by one for all 0 <= i < a and 0 <= j < b  you need to count and return the number of maximum integers in the matrix after performing all the operations  easy math 
c++ short solution range addition ii given an m   n matrix m initialized with all 0's and several update operations  operations are represented by a 2d array  and each operation is represented by an array with two positive integers a and b  which means m[i][j] should be added by one for all 0 <= i < a and 0 <= j < b  you need to count and return the number of maximum integers in the matrix after performing all the operations  easy math 
java o(n+m) time o(n) space minimum index sum of two lists suppose andy and doris want to choose a restaurant for dinner  and they both have a list of favorite restaurants represented by strings  you need to help them find out their common interest with the least list index sum  if there is a choice tie between answers  output all of them with no order requirement  you could assume there always exists an answer  easy hash table 
ucsd students? minimum index sum of two lists suppose andy and doris want to choose a restaurant for dinner  and they both have a list of favorite restaurants represented by strings  you need to help them find out their common interest with the least list index sum  if there is a choice tie between answers  output all of them with no order requirement  you could assume there always exists an answer  easy hash table 
python  straightforward with explanation minimum index sum of two lists suppose andy and doris want to choose a restaurant for dinner  and they both have a list of favorite restaurants represented by strings  you need to help them find out their common interest with the least list index sum  if there is a choice tie between answers  output all of them with no order requirement  you could assume there always exists an answer  easy hash table 
c++ 9 lines hash table easy to understand minimum index sum of two lists suppose andy and doris want to choose a restaurant for dinner  and they both have a list of favorite restaurants represented by strings  you need to help them find out their common interest with the least list index sum  if there is a choice tie between answers  output all of them with no order requirement  you could assume there always exists an answer  easy hash table 
bug report minimum index sum of two lists suppose andy and doris want to choose a restaurant for dinner  and they both have a list of favorite restaurants represented by strings  you need to help them find out their common interest with the least list index sum  if there is a choice tie between answers  output all of them with no order requirement  you could assume there always exists an answer  easy hash table 
java solution  dp non-negative integers without consecutive ones given a positive integer n  find the number of non-negative integers less than or equal to n  whose binary representations do not contain consecutive ones  hard dynamic programming 
c++  non-dp  o(32) fibonacci solution non-negative integers without consecutive ones given a positive integer n  find the number of non-negative integers less than or equal to n  whose binary representations do not contain consecutive ones  hard dynamic programming 
c++ 4 lines dp fibonacci 6 ms non-negative integers without consecutive ones given a positive integer n  find the number of non-negative integers less than or equal to n  whose binary representations do not contain consecutive ones  hard dynamic programming 
java o(1) time o(1) space dp solution non-negative integers without consecutive ones given a positive integer n  find the number of non-negative integers less than or equal to n  whose binary representations do not contain consecutive ones  hard dynamic programming 
python dp solution easily understood non-negative integers without consecutive ones given a positive integer n  find the number of non-negative integers less than or equal to n  whose binary representations do not contain consecutive ones  hard dynamic programming 
a simple solution human traffic of stadium sql schemax city built a new stadium  each day many people visit it and the stats are saved as these columns: id  date  people please write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive)  for hard 
solution using join human traffic of stadium sql schemax city built a new stadium  each day many people visit it and the stats are saved as these columns: id  date  people please write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive)  for hard 
i don't understand the problem human traffic of stadium sql schemax city built a new stadium  each day many people visit it and the stats are saved as these columns: id  date  people please write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive)  for hard 
wrong testcase human traffic of stadium sql schemax city built a new stadium  each day many people visit it and the stats are saved as these columns: id  date  people please write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive)  for hard 
a solution with union  join and where human traffic of stadium sql schemax city built a new stadium  each day many people visit it and the stats are saved as these columns: id  date  people please write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive)  for hard 
java - greedy solution - o(flowerbed) - beats 100% can place flowers suppose you have a long flowerbed in which some of the plots are planted and some are not  however  flowers cannot be planted in adjacent plots - they would compete for water and both would die  given a flowerbed (represented as an array containing 0 and 1  where 0 means empty and 1 means not empty)  and a number n  return if n new flowers can be planted in it without violating the no-adjacent-flowers rule  easy array 
[java] very easy solution can place flowers suppose you have a long flowerbed in which some of the plots are planted and some are not  however  flowers cannot be planted in adjacent plots - they would compete for water and both would die  given a flowerbed (represented as an array containing 0 and 1  where 0 means empty and 1 means not empty)  and a number n  return if n new flowers can be planted in it without violating the no-adjacent-flowers rule  easy array 
python  straightforward with explanation can place flowers suppose you have a long flowerbed in which some of the plots are planted and some are not  however  flowers cannot be planted in adjacent plots - they would compete for water and both would die  given a flowerbed (represented as an array containing 0 and 1  where 0 means empty and 1 means not empty)  and a number n  return if n new flowers can be planted in it without violating the no-adjacent-flowers rule  easy array 
simplest c++ code can place flowers suppose you have a long flowerbed in which some of the plots are planted and some are not  however  flowers cannot be planted in adjacent plots - they would compete for water and both would die  given a flowerbed (represented as an array containing 0 and 1  where 0 means empty and 1 means not empty)  and a number n  return if n new flowers can be planted in it without violating the no-adjacent-flowers rule  easy array 
[c++][java] clean code can place flowers suppose you have a long flowerbed in which some of the plots are planted and some are not  however  flowers cannot be planted in adjacent plots - they would compete for water and both would die  given a flowerbed (represented as an array containing 0 and 1  where 0 means empty and 1 means not empty)  and a number n  return if n new flowers can be planted in it without violating the no-adjacent-flowers rule  easy array 
java solution  tree traversal construct string from binary tree you need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way  the null node needs to be represented by empty parenthesis pair "()"  and you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree  easy string tree 
python  straightforward with explanation construct string from binary tree you need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way  the null node needs to be represented by empty parenthesis pair "()"  and you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree  easy string tree 
java simple recursion construct string from binary tree you need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way  the null node needs to be represented by empty parenthesis pair "()"  and you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree  easy string tree 
[java c++] 1 liner construct string from binary tree you need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way  the null node needs to be represented by empty parenthesis pair "()"  and you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree  easy string tree 
python simple solution construct string from binary tree you need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way  the null node needs to be represented by empty parenthesis pair "()"  and you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree  easy string tree 
c++ clean solution  answers to follow up find duplicate file in system given a list of directory info including directory path  and all the files with contents in this directory  you need to find out all the groups of duplicate files in the file system in terms of their paths  a group of duplicate files consists of at least two files that have exactly the same content  a single directory info string in the input list has the following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" it means there are n files (f1 txt  f2 txt     fn txt with content f1_content  f2_content     fn_content  respectively) in directory root d1 d2     dm  note that n >= 1 and m >= 0  if m = 0  it means the directory is just the root directory  the output is a list of group of duplicate file paths  for each group  it contains all the file paths of the files that have the same content  a file path is a string that has the following format: "directory_path file_name txt" medium hash table string 
python  straightforward with explanation find duplicate file in system given a list of directory info including directory path  and all the files with contents in this directory  you need to find out all the groups of duplicate files in the file system in terms of their paths  a group of duplicate files consists of at least two files that have exactly the same content  a single directory info string in the input list has the following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" it means there are n files (f1 txt  f2 txt     fn txt with content f1_content  f2_content     fn_content  respectively) in directory root d1 d2     dm  note that n >= 1 and m >= 0  if m = 0  it means the directory is just the root directory  the output is a list of group of duplicate file paths  for each group  it contains all the file paths of the files that have the same content  a file path is a string that has the following format: "directory_path file_name txt" medium hash table string 
java solution  hashmap find duplicate file in system given a list of directory info including directory path  and all the files with contents in this directory  you need to find out all the groups of duplicate files in the file system in terms of their paths  a group of duplicate files consists of at least two files that have exactly the same content  a single directory info string in the input list has the following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" it means there are n files (f1 txt  f2 txt     fn txt with content f1_content  f2_content     fn_content  respectively) in directory root d1 d2     dm  note that n >= 1 and m >= 0  if m = 0  it means the directory is just the root directory  the output is a list of group of duplicate file paths  for each group  it contains all the file paths of the files that have the same content  a file path is a string that has the following format: "directory_path file_name txt" medium hash table string 
straight forward solution with a tiny bit of java8 find duplicate file in system given a list of directory info including directory path  and all the files with contents in this directory  you need to find out all the groups of duplicate files in the file system in terms of their paths  a group of duplicate files consists of at least two files that have exactly the same content  a single directory info string in the input list has the following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" it means there are n files (f1 txt  f2 txt     fn txt with content f1_content  f2_content     fn_content  respectively) in directory root d1 d2     dm  note that n >= 1 and m >= 0  if m = 0  it means the directory is just the root directory  the output is a list of group of duplicate file paths  for each group  it contains all the file paths of the files that have the same content  a file path is a string that has the following format: "directory_path file_name txt" medium hash table string 
follow up questions discussion find duplicate file in system given a list of directory info including directory path  and all the files with contents in this directory  you need to find out all the groups of duplicate files in the file system in terms of their paths  a group of duplicate files consists of at least two files that have exactly the same content  a single directory info string in the input list has the following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" it means there are n files (f1 txt  f2 txt     fn txt with content f1_content  f2_content     fn_content  respectively) in directory root d1 d2     dm  note that n >= 1 and m >= 0  if m = 0  it means the directory is just the root directory  the output is a list of group of duplicate file paths  for each group  it contains all the file paths of the files that have the same content  a file path is a string that has the following format: "directory_path file_name txt" medium hash table string 
java o(n^2) time o(1) space valid triangle number given an array consists of non-negative integers  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle  medium array 
java solution  3 pointers valid triangle number given an array consists of non-negative integers  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle  medium array 
o(n^2) solution for c++ & python valid triangle number given an array consists of non-negative integers  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle  medium array 
a similar o(n^2) solution to 3-sum  valid triangle number given an array consists of non-negative integers  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle  medium array 
can this problem  possibly be solved by python? valid triangle number given an array consists of non-negative integers  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle  medium array 
python  straightforward with explanation merge two binary trees given two binary trees and imagine that when you put one of them to cover the other  some nodes of the two trees are overlapped while the others are not  you need to merge them into a new binary tree  the merge rule is that if two nodes overlap  then sum node values up as the new value of the merged node  otherwise  the not null node will be used as the node of new tree  easy tree 
java solution  6 lines  tree traversal merge two binary trees given two binary trees and imagine that when you put one of them to cover the other  some nodes of the two trees are overlapped while the others are not  you need to merge them into a new binary tree  the merge rule is that if two nodes overlap  then sum node values up as the new value of the merged node  otherwise  the not null node will be used as the node of new tree  easy tree 
short recursive solution w  python & c++ merge two binary trees given two binary trees and imagine that when you put one of them to cover the other  some nodes of the two trees are overlapped while the others are not  you need to merge them into a new binary tree  the merge rule is that if two nodes overlap  then sum node values up as the new value of the merged node  otherwise  the not null node will be used as the node of new tree  easy tree 
[java c++] clean code - unique node | shared node - 5 liner merge two binary trees given two binary trees and imagine that when you put one of them to cover the other  some nodes of the two trees are overlapped while the others are not  you need to merge them into a new binary tree  the merge rule is that if two nodes overlap  then sum node values up as the new value of the merged node  otherwise  the not null node will be used as the node of new tree  easy tree 
java one recursive solution and two iterative solutions (dfs and bfs) with explanations merge two binary trees given two binary trees and imagine that when you put one of them to cover the other  some nodes of the two trees are overlapped while the others are not  you need to merge them into a new binary tree  the merge rule is that if two nodes overlap  then sum node values up as the new value of the merged node  otherwise  the not null node will be used as the node of new tree  easy tree 
my solution not boring movies sql schemax city opened a new cinema  many people would like to go to this cinema  the cinema also gives out a poster indicating the movies’ ratings and descriptions  please write a sql query to output movies with an odd numbered id and a description that is not 'boring'  order the result by rating  for easy 
judge parity using '&' not boring movies sql schemax city opened a new cinema  many people would like to go to this cinema  the cinema also gives out a poster indicating the movies’ ratings and descriptions  please write a sql query to output movies with an odd numbered id and a description that is not 'boring'  order the result by rating  for easy 
my first post of sql questions! : ) not boring movies sql schemax city opened a new cinema  many people would like to go to this cinema  the cinema also gives out a poster indicating the movies’ ratings and descriptions  please write a sql query to output movies with an odd numbered id and a description that is not 'boring'  order the result by rating  for easy 
the problem description could be worded better not boring movies sql schemax city opened a new cinema  many people would like to go to this cinema  the cinema also gives out a poster indicating the movies’ ratings and descriptions  please write a sql query to output movies with an odd numbered id and a description that is not 'boring'  order the result by rating  for easy 
a slightly different way of solving this sql using case not boring movies sql schemax city opened a new cinema  many people would like to go to this cinema  the cinema also gives out a poster indicating the movies’ ratings and descriptions  please write a sql query to output movies with an odd numbered id and a description that is not 'boring'  order the result by rating  for easy 
concise java using array design circular queue design your implementation of the circular queue  the circular queue is a linear data structure in which the operations are performed based on fifo (first in first out) principle and the last position is connected back to the first position to make a circle  it is also called "ring buffer"  one of the benefits of the circular queue is that we can make use of the spaces in front of the queue  in a normal queue  once the queue becomes full  we cannot insert the next element even if there is a space in front of the queue  but using the circular queue  we can use the space to store new values  your implementation should support following operations: mycircularqueue(k): constructor  set the size of the queue to be k  front: get the front item from the queue  if the queue is empty  return -1  rear: get the last item from the queue  if the queue is empty  return -1  enqueue(value): insert an element into the circular queue  return true if the operation is successful  dequeue(): delete an element from the circular queue  return true if the operation is successful  isempty(): checks whether the circular queue is empty or not  isfull(): checks whether the circular queue is full or not  medium design queue 
python short & simple ac doubly linked list solution design circular queue design your implementation of the circular queue  the circular queue is a linear data structure in which the operations are performed based on fifo (first in first out) principle and the last position is connected back to the first position to make a circle  it is also called "ring buffer"  one of the benefits of the circular queue is that we can make use of the spaces in front of the queue  in a normal queue  once the queue becomes full  we cannot insert the next element even if there is a space in front of the queue  but using the circular queue  we can use the space to store new values  your implementation should support following operations: mycircularqueue(k): constructor  set the size of the queue to be k  front: get the front item from the queue  if the queue is empty  return -1  rear: get the last item from the queue  if the queue is empty  return -1  enqueue(value): insert an element into the circular queue  return true if the operation is successful  dequeue(): delete an element from the circular queue  return true if the operation is successful  isempty(): checks whether the circular queue is empty or not  isfull(): checks whether the circular queue is full or not  medium design queue 
straightforward implementation in c++ [20ms] design circular queue design your implementation of the circular queue  the circular queue is a linear data structure in which the operations are performed based on fifo (first in first out) principle and the last position is connected back to the first position to make a circle  it is also called "ring buffer"  one of the benefits of the circular queue is that we can make use of the spaces in front of the queue  in a normal queue  once the queue becomes full  we cannot insert the next element even if there is a space in front of the queue  but using the circular queue  we can use the space to store new values  your implementation should support following operations: mycircularqueue(k): constructor  set the size of the queue to be k  front: get the front item from the queue  if the queue is empty  return -1  rear: get the last item from the queue  if the queue is empty  return -1  enqueue(value): insert an element into the circular queue  return true if the operation is successful  dequeue(): delete an element from the circular queue  return true if the operation is successful  isempty(): checks whether the circular queue is empty or not  isfull(): checks whether the circular queue is full or not  medium design queue 
java solution with explanation design circular queue design your implementation of the circular queue  the circular queue is a linear data structure in which the operations are performed based on fifo (first in first out) principle and the last position is connected back to the first position to make a circle  it is also called "ring buffer"  one of the benefits of the circular queue is that we can make use of the spaces in front of the queue  in a normal queue  once the queue becomes full  we cannot insert the next element even if there is a space in front of the queue  but using the circular queue  we can use the space to store new values  your implementation should support following operations: mycircularqueue(k): constructor  set the size of the queue to be k  front: get the front item from the queue  if the queue is empty  return -1  rear: get the last item from the queue  if the queue is empty  return -1  enqueue(value): insert an element into the circular queue  return true if the operation is successful  dequeue(): delete an element from the circular queue  return true if the operation is successful  isempty(): checks whether the circular queue is empty or not  isfull(): checks whether the circular queue is full or not  medium design queue 
simple java solution using doubly linked list design circular queue design your implementation of the circular queue  the circular queue is a linear data structure in which the operations are performed based on fifo (first in first out) principle and the last position is connected back to the first position to make a circle  it is also called "ring buffer"  one of the benefits of the circular queue is that we can make use of the spaces in front of the queue  in a normal queue  once the queue becomes full  we cannot insert the next element even if there is a space in front of the queue  but using the circular queue  we can use the space to store new values  your implementation should support following operations: mycircularqueue(k): constructor  set the size of the queue to be k  front: get the front item from the queue  if the queue is empty  return -1  rear: get the last item from the queue  if the queue is empty  return -1  enqueue(value): insert an element into the circular queue  return true if the operation is successful  dequeue(): delete an element from the circular queue  return true if the operation is successful  isempty(): checks whether the circular queue is empty or not  isfull(): checks whether the circular queue is full or not  medium design queue 
[c++] [java] 10 line solution - no helper add one row to tree given the root of a binary tree  then value v and depth d  you need to add a row of nodes with value v at the given depth d  the root node is at depth 1  the adding rule is: given a positive integer depth d  for each not null tree nodes n in depth d-1  create two tree nodes with value v as n's left subtree root and right subtree root  and n's original left subtree should be the left subtree of the new left subtree root  its original right subtree should be the right subtree of the new right subtree root  if depth d is 1 that means there is no depth d-1 at all  then create a tree node with value v as the new root of the whole original tree  and the original tree is the new root's left subtree  medium tree 
java  three methods  one bfs and two dfs add one row to tree given the root of a binary tree  then value v and depth d  you need to add a row of nodes with value v at the given depth d  the root node is at depth 1  the adding rule is: given a positive integer depth d  for each not null tree nodes n in depth d-1  create two tree nodes with value v as n's left subtree root and right subtree root  and n's original left subtree should be the left subtree of the new left subtree root  its original right subtree should be the right subtree of the new right subtree root  if depth d is 1 that means there is no depth d-1 at all  then create a tree node with value v as the new root of the whole original tree  and the original tree is the new root's left subtree  medium tree 
short python bfs add one row to tree given the root of a binary tree  then value v and depth d  you need to add a row of nodes with value v at the given depth d  the root node is at depth 1  the adding rule is: given a positive integer depth d  for each not null tree nodes n in depth d-1  create two tree nodes with value v as n's left subtree root and right subtree root  and n's original left subtree should be the left subtree of the new left subtree root  its original right subtree should be the right subtree of the new right subtree root  if depth d is 1 that means there is no depth d-1 at all  then create a tree node with value v as the new root of the whole original tree  and the original tree is the new root's left subtree  medium tree 
simple java solution - o(n) add one row to tree given the root of a binary tree  then value v and depth d  you need to add a row of nodes with value v at the given depth d  the root node is at depth 1  the adding rule is: given a positive integer depth d  for each not null tree nodes n in depth d-1  create two tree nodes with value v as n's left subtree root and right subtree root  and n's original left subtree should be the left subtree of the new left subtree root  its original right subtree should be the right subtree of the new right subtree root  if depth d is 1 that means there is no depth d-1 at all  then create a tree node with value v as the new root of the whole original tree  and the original tree is the new root's left subtree  medium tree 
simple c++ solution add one row to tree given the root of a binary tree  then value v and depth d  you need to add a row of nodes with value v at the given depth d  the root node is at depth 1  the adding rule is: given a positive integer depth d  for each not null tree nodes n in depth d-1  create two tree nodes with value v as n's left subtree root and right subtree root  and n's original left subtree should be the left subtree of the new left subtree root  its original right subtree should be the right subtree of the new right subtree root  if depth d is 1 that means there is no depth d-1 at all  then create a tree node with value v as the new root of the whole original tree  and the original tree is the new root's left subtree  medium tree 
4 line solution using if statement exchange seats sql schemamary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids  the column id is continuous increment  mary wants to change seats for the adjacent students  can you write a sql query to output the result for mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ for the sample input  the output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: if the number of students is odd  there is no need to change the last one's seat  medium 
using two union operators exchange seats sql schemamary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids  the column id is continuous increment  mary wants to change seats for the adjacent students  can you write a sql query to output the result for mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ for the sample input  the output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: if the number of students is odd  there is no need to change the last one's seat  medium 
a solution without using union and order by exchange seats sql schemamary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids  the column id is continuous increment  mary wants to change seats for the adjacent students  can you write a sql query to output the result for mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ for the sample input  the output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: if the number of students is odd  there is no need to change the last one's seat  medium 
simple case solution exchange seats sql schemamary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids  the column id is continuous increment  mary wants to change seats for the adjacent students  can you write a sql query to output the result for mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ for the sample input  the output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: if the number of students is odd  there is no need to change the last one's seat  medium 
a simple solution exchange seats sql schemamary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids  the column id is continuous increment  mary wants to change seats for the adjacent students  can you write a sql query to output the result for mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ for the sample input  the output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: if the number of students is odd  there is no need to change the last one's seat  medium 
accept solution with xor swap salary sql schemagiven a table salary  such as the one below  that has m=male and f=female values  swap all f and m values (i e   change all f values to m and vice versa) with a single update query and no intermediate temp table  for easy 
short and simple swap salary sql schemagiven a table salary  such as the one below  that has m=male and f=female values  swap all f and m values (i e   change all f values to m and vice versa) with a single update query and no intermediate temp table  for easy 
simple and short with if swap salary sql schemagiven a table salary  such as the one below  that has m=male and f=female values  swap all f and m values (i e   change all f values to m and vice versa) with a single update query and no intermediate temp table  for easy 
solution using ascii code swap salary sql schemagiven a table salary  such as the one below  that has m=male and f=female values  swap all f and m values (i e   change all f values to m and vice versa) with a single update query and no intermediate temp table  for easy 
the solution with multiplication and division of ascii codes swap salary sql schemagiven a table salary  such as the one below  that has m=male and f=female values  swap all f and m values (i e   change all f values to m and vice versa) with a single update query and no intermediate temp table  for easy 
java o(1) space o(n) time solution beat 100% maximum product of three numbers given an integer array  find three numbers whose product is maximum and output the maximum product  easy array math 
java easy ac    maximum product of three numbers given an integer array  find three numbers whose product is maximum and output the maximum product  easy array math 
python concise solution  o(n) and 1 line maximum product of three numbers given an integer array  find three numbers whose product is maximum and output the maximum product  easy array math 
share my python solution: one pass  o(n) time o(1) space maximum product of three numbers given an integer array  find three numbers whose product is maximum and output the maximum product  easy array math 
general solution for any k  maximum product of three numbers given an integer array  find three numbers whose product is maximum and output the maximum product  easy array math 
java dp o(nk) solution k inverse pairs array given two integers n and k  find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs  we define an inverse pair as following: for ith and jth element in the array  if i < j and a[i] > a[j] then it's an inverse pair; otherwise  it's not  since the answer may be very large  the answer should be modulo 109 + 7  hard dynamic programming 
shared my c++ o(n   k) solution with explanation k inverse pairs array given two integers n and k  find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs  we define an inverse pair as following: for ith and jth element in the array  if i < j and a[i] > a[j] then it's an inverse pair; otherwise  it's not  since the answer may be very large  the answer should be modulo 109 + 7  hard dynamic programming 
python  straightforward with explanation k inverse pairs array given two integers n and k  find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs  we define an inverse pair as following: for ith and jth element in the array  if i < j and a[i] > a[j] then it's an inverse pair; otherwise  it's not  since the answer may be very large  the answer should be modulo 109 + 7  hard dynamic programming 
python concise solution k inverse pairs array given two integers n and k  find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs  we define an inverse pair as following: for ith and jth element in the array  if i < j and a[i] > a[j] then it's an inverse pair; otherwise  it's not  since the answer may be very large  the answer should be modulo 109 + 7  hard dynamic programming 
java dp thank you so much @gardenaaa for your advice  k inverse pairs array given two integers n and k  find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs  we define an inverse pair as following: for ith and jth element in the array  if i < j and a[i] > a[j] then it's an inverse pair; otherwise  it's not  since the answer may be very large  the answer should be modulo 109 + 7  hard dynamic programming 
short java code using priorityqueue course schedule iii there are n different online courses numbered from 1 to n  each course has some duration(course length) t and closed on dth day  a course should be taken continuously for t days and must be finished before or on the dth day  you will start at the 1st day  given n online courses represented by pairs (t d)  your task is to find the maximal number of courses that can be taken  hard greedy 
python  straightforward with explanation course schedule iii there are n different online courses numbered from 1 to n  each course has some duration(course length) t and closed on dth day  a course should be taken continuously for t days and must be finished before or on the dth day  you will start at the 1st day  given n online courses represented by pairs (t d)  your task is to find the maximal number of courses that can be taken  hard greedy 
c++ 13 lines with explanation course schedule iii there are n different online courses numbered from 1 to n  each course has some duration(course length) t and closed on dth day  a course should be taken continuously for t days and must be finished before or on the dth day  you will start at the 1st day  given n online courses represented by pairs (t d)  your task is to find the maximal number of courses that can be taken  hard greedy 
c++ short & elegant o(nlogn) time  o(k) space solution course schedule iii there are n different online courses numbered from 1 to n  each course has some duration(course length) t and closed on dth day  a course should be taken continuously for t days and must be finished before or on the dth day  you will start at the 1st day  given n online courses represented by pairs (t d)  your task is to find the maximal number of courses that can be taken  hard greedy 
c++ short code using priority queue  o(nlogn) course schedule iii there are n different online courses numbered from 1 to n  each course has some duration(course length) t and closed on dth day  a course should be taken continuously for t days and must be finished before or on the dth day  you will start at the 1st day  given n online courses represented by pairs (t d)  your task is to find the maximal number of courses that can be taken  hard greedy 
java code using priorityqueue  similar to merge k array smallest range you have k lists of sorted integers in ascending order  find the smallest range that includes at least one number from each of the k lists  we define the range [a b] is smaller than range [c d] if b-a < d-c or a < c if b-a == d-c  hard hash table two pointers string 
python  heap-based solution smallest range you have k lists of sorted integers in ascending order  find the smallest range that includes at least one number from each of the k lists  we define the range [a b] is smaller than range [c d] if b-a < d-c or a < c if b-a == d-c  hard hash table two pointers string 
clean c++ priority_queue solution using iterators smallest range you have k lists of sorted integers in ascending order  find the smallest range that includes at least one number from each of the k lists  we define the range [a b] is smaller than range [c d] if b-a < d-c or a < c if b-a == d-c  hard hash table two pointers string 
java 8  sliding window smallest range you have k lists of sorted integers in ascending order  find the smallest range that includes at least one number from each of the k lists  we define the range [a b] is smaller than range [c d] if b-a < d-c or a < c if b-a == d-c  hard hash table two pointers string 
java solution with maxheap&minheap smallest range you have k lists of sorted integers in ascending order  find the smallest range that includes at least one number from each of the k lists  we define the range [a b] is smaller than range [c d] if b-a < d-c or a < c if b-a == d-c  hard hash table two pointers string 
java two pointers solution sum of square numbers given a non-negative integer c  your task is to decide whether there're two integers a and b such that a2 + b2 = c  easy math 
hashset  java  quick solution  one for loop sum of square numbers given a non-negative integer c  your task is to decide whether there're two integers a and b such that a2 + b2 = c  easy math 
python  straightforward with explanation sum of square numbers given a non-negative integer c  your task is to decide whether there're two integers a and b such that a2 + b2 = c  easy math 
fermat sum of square numbers given a non-negative integer c  your task is to decide whether there're two integers a and b such that a2 + b2 = c  easy math 
c++ very simple o(1) space solution sum of square numbers given a non-negative integer c  your task is to decide whether there're two integers a and b such that a2 + b2 = c  easy math 
java stack solution o(n) time o(n) space exclusive time of functions given the running logs of n functions that are executed in a nonpreemptive single threaded cpu  find the exclusive time of these functions  each function has a unique id  start from 0 to n-1  a function may be called recursively or by another function  a log is a string has this format : function_id:start_or_end:timestamp  for medium stack 
python  straightforward with explanation exclusive time of functions given the running logs of n functions that are executed in a nonpreemptive single threaded cpu  find the exclusive time of these functions  each function has a unique id  start from 0 to n-1  a function may be called recursively or by another function  a log is a string has this format : function_id:start_or_end:timestamp  for medium stack 
how is function 1 executing 4 units of time? exclusive time of functions given the running logs of n functions that are executed in a nonpreemptive single threaded cpu  find the exclusive time of these functions  each function has a unique id  start from 0 to n-1  a function may be called recursively or by another function  a log is a string has this format : function_id:start_or_end:timestamp  for medium stack 
c++ o(n) stack with explaination exclusive time of functions given the running logs of n functions that are executed in a nonpreemptive single threaded cpu  find the exclusive time of these functions  each function has a unique id  start from 0 to n-1  a function may be called recursively or by another function  a log is a string has this format : function_id:start_or_end:timestamp  for medium stack 
java clean solution with normalized time explained exclusive time of functions given the running logs of n functions that are executed in a nonpreemptive single threaded cpu  find the exclusive time of these functions  each function has a unique id  start from 0 to n-1  a function may be called recursively or by another function  a log is a string has this format : function_id:start_or_end:timestamp  for medium stack 
java bfs solution average of levels in binary tree given a non-empty binary tree  return the average value of the nodes on each level in the form of an array  easy tree 
a good problem to practice (bfs + dfs) average of levels in binary tree given a non-empty binary tree  return the average value of the nodes on each level in the form of an array  easy tree 
c++ simple and clear bfs solution average of levels in binary tree given a non-empty binary tree  return the average value of the nodes on each level in the form of an array  easy tree 
python  straightforward with explanation average of levels in binary tree given a non-empty binary tree  return the average value of the nodes on each level in the form of an array  easy tree 
"one-liner" average of levels in binary tree given a non-empty binary tree  return the average value of the nodes on each level in the form of an array  easy tree 
very easy to understand java solution beats 95% with explanation shopping offers in leetcode store  there are some kinds of items to sell  each item has a price  however  there are some special offers  and a special offer consists of one or more different kinds of items with a sale price  you are given the each item's price  a set of special offers  and the number we need to buy for each item  the job is to output the lowest price you have to pay for exactly certain items as given  where you could make optimal use of the special offers  each special offer is represented in the form of an array  the last number represents the price you need to pay for this special offer  other numbers represents how many specific items you could get if you buy this offer  you could use any of special offers as many times as you want  medium dynamic programming depth-first search 
concise c++ dfs solution  6ms shopping offers in leetcode store  there are some kinds of items to sell  each item has a price  however  there are some special offers  and a special offer consists of one or more different kinds of items with a sale price  you are given the each item's price  a set of special offers  and the number we need to buy for each item  the job is to output the lowest price you have to pay for exactly certain items as given  where you could make optimal use of the special offers  each special offer is represented in the form of an array  the last number represents the price you need to pay for this special offer  other numbers represents how many specific items you could get if you buy this offer  you could use any of special offers as many times as you want  medium dynamic programming depth-first search 
simple java recursive solution shopping offers in leetcode store  there are some kinds of items to sell  each item has a price  however  there are some special offers  and a special offer consists of one or more different kinds of items with a sale price  you are given the each item's price  a set of special offers  and the number we need to buy for each item  the job is to output the lowest price you have to pay for exactly certain items as given  where you could make optimal use of the special offers  each special offer is represented in the form of an array  the last number represents the price you need to pay for this special offer  other numbers represents how many specific items you could get if you buy this offer  you could use any of special offers as many times as you want  medium dynamic programming depth-first search 
java dfs + dp shopping offers in leetcode store  there are some kinds of items to sell  each item has a price  however  there are some special offers  and a special offer consists of one or more different kinds of items with a sale price  you are given the each item's price  a set of special offers  and the number we need to buy for each item  the job is to output the lowest price you have to pay for exactly certain items as given  where you could make optimal use of the special offers  each special offer is represented in the form of an array  the last number represents the price you need to pay for this special offer  other numbers represents how many specific items you could get if you buy this offer  you could use any of special offers as many times as you want  medium dynamic programming depth-first search 
python dfs with memorization  shopping offers in leetcode store  there are some kinds of items to sell  each item has a price  however  there are some special offers  and a special offer consists of one or more different kinds of items with a sale price  you are given the each item's price  a set of special offers  and the number we need to buy for each item  the job is to output the lowest price you have to pay for exactly certain items as given  where you could make optimal use of the special offers  each special offer is represented in the form of an array  the last number represents the price you need to pay for this special offer  other numbers represents how many specific items you could get if you buy this offer  you could use any of special offers as many times as you want  medium dynamic programming depth-first search 
java o(n) by general solution for all dp problems decode ways ii a message containing letters from a-z is being encoded to numbers using the following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  now the encoded string can also contain the character ' '  which can be treated as one of the numbers from 1 to 9  given the encoded message containing digits and the character ' '  return the total number of ways to decode it  also  since the answer may be very large  you should return the output mod 109 + 7  hard dynamic programming 
python  straightforward with explanation decode ways ii a message containing letters from a-z is being encoded to numbers using the following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  now the encoded string can also contain the character ' '  which can be treated as one of the numbers from 1 to 9  given the encoded message containing digits and the character ' '  return the total number of ways to decode it  also  since the answer may be very large  you should return the output mod 109 + 7  hard dynamic programming 
java dp  o(n) time and o(1) space decode ways ii a message containing letters from a-z is being encoded to numbers using the following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  now the encoded string can also contain the character ' '  which can be treated as one of the numbers from 1 to 9  given the encoded message containing digits and the character ' '  return the total number of ways to decode it  also  since the answer may be very large  you should return the output mod 109 + 7  hard dynamic programming 
c++  dp  o(n) time o(1) space decode ways ii a message containing letters from a-z is being encoded to numbers using the following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  now the encoded string can also contain the character ' '  which can be treated as one of the numbers from 1 to 9  given the encoded message containing digits and the character ' '  return the total number of ways to decode it  also  since the answer may be very large  you should return the output mod 109 + 7  hard dynamic programming 
python 6-lines dp solution decode ways ii a message containing letters from a-z is being encoded to numbers using the following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  now the encoded string can also contain the character ' '  which can be treated as one of the numbers from 1 to 9  given the encoded message containing digits and the character ' '  return the total number of ways to decode it  also  since the answer may be very large  you should return the output mod 109 + 7  hard dynamic programming 
concise java solution solve the equation solve a given equation and return the value of x in the form of string "x=#value"  the equation contains only '+'  '-' operation  the variable x and its coefficient  if there is no solution for the equation  return "no solution"  if there are infinite solutions for the equation  return "infinite solutions"  if there is exactly one solution for the equation  we ensure that the value of x is an integer  medium math 
simple 2-liner (and more) solve the equation solve a given equation and return the value of x in the form of string "x=#value"  the equation contains only '+'  '-' operation  the variable x and its coefficient  if there is no solution for the equation  return "no solution"  if there are infinite solutions for the equation  return "infinite solutions"  if there is exactly one solution for the equation  we ensure that the value of x is an integer  medium math 
c++  two pointers  concise solution solve the equation solve a given equation and return the value of x in the form of string "x=#value"  the equation contains only '+'  '-' operation  the variable x and its coefficient  if there is no solution for the equation  return "no solution"  if there are infinite solutions for the equation  return "infinite solutions"  if there is exactly one solution for the equation  we ensure that the value of x is an integer  medium math 
python regex solution explained solve the equation solve a given equation and return the value of x in the form of string "x=#value"  the equation contains only '+'  '-' operation  the variable x and its coefficient  if there is no solution for the equation  return "no solution"  if there are infinite solutions for the equation  return "infinite solutions"  if there is exactly one solution for the equation  we ensure that the value of x is an integer  medium math 
clear java code with detailed example solve the equation solve a given equation and return the value of x in the form of string "x=#value"  the equation contains only '+'  '-' operation  the variable x and its coefficient  if there is no solution for the equation  return "no solution"  if there are infinite solutions for the equation  return "infinite solutions"  if there is exactly one solution for the equation  we ensure that the value of x is an integer  medium math 
c++ 99% ring buffer no edge cases  fb interviewer really loves it  easy to impl in 4mins  cheers! design circular deque design your implementation of the circular double-ended queue (deque)  your implementation should support following operations: mycirculardeque(k): constructor  set the size of the deque to be k  insertfront(): adds an item at the front of deque  return true if the operation is successful  insertlast(): adds an item at the rear of deque  return true if the operation is successful  deletefront(): deletes an item from the front of deque  return true if the operation is successful  deletelast(): deletes an item from the rear of deque  return true if the operation is successful  getfront(): gets the front item from the deque  if the deque is empty  return -1  getrear(): gets the last item from deque  if the deque is empty  return -1  isempty(): checks whether deque is empty or not  isfull(): checks whether deque is full or not  medium design queue 
java doubly linkedlist  solution  very straightforward design circular deque design your implementation of the circular double-ended queue (deque)  your implementation should support following operations: mycirculardeque(k): constructor  set the size of the deque to be k  insertfront(): adds an item at the front of deque  return true if the operation is successful  insertlast(): adds an item at the rear of deque  return true if the operation is successful  deletefront(): deletes an item from the front of deque  return true if the operation is successful  deletelast(): deletes an item from the rear of deque  return true if the operation is successful  getfront(): gets the front item from the deque  if the deque is empty  return -1  getrear(): gets the last item from deque  if the deque is empty  return -1  isempty(): checks whether deque is empty or not  isfull(): checks whether deque is full or not  medium design queue 
is the example return value correct  and why circular? design circular deque design your implementation of the circular double-ended queue (deque)  your implementation should support following operations: mycirculardeque(k): constructor  set the size of the deque to be k  insertfront(): adds an item at the front of deque  return true if the operation is successful  insertlast(): adds an item at the rear of deque  return true if the operation is successful  deletefront(): deletes an item from the front of deque  return true if the operation is successful  deletelast(): deletes an item from the rear of deque  return true if the operation is successful  getfront(): gets the front item from the deque  if the deque is empty  return -1  getrear(): gets the last item from deque  if the deque is empty  return -1  isempty(): checks whether deque is empty or not  isfull(): checks whether deque is full or not  medium design queue 
straightforward w  array in java(corner cases) design circular deque design your implementation of the circular double-ended queue (deque)  your implementation should support following operations: mycirculardeque(k): constructor  set the size of the deque to be k  insertfront(): adds an item at the front of deque  return true if the operation is successful  insertlast(): adds an item at the rear of deque  return true if the operation is successful  deletefront(): deletes an item from the front of deque  return true if the operation is successful  deletelast(): deletes an item from the rear of deque  return true if the operation is successful  getfront(): gets the front item from the deque  if the deque is empty  return -1  getrear(): gets the last item from deque  if the deque is empty  return -1  isempty(): checks whether deque is empty or not  isfull(): checks whether deque is full or not  medium design queue 
python3  using list  easy to understand design circular deque design your implementation of the circular double-ended queue (deque)  your implementation should support following operations: mycirculardeque(k): constructor  set the size of the deque to be k  insertfront(): adds an item at the front of deque  return true if the operation is successful  insertlast(): adds an item at the rear of deque  return true if the operation is successful  deletefront(): deletes an item from the front of deque  return true if the operation is successful  deletelast(): deletes an item from the rear of deque  return true if the operation is successful  getfront(): gets the front item from the deque  if the deque is empty  return -1  getrear(): gets the last item from deque  if the deque is empty  return -1  isempty(): checks whether deque is empty or not  isfull(): checks whether deque is full or not  medium design queue 
java solution  sum of sliding window maximum average subarray i given an array consisting of n integers  find the contiguous subarray of given length k that has the maximum average value  and you need to output the maximum average value  easy array 
python  straightforward with explanation maximum average subarray i given an array consisting of n integers  find the contiguous subarray of given length k that has the maximum average value  and you need to output the maximum average value  easy array 
2 lines python  2 versions maximum average subarray i given an array consisting of n integers  find the contiguous subarray of given length k that has the maximum average value  and you need to output the maximum average value  easy array 
c++ simple sliding-window solution maximum average subarray i given an array consisting of n integers  find the contiguous subarray of given length k that has the maximum average value  and you need to output the maximum average value  easy array 
simple java solution - sliding window maximum average subarray i given an array consisting of n integers  find the contiguous subarray of given length k that has the maximum average value  and you need to output the maximum average value  easy array 
java o(n) time o(1) space set mismatch the set s originally contains numbers from 1 to n  but unfortunately  due to the data error  one of the numbers in the set got duplicated to another number in the set  which results in repetition of one number and loss of another number  given an array nums representing the data status of this set after the error  your task is to firstly find the number occurs twice and then find the number that is missing  return them in the form of an array  easy hash table math 
[c++] 6 lines solution with explanation set mismatch the set s originally contains numbers from 1 to n  but unfortunately  due to the data error  one of the numbers in the set got duplicated to another number in the set  which results in repetition of one number and loss of another number  given an array nums representing the data status of this set after the error  your task is to firstly find the number occurs twice and then find the number that is missing  return them in the form of an array  easy hash table math 
xor  one pass set mismatch the set s originally contains numbers from 1 to n  but unfortunately  due to the data error  one of the numbers in the set got duplicated to another number in the set  which results in repetition of one number and loss of another number  given an array nums representing the data status of this set after the error  your task is to firstly find the number occurs twice and then find the number that is missing  return them in the form of an array  easy hash table math 
python  straightforward with explanation set mismatch the set s originally contains numbers from 1 to n  but unfortunately  due to the data error  one of the numbers in the set got duplicated to another number in the set  which results in repetition of one number and loss of another number  given an array nums representing the data status of this set after the error  your task is to firstly find the number occurs twice and then find the number that is missing  return them in the form of an array  easy hash table math 
simple java o(n) solution - hashset set mismatch the set s originally contains numbers from 1 to n  but unfortunately  due to the data error  one of the numbers in the set got duplicated to another number in the set  which results in repetition of one number and loss of another number  given an array nums representing the data status of this set after the error  your task is to firstly find the number occurs twice and then find the number that is missing  return them in the form of an array  easy hash table math 
easy dp maximum length of pair chain you are given n pairs of numbers  in every pair  the first number is always smaller than the second number  now  we define a pair (c  d) can follow another pair (a  b) if and only if b < c  chain of pairs can be formed in this fashion  given a set of pairs  find the length longest chain which can be formed  you needn't use up all the given pairs  you can select pairs in any order  medium dynamic programming 
4-liner python greedy maximum length of pair chain you are given n pairs of numbers  in every pair  the first number is always smaller than the second number  now  we define a pair (c  d) can follow another pair (a  b) if and only if b < c  chain of pairs can be formed in this fashion  given a set of pairs  find the length longest chain which can be formed  you needn't use up all the given pairs  you can select pairs in any order  medium dynamic programming 
java o(nlog(n)) time o(1) space maximum length of pair chain you are given n pairs of numbers  in every pair  the first number is always smaller than the second number  now  we define a pair (c  d) can follow another pair (a  b) if and only if b < c  chain of pairs can be formed in this fashion  given a set of pairs  find the length longest chain which can be formed  you needn't use up all the given pairs  you can select pairs in any order  medium dynamic programming 
[c++] clean code maximum length of pair chain you are given n pairs of numbers  in every pair  the first number is always smaller than the second number  now  we define a pair (c  d) can follow another pair (a  b) if and only if b < c  chain of pairs can be formed in this fashion  given a set of pairs  find the length longest chain which can be formed  you needn't use up all the given pairs  you can select pairs in any order  medium dynamic programming 
[java] very simple without dp maximum length of pair chain you are given n pairs of numbers  in every pair  the first number is always smaller than the second number  now  we define a pair (c  d) can follow another pair (a  b) if and only if b < c  chain of pairs can be formed in this fashion  given a set of pairs  find the length longest chain which can be formed  you needn't use up all the given pairs  you can select pairs in any order  medium dynamic programming 
java solution  8 lines  extendpalindrome palindromic substrings given a string  your task is to count how many palindromic substrings in this string  the substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters  medium string dynamic programming 
very simple java solution with detail explanation palindromic substrings given a string  your task is to count how many palindromic substrings in this string  the substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters  medium string dynamic programming 
java dp solution based on longest palindromic substring palindromic substrings given a string  your task is to count how many palindromic substrings in this string  the substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters  medium string dynamic programming 
python  straightforward with explanation (bonus o(n) solution) palindromic substrings given a string  your task is to count how many palindromic substrings in this string  the substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters  medium string dynamic programming 
[java c++] 6 lines solution - no dp palindromic substrings given a string  your task is to count how many palindromic substrings in this string  the substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters  medium string dynamic programming 
java simple classical trie question solution (beat 96%) replace words in english  we have a concept called root  which can be followed by some other words to form another longer word - let's call this word successor  for medium hash table trie 
python  straightforward with explanation (prefix hash  trie solutions) replace words in english  we have a concept called root  which can be followed by some other words to form another longer word - let's call this word successor  for medium hash table trie 
java solution  12 lines  hashset replace words in english  we have a concept called root  which can be followed by some other words to form another longer word - let's call this word successor  for medium hash table trie 
simple java 8 and trie based solution replace words in english  we have a concept called root  which can be followed by some other words to form another longer word - let's call this word successor  for medium hash table trie 
easy python solution  6 lines replace words in english  we have a concept called root  which can be followed by some other words to form another longer word - let's call this word successor  for medium hash table trie 
[java c++] very simple greedy solution with explanation dota2 senate in the world of dota2  there are two parties: the radiant and the dire  the dota2 senate consists of senators coming from two parties  now the senate wants to make a decision about a change in the dota2 game  the voting for this change is a round-based procedure  in each round  each senator can exercise one of the two rights: ban one senator's right: a senator can make another senator lose all his rights in this and all the following rounds  announce the victory: if this senator found the senators who still have rights to vote are all from the same party  he can announce the victory and make the decision about the change in the game  given a string representing each senator's party belonging  the character 'r' and 'd' represent the radiant party and the dire party respectively  then if there are n senators  the size of the given string will be n  the round-based procedure starts from the first senator to the last senator in the given order  this procedure will last until the end of voting  all the senators who have lost their rights will be skipped during the procedure  suppose every senator is smart enough and will play the best strategy for his own party  you need to predict which party will finally announce the victory and make the change in the dota2 game  the output should be radiant or dire  medium greedy 
python  straightforward with explanation dota2 senate in the world of dota2  there are two parties: the radiant and the dire  the dota2 senate consists of senators coming from two parties  now the senate wants to make a decision about a change in the dota2 game  the voting for this change is a round-based procedure  in each round  each senator can exercise one of the two rights: ban one senator's right: a senator can make another senator lose all his rights in this and all the following rounds  announce the victory: if this senator found the senators who still have rights to vote are all from the same party  he can announce the victory and make the decision about the change in the game  given a string representing each senator's party belonging  the character 'r' and 'd' represent the radiant party and the dire party respectively  then if there are n senators  the size of the given string will be n  the round-based procedure starts from the first senator to the last senator in the given order  this procedure will last until the end of voting  all the senators who have lost their rights will be skipped during the procedure  suppose every senator is smart enough and will play the best strategy for his own party  you need to predict which party will finally announce the victory and make the change in the dota2 game  the output should be radiant or dire  medium greedy 
java solution  greedy dota2 senate in the world of dota2  there are two parties: the radiant and the dire  the dota2 senate consists of senators coming from two parties  now the senate wants to make a decision about a change in the dota2 game  the voting for this change is a round-based procedure  in each round  each senator can exercise one of the two rights: ban one senator's right: a senator can make another senator lose all his rights in this and all the following rounds  announce the victory: if this senator found the senators who still have rights to vote are all from the same party  he can announce the victory and make the decision about the change in the game  given a string representing each senator's party belonging  the character 'r' and 'd' represent the radiant party and the dire party respectively  then if there are n senators  the size of the given string will be n  the round-based procedure starts from the first senator to the last senator in the given order  this procedure will last until the end of voting  all the senators who have lost their rights will be skipped during the procedure  suppose every senator is smart enough and will play the best strategy for his own party  you need to predict which party will finally announce the victory and make the change in the dota2 game  the output should be radiant or dire  medium greedy 
c++  o(n) solution dota2 senate in the world of dota2  there are two parties: the radiant and the dire  the dota2 senate consists of senators coming from two parties  now the senate wants to make a decision about a change in the dota2 game  the voting for this change is a round-based procedure  in each round  each senator can exercise one of the two rights: ban one senator's right: a senator can make another senator lose all his rights in this and all the following rounds  announce the victory: if this senator found the senators who still have rights to vote are all from the same party  he can announce the victory and make the decision about the change in the game  given a string representing each senator's party belonging  the character 'r' and 'd' represent the radiant party and the dire party respectively  then if there are n senators  the size of the given string will be n  the round-based procedure starts from the first senator to the last senator in the given order  this procedure will last until the end of voting  all the senators who have lost their rights will be skipped during the procedure  suppose every senator is smart enough and will play the best strategy for his own party  you need to predict which party will finally announce the victory and make the change in the dota2 game  the output should be radiant or dire  medium greedy 
confusion about the logic dota2 senate in the world of dota2  there are two parties: the radiant and the dire  the dota2 senate consists of senators coming from two parties  now the senate wants to make a decision about a change in the dota2 game  the voting for this change is a round-based procedure  in each round  each senator can exercise one of the two rights: ban one senator's right: a senator can make another senator lose all his rights in this and all the following rounds  announce the victory: if this senator found the senators who still have rights to vote are all from the same party  he can announce the victory and make the decision about the change in the game  given a string representing each senator's party belonging  the character 'r' and 'd' represent the radiant party and the dire party respectively  then if there are n senators  the size of the given string will be n  the round-based procedure starts from the first senator to the last senator in the given order  this procedure will last until the end of voting  all the senators who have lost their rights will be skipped during the procedure  suppose every senator is smart enough and will play the best strategy for his own party  you need to predict which party will finally announce the victory and make the change in the dota2 game  the output should be radiant or dire  medium greedy 
java dp solution 2 keys keyboard initially on a notepad only one character 'a' is present  you can perform two operations on this notepad for each step: copy all: you can copy all the characters present on the notepad (partial copy is not allowed)  paste: you can paste the characters which are copied last time  given a number n  you have to get exactly n 'a' on the notepad by performing the minimum number of steps permitted  output the minimum number of steps to get n 'a'  medium dynamic programming 
loop best case log(n)  no dp  no extra space  no recursion  with explanation 2 keys keyboard initially on a notepad only one character 'a' is present  you can perform two operations on this notepad for each step: copy all: you can copy all the characters present on the notepad (partial copy is not allowed)  paste: you can paste the characters which are copied last time  given a number n  you have to get exactly n 'a' on the notepad by performing the minimum number of steps permitted  output the minimum number of steps to get n 'a'  medium dynamic programming 
very simple java solution with detail explanation 2 keys keyboard initially on a notepad only one character 'a' is present  you can perform two operations on this notepad for each step: copy all: you can copy all the characters present on the notepad (partial copy is not allowed)  paste: you can paste the characters which are copied last time  given a number n  you have to get exactly n 'a' on the notepad by performing the minimum number of steps permitted  output the minimum number of steps to get n 'a'  medium dynamic programming 
[java c++] clean code with explanation - 4 lines  no dp 2 keys keyboard initially on a notepad only one character 'a' is present  you can perform two operations on this notepad for each step: copy all: you can copy all the characters present on the notepad (partial copy is not allowed)  paste: you can paste the characters which are copied last time  given a number n  you have to get exactly n 'a' on the notepad by performing the minimum number of steps permitted  output the minimum number of steps to get n 'a'  medium dynamic programming 
java solutions from naive-dp to optimized-dp to non-dp 2 keys keyboard initially on a notepad only one character 'a' is present  you can perform two operations on this notepad for each step: copy all: you can copy all the characters present on the notepad (partial copy is not allowed)  paste: you can paste the characters which are copied last time  given a number n  you have to get exactly n 'a' on the notepad by performing the minimum number of steps permitted  output the minimum number of steps to get n 'a'  medium dynamic programming 
java concise postorder traversal solution find duplicate subtrees given a binary tree  return all duplicate subtrees  for each kind of duplicate subtrees  you only need to return the root node of any one of them  two trees are duplicate if they have the same structure with same node values  medium tree 
o(n) time and space  lots of analysis find duplicate subtrees given a binary tree  return all duplicate subtrees  for each kind of duplicate subtrees  you only need to return the root node of any one of them  two trees are duplicate if they have the same structure with same node values  medium tree 
[c++] [java] clean code find duplicate subtrees given a binary tree  return all duplicate subtrees  for each kind of duplicate subtrees  you only need to return the root node of any one of them  two trees are duplicate if they have the same structure with same node values  medium tree 
python easy understand solution find duplicate subtrees given a binary tree  return all duplicate subtrees  for each kind of duplicate subtrees  you only need to return the root node of any one of them  two trees are duplicate if they have the same structure with same node values  medium tree 
verbose java solution  tree traversal find duplicate subtrees given a binary tree  return all duplicate subtrees  for each kind of duplicate subtrees  you only need to return the root node of any one of them  two trees are duplicate if they have the same structure with same node values  medium tree 
[java c++] three simple methods - choose one you like two sum iv - input is a bst given a binary search tree and a target number  return true if there exist two elements in the bst such that their sum is equal to the given target  easy tree 
[c++] clean code - o(n) time o(lg n) space - binarytree iterator two sum iv - input is a bst given a binary search tree and a target number  return true if there exist two elements in the bst such that their sum is equal to the given target  easy tree 
java simple ac with time o(n) space o(log n) in average two sum iv - input is a bst given a binary search tree and a target number  return true if there exist two elements in the bst such that their sum is equal to the given target  easy tree 
c++ python straight forward solution two sum iv - input is a bst given a binary search tree and a target number  return true if there exist two elements in the bst such that their sum is equal to the given target  easy tree 
java code - o(n) time   o(lg(n)) space using dfs + stack two sum iv - input is a bst given a binary search tree and a target number  return true if there exist two elements in the bst such that their sum is equal to the given target  easy tree 
c++ o(n) solution maximum binary tree given an integer array with no duplicates  a maximum tree building on this array is defined as follow: the root is the maximum number in the array  the left subtree is the maximum tree constructed from left part subarray divided by the maximum number  the right subtree is the maximum tree constructed from right part subarray divided by the maximum number  construct the maximum tree by the given array and output the root node of this tree  medium tree 
java worst case o(n) solution maximum binary tree given an integer array with no duplicates  a maximum tree building on this array is defined as follow: the root is the maximum number in the array  the left subtree is the maximum tree constructed from left part subarray divided by the maximum number  the right subtree is the maximum tree constructed from right part subarray divided by the maximum number  construct the maximum tree by the given array and output the root node of this tree  medium tree 
java solution  recursion maximum binary tree given an integer array with no duplicates  a maximum tree building on this array is defined as follow: the root is the maximum number in the array  the left subtree is the maximum tree constructed from left part subarray divided by the maximum number  the right subtree is the maximum tree constructed from right part subarray divided by the maximum number  construct the maximum tree by the given array and output the root node of this tree  medium tree 
c++ 9 lines o(n log n) map  plus stack with binary search maximum binary tree given an integer array with no duplicates  a maximum tree building on this array is defined as follow: the root is the maximum number in the array  the left subtree is the maximum tree constructed from left part subarray divided by the maximum number  the right subtree is the maximum tree constructed from right part subarray divided by the maximum number  construct the maximum tree by the given array and output the root node of this tree  medium tree 
poor quality question maximum binary tree given an integer array with no duplicates  a maximum tree building on this array is defined as follow: the root is the maximum number in the array  the left subtree is the maximum tree constructed from left part subarray divided by the maximum number  the right subtree is the maximum tree constructed from right part subarray divided by the maximum number  construct the maximum tree by the given array and output the root node of this tree  medium tree 
python one liner robot return to origin there is a robot starting at position (0  0)  the origin  on a 2d plane  given a sequence of its moves  judge if this robot ends up at (0  0) after it completes its moves  the move sequence is represented by a string  and the character moves[i] represents its ith move  valid moves are r (right)  l (left)  u (up)  and d (down)  if the robot returns to the origin after it finishes all of its moves  return true  otherwise  return false  note: the way that the robot is "facing" is irrelevant  "r" will always make the robot move to the right once  "l" will always make it move left  etc  also  assume that the magnitude of the robot's movement is the same for each move  easy string 
[c++] [java] clean code robot return to origin there is a robot starting at position (0  0)  the origin  on a 2d plane  given a sequence of its moves  judge if this robot ends up at (0  0) after it completes its moves  the move sequence is represented by a string  and the character moves[i] represents its ith move  valid moves are r (right)  l (left)  u (up)  and d (down)  if the robot returns to the origin after it finishes all of its moves  return true  otherwise  return false  note: the way that the robot is "facing" is irrelevant  "r" will always make the robot move to the right once  "l" will always make it move left  etc  also  assume that the magnitude of the robot's movement is the same for each move  easy string 
if you can't describe the problem in a right way  please don't make it a problem  robot return to origin there is a robot starting at position (0  0)  the origin  on a 2d plane  given a sequence of its moves  judge if this robot ends up at (0  0) after it completes its moves  the move sequence is represented by a string  and the character moves[i] represents its ith move  valid moves are r (right)  l (left)  u (up)  and d (down)  if the robot returns to the origin after it finishes all of its moves  return true  otherwise  return false  note: the way that the robot is "facing" is irrelevant  "r" will always make the robot move to the right once  "l" will always make it move left  etc  also  assume that the magnitude of the robot's movement is the same for each move  easy string 
2 lines python robot return to origin there is a robot starting at position (0  0)  the origin  on a 2d plane  given a sequence of its moves  judge if this robot ends up at (0  0) after it completes its moves  the move sequence is represented by a string  and the character moves[i] represents its ith move  valid moves are r (right)  l (left)  u (up)  and d (down)  if the robot returns to the origin after it finishes all of its moves  return true  otherwise  return false  note: the way that the robot is "facing" is irrelevant  "r" will always make the robot move to the right once  "l" will always make it move left  etc  also  assume that the magnitude of the robot's movement is the same for each move  easy string 
easy 2 lines java robot return to origin there is a robot starting at position (0  0)  the origin  on a 2d plane  given a sequence of its moves  judge if this robot ends up at (0  0) after it completes its moves  the move sequence is represented by a string  and the character moves[i] represents its ith move  valid moves are r (right)  l (left)  u (up)  and d (down)  if the robot returns to the origin after it finishes all of its moves  return true  otherwise  return false  note: the way that the robot is "facing" is irrelevant  "r" will always make the robot move to the right once  "l" will always make it move left  etc  also  assume that the magnitude of the robot's movement is the same for each move  easy string 
java o(n) time o(n) space split array into consecutive subsequences you are given an integer array sorted in ascending order (may contain duplicates)  you need to split them into several subsequences  where each subsequences consist of at least 3 consecutive integers  return whether you can make such a split  medium heap greedy 
java o(n) time & o(1) space solution -- greedily extending shorter subsequence split array into consecutive subsequences you are given an integer array sorted in ascending order (may contain duplicates)  you need to split them into several subsequences  where each subsequences consist of at least 3 consecutive integers  return whether you can make such a split  medium heap greedy 
c++ o(n) solution  two pass split array into consecutive subsequences you are given an integer array sorted in ascending order (may contain duplicates)  you need to split them into several subsequences  where each subsequences consist of at least 3 consecutive integers  return whether you can make such a split  medium heap greedy 
python esay understand solution split array into consecutive subsequences you are given an integer array sorted in ascending order (may contain duplicates)  you need to split them into several subsequences  where each subsequences consist of at least 3 consecutive integers  return whether you can make such a split  medium heap greedy 
simple c++ greedy o(nlogn) solution (with explanation) split array into consecutive subsequences you are given an integer array sorted in ascending order (may contain duplicates)  you need to split them into several subsequences  where each subsequences consist of at least 3 consecutive integers  return whether you can make such a split  medium heap greedy 
c++ o(1) space using "game of life" idea image smoother given a 2d integer matrix m representing the gray scale of an image  you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself  if a cell has less than 8 surrounding cells  then use as many as you can  easy array 
very clean solution in java image smoother given a 2d integer matrix m representing the gray scale of an image  you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself  if a cell has less than 8 surrounding cells  then use as many as you can  easy array 
straightforward python solution image smoother given a 2d integer matrix m representing the gray scale of an image  you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself  if a cell has less than 8 surrounding cells  then use as many as you can  easy array 
don't understand the question and sample output image smoother given a 2d integer matrix m representing the gray scale of an image  you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself  if a cell has less than 8 surrounding cells  then use as many as you can  easy array 
python o(m n) image smoother given a 2d integer matrix m representing the gray scale of an image  you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself  if a cell has less than 8 surrounding cells  then use as many as you can  easy array 
[java c++] very simple dfs solution maximum width of binary tree given a binary tree  write a function to get the maximum width of the given tree  the width of a tree is the maximum width among all levels  the binary tree has the same structure as a full binary tree  but some nodes are null  the width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level  where the null nodes between the end-nodes are also counted into the length calculation  medium tree 
[c++ java]   [bfs dfs 3liner] clean code  with explanation maximum width of binary tree given a binary tree  write a function to get the maximum width of the given tree  the width of a tree is the maximum width among all levels  the binary tree has the same structure as a full binary tree  but some nodes are null  the width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level  where the null nodes between the end-nodes are also counted into the length calculation  medium tree 
java one queue solution with hashmap maximum width of binary tree given a binary tree  write a function to get the maximum width of the given tree  the width of a tree is the maximum width among all levels  the binary tree has the same structure as a full binary tree  but some nodes are null  the width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level  where the null nodes between the end-nodes are also counted into the length calculation  medium tree 
java uff0clevel traversal using two queue maximum width of binary tree given a binary tree  write a function to get the maximum width of the given tree  the width of a tree is the maximum width among all levels  the binary tree has the same structure as a full binary tree  but some nodes are null  the width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level  where the null nodes between the end-nodes are also counted into the length calculation  medium tree 
python  straightforward bfs and dfs solutions maximum width of binary tree given a binary tree  write a function to get the maximum width of the given tree  the width of a tree is the maximum width among all levels  the binary tree has the same structure as a full binary tree  but some nodes are null  the width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level  where the null nodes between the end-nodes are also counted into the length calculation  medium tree 
java o(n^3) dp solution with explanation and simple optimization strange printer there is a strange printer with the following two special requirements: the printer can only print a sequence of the same character each time  at each turn  the printer can print new characters starting from and ending at any places  and will cover the original existing characters  given a string consists of lower english letters only  your job is to count the minimum number of turns the printer needed in order to print it  hard dynamic programming depth-first search 
java solution  dp strange printer there is a strange printer with the following two special requirements: the printer can only print a sequence of the same character each time  at each turn  the printer can print new characters starting from and ending at any places  and will cover the original existing characters  given a string consists of lower english letters only  your job is to count the minimum number of turns the printer needed in order to print it  hard dynamic programming depth-first search 
python  straightforward dp with explanation strange printer there is a strange printer with the following two special requirements: the printer can only print a sequence of the same character each time  at each turn  the printer can print new characters starting from and ending at any places  and will cover the original existing characters  given a string consists of lower english letters only  your job is to count the minimum number of turns the printer needed in order to print it  hard dynamic programming depth-first search 
java o(n^3) short dp solution strange printer there is a strange printer with the following two special requirements: the printer can only print a sequence of the same character each time  at each turn  the printer can print new characters starting from and ending at any places  and will cover the original existing characters  given a string consists of lower english letters only  your job is to count the minimum number of turns the printer needed in order to print it  hard dynamic programming depth-first search 
same as remove boxes strange printer there is a strange printer with the following two special requirements: the printer can only print a sequence of the same character each time  at each turn  the printer can print new characters starting from and ending at any places  and will cover the original existing characters  given a string consists of lower english letters only  your job is to count the minimum number of turns the printer needed in order to print it  hard dynamic programming depth-first search 
[java c++] simple greedy like solution with explanation non-decreasing array given an array with n integers  your task is to check if it could become non-decreasing by modifying at most 1 element  we define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n)  easy array 
python extremely easy to understand non-decreasing array given an array with n integers  your task is to check if it could become non-decreasing by modifying at most 1 element  we define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n)  easy array 
[c++] [java] clean code - 6 liner without modifying input non-decreasing array given an array with n integers  your task is to check if it could become non-decreasing by modifying at most 1 element  we define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n)  easy array 
the easiest python solution     non-decreasing array given an array with n integers  your task is to check if it could become non-decreasing by modifying at most 1 element  we define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n)  easy array 
java solution  7 liner  non-decreasing array given an array with n integers  your task is to check if it could become non-decreasing by modifying at most 1 element  we define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n)  easy array 
[c++] [java] clean code 4-liner beautiful arrangement ii given two integers n and k  you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: suppose this list is [a1  a2  a3        an]  then the list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] has exactly k distinct integers  if there are multiple answers  print any of them  medium array 
python  straightforward with explanation beautiful arrangement ii given two integers n and k  you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: suppose this list is [a1  a2  a3        an]  then the list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] has exactly k distinct integers  if there are multiple answers  print any of them  medium array 
java  easy to understand with explanation beautiful arrangement ii given two integers n and k  you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: suppose this list is [a1  a2  a3        an]  then the list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] has exactly k distinct integers  if there are multiple answers  print any of them  medium array 
c++  concise code  o(n) beautiful arrangement ii given two integers n and k  you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: suppose this list is [a1  a2  a3        an]  then the list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] has exactly k distinct integers  if there are multiple answers  print any of them  medium array 
short+simple with explanation beautiful arrangement ii given two integers n and k  you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: suppose this list is [a1  a2  a3        an]  then the list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] has exactly k distinct integers  if there are multiple answers  print any of them  medium array 
java solution  binary search kth smallest number in multiplication table nearly every one have used the multiplication table  but could you find out the k-th smallest number quickly from the multiplication table? given the height m and the length n of a m   n multiplication table  and a positive integer k  you need to return the k-th smallest number in this table  hard binary search 
this name is very miss leading kth smallest number in multiplication table nearly every one have used the multiplication table  but could you find out the k-th smallest number quickly from the multiplication table? given the height m and the length n of a m   n multiplication table  and a positive integer k  you need to return the k-th smallest number in this table  hard binary search 
python  straightforward with explanation kth smallest number in multiplication table nearly every one have used the multiplication table  but could you find out the k-th smallest number quickly from the multiplication table? given the height m and the length n of a m   n multiplication table  and a positive integer k  you need to return the k-th smallest number in this table  hard binary search 
this problem is found on another online judge kth smallest number in multiplication table nearly every one have used the multiplication table  but could you find out the k-th smallest number quickly from the multiplication table? given the height m and the length n of a m   n multiplication table  and a positive integer k  you need to return the k-th smallest number in this table  hard binary search 
solution like kth smallest number in sorted matrix kth smallest number in multiplication table nearly every one have used the multiplication table  but could you find out the k-th smallest number quickly from the multiplication table? given the height m and the length n of a m   n multiplication table  and a positive integer k  you need to return the k-th smallest number in this table  hard binary search 
java solution  6 liner trim a binary search tree given a binary search tree and the lowest and highest boundaries as l and r  trim the tree so that all its elements lies in [l  r] (r >= l)  you might need to change the root of the tree  so the result should return the new root of the trimmed binary search tree  easy tree 
java solution  iteration version trim a binary search tree given a binary search tree and the lowest and highest boundaries as l and r  trim the tree so that all its elements lies in [l  r] (r >= l)  you might need to change the root of the tree  so the result should return the new root of the trimmed binary search tree  easy tree 
c++  recursion trim a binary search tree given a binary search tree and the lowest and highest boundaries as l and r  trim the tree so that all its elements lies in [l  r] (r >= l)  you might need to change the root of the tree  so the result should return the new root of the trimmed binary search tree  easy tree 
clear python solution trim a binary search tree given a binary search tree and the lowest and highest boundaries as l and r  trim the tree so that all its elements lies in [l  r] (r >= l)  you might need to change the root of the tree  so the result should return the new root of the trimmed binary search tree  easy tree 
clean java solution with explanation and video link trim a binary search tree given a binary search tree and the lowest and highest boundaries as l and r  trim the tree so that all its elements lies in [l  r] (r >= l)  you might need to change the root of the tree  so the result should return the new root of the trimmed binary search tree  easy tree 
java simple solution  o(n) time maximum swap given a non-negative integer  you could swap two digits at most once to get the maximum valued number  return the maximum valued number you could get  medium array math 
c++ one-pass simple & fast solution: 1-3ms  o(n) time maximum swap given a non-negative integer  you could swap two digits at most once to get the maximum valued number  return the maximum valued number you could get  medium array math 
[c++] 3ms  o(n) time  o(n) space  dp solution maximum swap given a non-negative integer  you could swap two digits at most once to get the maximum valued number  return the maximum valued number you could get  medium array math 
simple ac o(n) java solution with ex maximum swap given a non-negative integer  you could swap two digits at most once to get the maximum valued number  return the maximum valued number you could get  medium array math 
python  straightforward with explanation maximum swap given a non-negative integer  you could swap two digits at most once to get the maximum valued number  return the maximum valued number you could get  medium array math 
java divide and conquer solution second minimum node in a binary tree given a non-empty special binary tree consisting of nodes with the non-negative value  where each node in this tree has exactly two or zero sub-node  if the node has two sub-nodes  then this node's value is the smaller value among its two sub-nodes  given such a binary tree  you need to output the second minimum value in the set made of all the nodes' value in the whole tree  if no such second minimum value exists  output -1 instead  easy tree 
c++  dfs recursion second minimum node in a binary tree given a non-empty special binary tree consisting of nodes with the non-negative value  where each node in this tree has exactly two or zero sub-node  if the node has two sub-nodes  then this node's value is the smaller value among its two sub-nodes  given such a binary tree  you need to output the second minimum value in the set made of all the nodes' value in the whole tree  if no such second minimum value exists  output -1 instead  easy tree 
python extremely easy to understand (beats 91%) second minimum node in a binary tree given a non-empty special binary tree consisting of nodes with the non-negative value  where each node in this tree has exactly two or zero sub-node  if the node has two sub-nodes  then this node's value is the smaller value among its two sub-nodes  given such a binary tree  you need to output the second minimum value in the set made of all the nodes' value in the whole tree  if no such second minimum value exists  output -1 instead  easy tree 
java 4 lines second minimum node in a binary tree given a non-empty special binary tree consisting of nodes with the non-negative value  where each node in this tree has exactly two or zero sub-node  if the node has two sub-nodes  then this node's value is the smaller value among its two sub-nodes  given such a binary tree  you need to output the second minimum value in the set made of all the nodes' value in the whole tree  if no such second minimum value exists  output -1 instead  easy tree 
very simple java solution second minimum node in a binary tree given a non-empty special binary tree consisting of nodes with the non-negative value  where each node in this tree has exactly two or zero sub-node  if the node has two sub-nodes  then this node's value is the smaller value among its two sub-nodes  given such a binary tree  you need to output the second minimum value in the set made of all the nodes' value in the whole tree  if no such second minimum value exists  output -1 instead  easy tree 
java o(1) bulb switcher ii there is a room with n lights which are turned on initially and 4 buttons on the wall  after performing exactly m unknown operations towards buttons  you need to return how many different kinds of status of the n lights could be  suppose n lights are labeled as number [1  2  3      n]  function of these 4 buttons are given below: flip all the lights  flip lights with even numbers  flip lights with odd numbers  flip lights with (3k + 1) numbers  k = 0  1  2      medium math 
c++  concise code  o(1) bulb switcher ii there is a room with n lights which are turned on initially and 4 buttons on the wall  after performing exactly m unknown operations towards buttons  you need to return how many different kinds of status of the n lights could be  suppose n lights are labeled as number [1  2  3      n]  function of these 4 buttons are given below: flip all the lights  flip lights with even numbers  flip lights with odd numbers  flip lights with (3k + 1) numbers  k = 0  1  2      medium math 
short and clean java o(1) solution bulb switcher ii there is a room with n lights which are turned on initially and 4 buttons on the wall  after performing exactly m unknown operations towards buttons  you need to return how many different kinds of status of the n lights could be  suppose n lights are labeled as number [1  2  3      n]  function of these 4 buttons are given below: flip all the lights  flip lights with even numbers  flip lights with odd numbers  flip lights with (3k + 1) numbers  k = 0  1  2      medium math 
python  straightforward with explanation bulb switcher ii there is a room with n lights which are turned on initially and 4 buttons on the wall  after performing exactly m unknown operations towards buttons  you need to return how many different kinds of status of the n lights could be  suppose n lights are labeled as number [1  2  3      n]  function of these 4 buttons are given below: flip all the lights  flip lights with even numbers  flip lights with odd numbers  flip lights with (3k + 1) numbers  k = 0  1  2      medium math 
easy to understand java bfs solution o(m) bulb switcher ii there is a room with n lights which are turned on initially and 4 buttons on the wall  after performing exactly m unknown operations towards buttons  you need to return how many different kinds of status of the n lights could be  suppose n lights are labeled as number [1  2  3      n]  function of these 4 buttons are given below: flip all the lights  flip lights with even numbers  flip lights with odd numbers  flip lights with (3k + 1) numbers  k = 0  1  2      medium math 
[java c++] simple dp solution with explanation number of longest increasing subsequence given an unsorted array of integers  find the number of longest increasing subsequence  medium dynamic programming 
c++  dp with explanation  o(n^2) number of longest increasing subsequence given an unsorted array of integers  find the number of longest increasing subsequence  medium dynamic programming 
python dp with explanation (beats 88%) number of longest increasing subsequence given an unsorted array of integers  find the number of longest increasing subsequence  medium dynamic programming 
9ms [c++] explanation: dp + binary search + prefix sums o(nlogn) time; o(n) space number of longest increasing subsequence given an unsorted array of integers  find the number of longest increasing subsequence  medium dynamic programming 
python dp solution with detailed explanation number of longest increasing subsequence given an unsorted array of integers  find the number of longest increasing subsequence  medium dynamic programming 
[java c++]clean solution longest continuous increasing subsequence given an unsorted array of integers  find the length of longest continuous increasing subsequence (subarray)  easy array 
python simple solution longest continuous increasing subsequence given an unsorted array of integers  find the length of longest continuous increasing subsequence (subarray)  easy array 
java code---6 liner longest continuous increasing subsequence given an unsorted array of integers  find the length of longest continuous increasing subsequence (subarray)  easy array 
java solution  dp longest continuous increasing subsequence given an unsorted array of integers  find the length of longest continuous increasing subsequence (subarray)  easy array 
[c++ java] clean code - 3 liner [2 pointers] longest continuous increasing subsequence given an unsorted array of integers  find the length of longest continuous increasing subsequence (subarray)  easy array 
java solution  priorityqueue + bfs cut off trees for golf event you are asked to cut off trees in a forest for a golf event  the forest is represented as a non-negative 2d map  in this map: 0 represents the obstacle can't be reached  1 represents the ground can be walked through  the place with number bigger than 1 represents a tree can be walked through  and this positive number represents the tree's height  you are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first  and after cutting  the original place has the tree will become a grass (value 1)  you will start from the point (0  0) and you should output the minimum steps you need to walk to cut off all the trees  if you can't cut off all the trees  output -1 in that situation  you are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off  hard breadth-first search 
very simple python bfs   but why tle?? cut off trees for golf event you are asked to cut off trees in a forest for a golf event  the forest is represented as a non-negative 2d map  in this map: 0 represents the obstacle can't be reached  1 represents the ground can be walked through  the place with number bigger than 1 represents a tree can be walked through  and this positive number represents the tree's height  you are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first  and after cutting  the original place has the tree will become a grass (value 1)  you will start from the point (0  0) and you should output the minimum steps you need to walk to cut off all the trees  if you can't cut off all the trees  output -1 in that situation  you are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off  hard breadth-first search 
python solution based on wufangjie's (hadlock's algorithm?) cut off trees for golf event you are asked to cut off trees in a forest for a golf event  the forest is represented as a non-negative 2d map  in this map: 0 represents the obstacle can't be reached  1 represents the ground can be walked through  the place with number bigger than 1 represents a tree can be walked through  and this positive number represents the tree's height  you are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first  and after cutting  the original place has the tree will become a grass (value 1)  you will start from the point (0  0) and you should output the minimum steps you need to walk to cut off all the trees  if you can't cut off all the trees  output -1 in that situation  you are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off  hard breadth-first search 
my python solution  inspired by a  algorithm cut off trees for golf event you are asked to cut off trees in a forest for a golf event  the forest is represented as a non-negative 2d map  in this map: 0 represents the obstacle can't be reached  1 represents the ground can be walked through  the place with number bigger than 1 represents a tree can be walked through  and this positive number represents the tree's height  you are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first  and after cutting  the original place has the tree will become a grass (value 1)  you will start from the point (0  0) and you should output the minimum steps you need to walk to cut off all the trees  if you can't cut off all the trees  output -1 in that situation  you are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off  hard breadth-first search 
c++  sort + bfs with explanation cut off trees for golf event you are asked to cut off trees in a forest for a golf event  the forest is represented as a non-negative 2d map  in this map: 0 represents the obstacle can't be reached  1 represents the ground can be walked through  the place with number bigger than 1 represents a tree can be walked through  and this positive number represents the tree's height  you are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first  and after cutting  the original place has the tree will become a grass (value 1)  you will start from the point (0  0) and you should output the minimum steps you need to walk to cut off all the trees  if you can't cut off all the trees  output -1 in that situation  you are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off  hard breadth-first search 
easy 14 lines java solution  hashmap implement magic dictionary implement a magic directory with builddict  and search methods  for the method builddict  you'll be given a list of non-repetitive words to build a dictionary  for the method search  you'll be given a word  and judge whether if you modify exactly one character into another character in this word  the modified word is in the dictionary you just built  medium hash table trie 
python  without  26 factor in complexity implement magic dictionary implement a magic directory with builddict  and search methods  for the method builddict  you'll be given a list of non-repetitive words to build a dictionary  for the method search  you'll be given a word  and judge whether if you modify exactly one character into another character in this word  the modified word is in the dictionary you just built  medium hash table trie 
easiest java with trie  no need to count the number of changes implement magic dictionary implement a magic directory with builddict  and search methods  for the method builddict  you'll be given a list of non-repetitive words to build a dictionary  for the method search  you'll be given a word  and judge whether if you modify exactly one character into another character in this word  the modified word is in the dictionary you just built  medium hash table trie 
easy java solution implement magic dictionary implement a magic directory with builddict  and search methods  for the method builddict  you'll be given a list of non-repetitive words to build a dictionary  for the method search  you'll be given a word  and judge whether if you modify exactly one character into another character in this word  the modified word is in the dictionary you just built  medium hash table trie 
python intuitive solution using dictionary implement magic dictionary implement a magic directory with builddict  and search methods  for the method builddict  you'll be given a list of non-repetitive words to build a dictionary  for the method search  you'll be given a word  and judge whether if you modify exactly one character into another character in this word  the modified word is in the dictionary you just built  medium hash table trie 
java solution  trie map sum pairs implement a mapsum class with insert  and sum methods  for the method insert  you'll be given a pair of (string  integer)  the string represents the key and the integer represents the value  if the key already existed  then the original key-value pair will be overridden to the new one  for the method sum  you'll be given a string representing the prefix  and you need to return the sum of all the pairs' value whose key starts with the prefix  medium trie 
c++  easy solution  ordered map map sum pairs implement a mapsum class with insert  and sum methods  for the method insert  you'll be given a pair of (string  integer)  the string represents the key and the integer represents the value  if the key already existed  then the original key-value pair will be overridden to the new one  for the method sum  you'll be given a string representing the prefix  and you need to return the sum of all the pairs' value whose key starts with the prefix  medium trie 
simple java hashmap solution - o(1) sum  and o(len(key)) insert map sum pairs implement a mapsum class with insert  and sum methods  for the method insert  you'll be given a pair of (string  integer)  the string represents the key and the integer represents the value  if the key already existed  then the original key-value pair will be overridden to the new one  for the method sum  you'll be given a string representing the prefix  and you need to return the sum of all the pairs' value whose key starts with the prefix  medium trie 
python easy and concise 3 lines solution map sum pairs implement a mapsum class with insert  and sum methods  for the method insert  you'll be given a pair of (string  integer)  the string represents the key and the integer represents the value  if the key already existed  then the original key-value pair will be overridden to the new one  for the method sum  you'll be given a string representing the prefix  and you need to return the sum of all the pairs' value whose key starts with the prefix  medium trie 
python efficient o(k) insert and sum using trie map sum pairs implement a mapsum class with insert  and sum methods  for the method insert  you'll be given a pair of (string  integer)  the string represents the key and the integer represents the value  if the key already existed  then the original key-value pair will be overridden to the new one  for the method sum  you'll be given a string representing the prefix  and you need to return the sum of all the pairs' value whose key starts with the prefix  medium trie 
short java o(n) time  o(1) space  one pass valid parenthesis string given a string containing only three types of characters: '('  ')' and ' '  write a function to check whether this string is valid  we define the validity of a string by these rules: any left parenthesis '(' must have a corresponding right parenthesis ')'  any right parenthesis ')' must have a corresponding left parenthesis '('  left parenthesis '(' must go before the corresponding right parenthesis ')'  ' ' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string  an empty string is also valid  medium string 
java 12 lines solution  backtracking valid parenthesis string given a string containing only three types of characters: '('  ')' and ' '  write a function to check whether this string is valid  we define the validity of a string by these rules: any left parenthesis '(' must have a corresponding right parenthesis ')'  any right parenthesis ')' must have a corresponding left parenthesis '('  left parenthesis '(' must go before the corresponding right parenthesis ')'  ' ' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string  an empty string is also valid  medium string 
very concise c++ solution with explaination  no dp valid parenthesis string given a string containing only three types of characters: '('  ')' and ' '  write a function to check whether this string is valid  we define the validity of a string by these rules: any left parenthesis '(' must have a corresponding right parenthesis ')'  any right parenthesis ')' must have a corresponding left parenthesis '('  left parenthesis '(' must go before the corresponding right parenthesis ')'  ' ' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string  an empty string is also valid  medium string 
java using 2 stacks   o(n) space and time complexity  valid parenthesis string given a string containing only three types of characters: '('  ')' and ' '  write a function to check whether this string is valid  we define the validity of a string by these rules: any left parenthesis '(' must have a corresponding right parenthesis ')'  any right parenthesis ')' must have a corresponding left parenthesis '('  left parenthesis '(' must go before the corresponding right parenthesis ')'  ' ' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string  an empty string is also valid  medium string 
java  very easy solution  no recursion or dp  valid parenthesis string given a string containing only three types of characters: '('  ')' and ' '  write a function to check whether this string is valid  we define the validity of a string by these rules: any left parenthesis '(' must have a corresponding right parenthesis ')'  any right parenthesis ')' must have a corresponding left parenthesis '('  left parenthesis '(' must go before the corresponding right parenthesis ')'  ' ' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string  an empty string is also valid  medium string 
 ub5a2 ube3b uac01 uac4e ub0c7 uac05 uac38 uae9a ubd5f uc223 uc684 ubd74 ubd5e ub93c uac08 uac0c ub914 ub58c uc60a uba54 ub284 uc22d uceb8 uae36 uae9b uc616 uac0d ub1d0 uca62 uacf4 ub4c7 uac6f uad84 uc615 uc679 ub21e uc1b4 uac43 ub057 uae2c ub549 uadbf uac00 uc300 ub090 uac44 uc224 ubeb4 ub298 uac58 uaf78 uc222 uac42 uac0b uac03 ucad0 uaf14 uc1be uca61 uc1d4 uc1bf ub05b ub91c uac04 ube3a uca6c uc6e8 ub534 uc620 ub91b uac02 ubd6a ub360 ub1a4 ube50 uc60b uadd2 ub282 uac30 uac16 ub1a5 uadbe uac06 uc60c ubf18 ubb30 uac70 uac0e uae37 ub0a4 uacbc 24 game you have 4 cards each containing a number from 1 to 9  you need to judge whether they could operated through       +  -  (  ) to get the value of 24  hard depth-first search 
[java] easy to understand  backtracking  24 game you have 4 cards each containing a number from 1 to 9  you need to judge whether they could operated through       +  -  (  ) to get the value of 24  hard depth-first search 
short python 24 game you have 4 cards each containing a number from 1 to 9  you need to judge whether they could operated through       +  -  (  ) to get the value of 24  hard depth-first search 
c++  concise code 24 game you have 4 cards each containing a number from 1 to 9  you need to judge whether they could operated through       +  -  (  ) to get the value of 24  hard depth-first search 
小时候真的玩儿过这个游戏 24 game you have 4 cards each containing a number from 1 to 9  you need to judge whether they could operated through       +  -  (  ) to get the value of 24  hard depth-first search 
java o(n) time o(1) space valid palindrome ii given a non-empty string s  you may delete at most one character  judge whether you can make it a palindrome  easy string 
easy to understand python solution valid palindrome ii given a non-empty string s  you may delete at most one character  judge whether you can make it a palindrome  easy string 
java solution  ispalindrome valid palindrome ii given a non-empty string s  you may delete at most one character  judge whether you can make it a palindrome  easy string 
easy and concise solution [c++ java python]  valid palindrome ii given a non-empty string s  you may delete at most one character  judge whether you can make it a palindrome  easy string 
[c++ java] clean code - 2 liner - generic for "you may delete at most n character" valid palindrome ii given a non-empty string s  you may delete at most one character  judge whether you can make it a palindrome  easy string 
straightforward python baseball game you're now a baseball game point recorder  given a list of strings  each string can be one of the 4 following types: integer (one round's score): directly represents the number of points you get in this round  "+" (one round's score): represents that the points you get in this round are the sum of the last two valid round's points  "d" (one round's score): represents that the points you get in this round are the doubled data of the last valid round's points  "c" (an operation  which isn't a round's score): represents the last valid round's points you get were invalid and should be removed  each round's operation is permanent and could have an impact on the round before and the round after  you need to return the sum of the points you could get in all the rounds  easy stack 
verbose java solution  linkedlist baseball game you're now a baseball game point recorder  given a list of strings  each string can be one of the 4 following types: integer (one round's score): directly represents the number of points you get in this round  "+" (one round's score): represents that the points you get in this round are the sum of the last two valid round's points  "d" (one round's score): represents that the points you get in this round are the doubled data of the last valid round's points  "c" (an operation  which isn't a round's score): represents the last valid round's points you get were invalid and should be removed  each round's operation is permanent and could have an impact on the round before and the round after  you need to return the sum of the points you could get in all the rounds  easy stack 
[c++] clean code baseball game you're now a baseball game point recorder  given a list of strings  each string can be one of the 4 following types: integer (one round's score): directly represents the number of points you get in this round  "+" (one round's score): represents that the points you get in this round are the sum of the last two valid round's points  "d" (one round's score): represents that the points you get in this round are the doubled data of the last valid round's points  "c" (an operation  which isn't a round's score): represents the last valid round's points you get were invalid and should be removed  each round's operation is permanent and could have an impact on the round before and the round after  you need to return the sum of the points you could get in all the rounds  easy stack 
simple c++ using vector baseball game you're now a baseball game point recorder  given a list of strings  each string can be one of the 4 following types: integer (one round's score): directly represents the number of points you get in this round  "+" (one round's score): represents that the points you get in this round are the sum of the last two valid round's points  "d" (one round's score): represents that the points you get in this round are the doubled data of the last valid round's points  "c" (an operation  which isn't a round's score): represents the last valid round's points you get were invalid and should be removed  each round's operation is permanent and could have an impact on the round before and the round after  you need to return the sum of the points you could get in all the rounds  easy stack 
java very concise and easy to understand using stack baseball game you're now a baseball game point recorder  given a list of strings  each string can be one of the 4 following types: integer (one round's score): directly represents the number of points you get in this round  "+" (one round's score): represents that the points you get in this round are the sum of the last two valid round's points  "d" (one round's score): represents that the points you get in this round are the doubled data of the last valid round's points  "c" (an operation  which isn't a round's score): represents the last valid round's points you get were invalid and should be removed  each round's operation is permanent and could have an impact on the round before and the round after  you need to return the sum of the points you could get in all the rounds  easy stack 
beats 97 96% union find java with explanations redundant connection in this problem  a tree is an undirected graph that is connected and has no cycles  the given input is a graph that started as a tree with n nodes (with distinct values 1  2       n)  with one additional edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] with u < v  that represents an undirected edge connecting nodes u and v  return an edge that can be removed so that the resulting graph is a tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  the answer edge [u  v] should be in the same format  with u < v  medium tree union find graph 
10 line java solution  union find  redundant connection in this problem  a tree is an undirected graph that is connected and has no cycles  the given input is a graph that started as a tree with n nodes (with distinct values 1  2       n)  with one additional edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] with u < v  that represents an undirected edge connecting nodes u and v  return an edge that can be removed so that the resulting graph is a tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  the answer edge [u  v] should be in the same format  with u < v  medium tree union find graph 
unicode-find (5 short lines) redundant connection in this problem  a tree is an undirected graph that is connected and has no cycles  the given input is a graph that started as a tree with n nodes (with distinct values 1  2       n)  with one additional edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] with u < v  that represents an undirected edge connecting nodes u and v  return an edge that can be removed so that the resulting graph is a tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  the answer edge [u  v] should be in the same format  with u < v  medium tree union find graph 
why does this(input: [[2 3] [5 2] [1 5] [4 2] [4 1]] output: [4 2] expected: [4 1] ) happens? redundant connection in this problem  a tree is an undirected graph that is connected and has no cycles  the given input is a graph that started as a tree with n nodes (with distinct values 1  2       n)  with one additional edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] with u < v  that represents an undirected edge connecting nodes u and v  return an edge that can be removed so that the resulting graph is a tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  the answer edge [u  v] should be in the same format  with u < v  medium tree union find graph 
c++ solution  using union find redundant connection in this problem  a tree is an undirected graph that is connected and has no cycles  the given input is a graph that started as a tree with n nodes (with distinct values 1  2       n)  with one additional edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] with u < v  that represents an undirected edge connecting nodes u and v  return an edge that can be removed so that the resulting graph is a tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  the answer edge [u  v] should be in the same format  with u < v  medium tree union find graph 
c++ java  union find with explanation  o(n) redundant connection ii in this problem  a rooted tree is a directed graph such that  there is exactly one node (the root) for which all other nodes are descendants of this node  plus every node has exactly one parent  except for the root node which has no parents  the given input is a directed graph that started as a rooted tree with n nodes (with distinct values 1  2       n)  with one additional directed edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] that represents a directed edge connecting nodes u and v  where u is a parent of child v  return an edge that can be removed so that the resulting graph is a rooted tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  hard tree depth-first search union find graph 
one pass disjoint set solution with explain redundant connection ii in this problem  a rooted tree is a directed graph such that  there is exactly one node (the root) for which all other nodes are descendants of this node  plus every node has exactly one parent  except for the root node which has no parents  the given input is a directed graph that started as a rooted tree with n nodes (with distinct values 1  2       n)  with one additional directed edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] that represents a directed edge connecting nodes u and v  where u is a parent of child v  return an edge that can be removed so that the resulting graph is a rooted tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  hard tree depth-first search union find graph 
python o(n) concise solution with detailed explanation  passed updated testcases redundant connection ii in this problem  a rooted tree is a directed graph such that  there is exactly one node (the root) for which all other nodes are descendants of this node  plus every node has exactly one parent  except for the root node which has no parents  the given input is a directed graph that started as a rooted tree with n nodes (with distinct values 1  2       n)  with one additional directed edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] that represents a directed edge connecting nodes u and v  where u is a parent of child v  return an edge that can be removed so that the resulting graph is a rooted tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  hard tree depth-first search union find graph 
share my solution  c++ redundant connection ii in this problem  a rooted tree is a directed graph such that  there is exactly one node (the root) for which all other nodes are descendants of this node  plus every node has exactly one parent  except for the root node which has no parents  the given input is a directed graph that started as a rooted tree with n nodes (with distinct values 1  2       n)  with one additional directed edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] that represents a directed edge connecting nodes u and v  where u is a parent of child v  return an edge that can be removed so that the resulting graph is a rooted tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  hard tree depth-first search union find graph 
easiest understanding java solution  using union find o(n)  redundant connection ii in this problem  a rooted tree is a directed graph such that  there is exactly one node (the root) for which all other nodes are descendants of this node  plus every node has exactly one parent  except for the root node which has no parents  the given input is a directed graph that started as a rooted tree with n nodes (with distinct values 1  2       n)  with one additional directed edge added  the added edge has two different vertices chosen from 1 to n  and was not an edge that already existed  the resulting graph is given as a 2d-array of edges  each element of edges is a pair [u  v] that represents a directed edge connecting nodes u and v  where u is a parent of child v  return an edge that can be removed so that the resulting graph is a rooted tree of n nodes  if there are multiple answers  return the answer that occurs last in the given 2d-array  hard tree depth-first search union find graph 
c++ 4 lines o(m   n) | o(1) and kmp o(m + n) | o(n) repeated string match given two strings a and b  find the minimum number of times a has to be repeated such that b is a substring of it  if no such solution  return -1  for easy string 
intuitive python 2-liner repeated string match given two strings a and b  find the minimum number of times a has to be repeated such that b is a substring of it  if no such solution  return -1  for easy string 
java solution - just keep building (oj missing test cases) repeated string match given two strings a and b  find the minimum number of times a has to be repeated such that b is a substring of it  if no such solution  return -1  for easy string 
share my java solution! repeated string match given two strings a and b  find the minimum number of times a has to be repeated such that b is a substring of it  if no such solution  return -1  for easy string 
understandable python solution repeated string match given two strings a and b  find the minimum number of times a has to be repeated such that b is a substring of it  if no such solution  return -1  for easy string 
[java c++] clean code longest univalue path given a binary tree  find the length of the longest path where each node in the path has the same value  this path may or may not pass through the root  note: the length of path between two nodes is represented by the number of edges between them  easy tree recursion 
java solution with global variable longest univalue path given a binary tree  find the length of the longest path where each node in the path has the same value  this path may or may not pass through the root  note: the length of path between two nodes is represented by the number of edges between them  easy tree recursion 
python simple to understand longest univalue path given a binary tree  find the length of the longest path where each node in the path has the same value  this path may or may not pass through the root  note: the length of path between two nodes is represented by the number of edges between them  easy tree recursion 
java solution with explanation longest univalue path given a binary tree  find the length of the longest path where each node in the path has the same value  this path may or may not pass through the root  note: the length of path between two nodes is represented by the number of edges between them  easy tree recursion 
test cases incorrect longest univalue path given a binary tree  find the length of the longest path where each node in the path has the same value  this path may or may not pass through the root  note: the length of path between two nodes is represented by the number of edges between them  easy tree recursion 
my accepted dp solution knight probability in chessboard on an nxn chessboard  a knight starts at the r-th row and c-th column and attempts to make exactly k moves  the rows and columns are 0 indexed  so the top-left square is (0  0)  and the bottom-right square is (n-1  n-1)  a chess knight has 8 possible moves it can make  as illustrated below  each move is two squares in a cardinal direction  then one square in an orthogonal direction  each time the knight is to move  it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there  the knight continues moving until it has made exactly k moves or has moved off the chessboard  return the probability that the knight remains on the board after it has stopped moving  medium dynamic programming 
my easy understand dp solution knight probability in chessboard on an nxn chessboard  a knight starts at the r-th row and c-th column and attempts to make exactly k moves  the rows and columns are 0 indexed  so the top-left square is (0  0)  and the bottom-right square is (n-1  n-1)  a chess knight has 8 possible moves it can make  as illustrated below  each move is two squares in a cardinal direction  then one square in an orthogonal direction  each time the knight is to move  it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there  the knight continues moving until it has made exactly k moves or has moved off the chessboard  return the probability that the knight remains on the board after it has stopped moving  medium dynamic programming 
evolve from recursive to dp beats 94% knight probability in chessboard on an nxn chessboard  a knight starts at the r-th row and c-th column and attempts to make exactly k moves  the rows and columns are 0 indexed  so the top-left square is (0  0)  and the bottom-right square is (n-1  n-1)  a chess knight has 8 possible moves it can make  as illustrated below  each move is two squares in a cardinal direction  then one square in an orthogonal direction  each time the knight is to move  it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there  the knight continues moving until it has made exactly k moves or has moved off the chessboard  return the probability that the knight remains on the board after it has stopped moving  medium dynamic programming 
c++ java  dp  concise solution knight probability in chessboard on an nxn chessboard  a knight starts at the r-th row and c-th column and attempts to make exactly k moves  the rows and columns are 0 indexed  so the top-left square is (0  0)  and the bottom-right square is (n-1  n-1)  a chess knight has 8 possible moves it can make  as illustrated below  each move is two squares in a cardinal direction  then one square in an orthogonal direction  each time the knight is to move  it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there  the knight continues moving until it has made exactly k moves or has moved off the chessboard  return the probability that the knight remains on the board after it has stopped moving  medium dynamic programming 
simple java dp solution with explanation knight probability in chessboard on an nxn chessboard  a knight starts at the r-th row and c-th column and attempts to make exactly k moves  the rows and columns are 0 indexed  so the top-left square is (0  0)  and the bottom-right square is (n-1  n-1)  a chess knight has 8 possible moves it can make  as illustrated below  each move is two squares in a cardinal direction  then one square in an orthogonal direction  each time the knight is to move  it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there  the knight continues moving until it has made exactly k moves or has moved off the chessboard  return the probability that the knight remains on the board after it has stopped moving  medium dynamic programming 
c++ java  dp with explanation  o(n) maximum sum of 3 non-overlapping subarrays in a given array nums of positive integers  find three non-overlapping subarrays with maximum sum  each subarray will be of size k  and we want to maximize the sum of all 3 k entries  return the result as a list of indices representing the starting position of each interval (0-indexed)  if there are multiple answers  return the lexicographically smallest one  hard array dynamic programming 
python o(n) time  o(1) space  greedy solution  maximum sum of 3 non-overlapping subarrays in a given array nums of positive integers  find three non-overlapping subarrays with maximum sum  each subarray will be of size k  and we want to maximize the sum of all 3 k entries  return the result as a list of indices representing the starting position of each interval (0-indexed)  if there are multiple answers  return the lexicographically smallest one  hard array dynamic programming 
clean java dp o(n) solution  easy extend to sum of k non-overlapping subarrays  maximum sum of 3 non-overlapping subarrays in a given array nums of positive integers  find three non-overlapping subarrays with maximum sum  each subarray will be of size k  and we want to maximize the sum of all 3 k entries  return the result as a list of indices representing the starting position of each interval (0-indexed)  if there are multiple answers  return the lexicographically smallest one  hard array dynamic programming 
java dp o(n) solution  explanation inline   maximum sum of 3 non-overlapping subarrays in a given array nums of positive integers  find three non-overlapping subarrays with maximum sum  each subarray will be of size k  and we want to maximize the sum of all 3 k entries  return the result as a list of indices representing the starting position of each interval (0-indexed)  if there are multiple answers  return the lexicographically smallest one  hard array dynamic programming 
c++ o(n) time o(n) space concise solution maximum sum of 3 non-overlapping subarrays in a given array nums of positive integers  find three non-overlapping subarrays with maximum sum  each subarray will be of size k  and we want to maximize the sum of all 3 k entries  return the result as a list of indices representing the starting position of each interval (0-indexed)  if there are multiple answers  return the lexicographically smallest one  hard array dynamic programming 
java hashmap bfs dfs employee importance you are given a data structure of employee information  which includes the employee's unique id  his importance value and his direct subordinates' id  for easy hash table depth-first search breadth-first search 
i literally didn't understand the data type of `employees` from the question employee importance you are given a data structure of employee information  which includes the employee's unique id  his importance value and his direct subordinates' id  for easy hash table depth-first search breadth-first search 
3-liner python solution (beats 99%) employee importance you are given a data structure of employee information  which includes the employee's unique id  his importance value and his direct subordinates' id  for easy hash table depth-first search breadth-first search 
c++ dfs using stl employee importance you are given a data structure of employee information  which includes the employee's unique id  his importance value and his direct subordinates' id  for easy hash table depth-first search breadth-first search 
java 5-liner employee importance you are given a data structure of employee information  which includes the employee's unique id  his importance value and his direct subordinates' id  for easy hash table depth-first search breadth-first search 
c++ java python  dp + memoization with optimization  29 ms (c++) stickers to spell word we are given n different types of stickers  each sticker has a lowercase english word on it  you would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them  you can use each sticker more than once if you want  and you have infinite quantities of each sticker  what is the minimum number of stickers that you need to spell out the target? if the task is impossible  return -1  hard dynamic programming backtracking 
rewrite of contest winner's solution stickers to spell word we are given n different types of stickers  each sticker has a lowercase english word on it  you would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them  you can use each sticker more than once if you want  and you have infinite quantities of each sticker  what is the minimum number of stickers that you need to spell out the target? if the task is impossible  return -1  hard dynamic programming backtracking 
explaining stefanpochmann's rewrite of contest winner's solution & +java stickers to spell word we are given n different types of stickers  each sticker has a lowercase english word on it  you would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them  you can use each sticker more than once if you want  and you have infinite quantities of each sticker  what is the minimum number of stickers that you need to spell out the target? if the task is impossible  return -1  hard dynamic programming backtracking 
java bfs solution stickers to spell word we are given n different types of stickers  each sticker has a lowercase english word on it  you would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them  you can use each sticker more than once if you want  and you have infinite quantities of each sticker  what is the minimum number of stickers that you need to spell out the target? if the task is impossible  return -1  hard dynamic programming backtracking 
c++ bfs solution stickers to spell word we are given n different types of stickers  each sticker has a lowercase english word on it  you would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them  you can use each sticker more than once if you want  and you have infinite quantities of each sticker  what is the minimum number of stickers that you need to spell out the target? if the task is impossible  return -1  hard dynamic programming backtracking 
my simple java solution using hashmap & priorityqueue - o(nlogk) time & o(n) space top k frequent words given a non-empty list of words  return the k most frequent elements  your answer should be sorted by frequency from highest to lowest  if two words have the same frequency  then the word with the lower alphabetical order comes first  medium hash table heap trie 
java o(n) solution using hashmap  bucketsort and trie - 22ms beat 81% top k frequent words given a non-empty list of words  return the k most frequent elements  your answer should be sorted by frequency from highest to lowest  if two words have the same frequency  then the word with the lower alphabetical order comes first  medium hash table heap trie 
python 3 solution with o(nlogk) and o(n) top k frequent words given a non-empty list of words  return the k most frequent elements  your answer should be sorted by frequency from highest to lowest  if two words have the same frequency  then the word with the lower alphabetical order comes first  medium hash table heap trie 
o(nlog(k)) priority queue c++ code top k frequent words given a non-empty list of words  return the k most frequent elements  your answer should be sorted by frequency from highest to lowest  if two words have the same frequency  then the word with the lower alphabetical order comes first  medium hash table heap trie 
simplest python solution top k frequent words given a non-empty list of words  return the k most frequent elements  your answer should be sorted by frequency from highest to lowest  if two words have the same frequency  then the word with the lower alphabetical order comes first  medium hash table heap trie 
oneliners (c++  java  ruby  python) binary number with alternating bits given a positive integer  check whether it has alternating bits: namely  if two adjacent bits will always have different values  easy bit manipulation 
java super simple explanation with inline example binary number with alternating bits given a positive integer  check whether it has alternating bits: namely  if two adjacent bits will always have different values  easy bit manipulation 
c++  concise code binary number with alternating bits given a positive integer  check whether it has alternating bits: namely  if two adjacent bits will always have different values  easy bit manipulation 
why not give the fu king precise definition of the fuc king "alternating bits"? binary number with alternating bits given a positive integer  check whether it has alternating bits: namely  if two adjacent bits will always have different values  easy bit manipulation 
easy python binary number with alternating bits given a positive integer  check whether it has alternating bits: namely  if two adjacent bits will always have different values  easy bit manipulation 
java o(n) time o(1) space count binary substrings give a string s  count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's  and all the 0's and all the 1's in these substrings are grouped consecutively  substrings that occur multiple times are counted the number of times they occur  easy string 
[python c++ java] easy and concise with explanation count binary substrings give a string s  count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's  and all the 0's and all the 1's in these substrings are grouped consecutively  substrings that occur multiple times are counted the number of times they occur  easy string 
acceptable java solution with explaination count binary substrings give a string s  count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's  and all the 0's and all the 1's in these substrings are grouped consecutively  substrings that occur multiple times are counted the number of times they occur  easy string 
python intuitive approaches with explanation (3-liner) count binary substrings give a string s  count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's  and all the 0's and all the 1's in these substrings are grouped consecutively  substrings that occur multiple times are counted the number of times they occur  easy string 
c++ easy understanding solution count binary substrings give a string s  count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's  and all the 0's and all the 1's in these substrings are grouped consecutively  substrings that occur multiple times are counted the number of times they occur  easy string 
the example for this question is poor degree of an array given a non-empty array of non-negative integers nums  the degree of this array is defined as the maximum frequency of any one of its elements  your task is to find the smallest possible length of a (contiguous) subarray of nums  that has the same degree as nums  easy array 
easy understand java solution (beats 100% solutions) degree of an array given a non-empty array of non-negative integers nums  the degree of this array is defined as the maximum frequency of any one of its elements  your task is to find the smallest possible length of a (contiguous) subarray of nums  that has the same degree as nums  easy array 
straightforward c++ solution  35ms degree of an array given a non-empty array of non-negative integers nums  the degree of this array is defined as the maximum frequency of any one of its elements  your task is to find the smallest possible length of a (contiguous) subarray of nums  that has the same degree as nums  easy array 
[c++ java python] one-pass and o(m) space degree of an array given a non-empty array of non-negative integers nums  the degree of this array is defined as the maximum frequency of any one of its elements  your task is to find the smallest possible length of a (contiguous) subarray of nums  that has the same degree as nums  easy array 
python easy and concise solution degree of an array given a non-empty array of non-negative integers nums  the degree of this array is defined as the maximum frequency of any one of its elements  your task is to find the smallest possible length of a (contiguous) subarray of nums  that has the same degree as nums  easy array 
[java c++]straightforward dfs solution partition to k equal sum subsets given an array of integers nums and a positive integer k  find whether it's possible to divide this array into k non-empty subsets whose sums are all equal  medium dynamic programming recursion 
easy to understand java solution partition to k equal sum subsets given an array of integers nums and a positive integer k  find whether it's possible to divide this array into k non-empty subsets whose sums are all equal  medium dynamic programming recursion 
cpp solution with explanation in details partition to k equal sum subsets given an array of integers nums and a positive integer k  find whether it's possible to divide this array into k non-empty subsets whose sums are all equal  medium dynamic programming recursion 
clear explanation  easy to understand c++ : 4ms beat 100% partition to k equal sum subsets given an array of integers nums and a positive integer k  find whether it's possible to divide this array into k non-empty subsets whose sums are all equal  medium dynamic programming recursion 
c++ 3ms dfs solution with pruning partition to k equal sum subsets given an array of integers nums and a positive integer k  find whether it's possible to divide this array into k non-empty subsets whose sums are all equal  medium dynamic programming recursion 
easy understood o(n^2) solution with explanation falling squares on an infinite number line (x-axis)  we drop given squares in the order they are given  the i-th square dropped (positions[i] = (left  side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]  the square is dropped with the bottom edge parallel to the number line  and from a higher height than all currently landed squares  we wait for each square to stick before dropping the next  the squares are infinitely sticky on their bottom edge  and will remain fixed to any positive length surface they touch (either the number line or another square)  squares dropped adjacent to each other will not stick together prematurely  return a list ans of heights  each height ans[i] represents the current highest height of any square we have dropped  after dropping squares represented by positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
treemap solution and segment tree (java) solution with lazy propagation and coordinates compression falling squares on an infinite number line (x-axis)  we drop given squares in the order they are given  the i-th square dropped (positions[i] = (left  side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]  the square is dropped with the bottom edge parallel to the number line  and from a higher height than all currently landed squares  we wait for each square to stick before dropping the next  the squares are infinitely sticky on their bottom edge  and will remain fixed to any positive length surface they touch (either the number line or another square)  squares dropped adjacent to each other will not stick together prematurely  return a list ans of heights  each height ans[i] represents the current highest height of any square we have dropped  after dropping squares represented by positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
easy understood treemap solution falling squares on an infinite number line (x-axis)  we drop given squares in the order they are given  the i-th square dropped (positions[i] = (left  side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]  the square is dropped with the bottom edge parallel to the number line  and from a higher height than all currently landed squares  we wait for each square to stick before dropping the next  the squares are infinitely sticky on their bottom edge  and will remain fixed to any positive length surface they touch (either the number line or another square)  squares dropped adjacent to each other will not stick together prematurely  return a list ans of heights  each height ans[i] represents the current highest height of any square we have dropped  after dropping squares represented by positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
easy and concise python solution (97%) falling squares on an infinite number line (x-axis)  we drop given squares in the order they are given  the i-th square dropped (positions[i] = (left  side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]  the square is dropped with the bottom edge parallel to the number line  and from a higher height than all currently landed squares  we wait for each square to stick before dropping the next  the squares are infinitely sticky on their bottom edge  and will remain fixed to any positive length surface they touch (either the number line or another square)  squares dropped adjacent to each other will not stick together prematurely  return a list ans of heights  each height ans[i] represents the current highest height of any square we have dropped  after dropping squares represented by positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
java 14ms  beats 99 38% using interval tree falling squares on an infinite number line (x-axis)  we drop given squares in the order they are given  the i-th square dropped (positions[i] = (left  side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]  the square is dropped with the bottom edge parallel to the number line  and from a higher height than all currently landed squares  we wait for each square to stick before dropping the next  the squares are infinitely sticky on their bottom edge  and will remain fixed to any positive length surface they touch (either the number line or another square)  squares dropped adjacent to each other will not stick together prematurely  return a list ans of heights  each height ans[i] represents the current highest height of any square we have dropped  after dropping squares represented by positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
java beats 100% concise method using recursion and iteration search in a binary search tree given the root node of a binary search tree (bst) and a value  you need to find the node in the bst that the node's value equals the given value  return the subtree rooted with that node  if such node doesn't exist  you should return null  for easy tree 
python 3 lines dfs solution w  a very simple approach search in a binary search tree given the root node of a binary search tree (bst) and a value  you need to find the node in the bst that the node's value equals the given value  return the subtree rooted with that node  if such node doesn't exist  you should return null  for easy tree 
concise iterative solution (c++) search in a binary search tree given the root node of a binary search tree (bst) and a value  you need to find the node in the bst that the node's value equals the given value  return the subtree rooted with that node  if such node doesn't exist  you should return null  for easy tree 
swift bug search in a binary search tree given the root node of a binary search tree (bst) and a value  you need to find the node in the bst that the node's value equals the given value  return the subtree rooted with that node  if such node doesn't exist  you should return null  for easy tree 
beats 100% java code search in a binary search tree given the root node of a binary search tree (bst) and a value  you need to find the node in the bst that the node's value equals the given value  return the subtree rooted with that node  if such node doesn't exist  you should return null  for easy tree 
java iterative 100% insert into a binary search tree given the root node of a binary search tree (bst) and a value to be inserted into the tree  insert the value into the bst  return the root node of the bst after the insertion  it is guaranteed that the new value does not exist in the original bst  note that there may exist multiple valid ways for the insertion  as long as the tree remains a bst after insertion  you can return any of them  for medium tree 
c++: very simple insert into a binary search tree given the root node of a binary search tree (bst) and a value to be inserted into the tree  insert the value into the bst  return the root node of the bst after the insertion  it is guaranteed that the new value does not exist in the original bst  note that there may exist multiple valid ways for the insertion  as long as the tree remains a bst after insertion  you can return any of them  for medium tree 
java easy to understand solution insert into a binary search tree given the root node of a binary search tree (bst) and a value to be inserted into the tree  insert the value into the bst  return the root node of the bst after the insertion  it is guaranteed that the new value does not exist in the original bst  note that there may exist multiple valid ways for the insertion  as long as the tree remains a bst after insertion  you can return any of them  for medium tree 
[java] beats 100%   simple and elegant solution insert into a binary search tree given the root node of a binary search tree (bst) and a value to be inserted into the tree  insert the value into the bst  return the root node of the bst after the insertion  it is guaranteed that the new value does not exist in the original bst  note that there may exist multiple valid ways for the insertion  as long as the tree remains a bst after insertion  you can return any of them  for medium tree 
python - 4 line clean recursive solution insert into a binary search tree given the root node of a binary search tree (bst) and a value to be inserted into the tree  insert the value into the bst  return the root node of the bst after the insertion  it is guaranteed that the new value does not exist in the original bst  note that there may exist multiple valid ways for the insertion  as long as the tree remains a bst after insertion  you can return any of them  for medium tree 
python simple heapq solution beats 100 % kth largest element in a stream design a class to find the kth largest element in a stream  note that it is the kth largest element in the sorted order  not the kth distinct element  your kthlargest class will have a constructor which accepts an integer k and an integer array nums  which contains initial elements from the stream  for each call to the method kthlargest add  return the element representing the kth largest element in the stream  easy heap 
explanation of minheap solution (no code) kth largest element in a stream design a class to find the kth largest element in a stream  note that it is the kth largest element in the sorted order  not the kth distinct element  your kthlargest class will have a constructor which accepts an integer k and an integer array nums  which contains initial elements from the stream  for each call to the method kthlargest add  return the element representing the kth largest element in the stream  easy heap 
java  priority queue kth largest element in a stream design a class to find the kth largest element in a stream  note that it is the kth largest element in the sorted order  not the kth distinct element  your kthlargest class will have a constructor which accepts an integer k and an integer array nums  which contains initial elements from the stream  for each call to the method kthlargest add  return the element representing the kth largest element in the stream  easy heap 
o(h) java solution using bst kth largest element in a stream design a class to find the kth largest element in a stream  note that it is the kth largest element in the sorted order  not the kth distinct element  your kthlargest class will have a constructor which accepts an integer k and an integer array nums  which contains initial elements from the stream  for each call to the method kthlargest add  return the element representing the kth largest element in the stream  easy heap 
minheap solution kth largest element in a stream design a class to find the kth largest element in a stream  note that it is the kth largest element in the sorted order  not the kth distinct element  your kthlargest class will have a constructor which accepts an integer k and an integer array nums  which contains initial elements from the stream  for each call to the method kthlargest add  return the element representing the kth largest element in the stream  easy heap 
python typical solutions beat 100 % binary search given a sorted (in ascending order) integer array nums of n elements and a target value  write a function to search target in nums  if target exists  then return its index  otherwise return -1  easy binary search 
java solution binary search given a sorted (in ascending order) integer array nums of n elements and a target value  write a function to search target in nums  if target exists  then return its index  otherwise return -1  easy binary search 
c++ solution binary search given a sorted (in ascending order) integer array nums of n elements and a target value  write a function to search target in nums  if target exists  then return its index  otherwise return -1  easy binary search 
python recursive + iterative easy to understand binary search given a sorted (in ascending order) integer array nums of n elements and a target value  write a function to search target in nums  if target exists  then return its index  otherwise return -1  easy binary search 
javascript solution binary search given a sorted (in ascending order) integer array nums of n elements and a target value  write a function to search target in nums  if target exists  then return its index  otherwise return -1  easy binary search 
beats 100% real java solution (not boolean array) design hashset design a hashset without using any built-in hash table libraries  to be specific  your design should include these functions: add(value): insert a value into the hashset  contains(value) : return whether the value exists in the hashset or not  remove(value): remove a value in the hashset  if the value does not exist in the hashset  do nothing  easy hash table design 
can you guys think before doing? design hashset design a hashset without using any built-in hash table libraries  to be specific  your design should include these functions: add(value): insert a value into the hashset  contains(value) : return whether the value exists in the hashset or not  remove(value): remove a value in the hashset  if the value does not exist in the hashset  do nothing  easy hash table design 
python solution    can we do better than boolean array ? design hashset design a hashset without using any built-in hash table libraries  to be specific  your design should include these functions: add(value): insert a value into the hashset  contains(value) : return whether the value exists in the hashset or not  remove(value): remove a value in the hashset  if the value does not exist in the hashset  do nothing  easy hash table design 
c++ 97 97% without a massive array or using a map  bst design hashset design a hashset without using any built-in hash table libraries  to be specific  your design should include these functions: add(value): insert a value into the hashset  contains(value) : return whether the value exists in the hashset or not  remove(value): remove a value in the hashset  if the value does not exist in the hashset  do nothing  easy hash table design 
description error in "design hashset" design hashset design a hashset without using any built-in hash table libraries  to be specific  your design should include these functions: add(value): insert a value into the hashset  contains(value) : return whether the value exists in the hashset or not  remove(value): remove a value in the hashset  if the value does not exist in the hashset  do nothing  easy hash table design 
java solution design hashmap design a hashmap without using any built-in hash table libraries  to be specific  your design should include these functions: put(key  value) : insert a (key  value) pair into the hashmap  if the value already exists in the hashmap  update the value  get(key): returns the value to which the specified key is mapped  or -1 if this map contains no mapping for the key  remove(key) : remove the mapping for the value key if this map contains the mapping for the key  easy hash table design 
java simple solution design hashmap design a hashmap without using any built-in hash table libraries  to be specific  your design should include these functions: put(key  value) : insert a (key  value) pair into the hashmap  if the value already exists in the hashmap  update the value  get(key): returns the value to which the specified key is mapped  or -1 if this map contains no mapping for the key  remove(key) : remove the mapping for the value key if this map contains the mapping for the key  easy hash table design 
hash with chaining [python] design hashmap design a hashmap without using any built-in hash table libraries  to be specific  your design should include these functions: put(key  value) : insert a (key  value) pair into the hashmap  if the value already exists in the hashmap  update the value  get(key): returns the value to which the specified key is mapped  or -1 if this map contains no mapping for the key  remove(key) : remove the mapping for the value key if this map contains the mapping for the key  easy hash table design 
python straightforward solution  one line for each function design hashmap design a hashmap without using any built-in hash table libraries  to be specific  your design should include these functions: put(key  value) : insert a (key  value) pair into the hashmap  if the value already exists in the hashmap  update the value  get(key): returns the value to which the specified key is mapped  or -1 if this map contains no mapping for the key  remove(key) : remove the mapping for the value key if this map contains the mapping for the key  easy hash table design 
javascript solution: 104ms design hashmap design a hashmap without using any built-in hash table libraries  to be specific  your design should include these functions: put(key  value) : insert a (key  value) pair into the hashmap  if the value already exists in the hashmap  update the value  get(key): returns the value to which the specified key is mapped  or -1 if this map contains no mapping for the key  remove(key) : remove the mapping for the value key if this map contains the mapping for the key  easy hash table design 
python solution design linked list design your implementation of the linked list  you can choose to use the singly linked list or the doubly linked list  a node in a singly linked list should have two attributes: val and next  val is the value of the current node  and next is a pointer reference to the next node  if you want to use the doubly linked list  you will need one more attribute prev to indicate the previous node in the linked list  assume all nodes in the linked list are 0-indexed  implement these functions in your linked list class: get(index) : get the value of the index-th node in the linked list  if the index is invalid  return -1  addathead(val) : add a node of value val before the first element of the linked list  after the insertion  the new node will be the first node of the linked list  addattail(val) : append a node of value val to the last element of the linked list  addatindex(index  val) : add a node of value val before the index-th node in the linked list  if index equals to the length of linked list  the node will be appended to the end of linked list  if index is greater than the length  the node will not be inserted  deleteatindex(index) : delete the index-th node in the linked list  if the index is valid  easy linked list design 
python ac short & simple linked list solution design linked list design your implementation of the linked list  you can choose to use the singly linked list or the doubly linked list  a node in a singly linked list should have two attributes: val and next  val is the value of the current node  and next is a pointer reference to the next node  if you want to use the doubly linked list  you will need one more attribute prev to indicate the previous node in the linked list  assume all nodes in the linked list are 0-indexed  implement these functions in your linked list class: get(index) : get the value of the index-th node in the linked list  if the index is invalid  return -1  addathead(val) : add a node of value val before the first element of the linked list  after the insertion  the new node will be the first node of the linked list  addattail(val) : append a node of value val to the last element of the linked list  addatindex(index  val) : add a node of value val before the index-th node in the linked list  if index equals to the length of linked list  the node will be appended to the end of linked list  if index is greater than the length  the node will not be inserted  deleteatindex(index) : delete the index-th node in the linked list  if the index is valid  easy linked list design 
c++ solution -24ms design linked list design your implementation of the linked list  you can choose to use the singly linked list or the doubly linked list  a node in a singly linked list should have two attributes: val and next  val is the value of the current node  and next is a pointer reference to the next node  if you want to use the doubly linked list  you will need one more attribute prev to indicate the previous node in the linked list  assume all nodes in the linked list are 0-indexed  implement these functions in your linked list class: get(index) : get the value of the index-th node in the linked list  if the index is invalid  return -1  addathead(val) : add a node of value val before the first element of the linked list  after the insertion  the new node will be the first node of the linked list  addattail(val) : append a node of value val to the last element of the linked list  addatindex(index  val) : add a node of value val before the index-th node in the linked list  if index equals to the length of linked list  the node will be appended to the end of linked list  if index is greater than the length  the node will not be inserted  deleteatindex(index) : delete the index-th node in the linked list  if the index is valid  easy linked list design 
c++ deque design linked list design your implementation of the linked list  you can choose to use the singly linked list or the doubly linked list  a node in a singly linked list should have two attributes: val and next  val is the value of the current node  and next is a pointer reference to the next node  if you want to use the doubly linked list  you will need one more attribute prev to indicate the previous node in the linked list  assume all nodes in the linked list are 0-indexed  implement these functions in your linked list class: get(index) : get the value of the index-th node in the linked list  if the index is invalid  return -1  addathead(val) : add a node of value val before the first element of the linked list  after the insertion  the new node will be the first node of the linked list  addattail(val) : append a node of value val to the last element of the linked list  addatindex(index  val) : add a node of value val before the index-th node in the linked list  if index equals to the length of linked list  the node will be appended to the end of linked list  if index is greater than the length  the node will not be inserted  deleteatindex(index) : delete the index-th node in the linked list  if the index is valid  easy linked list design 
c++ simple solution  beats 97 27%! design linked list design your implementation of the linked list  you can choose to use the singly linked list or the doubly linked list  a node in a singly linked list should have two attributes: val and next  val is the value of the current node  and next is a pointer reference to the next node  if you want to use the doubly linked list  you will need one more attribute prev to indicate the previous node in the linked list  assume all nodes in the linked list are 0-indexed  implement these functions in your linked list class: get(index) : get the value of the index-th node in the linked list  if the index is invalid  return -1  addathead(val) : add a node of value val before the first element of the linked list  after the insertion  the new node will be the first node of the linked list  addattail(val) : append a node of value val to the last element of the linked list  addatindex(index  val) : add a node of value val before the index-th node in the linked list  if index equals to the length of linked list  the node will be appended to the end of linked list  if index is greater than the length  the node will not be inserted  deleteatindex(index) : delete the index-th node in the linked list  if the index is valid  easy linked list design 
java  no library methods to lower case implement function tolowercase() that has a string parameter str  and returns the same string in lowercase  easy string 
easy c++ solution to lower case implement function tolowercase() that has a string parameter str  and returns the same string in lowercase  easy string 
python short 1 line ascii & string method solutions to lower case implement function tolowercase() that has a string parameter str  and returns the same string in lowercase  easy string 
c solution- 9 lines  0ms (with test cases) to lower case implement function tolowercase() that has a string parameter str  and returns the same string in lowercase  easy string 
javascript solution (not using built in method) to lower case implement function tolowercase() that has a string parameter str  and returns the same string in lowercase  easy string 
java o(b)   o(1)  hashmap random pick with blacklist given a blacklist b containing unique integers from [0  n)  write a function to return a uniform random integer from [0  n) which is not in b  optimize it such that it minimizes the call to system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) does not include n  see interval notation  hard hash table binary search sort random 
[c++] do not use rand() after c++11 ! random pick with blacklist given a blacklist b containing unique integers from [0  n)  write a function to return a uniform random integer from [0  n) which is not in b  optimize it such that it minimizes the call to system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) does not include n  see interval notation  hard hash table binary search sort random 
simple java solution with binary search random pick with blacklist given a blacklist b containing unique integers from [0  n)  write a function to return a uniform random integer from [0  n) which is not in b  optimize it such that it minimizes the call to system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) does not include n  see interval notation  hard hash table binary search sort random 
super simple python ac w  remapping random pick with blacklist given a blacklist b containing unique integers from [0  n)  write a function to return a uniform random integer from [0  n) which is not in b  optimize it such that it minimizes the call to system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) does not include n  see interval notation  hard hash table binary search sort random 
python ac solution with a very simple approach random pick with blacklist given a blacklist b containing unique integers from [0  n)  write a function to return a uniform random integer from [0  n) which is not in b  optimize it such that it minimizes the call to system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) does not include n  see interval notation  hard hash table binary search sort random 
c++  dp  with explanation minimum ascii delete sum for two strings given two strings s1  s2  find the lowest ascii sum of deleted characters to make two strings equal  medium dynamic programming 
concise dp solution minimum ascii delete sum for two strings given two strings s1  s2  find the lowest ascii sum of deleted characters to make two strings equal  medium dynamic programming 
[java]{dp}(with explanation) minimum ascii delete sum for two strings given two strings s1  s2  find the lowest ascii sum of deleted characters to make two strings equal  medium dynamic programming 
[java c++] clean code minimum ascii delete sum for two strings given two strings s1  s2  find the lowest ascii sum of deleted characters to make two strings equal  medium dynamic programming 
elegant python solution using dp minimum ascii delete sum for two strings given two strings s1  s2  find the lowest ascii sum of deleted characters to make two strings equal  medium dynamic programming 
[java c++] clean code with explanation subarray product less than k your are given an array of positive integers nums  count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k  medium array two pointers 
java two pointers o(n) time o(1) space subarray product less than k your are given an array of positive integers nums  count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k  medium array two pointers 
c++  concise solution  o(n) subarray product less than k your are given an array of positive integers nums  count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k  medium array two pointers 
python solution with detailed explanation subarray product less than k your are given an array of positive integers nums  count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k  medium array two pointers 
straightforward solution subarray product less than k your are given an array of positive integers nums  count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k  medium array two pointers 
most consistent ways of dealing with the series of stock problems best time to buy and sell stock with transaction fee your are given an array of integers prices  for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee  you may complete as many transactions as you like  but you need to pay the transaction fee for each transaction  you may not buy more than 1 share of a stock at a time (ie  you must sell the stock share before you buy again ) return the maximum profit you can make  medium array dynamic programming greedy 
2 solutions  2 states dp solutions  clear explanation! best time to buy and sell stock with transaction fee your are given an array of integers prices  for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee  you may complete as many transactions as you like  but you need to pay the transaction fee for each transaction  you may not buy more than 1 share of a stock at a time (ie  you must sell the stock share before you buy again ) return the maximum profit you can make  medium array dynamic programming greedy 
c++  concise solution  o(n) time o(1) space best time to buy and sell stock with transaction fee your are given an array of integers prices  for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee  you may complete as many transactions as you like  but you need to pay the transaction fee for each transaction  you may not buy more than 1 share of a stock at a time (ie  you must sell the stock share before you buy again ) return the maximum profit you can make  medium array dynamic programming greedy 
java simple dp solutions  o(n) best time to buy and sell stock with transaction fee your are given an array of integers prices  for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee  you may complete as many transactions as you like  but you need to pay the transaction fee for each transaction  you may not buy more than 1 share of a stock at a time (ie  you must sell the stock share before you buy again ) return the maximum profit you can make  medium array dynamic programming greedy 
java dp solution o(n) to o(1) space best time to buy and sell stock with transaction fee your are given an array of integers prices  for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee  you may complete as many transactions as you like  but you need to pay the transaction fee for each transaction  you may not buy more than 1 share of a stock at a time (ie  you must sell the stock share before you buy again ) return the maximum profit you can make  medium array dynamic programming greedy 
java treemap range module a range module is a module that tracks ranges of numbers  your task is to design and implement the following interfaces in an efficient manner  addrange(int left  int right) adds the half-open interval [left  right)  tracking every real number in that interval  adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left  right) that are not already tracked  queryrange(int left  int right) returns true if and only if every real number in the interval [left  right) is currently being tracked  removerange(int left  int right) stops tracking every real number currently being tracked in the interval [left  right)  hard array segment tree binary search tree 
c++  vector o(n) and map o(logn)  compare two solutions range module a range module is a module that tracks ranges of numbers  your task is to design and implement the following interfaces in an efficient manner  addrange(int left  int right) adds the half-open interval [left  right)  tracking every real number in that interval  adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left  right) that are not already tracked  queryrange(int left  int right) returns true if and only if every real number in the interval [left  right) is currently being tracked  removerange(int left  int right) stops tracking every real number currently being tracked in the interval [left  right)  hard array segment tree binary search tree 
python range module a range module is a module that tracks ranges of numbers  your task is to design and implement the following interfaces in an efficient manner  addrange(int left  int right) adds the half-open interval [left  right)  tracking every real number in that interval  adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left  right) that are not already tracked  queryrange(int left  int right) returns true if and only if every real number in the interval [left  right) is currently being tracked  removerange(int left  int right) stops tracking every real number currently being tracked in the interval [left  right)  hard array segment tree binary search tree 
c++ o(nlogn) based on disjoint intervals data structure range module a range module is a module that tracks ranges of numbers  your task is to design and implement the following interfaces in an efficient manner  addrange(int left  int right) adds the half-open interval [left  right)  tracking every real number in that interval  adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left  right) that are not already tracked  queryrange(int left  int right) returns true if and only if every real number in the interval [left  right) is currently being tracked  removerange(int left  int right) stops tracking every real number currently being tracked in the interval [left  right)  hard array segment tree binary search tree 
clean python solution range module a range module is a module that tracks ranges of numbers  your task is to design and implement the following interfaces in an efficient manner  addrange(int left  int right) adds the half-open interval [left  right)  tracking every real number in that interval  adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left  right) that are not already tracked  queryrange(int left  int right) returns true if and only if every real number in the interval [left  right) is currently being tracked  removerange(int left  int right) stops tracking every real number currently being tracked in the interval [left  right)  hard array segment tree binary search tree 
java  check only the end of array 1-bit and 2-bit characters we have two special characters  the first character can be represented by one bit 0  the second character can be represented by two bits (10 or 11)  now given a string represented by several bits  return whether the last character must be a one-bit character or not  the given string will always end with a zero  easy array 
java solution  1 or 2 1-bit and 2-bit characters we have two special characters  the first character can be represented by one bit 0  the second character can be represented by two bits (10 or 11)  now given a string represented by several bits  return whether the last character must be a one-bit character or not  the given string will always end with a zero  easy array 
python solution  easy 1-bit and 2-bit characters we have two special characters  the first character can be represented by one bit 0  the second character can be represented by two bits (10 or 11)  now given a string represented by several bits  return whether the last character must be a one-bit character or not  the given string will always end with a zero  easy array 
easy to understand c++ solution with modified for loop 1-bit and 2-bit characters we have two special characters  the first character can be represented by one bit 0  the second character can be represented by two bits (10 or 11)  now given a string represented by several bits  return whether the last character must be a one-bit character or not  the given string will always end with a zero  easy array 
single regular expression - js: es6 1-bit and 2-bit characters we have two special characters  the first character can be represented by one bit 0  the second character can be represented by two bits (10 or 11)  now given a string represented by several bits  return whether the last character must be a one-bit character or not  the given string will always end with a zero  easy array 
concise java dp: same idea of longest common substring maximum length of repeated subarray given two integer arrays a and b  return the maximum length of an subarray that appears in both arrays  medium array hash table binary search dynamic programming 
[java c++] clean code - 8 lines maximum length of repeated subarray given two integer arrays a and b  return the maximum length of an subarray that appears in both arrays  medium array hash table binary search dynamic programming 
java o(mn) time  o(1) space maximum length of repeated subarray given two integer arrays a and b  return the maximum length of an subarray that appears in both arrays  medium array hash table binary search dynamic programming 
python concise dp maximum length of repeated subarray given two integer arrays a and b  return the maximum length of an subarray that appears in both arrays  medium array hash table binary search dynamic programming 
simple o(nm) dp solution maximum length of repeated subarray given two integer arrays a and b  return the maximum length of an subarray that appears in both arrays  medium array hash table binary search dynamic programming 
[java c++] clean code longest word in dictionary given a list of strings words representing an english dictionary  find the longest word in words that can be built one character at a time by other words in words  if there is more than one possible answer  return the longest word with the smallest lexicographical order  if there is no answer  return the empty string  easy hash table trie 
python elegant and extremely easy to understand longest word in dictionary given a list of strings words representing an english dictionary  find the longest word in words that can be built one character at a time by other words in words  if there is more than one possible answer  return the longest word with the smallest lexicographical order  if there is no answer  return the empty string  easy hash table trie 
[java 16ms (99%) @ 20180108] trie+dfs: clean  easy  explained and illustrated longest word in dictionary given a list of strings words representing an english dictionary  find the longest word in words that can be built one character at a time by other words in words  if there is more than one possible answer  return the longest word with the smallest lexicographical order  if there is no answer  return the empty string  easy hash table trie 
java solution with trie + bfs longest word in dictionary given a list of strings words representing an english dictionary  find the longest word in words that can be built one character at a time by other words in words  if there is more than one possible answer  return the longest word with the smallest lexicographical order  if there is no answer  return the empty string  easy hash table trie 
1-liner longest word in dictionary given a list of strings words representing an english dictionary  find the longest word in words that can be built one character at a time by other words in words  if there is more than one possible answer  return the longest word with the smallest lexicographical order  if there is no answer  return the empty string  easy hash table trie 
[java c++] union find accounts merge given a list accounts  each element accounts[i] is a list of strings  where the first element accounts[i][0] is a name  and the rest of the elements are emails representing emails of the account  now  we would like to merge these accounts  two accounts definitely belong to the same person if there is some email that is common to both accounts  note that even if two accounts have the same name  they may belong to different people as people could have the same name  a person can have any number of accounts initially  but all of their accounts definitely have the same name  after merging the accounts  return the accounts in the following format: the first element of each account is the name  and the rest of the elements are emails in sorted order  the accounts themselves can be returned in any order  medium depth-first search union find 
java solution (build graph + dfs search) accounts merge given a list accounts  each element accounts[i] is a list of strings  where the first element accounts[i][0] is a name  and the rest of the elements are emails representing emails of the account  now  we would like to merge these accounts  two accounts definitely belong to the same person if there is some email that is common to both accounts  note that even if two accounts have the same name  they may belong to different people as people could have the same name  a person can have any number of accounts initially  but all of their accounts definitely have the same name  after merging the accounts  return the accounts in the following format: the first element of each account is the name  and the rest of the elements are emails in sorted order  the accounts themselves can be returned in any order  medium depth-first search union find 
python simple dfs with explanation!!! accounts merge given a list accounts  each element accounts[i] is a list of strings  where the first element accounts[i][0] is a name  and the rest of the elements are emails representing emails of the account  now  we would like to merge these accounts  two accounts definitely belong to the same person if there is some email that is common to both accounts  note that even if two accounts have the same name  they may belong to different people as people could have the same name  a person can have any number of accounts initially  but all of their accounts definitely have the same name  after merging the accounts  return the accounts in the following format: the first element of each account is the name  and the rest of the elements are emails in sorted order  the accounts themselves can be returned in any order  medium depth-first search union find 
summary for dfs templates accounts merge given a list accounts  each element accounts[i] is a list of strings  where the first element accounts[i][0] is a name  and the rest of the elements are emails representing emails of the account  now  we would like to merge these accounts  two accounts definitely belong to the same person if there is some email that is common to both accounts  note that even if two accounts have the same name  they may belong to different people as people could have the same name  a person can have any number of accounts initially  but all of their accounts definitely have the same name  after merging the accounts  return the accounts in the following format: the first element of each account is the name  and the rest of the elements are emails in sorted order  the accounts themselves can be returned in any order  medium depth-first search union find 
hashmap plus union found solution using java programming! accounts merge given a list accounts  each element accounts[i] is a list of strings  where the first element accounts[i][0] is a name  and the rest of the elements are emails representing emails of the account  now  we would like to merge these accounts  two accounts definitely belong to the same person if there is some email that is common to both accounts  note that even if two accounts have the same name  they may belong to different people as people could have the same name  a person can have any number of accounts initially  but all of their accounts definitely have the same name  after merging the accounts  return the accounts in the following format: the first element of each account is the name  and the rest of the elements are emails in sorted order  the accounts themselves can be returned in any order  medium depth-first search union find 
one pass solution in java remove comments given a c++ program  remove comments from it  the program source is an array where source[i] is the i-th line of the source code  this represents the result of splitting the original source code string by the newline character  n  in c++  there are two types of comments  line comments  and block comments  the string    denotes a line comment  which represents that it and rest of the characters to the right of it in the same line should be ignored  the string    denotes a block comment  which represents that all characters until the next (non-overlapping) occurrence of    should be ignored  (here  occurrences happen in reading order: line by line from left to right ) to be clear  the string     does not yet end the block comment  as the ending would be overlapping the beginning  the first effective comment takes precedence over others: if the string    occurs in a block comment  it is ignored  similarly  if the string    occurs in a line or block comment  it is also ignored  if a certain line of code is empty after removing comments  you must not output that line: each string in the answer list will be non-empty  there will be no control characters  single quote  or double quote characters  for medium string 
1-liners remove comments given a c++ program  remove comments from it  the program source is an array where source[i] is the i-th line of the source code  this represents the result of splitting the original source code string by the newline character  n  in c++  there are two types of comments  line comments  and block comments  the string    denotes a line comment  which represents that it and rest of the characters to the right of it in the same line should be ignored  the string    denotes a block comment  which represents that all characters until the next (non-overlapping) occurrence of    should be ignored  (here  occurrences happen in reading order: line by line from left to right ) to be clear  the string     does not yet end the block comment  as the ending would be overlapping the beginning  the first effective comment takes precedence over others: if the string    occurs in a block comment  it is ignored  similarly  if the string    occurs in a line or block comment  it is also ignored  if a certain line of code is empty after removing comments  you must not output that line: each string in the answer list will be non-empty  there will be no control characters  single quote  or double quote characters  for medium string 
simple python one-pass with clear inline explanation!!! remove comments given a c++ program  remove comments from it  the program source is an array where source[i] is the i-th line of the source code  this represents the result of splitting the original source code string by the newline character  n  in c++  there are two types of comments  line comments  and block comments  the string    denotes a line comment  which represents that it and rest of the characters to the right of it in the same line should be ignored  the string    denotes a block comment  which represents that all characters until the next (non-overlapping) occurrence of    should be ignored  (here  occurrences happen in reading order: line by line from left to right ) to be clear  the string     does not yet end the block comment  as the ending would be overlapping the beginning  the first effective comment takes precedence over others: if the string    occurs in a block comment  it is ignored  similarly  if the string    occurs in a line or block comment  it is also ignored  if a certain line of code is empty after removing comments  you must not output that line: each string in the answer list will be non-empty  there will be no control characters  single quote  or double quote characters  for medium string 
c++ o(n) (one pass) remove comments given a c++ program  remove comments from it  the program source is an array where source[i] is the i-th line of the source code  this represents the result of splitting the original source code string by the newline character  n  in c++  there are two types of comments  line comments  and block comments  the string    denotes a line comment  which represents that it and rest of the characters to the right of it in the same line should be ignored  the string    denotes a block comment  which represents that all characters until the next (non-overlapping) occurrence of    should be ignored  (here  occurrences happen in reading order: line by line from left to right ) to be clear  the string     does not yet end the block comment  as the ending would be overlapping the beginning  the first effective comment takes precedence over others: if the string    occurs in a block comment  it is ignored  similarly  if the string    occurs in a line or block comment  it is also ignored  if a certain line of code is empty after removing comments  you must not output that line: each string in the answer list will be non-empty  there will be no control characters  single quote  or double quote characters  for medium string 
just kill me remove comments given a c++ program  remove comments from it  the program source is an array where source[i] is the i-th line of the source code  this represents the result of splitting the original source code string by the newline character  n  in c++  there are two types of comments  line comments  and block comments  the string    denotes a line comment  which represents that it and rest of the characters to the right of it in the same line should be ignored  the string    denotes a block comment  which represents that all characters until the next (non-overlapping) occurrence of    should be ignored  (here  occurrences happen in reading order: line by line from left to right ) to be clear  the string     does not yet end the block comment  as the ending would be overlapping the beginning  the first effective comment takes precedence over others: if the string    occurs in a block comment  it is ignored  similarly  if the string    occurs in a line or block comment  it is also ignored  if a certain line of code is empty after removing comments  you must not output that line: each string in the answer list will be non-empty  there will be no control characters  single quote  or double quote characters  for medium string 
short python o(n) time o(1) space with explanation find pivot index given an array of integers nums  write a method that returns the "pivot" index of this array  we define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index  if no such index exists  we should return -1  if there are multiple pivot indexes  you should return the left-most pivot index  easy array 
this is a very poorly described problem find pivot index given an array of integers nums  write a method that returns the "pivot" index of this array  we define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index  if no such index exists  we should return -1  if there are multiple pivot indexes  you should return the left-most pivot index  easy array 
java 6 liner find pivot index given an array of integers nums  write a method that returns the "pivot" index of this array  we define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index  if no such index exists  we should return -1  if there are multiple pivot indexes  you should return the left-most pivot index  easy array 
[java c++] clean code find pivot index given an array of integers nums  write a method that returns the "pivot" index of this array  we define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index  if no such index exists  we should return -1  if there are multiple pivot indexes  you should return the left-most pivot index  easy array 
easy to understand c++ code  find pivot index given an array of integers nums  write a method that returns the "pivot" index of this array  we define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index  if no such index exists  we should return -1  if there are multiple pivot indexes  you should return the left-most pivot index  easy array 
[java c++] clean code split linked list in parts given a (singly) linked list with head node root  write a function to split the linked list into k consecutive linked list "parts"  the length of each part should be as equal as possible: no two parts should have a size differing by more than 1  this may lead to some parts being null  the parts should be in order of occurrence in the input list  and parts occurring earlier should always have a size greater than or equal parts occurring later  return a list of listnode's representing the linked list parts that are formed  medium linked list 
elegant python with explanation - 45ms split linked list in parts given a (singly) linked list with head node root  write a function to split the linked list into k consecutive linked list "parts"  the length of each part should be as equal as possible: no two parts should have a size differing by more than 1  this may lead to some parts being null  the parts should be in order of occurrence in the input list  and parts occurring earlier should always have a size greater than or equal parts occurring later  return a list of listnode's representing the linked list parts that are formed  medium linked list 
c++ solution o(1) space 9ms split linked list in parts given a (singly) linked list with head node root  write a function to split the linked list into k consecutive linked list "parts"  the length of each part should be as equal as possible: no two parts should have a size differing by more than 1  this may lead to some parts being null  the parts should be in order of occurrence in the input list  and parts occurring earlier should always have a size greater than or equal parts occurring later  return a list of listnode's representing the linked list parts that are formed  medium linked list 
easy to follow python solution split linked list in parts given a (singly) linked list with head node root  write a function to split the linked list into k consecutive linked list "parts"  the length of each part should be as equal as possible: no two parts should have a size differing by more than 1  this may lead to some parts being null  the parts should be in order of occurrence in the input list  and parts occurring earlier should always have a size greater than or equal parts occurring later  return a list of listnode's representing the linked list parts that are formed  medium linked list 
simple pythonic solution  beats 100% split linked list in parts given a (singly) linked list with head node root  write a function to split the linked list into k consecutive linked list "parts"  the length of each part should be as equal as possible: no two parts should have a size differing by more than 1  this may lead to some parts being null  the parts should be in order of occurrence in the input list  and parts occurring earlier should always have a size greater than or equal parts occurring later  return a list of listnode's representing the linked list parts that are formed  medium linked list 
java solution using stack and map number of atoms given a chemical formula (given as a string)  return the count of each atom  an atomic element always starts with an uppercase character  then zero or more lowercase letters  representing the name  1 or more digits representing the count of that element may follow if the count is greater than 1  if the count is 1  no digits will follow  for hard hash table stack recursion 
neat python with explanation - 35ms number of atoms given a chemical formula (given as a string)  return the count of each atom  an atomic element always starts with an uppercase character  then zero or more lowercase letters  representing the name  1 or more digits representing the count of that element may follow if the count is greater than 1  if the count is 1  no digits will follow  for hard hash table stack recursion 
python    20 lines very readable  simplest and shortest solution    36 ms    beats 100 % number of atoms given a chemical formula (given as a string)  return the count of each atom  an atomic element always starts with an uppercase character  then zero or more lowercase letters  representing the name  1 or more digits representing the count of that element may follow if the count is greater than 1  if the count is 1  no digits will follow  for hard hash table stack recursion 
[c++] recursive parser number of atoms given a chemical formula (given as a string)  return the count of each atom  an atomic element always starts with an uppercase character  then zero or more lowercase letters  representing the name  1 or more digits representing the count of that element may follow if the count is greater than 1  if the count is 1  no digits will follow  for hard hash table stack recursion 
c++ iterative solution number of atoms given a chemical formula (given as a string)  return the count of each atom  an atomic element always starts with an uppercase character  then zero or more lowercase letters  representing the name  1 or more digits representing the count of that element may follow if the count is greater than 1  if the count is 1  no digits will follow  for hard hash table stack recursion 
python elegant 2-liner!!! self dividing numbers a self-dividing number is a number that is divisible by every digit it contains  for easy math 
[java c++] clean code self dividing numbers a self-dividing number is a number that is divisible by every digit it contains  for easy math 
one-line python (learn some python tricks that you might not know) self dividing numbers a self-dividing number is a number that is divisible by every digit it contains  for easy math 
java solution with explanation  no tostring() conversion self dividing numbers a self-dividing number is a number that is divisible by every digit it contains  for easy math 
my javascript solution self dividing numbers a self-dividing number is a number that is divisible by every digit it contains  for easy math 
java 8 liner  treemap my calendar i implement a mycalendar class to store your events  a new event can be added if adding the event will not cause a double booking  your class will have the method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a double booking happens when two events have some non-empty intersection (ie   there is some time that is common to both events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a double booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
[java c++] clean code with explanation my calendar i implement a mycalendar class to store your events  a new event can be added if adding the event will not cause a double booking  your class will have the method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a double booking happens when two events have some non-empty intersection (ie   there is some time that is common to both events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a double booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
binary search tree python my calendar i implement a mycalendar class to store your events  a new event can be added if adding the event will not cause a double booking  your class will have the method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a double booking happens when two events have some non-empty intersection (ie   there is some time that is common to both events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a double booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
[java] simple 6 line solution  treemap lowerentry my calendar i implement a mycalendar class to store your events  a new event can be added if adding the event will not cause a double booking  your class will have the method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a double booking happens when two events have some non-empty intersection (ie   there is some time that is common to both events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a double booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
short brute force python solution my calendar i implement a mycalendar class to store your events  a new event can be added if adding the event will not cause a double booking  your class will have the method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a double booking happens when two events have some non-empty intersection (ie   there is some time that is common to both events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a double booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
java 96ms dp solution with detailed explanation count different palindromic subsequences given a string s  find the number of different non-empty palindromic subsequences in s  and return that number modulo 10^9 + 7  a subsequence of a string s is obtained by deleting 0 or more characters from s  a sequence is palindromic if it is equal to the sequence reversed  two sequences a_1  a_2      and b_1  b_2      are different if there is some i for which a_i != b_i  hard string dynamic programming 
accepted java solution using memoization count different palindromic subsequences given a string s  find the number of different non-empty palindromic subsequences in s  and return that number modulo 10^9 + 7  a subsequence of a string s is obtained by deleting 0 or more characters from s  a sequence is palindromic if it is equal to the sequence reversed  two sequences a_1  a_2      and b_1  b_2      are different if there is some i for which a_i != b_i  hard string dynamic programming 
c++ o(n^2) time  o(n) memory with explanation count different palindromic subsequences given a string s  find the number of different non-empty palindromic subsequences in s  and return that number modulo 10^9 + 7  a subsequence of a string s is obtained by deleting 0 or more characters from s  a sequence is palindromic if it is equal to the sequence reversed  two sequences a_1  a_2      and b_1  b_2      are different if there is some i for which a_i != b_i  hard string dynamic programming 
n^2 dp python with explanation count different palindromic subsequences given a string s  find the number of different non-empty palindromic subsequences in s  and return that number modulo 10^9 + 7  a subsequence of a string s is obtained by deleting 0 or more characters from s  a sequence is palindromic if it is equal to the sequence reversed  two sequences a_1  a_2      and b_1  b_2      are different if there is some i for which a_i != b_i  hard string dynamic programming 
java solution using simple dp  o(n^2) run time and o(n^2) space count different palindromic subsequences given a string s  find the number of different non-empty palindromic subsequences in s  and return that number modulo 10^9 + 7  a subsequence of a string s is obtained by deleting 0 or more characters from s  a sequence is palindromic if it is equal to the sequence reversed  two sequences a_1  a_2      and b_1  b_2      are different if there is some i for which a_i != b_i  hard string dynamic programming 
[java c++] clean code with explanation my calendar ii implement a mycalendartwo class to store your events  a new event can be added if adding the event will not cause a triple booking  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a triple booking happens when three events have some non-empty intersection (ie   there is some time that is common to all 3 events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a triple booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
n^2 python  short and elegant my calendar ii implement a mycalendartwo class to store your events  a new event can be added if adding the event will not cause a triple booking  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a triple booking happens when three events have some non-empty intersection (ie   there is some time that is common to all 3 events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a triple booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
nlogd java solution using segment tree with lazy propagation -- applicable to the general case of k-booking my calendar ii implement a mycalendartwo class to store your events  a new event can be added if adding the event will not cause a triple booking  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a triple booking happens when three events have some non-empty intersection (ie   there is some time that is common to all 3 events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a triple booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
simplified winner's solution my calendar ii implement a mycalendartwo class to store your events  a new event can be added if adding the event will not cause a triple booking  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a triple booking happens when three events have some non-empty intersection (ie   there is some time that is common to all 3 events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a triple booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
simple ac by treemap my calendar ii implement a mycalendartwo class to store your events  a new event can be added if adding the event will not cause a triple booking  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a triple booking happens when three events have some non-empty intersection (ie   there is some time that is common to all 3 events ) for each call to the method mycalendar book  return true if the event can be added to the calendar successfully without causing a triple booking  otherwise  return false and do not add the event to the calendar  your class will be called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
[java c++] clean code my calendar iii implement a mycalendarthree class to store your events  a new event can always be added  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a k-booking happens when k events have some non-empty intersection (ie   there is some time that is common to all k events ) for each call to the method mycalendar book  return an integer k representing the largest integer such that there exists a k-booking in the calendar  your class will be called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
question explanation please my calendar iii implement a mycalendarthree class to store your events  a new event can always be added  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a k-booking happens when k events have some non-empty intersection (ie   there is some time that is common to all k events ) for each call to the method mycalendar book  return an integer k representing the largest integer such that there exists a k-booking in the calendar  your class will be called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
c++ o(n) method my calendar iii implement a mycalendarthree class to store your events  a new event can always be added  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a k-booking happens when k events have some non-empty intersection (ie   there is some time that is common to all k events ) for each call to the method mycalendar book  return an integer k representing the largest integer such that there exists a k-booking in the calendar  your class will be called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
is this a right test case? my calendar iii implement a mycalendarthree class to store your events  a new event can always be added  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a k-booking happens when k events have some non-empty intersection (ie   there is some time that is common to all k events ) for each call to the method mycalendar book  return an integer k representing the largest integer such that there exists a k-booking in the calendar  your class will be called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
java solution o(n log(len)) beats 100% segment tree my calendar iii implement a mycalendarthree class to store your events  a new event can always be added  your class will have one method  book(int start  int end)  formally  this represents a booking on the half open interval [start  end)  the range of real numbers x such that start <= x < end  a k-booking happens when k events have some non-empty intersection (ie   there is some time that is common to all k events ) for each call to the method mycalendar book  return an integer k representing the largest integer such that there exists a k-booking in the calendar  your class will be called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
java 9 liner  dfs flood fill an image is represented by a 2-d array of integers  each integer representing the pixel value of the image (from 0 to 65535)  given a coordinate (sr  sc) representing the starting pixel (row and column) of the flood fill  and a pixel value newcolor  "flood fill" the image  to perform a "flood fill"  consider the starting pixel  plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel  plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel)  and so on  replace the color of all of the aforementioned pixels with the newcolor  at the end  return the modified image  easy depth-first search 
easy python dfs (no need for visited)!!! flood fill an image is represented by a 2-d array of integers  each integer representing the pixel value of the image (from 0 to 65535)  given a coordinate (sr  sc) representing the starting pixel (row and column) of the flood fill  and a pixel value newcolor  "flood fill" the image  to perform a "flood fill"  consider the starting pixel  plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel  plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel)  and so on  replace the color of all of the aforementioned pixels with the newcolor  at the end  return the modified image  easy depth-first search 
[java c++] clean code flood fill an image is represented by a 2-d array of integers  each integer representing the pixel value of the image (from 0 to 65535)  given a coordinate (sr  sc) representing the starting pixel (row and column) of the flood fill  and a pixel value newcolor  "flood fill" the image  to perform a "flood fill"  consider the starting pixel  plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel  plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel)  and so on  replace the color of all of the aforementioned pixels with the newcolor  at the end  return the modified image  easy depth-first search 
c# dfs solution flood fill an image is represented by a 2-d array of integers  each integer representing the pixel value of the image (from 0 to 65535)  given a coordinate (sr  sc) representing the starting pixel (row and column) of the flood fill  and a pixel value newcolor  "flood fill" the image  to perform a "flood fill"  consider the starting pixel  plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel  plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel)  and so on  replace the color of all of the aforementioned pixels with the newcolor  at the end  return the modified image  easy depth-first search 
java easy bfs flood fill an image is represented by a 2-d array of integers  each integer representing the pixel value of the image (from 0 to 65535)  given a coordinate (sr  sc) representing the starting pixel (row and column) of the flood fill  and a pixel value newcolor  "flood fill" the image  to perform a "flood fill"  consider the starting pixel  plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel  plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel)  and so on  replace the color of all of the aforementioned pixels with the newcolor  at the end  return the modified image  easy depth-first search 
[java c++] clean code asteroid collision we are given an array asteroids of integers representing asteroids in a row  for each asteroid  the absolute value represents its size  and the sign represents its direction (positive meaning right  negative meaning left)  each asteroid moves at the same speed  find out the state of the asteroids after all collisions  if two asteroids meet  the smaller one will explode  if both are the same size  both will explode  two asteroids moving in the same direction will never meet  medium stack 
python o(n) stack-based with explanation asteroid collision we are given an array asteroids of integers representing asteroids in a row  for each asteroid  the absolute value represents its size  and the sign represents its direction (positive meaning right  negative meaning left)  each asteroid moves at the same speed  find out the state of the asteroids after all collisions  if two asteroids meet  the smaller one will explode  if both are the same size  both will explode  two asteroids moving in the same direction will never meet  medium stack 
java solution  stack asteroid collision we are given an array asteroids of integers representing asteroids in a row  for each asteroid  the absolute value represents its size  and the sign represents its direction (positive meaning right  negative meaning left)  each asteroid moves at the same speed  find out the state of the asteroids after all collisions  if two asteroids meet  the smaller one will explode  if both are the same size  both will explode  two asteroids moving in the same direction will never meet  medium stack 
java solution - beat 90% - no extra space  asteroid collision we are given an array asteroids of integers representing asteroids in a row  for each asteroid  the absolute value represents its size  and the sign represents its direction (positive meaning right  negative meaning left)  each asteroid moves at the same speed  find out the state of the asteroids after all collisions  if two asteroids meet  the smaller one will explode  if both are the same size  both will explode  two asteroids moving in the same direction will never meet  medium stack 
stack java solution asteroid collision we are given an array asteroids of integers representing asteroids in a row  for each asteroid  the absolute value represents its size  and the sign represents its direction (positive meaning right  negative meaning left)  each asteroid moves at the same speed  find out the state of the asteroids after all collisions  if two asteroids meet  the smaller one will explode  if both are the same size  both will explode  two asteroids moving in the same direction will never meet  medium stack 
c++ recursion solution with explaination parse lisp expression you are given a string expression representing a lisp-like expression to return the integer value of  the syntax for these expressions is given as follows  an expression is either an integer  a let-expression  an add-expression  a mult-expression  or an assigned variable  expressions always evaluate to a single integer  (an integer could be positive or negative ) a let-expression takes the form (let v1 e1 v2 e2     vn en expr)  where let is always the string "let"  then there are 1 or more pairs of alternating variables and expressions  meaning that the first variable v1 is assigned the value of the expression e1  the second variable v2 is assigned the value of the expression e2  and so on sequentially; and then the value of this let-expression is the value of the expression expr  an add-expression takes the form (add e1 e2) where add is always the string "add"  there are always two expressions e1  e2  and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2  a mult-expression takes the form (mult e1 e2) where mult is always the string "mult"  there are always two expressions e1  e2  and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2  for the purposes of this question  we will use a smaller subset of variable names  a variable starts with a lowercase letter  then zero or more lowercase letters or digits  additionally for your convenience  the names "add"  "let"  or "mult" are protected and will never be used as variable names  finally  there is the concept of scope  when an expression of a variable name is evaluated  within the context of that evaluation  the innermost scope (in terms of parentheses) is checked first for the value of that variable  and then outer scopes are checked sequentially  it is guaranteed that every expression is legal  please see the hard string 
i don't think this problem is good one for interview to be honest parse lisp expression you are given a string expression representing a lisp-like expression to return the integer value of  the syntax for these expressions is given as follows  an expression is either an integer  a let-expression  an add-expression  a mult-expression  or an assigned variable  expressions always evaluate to a single integer  (an integer could be positive or negative ) a let-expression takes the form (let v1 e1 v2 e2     vn en expr)  where let is always the string "let"  then there are 1 or more pairs of alternating variables and expressions  meaning that the first variable v1 is assigned the value of the expression e1  the second variable v2 is assigned the value of the expression e2  and so on sequentially; and then the value of this let-expression is the value of the expression expr  an add-expression takes the form (add e1 e2) where add is always the string "add"  there are always two expressions e1  e2  and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2  a mult-expression takes the form (mult e1 e2) where mult is always the string "mult"  there are always two expressions e1  e2  and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2  for the purposes of this question  we will use a smaller subset of variable names  a variable starts with a lowercase letter  then zero or more lowercase letters or digits  additionally for your convenience  the names "add"  "let"  or "mult" are protected and will never be used as variable names  finally  there is the concept of scope  when an expression of a variable name is evaluated  within the context of that evaluation  the innermost scope (in terms of parentheses) is checked first for the value of that variable  and then outer scopes are checked sequentially  it is guaranteed that every expression is legal  please see the hard string 
python solution using stacks  parse lisp expression you are given a string expression representing a lisp-like expression to return the integer value of  the syntax for these expressions is given as follows  an expression is either an integer  a let-expression  an add-expression  a mult-expression  or an assigned variable  expressions always evaluate to a single integer  (an integer could be positive or negative ) a let-expression takes the form (let v1 e1 v2 e2     vn en expr)  where let is always the string "let"  then there are 1 or more pairs of alternating variables and expressions  meaning that the first variable v1 is assigned the value of the expression e1  the second variable v2 is assigned the value of the expression e2  and so on sequentially; and then the value of this let-expression is the value of the expression expr  an add-expression takes the form (add e1 e2) where add is always the string "add"  there are always two expressions e1  e2  and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2  a mult-expression takes the form (mult e1 e2) where mult is always the string "mult"  there are always two expressions e1  e2  and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2  for the purposes of this question  we will use a smaller subset of variable names  a variable starts with a lowercase letter  then zero or more lowercase letters or digits  additionally for your convenience  the names "add"  "let"  or "mult" are protected and will never be used as variable names  finally  there is the concept of scope  when an expression of a variable name is evaluated  within the context of that evaluation  the innermost scope (in terms of parentheses) is checked first for the value of that variable  and then outer scopes are checked sequentially  it is guaranteed that every expression is legal  please see the hard string 
a clean java solution parse lisp expression you are given a string expression representing a lisp-like expression to return the integer value of  the syntax for these expressions is given as follows  an expression is either an integer  a let-expression  an add-expression  a mult-expression  or an assigned variable  expressions always evaluate to a single integer  (an integer could be positive or negative ) a let-expression takes the form (let v1 e1 v2 e2     vn en expr)  where let is always the string "let"  then there are 1 or more pairs of alternating variables and expressions  meaning that the first variable v1 is assigned the value of the expression e1  the second variable v2 is assigned the value of the expression e2  and so on sequentially; and then the value of this let-expression is the value of the expression expr  an add-expression takes the form (add e1 e2) where add is always the string "add"  there are always two expressions e1  e2  and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2  a mult-expression takes the form (mult e1 e2) where mult is always the string "mult"  there are always two expressions e1  e2  and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2  for the purposes of this question  we will use a smaller subset of variable names  a variable starts with a lowercase letter  then zero or more lowercase letters or digits  additionally for your convenience  the names "add"  "let"  or "mult" are protected and will never be used as variable names  finally  there is the concept of scope  when an expression of a variable name is evaluated  within the context of that evaluation  the innermost scope (in terms of parentheses) is checked first for the value of that variable  and then outer scopes are checked sequentially  it is guaranteed that every expression is legal  please see the hard string 
java modularized solution parse lisp expression you are given a string expression representing a lisp-like expression to return the integer value of  the syntax for these expressions is given as follows  an expression is either an integer  a let-expression  an add-expression  a mult-expression  or an assigned variable  expressions always evaluate to a single integer  (an integer could be positive or negative ) a let-expression takes the form (let v1 e1 v2 e2     vn en expr)  where let is always the string "let"  then there are 1 or more pairs of alternating variables and expressions  meaning that the first variable v1 is assigned the value of the expression e1  the second variable v2 is assigned the value of the expression e2  and so on sequentially; and then the value of this let-expression is the value of the expression expr  an add-expression takes the form (add e1 e2) where add is always the string "add"  there are always two expressions e1  e2  and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2  a mult-expression takes the form (mult e1 e2) where mult is always the string "mult"  there are always two expressions e1  e2  and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2  for the purposes of this question  we will use a smaller subset of variable names  a variable starts with a lowercase letter  then zero or more lowercase letters or digits  additionally for your convenience  the names "add"  "let"  or "mult" are protected and will never be used as variable names  finally  there is the concept of scope  when an expression of a variable name is evaluated  within the context of that evaluation  the innermost scope (in terms of parentheses) is checked first for the value of that variable  and then outer scopes are checked sequentially  it is guaranteed that every expression is legal  please see the hard string 
simple and very short c++ solution monotone increasing digits given a non-negative integer n  find the largest number that is less than or equal to n with monotone increasing digits  (recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y ) medium greedy 
simple python solution w  explanation monotone increasing digits given a non-negative integer n  find the largest number that is less than or equal to n with monotone increasing digits  (recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y ) medium greedy 
simple and very short java solution monotone increasing digits given a non-negative integer n  find the largest number that is less than or equal to n with monotone increasing digits  (recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y ) medium greedy 
easy java monotone increasing digits given a non-negative integer n  find the largest number that is less than or equal to n with monotone increasing digits  (recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y ) medium greedy 
simple java solution with clear explanation  very easy to understand  monotone increasing digits given a non-negative integer n  find the largest number that is less than or equal to n with monotone increasing digits  (recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y ) medium greedy 
[java] easy ac solution with stack daily temperatures given a list of daily temperatures t  return a list such that  for each day in the input  tells you how many days you would have to wait until a warmer temperature  if there is no future day for which this is possible  put 0 instead  for medium hash table stack 
[c++] clean code with explanation: o(n) time and o(1) space (beats 99 13%) daily temperatures given a list of daily temperatures t  return a list such that  for each day in the input  tells you how many days you would have to wait until a warmer temperature  if there is no future day for which this is possible  put 0 instead  for medium hash table stack 
elegant python solution with stack daily temperatures given a list of daily temperatures t  return a list such that  for each day in the input  tells you how many days you would have to wait until a warmer temperature  if there is no future day for which this is possible  put 0 instead  for medium hash table stack 
javascript stack solution with explaination daily temperatures given a list of daily temperatures t  return a list such that  for each day in the input  tells you how many days you would have to wait until a warmer temperature  if there is no future day for which this is possible  put 0 instead  for medium hash table stack 
simple python by hashing the temperatures daily temperatures given a list of daily temperatures t  return a list such that  for each day in the input  tells you how many days you would have to wait until a warmer temperature  if there is no future day for which this is possible  put 0 instead  for medium hash table stack 
[java c++] clean code with explanation delete and earn given an array nums of integers  you can perform operations on the array  in each operation  you pick any nums[i] and delete it to earn nums[i] points  after  you must delete every element equal to nums[i] - 1 or nums[i] + 1  you start with 0 points  return the maximum number of points you can earn by applying such operations  medium dynamic programming 
awesome python 4-liner with explanation - reduce to house robbers question  u0001f31d delete and earn given an array nums of integers  you can perform operations on the array  in each operation  you pick any nums[i] and delete it to earn nums[i] points  after  you must delete every element equal to nums[i] - 1 or nums[i] + 1  you start with 0 points  return the maximum number of points you can earn by applying such operations  medium dynamic programming 
sharing my simple straight forward java o(n) solution -- explanation included delete and earn given an array nums of integers  you can perform operations on the array  in each operation  you pick any nums[i] and delete it to earn nums[i] points  after  you must delete every element equal to nums[i] - 1 or nums[i] + 1  you start with 0 points  return the maximum number of points you can earn by applying such operations  medium dynamic programming 
[java] easy dp solution delete and earn given an array nums of integers  you can perform operations on the array  in each operation  you pick any nums[i] and delete it to earn nums[i] points  after  you must delete every element equal to nums[i] - 1 or nums[i] + 1  you start with 0 points  return the maximum number of points you can earn by applying such operations  medium dynamic programming 
java ------ 4 lines delete and earn given an array nums of integers  you can perform operations on the array  in each operation  you pick any nums[i] and delete it to earn nums[i] points  after  you must delete every element equal to nums[i] - 1 or nums[i] + 1  you start with 0 points  return the maximum number of points you can earn by applying such operations  medium dynamic programming 
step by step guidance of the o(n^3) time and o(n^2) space solution cherry pickup in a n x n grid representing a field of cherries  each cell is one of three possible integers  0 means the cell is empty  so you can pass through; 1 means the cell contains a cherry  that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way  your task is to collect maximum number of cherries possible by following the rules below: starting at the position (0  0) and reaching (n-1  n-1) by moving right or down through valid path cells (cells with value 0 or 1); after reaching (n-1  n-1)  returning to (0  0) by moving left or up through valid path cells; when passing through a path cell containing a cherry  you pick it up and the cell becomes an empty cell (0); if there is no valid path between (0  0) and (n-1  n-1)  then no cherries can be collected  hard dynamic programming 
annotated c++ dp solution cherry pickup in a n x n grid representing a field of cherries  each cell is one of three possible integers  0 means the cell is empty  so you can pass through; 1 means the cell contains a cherry  that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way  your task is to collect maximum number of cherries possible by following the rules below: starting at the position (0  0) and reaching (n-1  n-1) by moving right or down through valid path cells (cells with value 0 or 1); after reaching (n-1  n-1)  returning to (0  0) by moving left or up through valid path cells; when passing through a path cell containing a cherry  you pick it up and the cell becomes an empty cell (0); if there is no valid path between (0  0) and (n-1  n-1)  then no cherries can be collected  hard dynamic programming 
c++ dp solution cherry pickup in a n x n grid representing a field of cherries  each cell is one of three possible integers  0 means the cell is empty  so you can pass through; 1 means the cell contains a cherry  that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way  your task is to collect maximum number of cherries possible by following the rules below: starting at the position (0  0) and reaching (n-1  n-1) by moving right or down through valid path cells (cells with value 0 or 1); after reaching (n-1  n-1)  returning to (0  0) by moving left or up through valid path cells; when passing through a path cell containing a cherry  you pick it up and the cell becomes an empty cell (0); if there is no valid path between (0  0) and (n-1  n-1)  then no cherries can be collected  hard dynamic programming 
java o(n^3) dp solution w  specific explanation cherry pickup in a n x n grid representing a field of cherries  each cell is one of three possible integers  0 means the cell is empty  so you can pass through; 1 means the cell contains a cherry  that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way  your task is to collect maximum number of cherries possible by following the rules below: starting at the position (0  0) and reaching (n-1  n-1) by moving right or down through valid path cells (cells with value 0 or 1); after reaching (n-1  n-1)  returning to (0  0) by moving left or up through valid path cells; when passing through a path cell containing a cherry  you pick it up and the cell becomes an empty cell (0); if there is no valid path between (0  0) and (n-1  n-1)  then no cherries can be collected  hard dynamic programming 
python clean&commented o(n^3) dp cherry pickup in a n x n grid representing a field of cherries  each cell is one of three possible integers  0 means the cell is empty  so you can pass through; 1 means the cell contains a cherry  that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way  your task is to collect maximum number of cherries possible by following the rules below: starting at the position (0  0) and reaching (n-1  n-1) by moving right or down through valid path cells (cells with value 0 or 1); after reaching (n-1  n-1)  returning to (0  0) by moving left or up through valid path cells; when passing through a path cell containing a cherry  you pick it up and the cell becomes an empty cell (0); if there is no valid path between (0  0) and (n-1  n-1)  then no cherries can be collected  hard dynamic programming 
[c++] bellman ford network delay time there are n network nodes  labelled 1 to n  given times  a list of travel times as directed edges times[i] = (u  v  w)  where u is the source node  v is the target node  and w is the time it takes for a signal to travel from source to target  now  we send a signal from a certain node k  how long will it take for all nodes to receive the signal? if it is impossible  return -1  note: n will be in the range [1  100]  k will be in the range [1  n]  the length of times will be in the range [1  6000]  all edges times[i] = (u  v  w) will have 1 <= u  v <= n and 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
simple java djikstra's (priorityqueue optimized) solution with explanation network delay time there are n network nodes  labelled 1 to n  given times  a list of travel times as directed edges times[i] = (u  v  w)  where u is the source node  v is the target node  and w is the time it takes for a signal to travel from source to target  now  we send a signal from a certain node k  how long will it take for all nodes to receive the signal? if it is impossible  return -1  note: n will be in the range [1  100]  k will be in the range [1  n]  the length of times will be in the range [1  6000]  all edges times[i] = (u  v  w) will have 1 <= u  v <= n and 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
oj was testing out of given conditions  network delay time there are n network nodes  labelled 1 to n  given times  a list of travel times as directed edges times[i] = (u  v  w)  where u is the source node  v is the target node  and w is the time it takes for a signal to travel from source to target  now  we send a signal from a certain node k  how long will it take for all nodes to receive the signal? if it is impossible  return -1  note: n will be in the range [1  100]  k will be in the range [1  n]  the length of times will be in the range [1  6000]  all edges times[i] = (u  v  w) will have 1 <= u  v <= n and 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
straightforward python dijkstra's  u0001f60c network delay time there are n network nodes  labelled 1 to n  given times  a list of travel times as directed edges times[i] = (u  v  w)  where u is the source node  v is the target node  and w is the time it takes for a signal to travel from source to target  now  we send a signal from a certain node k  how long will it take for all nodes to receive the signal? if it is impossible  return -1  note: n will be in the range [1  100]  k will be in the range [1  n]  the length of times will be in the range [1  6000]  all edges times[i] = (u  v  w) will have 1 <= u  v <= n and 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
simple java solution using bfs (similar to dijkstra's shortest path algorithm) with explanation network delay time there are n network nodes  labelled 1 to n  given times  a list of travel times as directed edges times[i] = (u  v  w)  where u is the source node  v is the target node  and w is the time it takes for a signal to travel from source to target  now  we send a signal from a certain node k  how long will it take for all nodes to receive the signal? if it is impossible  return -1  note: n will be in the range [1  100]  k will be in the range [1  n]  the length of times will be in the range [1  6000]  all edges times[i] = (u  v  w) will have 1 <= u  v <= n and 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
easy binary search in java - o(log(n)) time find smallest letter greater than target given a list of sorted characters letters containing only lowercase letters  and given a target letter target  find the smallest element in the list that is larger than the given target  letters also wrap around  for easy binary search 
python no brainer!  u0001f921 find smallest letter greater than target given a list of sorted characters letters containing only lowercase letters  and given a target letter target  find the smallest element in the list that is larger than the given target  letters also wrap around  for easy binary search 
[c++] 2 lines solution using upper_bound find smallest letter greater than target given a list of sorted characters letters containing only lowercase letters  and given a target letter target  find the smallest element in the list that is larger than the given target  letters also wrap around  for easy binary search 
java 2 lines o(log n) find smallest letter greater than target given a list of sorted characters letters containing only lowercase letters  and given a target letter target  find the smallest element in the list that is larger than the given target  letters also wrap around  for easy binary search 
java binary search find smallest letter greater than target given a list of sorted characters letters containing only lowercase letters  and given a target letter target  find the smallest element in the list that is larger than the given target  letters also wrap around  for easy binary search 
three ways to solve this problem in java prefix and suffix search given many words  words[i] has weight i  design a class wordfilter that supports one function  wordfilter f(string prefix  string suffix)  it will return the word with given prefix and suffix with maximum weight  if no word exists  return -1  hard trie 
python few ways to do it  with explanations!  u0001f389 prefix and suffix search given many words  words[i] has weight i  design a class wordfilter that supports one function  wordfilter f(string prefix  string suffix)  it will return the word with given prefix and suffix with maximum weight  if no word exists  return -1  hard trie 
java beat 95%  just small modifications in implementing trie  prefix and suffix search given many words  words[i] has weight i  design a class wordfilter that supports one function  wordfilter f(string prefix  string suffix)  it will return the word with given prefix and suffix with maximum weight  if no word exists  return -1  hard trie 
accepted java code  using trie prefix and suffix search given many words  words[i] has weight i  design a class wordfilter that supports one function  wordfilter f(string prefix  string suffix)  it will return the word with given prefix and suffix with maximum weight  if no word exists  return -1  hard trie 
c++ solution using two trie  time & memory efficient  prefix and suffix search given many words  words[i] has weight i  design a class wordfilter that supports one function  wordfilter f(string prefix  string suffix)  it will return the word with given prefix and suffix with maximum weight  if no word exists  return -1  hard trie 
easy to understand c++ using dp with detailed explanation min cost climbing stairs on a staircase  the i-th step has some non-negative cost cost[i] assigned (0 indexed)  once you pay the cost  you can either climb one or two steps  you need to find minimum cost to reach the top of the floor  and you can either start from the step with index 0  or the step with index 1  easy array dynamic programming 
3 lines java solution - o(1) space min cost climbing stairs on a staircase  the i-th step has some non-negative cost cost[i] assigned (0 indexed)  once you pay the cost  you can either climb one or two steps  you need to find minimum cost to reach the top of the floor  and you can either start from the step with index 0  or the step with index 1  easy array dynamic programming 
easy to understand - python solution - o(1) space min cost climbing stairs on a staircase  the i-th step has some non-negative cost cost[i] assigned (0 indexed)  once you pay the cost  you can either climb one or two steps  you need to find minimum cost to reach the top of the floor  and you can either start from the step with index 0  or the step with index 1  easy array dynamic programming 
doubt ?? min cost climbing stairs on a staircase  the i-th step has some non-negative cost cost[i] assigned (0 indexed)  once you pay the cost  you can either climb one or two steps  you need to find minimum cost to reach the top of the floor  and you can either start from the step with index 0  or the step with index 1  easy array dynamic programming 
simple python solution min cost climbing stairs on a staircase  the i-th step has some non-negative cost cost[i] assigned (0 indexed)  once you pay the cost  you can either climb one or two steps  you need to find minimum cost to reach the top of the floor  and you can either start from the step with index 0  or the step with index 1  easy array dynamic programming 
python o(n) time and o(1) space without fancy builtins largest number at least twice of others in a given integer array nums  there is always exactly one largest element  find whether the largest element in the array is at least twice as much as every other number in the array  if it is  return the index of the largest element  otherwise return -1  easy array 
[java] one pass solution o(n) complexity largest number at least twice of others in a given integer array nums  there is always exactly one largest element  find whether the largest element in the array is at least twice as much as every other number in the array  if it is  return the index of the largest element  otherwise return -1  easy array 
one pass o(n) java solution 9ms 100% largest number at least twice of others in a given integer array nums  there is always exactly one largest element  find whether the largest element in the array is at least twice as much as every other number in the array  if it is  return the index of the largest element  otherwise return -1  easy array 
my c++ solution largest number at least twice of others in a given integer array nums  there is always exactly one largest element  find whether the largest element in the array is at least twice as much as every other number in the array  if it is  return the index of the largest element  otherwise return -1  easy array 
[java]-fetch two largest values  one pass tc-o(n)  sc-o(1) largest number at least twice of others in a given integer array nums  there is always exactly one largest element  find whether the largest element in the array is at least twice as much as every other number in the array  if it is  return the index of the largest element  otherwise return -1  easy array 
java 6ms beats 100% prime numbers shortest completing word find the minimum length word from a given dictionary words  which has all the letters from the string licenseplate  such a word is said to complete the given string licenseplate here  for letters we ignore case  for easy hash table 
java solution using character array shortest completing word find the minimum length word from a given dictionary words  which has all the letters from the string licenseplate  such a word is said to complete the given string licenseplate here  for letters we ignore case  for easy hash table 
python solutions shortest completing word find the minimum length word from a given dictionary words  which has all the letters from the string licenseplate  such a word is said to complete the given string licenseplate here  for letters we ignore case  for easy hash table 
java solution 17ms using char array shortest completing word find the minimum length word from a given dictionary words  which has all the letters from the string licenseplate  such a word is said to complete the given string licenseplate here  for letters we ignore case  for easy hash table 
easy java shortest completing word find the minimum length word from a given dictionary words  which has all the letters from the string licenseplate  such a word is said to complete the given string licenseplate here  for letters we ignore case  for easy hash table 
funniest output answer i've ever seen on leetcode contain virus a virus is spreading rapidly  and your task is to quarantine the infected area by installing walls  the world is modeled as a 2-d array of cells  where 0 represents uninfected cells  and 1 represents cells contaminated with the virus  a wall (and only one wall) can be installed between any two 4-directionally adjacent cells  on the shared boundary  every night  the virus spreads to all neighboring cells in all four directions unless blocked by a wall  resources are limited  each day  you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night  there will never be a tie  can you save the day? if so  what is the number of walls required? if not  and the world becomes fully infected  return the number of walls used  hard depth-first search 
c++  dfs  12ms contain virus a virus is spreading rapidly  and your task is to quarantine the infected area by installing walls  the world is modeled as a 2-d array of cells  where 0 represents uninfected cells  and 1 represents cells contaminated with the virus  a wall (and only one wall) can be installed between any two 4-directionally adjacent cells  on the shared boundary  every night  the virus spreads to all neighboring cells in all four directions unless blocked by a wall  resources are limited  each day  you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night  there will never be a tie  can you save the day? if so  what is the number of walls required? if not  and the world becomes fully infected  return the number of walls used  hard depth-first search 
my neat java solution using dfs contain virus a virus is spreading rapidly  and your task is to quarantine the infected area by installing walls  the world is modeled as a 2-d array of cells  where 0 represents uninfected cells  and 1 represents cells contaminated with the virus  a wall (and only one wall) can be installed between any two 4-directionally adjacent cells  on the shared boundary  every night  the virus spreads to all neighboring cells in all four directions unless blocked by a wall  resources are limited  each day  you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night  there will never be a tie  can you save the day? if so  what is the number of walls required? if not  and the world becomes fully infected  return the number of walls used  hard depth-first search 
after a region is quarantined  is it still considered continuous with other regions? contain virus a virus is spreading rapidly  and your task is to quarantine the infected area by installing walls  the world is modeled as a 2-d array of cells  where 0 represents uninfected cells  and 1 represents cells contaminated with the virus  a wall (and only one wall) can be installed between any two 4-directionally adjacent cells  on the shared boundary  every night  the virus spreads to all neighboring cells in all four directions unless blocked by a wall  resources are limited  each day  you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night  there will never be a tie  can you save the day? if so  what is the number of walls required? if not  and the world becomes fully infected  return the number of walls used  hard depth-first search 
did the problem logic change during the contest? contain virus a virus is spreading rapidly  and your task is to quarantine the infected area by installing walls  the world is modeled as a 2-d array of cells  where 0 represents uninfected cells  and 1 represents cells contaminated with the virus  a wall (and only one wall) can be installed between any two 4-directionally adjacent cells  on the shared boundary  every night  the virus spreads to all neighboring cells in all four directions unless blocked by a wall  resources are limited  each day  you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night  there will never be a tie  can you save the day? if so  what is the number of walls required? if not  and the world becomes fully infected  return the number of walls used  hard depth-first search 
regular java bfs solution and 2-end bfs solution with improvement open the lock you have a lock in front of you with 4 circular wheels  each wheel has 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  the wheels can rotate freely and wrap around: for medium breadth-first search 
bfs solution c++ open the lock you have a lock in front of you with 4 circular wheels  each wheel has 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  the wheels can rotate freely and wrap around: for medium breadth-first search 
accepted python java bfs  + how to avoid tle open the lock you have a lock in front of you with 4 circular wheels  each wheel has 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  the wheels can rotate freely and wrap around: for medium breadth-first search 
why wrong answer? open the lock you have a lock in front of you with 4 circular wheels  each wheel has 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  the wheels can rotate freely and wrap around: for medium breadth-first search 
python 16 lines    simple and readable    bfs solution    beats 94 % open the lock you have a lock in front of you with 4 circular wheels  each wheel has 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  the wheels can rotate freely and wrap around: for medium breadth-first search 
short java solution with explanation reach a number you are standing at position 0 on an infinite number line  there is a goal at position target  on each move  you can either go left or right  during the n-th move (starting from 1)  you take n steps  return the minimum number of steps required to reach the destination  easy math 
c++ o(1) solution  without loop reach a number you are standing at position 0 on an infinite number line  there is a goal at position target  on each move  you can either go left or right  during the n-th move (starting from 1)  you take n steps  return the minimum number of steps required to reach the destination  easy math 
not an easy reach a number you are standing at position 0 on an infinite number line  there is a goal at position target  on each move  you can either go left or right  during the n-th move (starting from 1)  you take n steps  return the minimum number of steps required to reach the destination  easy math 
concise python with explanation and example reach a number you are standing at position 0 on an infinite number line  there is a goal at position target  on each move  you can either go left or right  during the n-th move (starting from 1)  you take n steps  return the minimum number of steps required to reach the destination  easy math 
learn from other with my explanations  reach a number you are standing at position 0 on an infinite number line  there is a goal at position target  on each move  you can either go left or right  during the n-th move (starting from 1)  you take n steps  return the minimum number of steps required to reach the destination  easy math 
java solution - map + backtracking pyramid transition matrix we are stacking blocks to form a pyramid  each block has a color which is a one letter string  like `'z'`  for every block of color `c` we place not in the bottom row  we are placing it on top of a left block of color `a` and right block of color `b`  we are allowed to place the block there only if `(a  b  c)` is an allowed triple  we start with a bottom row of bottom  represented as a single string  we also start with a list of allowed triples allowed  each allowed triple is represented as a string of length 3  return true if we can build the pyramid all the way to the top  otherwise false  medium bit manipulation depth-first search 
counter example to the standard code pyramid transition matrix we are stacking blocks to form a pyramid  each block has a color which is a one letter string  like `'z'`  for every block of color `c` we place not in the bottom row  we are placing it on top of a left block of color `a` and right block of color `b`  we are allowed to place the block there only if `(a  b  c)` is an allowed triple  we start with a bottom row of bottom  represented as a single string  we also start with a list of allowed triples allowed  each allowed triple is represented as a string of length 3  return true if we can build the pyramid all the way to the top  otherwise false  medium bit manipulation depth-first search 
c++ passed counter example  dfs with memoization  6 ms pyramid transition matrix we are stacking blocks to form a pyramid  each block has a color which is a one letter string  like `'z'`  for every block of color `c` we place not in the bottom row  we are placing it on top of a left block of color `a` and right block of color `b`  we are allowed to place the block there only if `(a  b  c)` is an allowed triple  we start with a bottom row of bottom  represented as a single string  we also start with a list of allowed triples allowed  each allowed triple is represented as a string of length 3  return true if we can build the pyramid all the way to the top  otherwise false  medium bit manipulation depth-first search 
easy and concise python solution pyramid transition matrix we are stacking blocks to form a pyramid  each block has a color which is a one letter string  like `'z'`  for every block of color `c` we place not in the bottom row  we are placing it on top of a left block of color `a` and right block of color `b`  we are allowed to place the block there only if `(a  b  c)` is an allowed triple  we start with a bottom row of bottom  represented as a single string  we also start with a list of allowed triples allowed  each allowed triple is represented as a string of length 3  return true if we can build the pyramid all the way to the top  otherwise false  medium bit manipulation depth-first search 
dp o(n^2   m) pyramid transition matrix we are stacking blocks to form a pyramid  each block has a color which is a one letter string  like `'z'`  for every block of color `c` we place not in the bottom row  we are placing it on top of a left block of color `a` and right block of color `b`  we are allowed to place the block there only if `(a  b  c)` is an allowed triple  we start with a bottom row of bottom  represented as a single string  we also start with a list of allowed triples allowed  each allowed triple is represented as a string of length 3  return true if we can build the pyramid all the way to the top  otherwise false  medium bit manipulation depth-first search 
ever wonder why the greedy algorithm works? here is the explanation! set intersection size at least two an integer interval [a  b] (for integers a < b) is a set of all consecutive integers from a to b  including a and b  find the minimum size of a set s such that for every integer interval a in intervals  the intersection of s with a has size at least 2  hard greedy 
java o(nlogn) solution  greedy set intersection size at least two an integer interval [a  b] (for integers a < b) is a set of all consecutive integers from a to b  including a and b  find the minimum size of a set s such that for every integer interval a in intervals  the intersection of s with a has size at least 2  hard greedy 
c++ concise solution  o(nlogn) greedy  39 ms set intersection size at least two an integer interval [a  b] (for integers a < b) is a set of all consecutive integers from a to b  including a and b  find the minimum size of a set s such that for every integer interval a in intervals  the intersection of s with a has size at least 2  hard greedy 
hope you enjoy this problem  : )  o(nlogn) java greedy  easy to understand solution set intersection size at least two an integer interval [a  b] (for integers a < b) is a set of all consecutive integers from a to b  including a and b  find the minimum size of a set s such that for every integer interval a in intervals  the intersection of s with a has size at least 2  hard greedy 
c++ greedy o(nlogn) with explanations set intersection size at least two an integer interval [a  b] (for integers a < b) is a set of all consecutive integers from a to b  including a and b  find the minimum size of a set s such that for every integer interval a in intervals  the intersection of s with a has size at least 2  hard greedy 
easy and concise solution with explanation [c++ java python] special binary string special binary strings are binary strings with the following two properties: the number of 0's is equal to the number of 1's  every prefix of the binary string has at least as many 1's as 0's  given a special string s  a move consists of choosing two consecutive  non-empty  special substrings of s  and swapping them  (two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string ) at the end of any number of moves  what is the lexicographically largest resulting string possible? hard string recursion 
think of it as valid-parentheses special binary string special binary strings are binary strings with the following two properties: the number of 0's is equal to the number of 1's  every prefix of the binary string has at least as many 1's as 0's  given a special string s  a move consists of choosing two consecutive  non-empty  special substrings of s  and swapping them  (two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string ) at the end of any number of moves  what is the lexicographically largest resulting string possible? hard string recursion 
what is the definition of "special"? special binary string special binary strings are binary strings with the following two properties: the number of 0's is equal to the number of 1's  every prefix of the binary string has at least as many 1's as 0's  given a special string s  a move consists of choosing two consecutive  non-empty  special substrings of s  and swapping them  (two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string ) at the end of any number of moves  what is the lexicographically largest resulting string possible? hard string recursion 
logical thinking with clear code special binary string special binary strings are binary strings with the following two properties: the number of 0's is equal to the number of 1's  every prefix of the binary string has at least as many 1's as 0's  given a special string s  a move consists of choosing two consecutive  non-empty  special substrings of s  and swapping them  (two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string ) at the end of any number of moves  what is the lexicographically largest resulting string possible? hard string recursion 
sharing my simple   easy to understand straight forward java solution special binary string special binary strings are binary strings with the following two properties: the number of 0's is equal to the number of 1's  every prefix of the binary string has at least as many 1's as 0's  given a special string s  a move consists of choosing two consecutive  non-empty  special substrings of s  and swapping them  (two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string ) at the end of any number of moves  what is the lexicographically largest resulting string possible? hard string recursion 
665772 prime number of set bits in binary representation given two integers l and r  find the count of numbers in the range [l  r] (inclusive) having a prime number of set bits in their binary representation  (recall that the number of set bits an integer has is the number of 1s present when written in binary  for easy bit manipulation 
[java c++] clean code prime number of set bits in binary representation given two integers l and r  find the count of numbers in the range [l  r] (inclusive) having a prime number of set bits in their binary representation  (recall that the number of set bits an integer has is the number of 1s present when written in binary  for easy bit manipulation 
easy o(n) java solution using dp prime number of set bits in binary representation given two integers l and r  find the count of numbers in the range [l  r] (inclusive) having a prime number of set bits in their binary representation  (recall that the number of set bits an integer has is the number of 1s present when written in binary  for easy bit manipulation 
sort easy python prime number of set bits in binary representation given two integers l and r  find the count of numbers in the range [l  r] (inclusive) having a prime number of set bits in their binary representation  (recall that the number of set bits an integer has is the number of 1s present when written in binary  for easy bit manipulation 
python 1 line prime number of set bits in binary representation given two integers l and r  find the count of numbers in the range [l  r] (inclusive) having a prime number of set bits in their binary representation  (recall that the number of set bits an integer has is the number of 1s present when written in binary  for easy bit manipulation 
java 2 pass o(n) time o(1) space  extending end pointer solution partition labels a string s of lowercase letters is given  we want to partition this string into as many parts as possible so that each letter appears in at most one part  and return a list of integers representing the size of these parts  medium two pointers greedy 
short easy python partition labels a string s of lowercase letters is given  we want to partition this string into as many parts as possible so that each letter appears in at most one part  and return a list of integers representing the size of these parts  medium two pointers greedy 
c++ 6 lines o(n)   o(1) - two simple passes partition labels a string s of lowercase letters is given  we want to partition this string into as many parts as possible so that each letter appears in at most one part  and return a list of integers representing the size of these parts  medium two pointers greedy 
easy o(n) java solution using sliding window (two pointers)  comments and explanation given partition labels a string s of lowercase letters is given  we want to partition this string into as many parts as possible so that each letter appears in at most one part  and return a list of integers representing the size of these parts  medium two pointers greedy 
java very short and easy solution partition labels a string s of lowercase letters is given  we want to partition this string into as many parts as possible so that each letter appears in at most one part  and return a list of integers representing the size of these parts  medium two pointers greedy 
java c++ python o(n^2) solution using only one grid matrix largest plus sign in a 2d grid from (0  0) to (n-1  n-1)  every cell contains a 1  except those cells in the given list mines which are 0  what is the largest axis-aligned plus sign of 1s contained in the grid? return the order of the plus sign  if there is none  return 0  an "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up  down  left  and right  and made of 1s  this is demonstrated in the diagrams below  note that there could be 0s or 1s beyond the arms of the plus sign  only the relevant area of the plus sign is checked for 1s  medium dynamic programming 
easy to understand java solution largest plus sign in a 2d grid from (0  0) to (n-1  n-1)  every cell contains a 1  except those cells in the given list mines which are 0  what is the largest axis-aligned plus sign of 1s contained in the grid? return the order of the plus sign  if there is none  return 0  an "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up  down  left  and right  and made of 1s  this is demonstrated in the diagrams below  note that there could be 0s or 1s beyond the arms of the plus sign  only the relevant area of the plus sign is checked for 1s  medium dynamic programming 
python 250ms solution largest plus sign in a 2d grid from (0  0) to (n-1  n-1)  every cell contains a 1  except those cells in the given list mines which are 0  what is the largest axis-aligned plus sign of 1s contained in the grid? return the order of the plus sign  if there is none  return 0  an "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up  down  left  and right  and made of 1s  this is demonstrated in the diagrams below  note that there could be 0s or 1s beyond the arms of the plus sign  only the relevant area of the plus sign is checked for 1s  medium dynamic programming 
my simple o(n^2) time and o(n^2) space accepted solution 150ms largest plus sign in a 2d grid from (0  0) to (n-1  n-1)  every cell contains a 1  except those cells in the given list mines which are 0  what is the largest axis-aligned plus sign of 1s contained in the grid? return the order of the plus sign  if there is none  return 0  an "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up  down  left  and right  and made of 1s  this is demonstrated in the diagrams below  note that there could be 0s or 1s beyond the arms of the plus sign  only the relevant area of the plus sign is checked for 1s  medium dynamic programming 
c++ o(n^3) solution 226ms with explanation  largest plus sign in a 2d grid from (0  0) to (n-1  n-1)  every cell contains a 1  except those cells in the given list mines which are 0  what is the largest axis-aligned plus sign of 1s contained in the grid? return the order of the plus sign  if there is none  return 0  an "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up  down  left  and right  and made of 1s  this is demonstrated in the diagrams below  note that there could be 0s or 1s beyond the arms of the plus sign  only the relevant area of the plus sign is checked for 1s  medium dynamic programming 
java c++ o(n) solution using cyclic swapping couples holding hands n couples sit in 2n seats arranged in a row and want to hold hands  we want to know the minimum number of swaps so that every couple is sitting side by side  a swap consists of choosing any two people  then they stand up and switch seats  the people and seats are represented by an integer from 0 to 2n-1  the couples are numbered in order  the first couple being (0  1)  the second couple being (2  3)  and so on with the last couple being (2n-2  2n-1)  the couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat  hard greedy union find graph 
java  union find  easy to understand  5 ms couples holding hands n couples sit in 2n seats arranged in a row and want to hold hands  we want to know the minimum number of swaps so that every couple is sitting side by side  a swap consists of choosing any two people  then they stand up and switch seats  the people and seats are represented by an integer from 0 to 2n-1  the couples are numbered in order  the first couple being (0  1)  the second couple being (2  3)  and so on with the last couple being (2n-2  2n-1)  the couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat  hard greedy union find graph 
java ac o(n) greedy solution  couples holding hands n couples sit in 2n seats arranged in a row and want to hold hands  we want to know the minimum number of swaps so that every couple is sitting side by side  a swap consists of choosing any two people  then they stand up and switch seats  the people and seats are represented by an integer from 0 to 2n-1  the couples are numbered in order  the first couple being (0  1)  the second couple being (2  3)  and so on with the last couple being (2n-2  2n-1)  the couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat  hard greedy union find graph 
na xefve solution accepted (with a proof)    wrong difficulty? couples holding hands n couples sit in 2n seats arranged in a row and want to hold hands  we want to know the minimum number of swaps so that every couple is sitting side by side  a swap consists of choosing any two people  then they stand up and switch seats  the people and seats are represented by an integer from 0 to 2n-1  the couples are numbered in order  the first couple being (0  1)  the second couple being (2  3)  and so on with the last couple being (2n-2  2n-1)  the couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat  hard greedy union find graph 
union find  understand in 60 seconds  beats 99 6% couples holding hands n couples sit in 2n seats arranged in a row and want to hold hands  we want to know the minimum number of swaps so that every couple is sitting side by side  a swap consists of choosing any two people  then they stand up and switch seats  the people and seats are represented by an integer from 0 to 2n-1  the couples are numbered in order  the first couple being (0  1)  the second couple being (2  3)  and so on with the last couple being (2n-2  2n-1)  the couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat  hard greedy union find graph 
java solution  4 liner  toeplitz matrix a matrix is toeplitz if every diagonal from top-left to bottom-right has the same element  now given an m x n matrix  return true if and only if the matrix is toeplitz  easy array 
python easy and concise solution toeplitz matrix a matrix is toeplitz if every diagonal from top-left to bottom-right has the same element  now given an m x n matrix  return true if and only if the matrix is toeplitz  easy array 
[c++ java] clean code toeplitz matrix a matrix is toeplitz if every diagonal from top-left to bottom-right has the same element  now given an m x n matrix  return true if and only if the matrix is toeplitz  easy array 
java answers to the follow-ups (load partial row column one time)  the 3rd one beats 98%  toeplitz matrix a matrix is toeplitz if every diagonal from top-left to bottom-right has the same element  now given an m x n matrix  return true if and only if the matrix is toeplitz  easy array 
one line easy python solution  using slice  only 1 "for loop"  toeplitz matrix a matrix is toeplitz if every diagonal from top-left to bottom-right has the same element  now given an m x n matrix  return true if and only if the matrix is toeplitz  easy array 
java solution  priorityqueue reorganize string given a string s  check if the letters can be rearranged so that two characters that are adjacent to each other are not the same  if possible  output any possible result  if not possible  return the empty string  medium string heap greedy sort 
4 lines python reorganize string given a string s  check if the letters can be rearranged so that two characters that are adjacent to each other are not the same  if possible  output any possible result  if not possible  return the empty string  medium string heap greedy sort 
c++  greedy sort  o(n) reorganize string given a string s  check if the letters can be rearranged so that two characters that are adjacent to each other are not the same  if possible  output any possible result  if not possible  return the empty string  medium string heap greedy sort 
simple python solution using priorityqueue reorganize string given a string s  check if the letters can be rearranged so that two characters that are adjacent to each other are not the same  if possible  output any possible result  if not possible  return the empty string  medium string heap greedy sort 
java solution  99% similar to 358 reorganize string given a string s  check if the letters can be rearranged so that two characters that are adjacent to each other are not the same  if possible  output any possible result  if not possible  return the empty string  medium string heap greedy sort 
java solution  left max and right min  max chunks to make sorted ii this question is the same as "max chunks to make sorted" except the integers of the given array are not necessarily distinct  the input array could be up to length 2000  and the elements could be up to 10  8  given an array arr of integers (not necessarily distinct)  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? hard array 
[c++] 9 lines  15ms max chunks to make sorted ii this question is the same as "max chunks to make sorted" except the integers of the given array are not necessarily distinct  the input array could be up to length 2000  and the elements could be up to 10  8  given an array arr of integers (not necessarily distinct)  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? hard array 
python easy and concise solution max chunks to make sorted ii this question is the same as "max chunks to make sorted" except the integers of the given array are not necessarily distinct  the input array could be up to length 2000  and the elements could be up to 10  8  given an array arr of integers (not necessarily distinct)  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? hard array 
simple java solution with explanation max chunks to make sorted ii this question is the same as "max chunks to make sorted" except the integers of the given array are not necessarily distinct  the input array could be up to length 2000  and the elements could be up to 10  8  given an array arr of integers (not necessarily distinct)  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? hard array 
c++ 7 lines  o (n   log n)   o(n) max chunks to make sorted ii this question is the same as "max chunks to make sorted" except the integers of the given array are not necessarily distinct  the input array could be up to length 2000  and the elements could be up to 10  8  given an array arr of integers (not necessarily distinct)  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? hard array 
simple java o(n) solution with detailed explanation max chunks to make sorted given an array arr that is a permutation of [0  1       arr length - 1]  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? medium array 
java solution  left max and right min  max chunks to make sorted given an array arr that is a permutation of [0  1       arr length - 1]  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? medium array 
c++ 4 lines o(n)   o(1) max chunks to make sorted given an array arr that is a permutation of [0  1       arr length - 1]  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? medium array 
[c++] 6 lines  3ms solution max chunks to make sorted given an array arr that is a permutation of [0  1       arr length - 1]  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? medium array 
java o(n)  beats 100% max chunks to make sorted given an array arr that is a permutation of [0  1       arr length - 1]  we split the array into some number of "chunks" (partitions)  and individually sort each chunk  after concatenating them  the result equals the sorted array  what is the most number of chunks we could have made? medium array 
i would give up directly if asked this question in interview basic calculator iv given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1])  return a list of tokens representing the simplified expression  such as ["-1 a" "14"] an expression alternates chunks and symbols  with a space separating each chunk and symbol  a chunk is either an expression in parentheses  a variable  or a non-negative integer  a variable is a string of lowercase letters (not including digits ) note that variables can be multiple letters  and note that variables never have a leading coefficient or unary operator like "2x" or "-x"  expressions are evaluated in the usual order: brackets first  then multiplication  then addition and subtraction  for hard hash table string stack 
easy :-p basic calculator iv given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1])  return a list of tokens representing the simplified expression  such as ["-1 a" "14"] an expression alternates chunks and symbols  with a space separating each chunk and symbol  a chunk is either an expression in parentheses  a variable  or a non-negative integer  a variable is a string of lowercase letters (not including digits ) note that variables can be multiple letters  and note that variables never have a leading coefficient or unary operator like "2x" or "-x"  expressions are evaluated in the usual order: brackets first  then multiplication  then addition and subtraction  for hard hash table string stack 
c++  unordered_map + stack  with explanation basic calculator iv given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1])  return a list of tokens representing the simplified expression  such as ["-1 a" "14"] an expression alternates chunks and symbols  with a space separating each chunk and symbol  a chunk is either an expression in parentheses  a variable  or a non-negative integer  a variable is a string of lowercase letters (not including digits ) note that variables can be multiple letters  and note that variables never have a leading coefficient or unary operator like "2x" or "-x"  expressions are evaluated in the usual order: brackets first  then multiplication  then addition and subtraction  for hard hash table string stack 
java solution  using stack basic calculator iv given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1])  return a list of tokens representing the simplified expression  such as ["-1 a" "14"] an expression alternates chunks and symbols  with a space separating each chunk and symbol  a chunk is either an expression in parentheses  a variable  or a non-negative integer  a variable is a string of lowercase letters (not including digits ) note that variables can be multiple letters  and note that variables never have a leading coefficient or unary operator like "2x" or "-x"  expressions are evaluated in the usual order: brackets first  then multiplication  then addition and subtraction  for hard hash table string stack 
do it the hard way: real tokenizer & parser basic calculator iv given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1])  return a list of tokens representing the simplified expression  such as ["-1 a" "14"] an expression alternates chunks and symbols  with a space separating each chunk and symbol  a chunk is either an expression in parentheses  a variable  or a non-negative integer  a variable is a string of lowercase letters (not including digits ) note that variables can be multiple letters  and note that variables never have a leading coefficient or unary operator like "2x" or "-x"  expressions are evaluated in the usual order: brackets first  then multiplication  then addition and subtraction  for hard hash table string stack 
1-liners python java ruby jewels and stones you're given strings j representing the types of stones that are jewels  and s representing the stones you have  each character in s is a type of stone you have  you want to know how many of the stones you have are also jewels  the letters in j are guaranteed distinct  and all characters in j and s are letters  letters are case sensitive  so "a" is considered a different type of stone from "a"  easy hash table 
[c++ java python] easy and concise solution o(m+n)  jewels and stones you're given strings j representing the types of stones that are jewels  and s representing the stones you have  each character in s is a type of stone you have  you want to know how many of the stones you have are also jewels  the letters in j are guaranteed distinct  and all characters in j and s are letters  letters are case sensitive  so "a" is considered a different type of stone from "a"  easy hash table 
java: o(s+j) time and o(1) space jewels and stones you're given strings j representing the types of stones that are jewels  and s representing the stones you have  each character in s is a type of stone you have  you want to know how many of the stones you have are also jewels  the letters in j are guaranteed distinct  and all characters in j and s are letters  letters are case sensitive  so "a" is considered a different type of stone from "a"  easy hash table 
python o(m+n) hash - 公瑾 jewels and stones you're given strings j representing the types of stones that are jewels  and s representing the stones you have  each character in s is a type of stone you have  you want to know how many of the stones you have are also jewels  the letters in j are guaranteed distinct  and all characters in j and s are letters  letters are case sensitive  so "a" is considered a different type of stone from "a"  easy hash table 
two-line javascript solution jewels and stones you're given strings j representing the types of stones that are jewels  and s representing the stones you have  each character in s is a type of stone you have  you want to know how many of the stones you have are also jewels  the letters in j are guaranteed distinct  and all characters in j and s are letters  letters are case sensitive  so "a" is considered a different type of stone from "a"  easy hash table 
java 19ms 26 clean lines bfs with comment  sliding puzzle on a 2x3 board  there are 5 tiles represented by the integers 1 through 5  and an empty square represented by 0  a move consists of choosing 0 and a 4-directionally adjacent number and swapping it  the state of the board is solved if and only if the board is [[1 2 3] [4 5 0]]  given a puzzle board  return the least number of moves required so that the state of the board is solved  if it is impossible for the state of the board to be solved  return -1  hard breadth-first search 
java 8ms bfs with algorithm explained sliding puzzle on a 2x3 board  there are 5 tiles represented by the integers 1 through 5  and an empty square represented by 0  a move consists of choosing 0 and a 4-directionally adjacent number and swapping it  the state of the board is solved if and only if the board is [[1 2 3] [4 5 0]]  given a puzzle board  return the least number of moves required so that the state of the board is solved  if it is impossible for the state of the board to be solved  return -1  hard breadth-first search 
c++ 9 lines dfs and bfs sliding puzzle on a 2x3 board  there are 5 tiles represented by the integers 1 through 5  and an empty square represented by 0  a move consists of choosing 0 and a 4-directionally adjacent number and swapping it  the state of the board is solved if and only if the board is [[1 2 3] [4 5 0]]  given a puzzle board  return the least number of moves required so that the state of the board is solved  if it is impossible for the state of the board to be solved  return -1  hard breadth-first search 
readable java solution sliding puzzle on a 2x3 board  there are 5 tiles represented by the integers 1 through 5  and an empty square represented by 0  a move consists of choosing 0 and a 4-directionally adjacent number and swapping it  the state of the board is solved if and only if the board is [[1 2 3] [4 5 0]]  given a puzzle board  return the least number of moves required so that the state of the board is solved  if it is impossible for the state of the board to be solved  return -1  hard breadth-first search 
java intuitive dfs+backtracking sliding puzzle on a 2x3 board  there are 5 tiles represented by the integers 1 through 5  and an empty square represented by 0  a move consists of choosing 0 and a 4-directionally adjacent number and swapping it  the state of the board is solved if and only if the board is [[1 2 3] [4 5 0]]  given a puzzle board  return the least number of moves required so that the state of the board is solved  if it is impossible for the state of the board to be solved  return -1  hard breadth-first search 
my 3 lines c++ solution global and local inversions we have some permutation a of [0  1       n - 1]  where n is the length of a  the number of (global) inversions is the number of i < j with 0 <= i < j < n and a[i] > a[j]  the number of local inversions is the number of i with 0 <= i < n and a[i] > a[i+1]  return true if and only if the number of global inversions is equal to the number of local inversions  medium array math 
easy and concise solution [c++ java python] global and local inversions we have some permutation a of [0  1       n - 1]  where n is the length of a  the number of (global) inversions is the number of i < j with 0 <= i < j < n and a[i] > a[j]  the number of local inversions is the number of i with 0 <= i < n and a[i] > a[i+1]  return true if and only if the number of global inversions is equal to the number of local inversions  medium array math 
check if we can sort the array with only local inversions global and local inversions we have some permutation a of [0  1       n - 1]  where n is the length of a  the number of (global) inversions is the number of i < j with 0 <= i < j < n and a[i] > a[j]  the number of local inversions is the number of i with 0 <= i < n and a[i] > a[i+1]  return true if and only if the number of global inversions is equal to the number of local inversions  medium array math 
java o(n) solution with explanation global and local inversions we have some permutation a of [0  1       n - 1]  where n is the length of a  the number of (global) inversions is the number of i < j with 0 <= i < j < n and a[i] > a[j]  the number of local inversions is the number of i with 0 <= i < n and a[i] > a[i+1]  return true if and only if the number of global inversions is equal to the number of local inversions  medium array math 
logical thinking with clear code global and local inversions we have some permutation a of [0  1       n - 1]  where n is the length of a  the number of (global) inversions is the number of i < j with 0 <= i < j < n and a[i] > a[j]  the number of local inversions is the number of i with 0 <= i < n and a[i] > a[i+1]  return true if and only if the number of global inversions is equal to the number of local inversions  medium array math 
simple java one pass o(n) solution with explaination swap adjacent in lr string in a string composed of 'l'  'r'  and 'x' characters  like "rxxlrxrxl"  a move consists of either replacing one occurrence of "xl" with "lx"  or replacing one occurrence of "rx" with "xr"  given the starting string start and the ending string end  return true if and only if there exists a sequence of moves to transform one string to the other  medium brainteaser 
simple java solution swap adjacent in lr string in a string composed of 'l'  'r'  and 'x' characters  like "rxxlrxrxl"  a move consists of either replacing one occurrence of "xl" with "lx"  or replacing one occurrence of "rx" with "xr"  given the starting string start and the ending string end  return true if and only if there exists a sequence of moves to transform one string to the other  medium brainteaser 
python simple solution  3 lines o(n) swap adjacent in lr string in a string composed of 'l'  'r'  and 'x' characters  like "rxxlrxrxl"  a move consists of either replacing one occurrence of "xl" with "lx"  or replacing one occurrence of "rx" with "xr"  given the starting string start and the ending string end  return true if and only if there exists a sequence of moves to transform one string to the other  medium brainteaser 
[c++] simple subsequence matching with position constraint  swap adjacent in lr string in a string composed of 'l'  'r'  and 'x' characters  like "rxxlrxrxl"  a move consists of either replacing one occurrence of "xl" with "lx"  or replacing one occurrence of "rx" with "xr"  given the starting string start and the ending string end  return true if and only if there exists a sequence of moves to transform one string to the other  medium brainteaser 
c++ with explanation  o(n)  14ms swap adjacent in lr string in a string composed of 'l'  'r'  and 'x' characters  like "rxxlrxrxl"  a move consists of either replacing one occurrence of "xl" with "lx"  or replacing one occurrence of "rx" with "xr"  given the starting string start and the ending string end  return true if and only if there exists a sequence of moves to transform one string to the other  medium brainteaser 
easy and concise solution using priorityqueue [python c++] swim in rising water on an n x n grid  each square grid[i][j] represents the elevation at that point (i j)  now rain starts to fall  at time t  the depth of the water everywhere is t  you can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t  you can swim infinite distance in zero time  of course  you must stay within the boundaries of the grid during your swim  you start at the top left square (0  0)  what is the least time until you can reach the bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
c++ two solutions  binary search+dfs and dijkstra+bfs  o(n^2logn)  11ms swim in rising water on an n x n grid  each square grid[i][j] represents the elevation at that point (i j)  now rain starts to fall  at time t  the depth of the water everywhere is t  you can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t  you can swim infinite distance in zero time  of course  you must stay within the boundaries of the grid during your swim  you start at the top left square (0  0)  what is the least time until you can reach the bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
java - dfs and union find swim in rising water on an n x n grid  each square grid[i][j] represents the elevation at that point (i j)  now rain starts to fall  at time t  the depth of the water everywhere is t  you can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t  you can swim infinite distance in zero time  of course  you must stay within the boundaries of the grid during your swim  you start at the top left square (0  0)  what is the least time until you can reach the bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
easy and concise solution using binary search [python c++] swim in rising water on an n x n grid  each square grid[i][j] represents the elevation at that point (i j)  now rain starts to fall  at time t  the depth of the water everywhere is t  you can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t  you can swim infinite distance in zero time  of course  you must stay within the boundaries of the grid during your swim  you start at the top left square (0  0)  what is the least time until you can reach the bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
o(n^2) solution  union-find  python swim in rising water on an n x n grid  each square grid[i][j] represents the elevation at that point (i j)  now rain starts to fall  at time t  the depth of the water everywhere is t  you can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t  you can swim infinite distance in zero time  of course  you must stay within the boundaries of the grid during your swim  you start at the top left square (0  0)  what is the least time until you can reach the bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
my 3 lines c++ recursive solution k-th symbol in grammar on the first row  we write a 0  now in every subsequent row  we look at the previous row and replace each occurrence of 0 with 01  and each occurrence of 1 with 10  given row n and index k  return the k-th indexed symbol in row n  (the values of k are 1-indexed ) (1 indexed)  medium recursion 
[java] one line k-th symbol in grammar on the first row  we write a 0  now in every subsequent row  we look at the previous row and replace each occurrence of 0 with 01  and each occurrence of 1 with 10  given row n and index k  return the k-th indexed symbol in row n  (the values of k are 1-indexed ) (1 indexed)  medium recursion 
python 1-line k-th symbol in grammar on the first row  we write a 0  now in every subsequent row  we look at the previous row and replace each occurrence of 0 with 01  and each occurrence of 1 with 10  given row n and index k  return the k-th indexed symbol in row n  (the values of k are 1-indexed ) (1 indexed)  medium recursion 
[python java c++] easy 1-line solution with detailed explanation k-th symbol in grammar on the first row  we write a 0  now in every subsequent row  we look at the previous row and replace each occurrence of 0 with 01  and each occurrence of 1 with 10  given row n and index k  return the k-th indexed symbol in row n  (the values of k are 1-indexed ) (1 indexed)  medium recursion 
c++ with explanation  three solutions o(n)  o(logn)  and o(loglogn) k-th symbol in grammar on the first row  we write a 0  now in every subsequent row  we look at the previous row and replace each occurrence of 0 with 01  and each occurrence of 1 with 10  given row n and index k  return the k-th indexed symbol in row n  (the values of k are 1-indexed ) (1 indexed)  medium recursion 
easy and concise 2-line solution[python c++ java] reaching points a move consists of taking a point (x  y) and transforming it to either (x  x+y) or (x+y  y)  given a starting point (sx  sy) and a target point (tx  ty)  return true if and only if a sequence of moves exists to transform the point (sx  sy) to (tx  ty)  otherwise  return false  hard math 
[c++] simple iterative  reaching points a move consists of taking a point (x  y) and transforming it to either (x  x+y) or (x+y  y)  given a starting point (sx  sy) and a target point (tx  ty)  return true if and only if a sequence of moves exists to transform the point (sx  sy) to (tx  ty)  otherwise  return false  hard math 
[java] easy to understand recursion solution reaching points a move consists of taking a point (x  y) and transforming it to either (x  x+y) or (x+y  y)  given a starting point (sx  sy) and a target point (tx  ty)  return true if and only if a sequence of moves exists to transform the point (sx  sy) to (tx  ty)  otherwise  return false  hard math 
[java] simple solution with explanation reaching points a move consists of taking a point (x  y) and transforming it to either (x  x+y) or (x+y  y)  given a starting point (sx  sy) and a target point (tx  ty)  return true if and only if a sequence of moves exists to transform the point (sx  sy) to (tx  ty)  otherwise  return false  hard math 
c++ simple 6 line solution reaching points a move consists of taking a point (x  y) and transforming it to either (x  x+y) or (x+y  y)  given a starting point (sx  sy) and a target point (tx  ty)  return true if and only if a sequence of moves exists to transform the point (sx  sy) to (tx  ty)  otherwise  return false  hard math 
 [c++ java python] easy and concise solution rabbits in forest in a forest  each rabbit has some color  some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them  those answers are placed in an array  return the minimum number of rabbits that could be in the forest  medium hash table math 
my easy java hashmap solution rabbits in forest in a forest  each rabbit has some color  some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them  those answers are placed in an array  return the minimum number of rabbits that could be in the forest  medium hash table math 
java solution with hashmap o(n) and comments rabbits in forest in a forest  each rabbit has some color  some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them  those answers are placed in an array  return the minimum number of rabbits that could be in the forest  medium hash table math 
java simple solution rabbits in forest in a forest  each rabbit has some color  some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them  those answers are placed in an array  return the minimum number of rabbits that could be in the forest  medium hash table math 
 u3010simple python u3011 rabbits in forest in a forest  each rabbit has some color  some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them  those answers are placed in an array  return the minimum number of rabbits that could be in the forest  medium hash table math 
easy and concise solution with explanation [c++ java python] transform to chessboard an n x n board contains only 0s and 1s  in each move  you can swap any 2 rows with each other  or any 2 columns with each other  what is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? if the task is impossible  return -1  hard array math 
key observation on property of chessboard transform to chessboard an n x n board contains only 0s and 1s  in each move  you can swap any 2 rows with each other  or any 2 columns with each other  what is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? if the task is impossible  return -1  hard array math 
short c++ solution  no swaps  9ms  o(n^2) time  o(1) space transform to chessboard an n x n board contains only 0s and 1s  in each move  you can swap any 2 rows with each other  or any 2 columns with each other  what is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? if the task is impossible  return -1  hard array math 
java clear code with detailed explanations transform to chessboard an n x n board contains only 0s and 1s  in each move  you can swap any 2 rows with each other  or any 2 columns with each other  what is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? if the task is impossible  return -1  hard array math 
c++ o(n^2) time solution with explantion transform to chessboard an n x n board contains only 0s and 1s  in each move  you can swap any 2 rows with each other  or any 2 columns with each other  what is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? if the task is impossible  return -1  hard array math 
come on guys  it is obviously the same as problems 530  minimum absolute difference in bst minimum distance between bst nodes given a binary search tree (bst) with the root node root  return the minimum difference between the values of any two different nodes in the tree  easy binary search tree 
inorder traversal o(n) time recursion [c++ java python] minimum distance between bst nodes given a binary search tree (bst) with the root node root  return the minimum difference between the values of any two different nodes in the tree  easy binary search tree 
problem title is confusing minimum distance between bst nodes given a binary search tree (bst) with the root node root  return the minimum difference between the values of any two different nodes in the tree  easy binary search tree 
what the result of [2147483647 -2147483648 null]? minimum distance between bst nodes given a binary search tree (bst) with the root node root  return the minimum difference between the values of any two different nodes in the tree  easy binary search tree 
c++ recursive and iterative summary for question 783 & 530  minimum distance between bst nodes given a binary search tree (bst) with the root node root  return the minimum difference between the values of any two different nodes in the tree  easy binary search tree 
java easy bfs   dfs solution with explanation letter case permutation given a string s  we can transform every letter individually to be lowercase or uppercase to create another string  return a list of all possible strings we could create  easy backtracking bit manipulation 
python simple solution (7 lines) letter case permutation given a string s  we can transform every letter individually to be lowercase or uppercase to create another string  return a list of all possible strings we could create  easy backtracking bit manipulation 
c++ backtrack solution w  trick letter case permutation given a string s  we can transform every letter individually to be lowercase or uppercase to create another string  return a list of all possible strings we could create  easy backtracking bit manipulation 
easy python 2 line solution letter case permutation given a string s  we can transform every letter individually to be lowercase or uppercase to create another string  return a list of all possible strings we could create  easy backtracking bit manipulation 
java solution using recursion letter case permutation given a string s  we can transform every letter individually to be lowercase or uppercase to create another string  return a list of all possible strings we could create  easy backtracking bit manipulation 
java clean dfs solution with explanation is graph bipartite? given an undirected graph  return true if and only if it is bipartite  recall that a graph is bipartite if we can split it's set of nodes into two independent subsets a and b such that every edge in the graph has one node in a and another node in b  the graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists  each node is an integer between 0 and graph length - 1  there are no self edges or parallel edges: graph[i] does not contain i  and it doesn't contain any element twice  medium depth-first search breadth-first search graph 
java bfs  is graph bipartite? given an undirected graph  return true if and only if it is bipartite  recall that a graph is bipartite if we can split it's set of nodes into two independent subsets a and b such that every edge in the graph has one node in a and another node in b  the graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists  each node is an integer between 0 and graph length - 1  there are no self edges or parallel edges: graph[i] does not contain i  and it doesn't contain any element twice  medium depth-first search breadth-first search graph 
java short iterative solution is graph bipartite? given an undirected graph  return true if and only if it is bipartite  recall that a graph is bipartite if we can split it's set of nodes into two independent subsets a and b such that every edge in the graph has one node in a and another node in b  the graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists  each node is an integer between 0 and graph length - 1  there are no self edges or parallel edges: graph[i] does not contain i  and it doesn't contain any element twice  medium depth-first search breadth-first search graph 
why is this even a test case? [[1] [0] [0 1]] is graph bipartite? given an undirected graph  return true if and only if it is bipartite  recall that a graph is bipartite if we can split it's set of nodes into two independent subsets a and b such that every edge in the graph has one node in a and another node in b  the graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists  each node is an integer between 0 and graph length - 1  there are no self edges or parallel edges: graph[i] does not contain i  and it doesn't contain any element twice  medium depth-first search breadth-first search graph 
easy python solution is graph bipartite? given an undirected graph  return true if and only if it is bipartite  recall that a graph is bipartite if we can split it's set of nodes into two independent subsets a and b such that every edge in the graph has one node in a and another node in b  the graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists  each node is an integer between 0 and graph length - 1  there are no self edges or parallel edges: graph[i] does not contain i  and it doesn't contain any element twice  medium depth-first search breadth-first search graph 
summary of solutions for problems "reducible" to leetcode 378 k-th smallest prime fraction a sorted list a contains 1  plus some number of primes  then  for every p < q in the list  we consider the fraction p q  what is the k-th smallest fraction considered? return your answer as an array of ints  where answer[0] = p and answer[1] = q  hard binary search heap 
[java] ac o(max(n k)   logn) short easy priorityqueue k-th smallest prime fraction a sorted list a contains 1  plus some number of primes  then  for every p < q in the list  we consider the fraction p q  what is the k-th smallest fraction considered? return your answer as an array of ints  where answer[0] = p and answer[1] = q  hard binary search heap 
c++ 9lines priority queue k-th smallest prime fraction a sorted list a contains 1  plus some number of primes  then  for every p < q in the list  we consider the fraction p q  what is the k-th smallest fraction considered? return your answer as an array of ints  where answer[0] = p and answer[1] = q  hard binary search heap 
o(n) k-th smallest prime fraction a sorted list a contains 1  plus some number of primes  then  for every p < q in the list  we consider the fraction p q  what is the k-th smallest fraction considered? return your answer as an array of ints  where answer[0] = p and answer[1] = q  hard binary search heap 
python solution using binary search k-th smallest prime fraction a sorted list a contains 1  plus some number of primes  then  for every p < q in the list  we consider the fraction p q  what is the k-th smallest fraction considered? return your answer as an array of ints  where answer[0] = p and answer[1] = q  hard binary search heap 
 [java python] priority queue solution cheapest flights within k stops there are n cities connected by m flights  each fight starts from city u and arrives at v with a price w  now given all the cities and flights  together with starting city src and the destination dst  your task is to find the cheapest price from src to dst with up to k stops  if there is no such route  output -1  medium dynamic programming heap breadth-first search 
c++ 8 line bellman ford cheapest flights within k stops there are n cities connected by m flights  each fight starts from city u and arrives at v with a price w  now given all the cities and flights  together with starting city src and the destination dst  your task is to find the cheapest price from src to dst with up to k stops  if there is no such route  output -1  medium dynamic programming heap breadth-first search 
5 ms ac java solution based on dijkstra's algorithm  cheapest flights within k stops there are n cities connected by m flights  each fight starts from city u and arrives at v with a price w  now given all the cities and flights  together with starting city src and the destination dst  your task is to find the cheapest price from src to dst with up to k stops  if there is no such route  output -1  medium dynamic programming heap breadth-first search 
three c++ solutions bfs  dfs  and bf cheapest flights within k stops there are n cities connected by m flights  each fight starts from city u and arrives at v with a price w  now given all the cities and flights  together with starting city src and the destination dst  your task is to find the cheapest price from src to dst with up to k stops  if there is no such route  output -1  medium dynamic programming heap breadth-first search 
c++ solution using dynamic programming cheapest flights within k stops there are n cities connected by m flights  each fight starts from city u and arrives at v with a price w  now given all the cities and flights  together with starting city src and the destination dst  your task is to find the cheapest price from src to dst with up to k stops  if there is no such route  output -1  medium dynamic programming heap breadth-first search 
java dp solution 9ms rotated digits x is a good number if after rotating each digit individually by 180 degrees  we get a valid number that is different from x  each digit must be rotated - we cannot choose to leave it alone  a number is valid if each digit remains a digit after rotation  0  1  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other  and the rest of the numbers do not rotate to any other number and become invalid  now given a positive number n  how many numbers x from 1 to n are good? easy string 
easily understood java solution rotated digits x is a good number if after rotating each digit individually by 180 degrees  we get a valid number that is different from x  each digit must be rotated - we cannot choose to leave it alone  a number is valid if each digit remains a digit after rotation  0  1  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other  and the rest of the numbers do not rotate to any other number and become invalid  now given a positive number n  how many numbers x from 1 to n are good? easy string 
the question need to be explained clearly rotated digits x is a good number if after rotating each digit individually by 180 degrees  we get a valid number that is different from x  each digit must be rotated - we cannot choose to leave it alone  a number is valid if each digit remains a digit after rotation  0  1  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other  and the rest of the numbers do not rotate to any other number and become invalid  now given a positive number n  how many numbers x from 1 to n are good? easy string 
easy to understand python solution (using string) rotated digits x is a good number if after rotating each digit individually by 180 degrees  we get a valid number that is different from x  each digit must be rotated - we cannot choose to leave it alone  a number is valid if each digit remains a digit after rotation  0  1  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other  and the rest of the numbers do not rotate to any other number and become invalid  now given a positive number n  how many numbers x from 1 to n are good? easy string 
o(log10(n)) easy to understand java solution rotated digits x is a good number if after rotating each digit individually by 180 degrees  we get a valid number that is different from x  each digit must be rotated - we cannot choose to leave it alone  a number is valid if each digit remains a digit after rotation  0  1  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other  and the rest of the numbers do not rotate to any other number and become invalid  now given a positive number n  how many numbers x from 1 to n are good? easy string 
why interception in the middle is not a good idea for ghosts  escape the ghosts you are playing a simplified pacman game  you start at the point (0  0)  and your destination is (target[0]  target[1])  there are several ghosts on the map  the i-th ghost starts at (ghosts[i][0]  ghosts[i][1])  each turn  you and all ghosts simultaneously  may  move in one of 4 cardinal directions: north  east  west  or south  going from the previous point to a new point 1 unit of distance away  you escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take ) if you reach any square (including the target) at the same time as a ghost  it doesn't count as an escape  return true if and only if it is possible to escape  medium math 
java 5 liner escape the ghosts you are playing a simplified pacman game  you start at the point (0  0)  and your destination is (target[0]  target[1])  there are several ghosts on the map  the i-th ghost starts at (ghosts[i][0]  ghosts[i][1])  each turn  you and all ghosts simultaneously  may  move in one of 4 cardinal directions: north  east  west  or south  going from the previous point to a new point 1 unit of distance away  you escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take ) if you reach any square (including the target) at the same time as a ghost  it doesn't count as an escape  return true if and only if it is possible to escape  medium math 
short with explanation  python escape the ghosts you are playing a simplified pacman game  you start at the point (0  0)  and your destination is (target[0]  target[1])  there are several ghosts on the map  the i-th ghost starts at (ghosts[i][0]  ghosts[i][1])  each turn  you and all ghosts simultaneously  may  move in one of 4 cardinal directions: north  east  west  or south  going from the previous point to a new point 1 unit of distance away  you escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take ) if you reach any square (including the target) at the same time as a ghost  it doesn't count as an escape  return true if and only if it is possible to escape  medium math 
test case showing true  but false in output escape the ghosts you are playing a simplified pacman game  you start at the point (0  0)  and your destination is (target[0]  target[1])  there are several ghosts on the map  the i-th ghost starts at (ghosts[i][0]  ghosts[i][1])  each turn  you and all ghosts simultaneously  may  move in one of 4 cardinal directions: north  east  west  or south  going from the previous point to a new point 1 unit of distance away  you escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take ) if you reach any square (including the target) at the same time as a ghost  it doesn't count as an escape  return true if and only if it is possible to escape  medium math 
[c++ java python] easy and concise solution escape the ghosts you are playing a simplified pacman game  you start at the point (0  0)  and your destination is (target[0]  target[1])  there are several ghosts on the map  the i-th ghost starts at (ghosts[i][0]  ghosts[i][1])  each turn  you and all ghosts simultaneously  may  move in one of 4 cardinal directions: north  east  west  or south  going from the previous point to a new point 1 unit of distance away  you escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take ) if you reach any square (including the target) at the same time as a ghost  it doesn't count as an escape  return true if and only if it is possible to escape  medium math 
detail and explanation of o(n) solution why dp[n]=2 d[n-1]+dp[n-3] domino and tromino tiling we have two types of tiles: a 2x1 domino shape  and an "l" tromino shape  these shapes may be rotated  xx <- domino xx <- "l" tromino x given n  how many ways are there to tile a 2 x n board? return your answer modulo 10^9 + 7  (in a tiling  every square must be covered by a tile  two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile ) medium dynamic programming 
schematic explanation of two equivalent dp recurrence formula domino and tromino tiling we have two types of tiles: a 2x1 domino shape  and an "l" tromino shape  these shapes may be rotated  xx <- domino xx <- "l" tromino x given n  how many ways are there to tile a 2 x n board? return your answer modulo 10^9 + 7  (in a tiling  every square must be covered by a tile  two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile ) medium dynamic programming 
python recursive dp solution with cache w  explanation domino and tromino tiling we have two types of tiles: a 2x1 domino shape  and an "l" tromino shape  these shapes may be rotated  xx <- domino xx <- "l" tromino x given n  how many ways are there to tile a 2 x n board? return your answer modulo 10^9 + 7  (in a tiling  every square must be covered by a tile  two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile ) medium dynamic programming 
easy to understand o(n) solution with drawing picture explanation! domino and tromino tiling we have two types of tiles: a 2x1 domino shape  and an "l" tromino shape  these shapes may be rotated  xx <- domino xx <- "l" tromino x given n  how many ways are there to tile a 2 x n board? return your answer modulo 10^9 + 7  (in a tiling  every square must be covered by a tile  two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile ) medium dynamic programming 
o(n) time and o(1) space [c++ java python] domino and tromino tiling we have two types of tiles: a 2x1 domino shape  and an "l" tromino shape  these shapes may be rotated  xx <- domino xx <- "l" tromino x given n  how many ways are there to tile a 2 x n board? return your answer modulo 10^9 + 7  (in a tiling  every square must be covered by a tile  two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile ) medium dynamic programming 
java 5 ms 10 line counting solution with comment custom sort string s and t are strings composed of lowercase letters  in s  no letter occurs more than once  s was sorted in some custom order previously  we want to permute the characters of t so that they match the order that s was sorted  more specifically  if x occurs before y in s  then x should occur before y in the returned string  return any permutation of t (as a string) that satisfies this property  medium string 
two lines c++ custom sort string s and t are strings composed of lowercase letters  in s  no letter occurs more than once  s was sorted in some custom order previously  we want to permute the characters of t so that they match the order that s was sorted  more specifically  if x occurs before y in s  then x should occur before y in the returned string  return any permutation of t (as a string) that satisfies this property  medium string 
java bucket sort solution o(n+m) with follow up questions custom sort string s and t are strings composed of lowercase letters  in s  no letter occurs more than once  s was sorted in some custom order previously  we want to permute the characters of t so that they match the order that s was sorted  more specifically  if x occurs before y in s  then x should occur before y in the returned string  return any permutation of t (as a string) that satisfies this property  medium string 
easy python solution custom sort string s and t are strings composed of lowercase letters  in s  no letter occurs more than once  s was sorted in some custom order previously  we want to permute the characters of t so that they match the order that s was sorted  more specifically  if x occurs before y in s  then x should occur before y in the returned string  return any permutation of t (as a string) that satisfies this property  medium string 
python priority queue solution o(nlgn) custom sort string s and t are strings composed of lowercase letters  in s  no letter occurs more than once  s was sorted in some custom order previously  we want to permute the characters of t so that they match the order that s was sorted  more specifically  if x occurs before y in s  then x should occur before y in the returned string  return any permutation of t (as a string) that satisfies this property  medium string 
efficient and simple  go through words in parallel  with explanation number of matching subsequences given string s and a dictionary of words words  find the number of words[i] that is a subsequence of s  medium array 
java solution using hashmap and queue number of matching subsequences given string s and a dictionary of words words  find the number of words[i] that is a subsequence of s  medium array 
simple python solution number of matching subsequences given string s and a dictionary of words words  find the number of words[i] that is a subsequence of s  medium array 
java o(n) solution number of matching subsequences given string s and a dictionary of words words  find the number of words[i] that is a subsequence of s  medium array 
c++ 12 line solution with explanation number of matching subsequences given string s and a dictionary of words words  find the number of words[i] that is a subsequence of s  medium array 
four binary search solutions based on different ideas preimage size of factorial zeroes function let f(x) be the number of zeroes at the end of x!  (recall that x! = 1   2   3         x  and by convention  0! = 1 ) for hard binary search 
binary search python code [40ms] preimage size of factorial zeroes function let f(x) be the number of zeroes at the end of x!  (recall that x! = 1   2   3         x  and by convention  0! = 1 ) for hard binary search 
c++  o(logn)  math solution with explanation preimage size of factorial zeroes function let f(x) be the number of zeroes at the end of x!  (recall that x! = 1   2   3         x  and by convention  0! = 1 ) for hard binary search 
using binary search java solution preimage size of factorial zeroes function let f(x) be the number of zeroes at the end of x!  (recall that x! = 1   2   3         x  and by convention  0! = 1 ) for hard binary search 
python simple binary search solution preimage size of factorial zeroes function let f(x) be the number of zeroes at the end of x!  (recall that x! = 1   2   3         x  and by convention  0! = 1 ) for hard binary search 
straightforward java solution with explaination valid tic-tac-toe state a tic-tac-toe board is given as a string array board  return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game  the board is a 3 x 3 array  and consists of characters " "  "x"  and "o"  the " " character represents an empty square  here are the rules of tic-tac-toe: players take turns placing characters into empty squares (" ")  the first player always places "x" characters  while the second player always places "o" characters  "x" and "o" characters are always placed into empty squares  never filled ones  the game ends when there are 3 of the same (non-empty) character filling any row  column  or diagonal  the game also ends if all squares are non-empty  no more moves can be played if the game is over  medium math recursion 
4 lines python valid tic-tac-toe state a tic-tac-toe board is given as a string array board  return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game  the board is a 3 x 3 array  and consists of characters " "  "x"  and "o"  the " " character represents an empty square  here are the rules of tic-tac-toe: players take turns placing characters into empty squares (" ")  the first player always places "x" characters  while the second player always places "o" characters  "x" and "o" characters are always placed into empty squares  never filled ones  the game ends when there are 3 of the same (non-empty) character filling any row  column  or diagonal  the game also ends if all squares are non-empty  no more moves can be played if the game is over  medium math recursion 
simple python solution with explanation valid tic-tac-toe state a tic-tac-toe board is given as a string array board  return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game  the board is a 3 x 3 array  and consists of characters " "  "x"  and "o"  the " " character represents an empty square  here are the rules of tic-tac-toe: players take turns placing characters into empty squares (" ")  the first player always places "x" characters  while the second player always places "o" characters  "x" and "o" characters are always placed into empty squares  never filled ones  the game ends when there are 3 of the same (non-empty) character filling any row  column  or diagonal  the game also ends if all squares are non-empty  no more moves can be played if the game is over  medium math recursion 
java - 20 lines with a cute trick  valid tic-tac-toe state a tic-tac-toe board is given as a string array board  return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game  the board is a 3 x 3 array  and consists of characters " "  "x"  and "o"  the " " character represents an empty square  here are the rules of tic-tac-toe: players take turns placing characters into empty squares (" ")  the first player always places "x" characters  while the second player always places "o" characters  "x" and "o" characters are always placed into empty squares  never filled ones  the game ends when there are 3 of the same (non-empty) character filling any row  column  or diagonal  the game also ends if all squares are non-empty  no more moves can be played if the game is over  medium math recursion 
easy to understand in c valid tic-tac-toe state a tic-tac-toe board is given as a string array board  return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game  the board is a 3 x 3 array  and consists of characters " "  "x"  and "o"  the " " character represents an empty square  here are the rules of tic-tac-toe: players take turns placing characters into empty squares (" ")  the first player always places "x" characters  while the second player always places "o" characters  "x" and "o" characters are always placed into empty squares  never filled ones  the game ends when there are 3 of the same (non-empty) character filling any row  column  or diagonal  the game also ends if all squares are non-empty  no more moves can be played if the game is over  medium math recursion 
short java o(n) solution number of subarrays with bounded maximum we are given an array a of positive integers  and two positive integers l and r (l <= r)  return the number of (contiguous  non-empty) subarrays such that the value of the maximum array element in that subarray is at least l and at most r  medium array 
c++  o(n)  <10 lines number of subarrays with bounded maximum we are given an array a of positive integers  and two positive integers l and r (l <= r)  return the number of (contiguous  non-empty) subarrays such that the value of the maximum array element in that subarray is at least l and at most r  medium array 
python   standard dp solution with explanation  number of subarrays with bounded maximum we are given an array a of positive integers  and two positive integers l and r (l <= r)  return the number of (contiguous  non-empty) subarrays such that the value of the maximum array element in that subarray is at least l and at most r  medium array 
c++ o(n) solution with explanations number of subarrays with bounded maximum we are given an array a of positive integers  and two positive integers l and r (l <= r)  return the number of (contiguous  non-empty) subarrays such that the value of the maximum array element in that subarray is at least l and at most r  medium array 
clean & simple o(n) java  number of subarrays with bounded maximum we are given an array a of positive integers  and two positive integers l and r (l <= r)  return the number of (contiguous  non-empty) subarrays such that the value of the maximum array element in that subarray is at least l and at most r  medium array 
c++   java   python 1 line solution rotate string we are given two strings  a and b  a shift on a consists of taking string a and moving the leftmost character to the rightmost position  for easy 
java 1 line solution rotate string we are given two strings  a and b  a shift on a consists of taking string a and moving the leftmost character to the rightmost position  for easy 
[c++ java python] 1-line solution rotate string we are given two strings  a and b  a shift on a consists of taking string a and moving the leftmost character to the rightmost position  for easy 
1 line c++ rotate string we are given two strings  a and b  a shift on a consists of taking string a and moving the leftmost character to the rightmost position  for easy 
python 3  beats 100% rotate string we are given two strings  a and b  a shift on a consists of taking string a and moving the leftmost character to the rightmost position  for easy 
java dfs solution all paths from source to target given a directed  acyclic graph of n nodes  find all possible paths from node 0 to node n-1  and return them in any order  the graph is given as follows: the nodes are 0  1       graph length - 1  graph[i] is a list of all nodes j for which the edge (i  j) exists  medium 
easy and concise dfs solution [c++   2-line python] all paths from source to target given a directed  acyclic graph of n nodes  find all possible paths from node 0 to node n-1  and return them in any order  the graph is given as follows: the nodes are 0  1       graph length - 1  graph[i] is a list of all nodes j for which the edge (i  j) exists  medium 
c++ dfs recursive  easy to understand all paths from source to target given a directed  acyclic graph of n nodes  find all possible paths from node 0 to node n-1  and return them in any order  the graph is given as follows: the nodes are 0  1       graph length - 1  graph[i] is a list of all nodes j for which the edge (i  j) exists  medium 
short python iterative dfs all paths from source to target given a directed  acyclic graph of n nodes  find all possible paths from node 0 to node n-1  and return them in any order  the graph is given as follows: the nodes are 0  1       graph length - 1  graph[i] is a list of all nodes j for which the edge (i  j) exists  medium 
javascript solution all paths from source to target given a directed  acyclic graph of n nodes  find all possible paths from node 0 to node n-1  and return them in any order  the graph is given as follows: the nodes are 0  1       graph length - 1  graph[i] is a list of all nodes j for which the edge (i  j) exists  medium 
 [c++ java python] solution with explanation smallest rotation with highest score given an array a  we may rotate it by a non-negative integer k so that the array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  any entries that are less than or equal to their index are worth 1 point  for hard 
java  o(n)time o(n) space solution smallest rotation with highest score given an array a  we may rotate it by a non-negative integer k so that the array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  any entries that are less than or equal to their index are worth 1 point  for hard 
easy c++  w  comments - o(n) time smallest rotation with highest score given an array a  we may rotate it by a non-negative integer k so that the array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  any entries that are less than or equal to their index are worth 1 point  for hard 
two python3 o(n) time and space ac solutions with picture explanation smallest rotation with highest score given an array a  we may rotate it by a non-negative integer k so that the array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  any entries that are less than or equal to their index are worth 1 point  for hard 
java solution w  comments smallest rotation with highest score given an array a  we may rotate it by a non-negative integer k so that the array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  any entries that are less than or equal to their index are worth 1 point  for hard 
[20ms] c++  easy understand solution champagne tower we stack glasses in a pyramid  where the first row has 1 glass  the second row has 2 glasses  and so on until the 100th row  each glass holds one cup (250ml) of champagne  then  some champagne is poured in the first glass at the top  when the top most glass is full  any excess liquid poured will fall equally to the glass immediately to the left and right of it  when those glasses become full  any excess champagne will fall equally to the left and right of those glasses  and so on  (a glass at the bottom row has it's excess champagne fall on the floor ) for medium 
[9ms] 5 lines code [ c++ java ] champagne tower we stack glasses in a pyramid  where the first row has 1 glass  the second row has 2 glasses  and so on until the 100th row  each glass holds one cup (250ml) of champagne  then  some champagne is poured in the first glass at the top  when the top most glass is full  any excess liquid poured will fall equally to the glass immediately to the left and right of it  when those glasses become full  any excess champagne will fall equally to the left and right of those glasses  and so on  (a glass at the bottom row has it's excess champagne fall on the floor ) for medium 
 [c++ java python] o(101) space solution champagne tower we stack glasses in a pyramid  where the first row has 1 glass  the second row has 2 glasses  and so on until the 100th row  each glass holds one cup (250ml) of champagne  then  some champagne is poured in the first glass at the top  when the top most glass is full  any excess liquid poured will fall equally to the glass immediately to the left and right of it  when those glasses become full  any excess champagne will fall equally to the left and right of those glasses  and so on  (a glass at the bottom row has it's excess champagne fall on the floor ) for medium 
simple c++ solution and explanations champagne tower we stack glasses in a pyramid  where the first row has 1 glass  the second row has 2 glasses  and so on until the 100th row  each glass holds one cup (250ml) of champagne  then  some champagne is poured in the first glass at the top  when the top most glass is full  any excess liquid poured will fall equally to the glass immediately to the left and right of it  when those glasses become full  any excess champagne will fall equally to the left and right of those glasses  and so on  (a glass at the bottom row has it's excess champagne fall on the floor ) for medium 
simple python dp solution champagne tower we stack glasses in a pyramid  where the first row has 1 glass  the second row has 2 glasses  and so on until the 100th row  each glass holds one cup (250ml) of champagne  then  some champagne is poured in the first glass at the top  when the top most glass is full  any excess liquid poured will fall equally to the glass immediately to the left and right of it  when those glasses become full  any excess champagne will fall equally to the left and right of those glasses  and so on  (a glass at the bottom row has it's excess champagne fall on the floor ) for medium 
java o(n) dp solution minimum swaps to make sequences increasing we have two integer sequences a and b of the same non-zero length  we are allowed to swap elements a[i] and b[i]  note that both elements are in the same index position in their respective sequences  at the end of some number of swaps  a and b are both strictly increasing  (a sequence is strictly increasing if and only if a[0] < a[1] < a[2] <     < a[a length - 1] ) given a and b  return the minimum number of swaps to make both sequences strictly increasing  it is guaranteed that the given input always makes it possible  medium dynamic programming 
python 14-line o(1) space o(n) time dp solution minimum swaps to make sequences increasing we have two integer sequences a and b of the same non-zero length  we are allowed to swap elements a[i] and b[i]  note that both elements are in the same index position in their respective sequences  at the end of some number of swaps  a and b are both strictly increasing  (a sequence is strictly increasing if and only if a[0] < a[1] < a[2] <     < a[a length - 1] ) given a and b  return the minimum number of swaps to make both sequences strictly increasing  it is guaranteed that the given input always makes it possible  medium dynamic programming 
[c++ java python] easy understood dp solution minimum swaps to make sequences increasing we have two integer sequences a and b of the same non-zero length  we are allowed to swap elements a[i] and b[i]  note that both elements are in the same index position in their respective sequences  at the end of some number of swaps  a and b are both strictly increasing  (a sequence is strictly increasing if and only if a[0] < a[1] < a[2] <     < a[a length - 1] ) given a and b  return the minimum number of swaps to make both sequences strictly increasing  it is guaranteed that the given input always makes it possible  medium dynamic programming 
logical thinking with optimization minimum swaps to make sequences increasing we have two integer sequences a and b of the same non-zero length  we are allowed to swap elements a[i] and b[i]  note that both elements are in the same index position in their respective sequences  at the end of some number of swaps  a and b are both strictly increasing  (a sequence is strictly increasing if and only if a[0] < a[1] < a[2] <     < a[a length - 1] ) given a and b  return the minimum number of swaps to make both sequences strictly increasing  it is guaranteed that the given input always makes it possible  medium dynamic programming 
java neat and easy to understand dp o(n) solution! minimum swaps to make sequences increasing we have two integer sequences a and b of the same non-zero length  we are allowed to swap elements a[i] and b[i]  note that both elements are in the same index position in their respective sequences  at the end of some number of swaps  a and b are both strictly increasing  (a sequence is strictly increasing if and only if a[0] < a[1] < a[2] <     < a[a length - 1] ) given a and b  return the minimum number of swaps to make both sequences strictly increasing  it is guaranteed that the given input always makes it possible  medium dynamic programming 
straightforward java solution  easy to understand! find eventual safe states in a directed graph  we start at some node and every turn  walk along a directed edge of the graph  if we reach a node that is terminal (that is  it has no outgoing directed edges)  we stop  now  say our starting node is eventually safe if and only if we must eventually walk to a terminal node  more specifically  there exists a natural number k so that for any choice of where to walk  we must have stopped at a terminal node in less than k steps  which nodes are eventually safe? return them as an array in sorted order  the directed graph has n nodes with labels 0  1       n-1  where n is the length of graph  the graph is given in the following form: graph[i] is a list of labels j such that (i  j) is a directed edge of the graph  medium depth-first search graph 
20-line python concise sol by removing 0 out degree nodes find eventual safe states in a directed graph  we start at some node and every turn  walk along a directed edge of the graph  if we reach a node that is terminal (that is  it has no outgoing directed edges)  we stop  now  say our starting node is eventually safe if and only if we must eventually walk to a terminal node  more specifically  there exists a natural number k so that for any choice of where to walk  we must have stopped at a terminal node in less than k steps  which nodes are eventually safe? return them as an array in sorted order  the directed graph has n nodes with labels 0  1       n-1  where n is the length of graph  the graph is given in the following form: graph[i] is a list of labels j such that (i  j) is a directed edge of the graph  medium depth-first search graph 
python  easy peasy    11 lines very simple and clear solution    192 ms    beats 100 % find eventual safe states in a directed graph  we start at some node and every turn  walk along a directed edge of the graph  if we reach a node that is terminal (that is  it has no outgoing directed edges)  we stop  now  say our starting node is eventually safe if and only if we must eventually walk to a terminal node  more specifically  there exists a natural number k so that for any choice of where to walk  we must have stopped at a terminal node in less than k steps  which nodes are eventually safe? return them as an array in sorted order  the directed graph has n nodes with labels 0  1       n-1  where n is the length of graph  the graph is given in the following form: graph[i] is a list of labels j such that (i  j) is a directed edge of the graph  medium depth-first search graph 
c++  simple topological sorting with dp find eventual safe states in a directed graph  we start at some node and every turn  walk along a directed edge of the graph  if we reach a node that is terminal (that is  it has no outgoing directed edges)  we stop  now  say our starting node is eventually safe if and only if we must eventually walk to a terminal node  more specifically  there exists a natural number k so that for any choice of where to walk  we must have stopped at a terminal node in less than k steps  which nodes are eventually safe? return them as an array in sorted order  the directed graph has n nodes with labels 0  1       n-1  where n is the length of graph  the graph is given in the following form: graph[i] is a list of labels j such that (i  j) is a directed edge of the graph  medium depth-first search graph 
c++ dfs solution with explanation  o(n) find eventual safe states in a directed graph  we start at some node and every turn  walk along a directed edge of the graph  if we reach a node that is terminal (that is  it has no outgoing directed edges)  we stop  now  say our starting node is eventually safe if and only if we must eventually walk to a terminal node  more specifically  there exists a natural number k so that for any choice of where to walk  we must have stopped at a terminal node in less than k steps  which nodes are eventually safe? return them as an array in sorted order  the directed graph has n nodes with labels 0  1       n-1  where n is the length of graph  the graph is given in the following form: graph[i] is a list of labels j such that (i  j) is a directed edge of the graph  medium depth-first search graph 
python solution by reversely adding hits bricks back bricks falling when hit we have a grid of 1s and 0s; the 1s in a cell represent bricks  a brick will not drop if and only if it is directly connected to the top of the grid  or at least one of its (4-way) adjacent bricks will not drop  we will do some erasures sequentially  each time we want to do the erasure at the location (i  j)  the brick (if it exists) on that location will disappear  and then some other bricks may drop because of that erasure  return an array representing the number of bricks that will drop after each erasure in sequence  hard union find 
tricky problem that reverses lc305 bricks falling when hit we have a grid of 1s and 0s; the 1s in a cell represent bricks  a brick will not drop if and only if it is directly connected to the top of the grid  or at least one of its (4-way) adjacent bricks will not drop  we will do some erasures sequentially  each time we want to do the erasure at the location (i  j)  the brick (if it exists) on that location will disappear  and then some other bricks may drop because of that erasure  return an array representing the number of bricks that will drop after each erasure in sequence  hard union find 
c++ dfs (similar to lc749) bricks falling when hit we have a grid of 1s and 0s; the 1s in a cell represent bricks  a brick will not drop if and only if it is directly connected to the top of the grid  or at least one of its (4-way) adjacent bricks will not drop  we will do some erasures sequentially  each time we want to do the erasure at the location (i  j)  the brick (if it exists) on that location will disappear  and then some other bricks may drop because of that erasure  return an array representing the number of bricks that will drop after each erasure in sequence  hard union find 
java solution bricks falling when hit we have a grid of 1s and 0s; the 1s in a cell represent bricks  a brick will not drop if and only if it is directly connected to the top of the grid  or at least one of its (4-way) adjacent bricks will not drop  we will do some erasures sequentially  each time we want to do the erasure at the location (i  j)  the brick (if it exists) on that location will disappear  and then some other bricks may drop because of that erasure  return an array representing the number of bricks that will drop after each erasure in sequence  hard union find 
java simple dfs 16ms  reversely add bricks back bricks falling when hit we have a grid of 1s and 0s; the 1s in a cell represent bricks  a brick will not drop if and only if it is directly connected to the top of the grid  or at least one of its (4-way) adjacent bricks will not drop  we will do some erasures sequentially  each time we want to do the erasure at the location (i  j)  the brick (if it exists) on that location will disappear  and then some other bricks may drop because of that erasure  return an array representing the number of bricks that will drop after each erasure in sequence  hard union find 
is the description of the problem correct? unique morse code words international morse code defines a standard encoding where each letter is mapped to a series of dots and dashes  as follows: "a" maps to " -"  "b" maps to "-   "  "c" maps to "- - "  and so on  for convenience  the full table for the 26 letters of the english alphabet is given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given a list of words  each word can be written as a concatenation of the morse code of each letter  for easy string 
[c++ java python]  easy and concise solution unique morse code words international morse code defines a standard encoding where each letter is mapped to a series of dots and dashes  as follows: "a" maps to " -"  "b" maps to "-   "  "c" maps to "- - "  and so on  for convenience  the full table for the 26 letters of the english alphabet is given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given a list of words  each word can be written as a concatenation of the morse code of each letter  for easy string 
c++  straightforward unique morse code words international morse code defines a standard encoding where each letter is mapped to a series of dots and dashes  as follows: "a" maps to " -"  "b" maps to "-   "  "c" maps to "- - "  and so on  for convenience  the full table for the 26 letters of the english alphabet is given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given a list of words  each word can be written as a concatenation of the morse code of each letter  for easy string 
accepted java solution unique morse code words international morse code defines a standard encoding where each letter is mapped to a series of dots and dashes  as follows: "a" maps to " -"  "b" maps to "-   "  "c" maps to "- - "  and so on  for convenience  the full table for the 26 letters of the english alphabet is given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given a list of words  each word can be written as a concatenation of the morse code of each letter  for easy string 
easy python solution unique morse code words international morse code defines a standard encoding where each letter is mapped to a series of dots and dashes  as follows: "a" maps to " -"  "b" maps to "-   "  "c" maps to "- - "  and so on  for convenience  the full table for the 26 letters of the english alphabet is given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given a list of words  each word can be written as a concatenation of the morse code of each letter  for easy string 
c++ solution with explanation  early termination (updated for new test case) split array with same average in a given integer array a  we must move every element of a to either list b or list c  (b and c initially start empty ) return true if and only if after such a move  it is possible that the average value of b is equal to the average value of c  and b and c are both non-empty  hard math 
dp with bitset over  sum  (fast python ruby  decent c++) split array with same average in a given integer array a  we must move every element of a to either list b or list c  (b and c initially start empty ) return true if and only if after such a move  it is possible that the average value of b is equal to the average value of c  and b and c are both non-empty  hard math 
simple python with explanation split array with same average in a given integer array a  we must move every element of a to either list b or list c  (b and c initially start empty ) return true if and only if after such a move  it is possible that the average value of b is equal to the average value of c  and b and c are both non-empty  hard math 
java  accepted recursive solution  with explanation split array with same average in a given integer array a  we must move every element of a to either list b or list c  (b and c initially start empty ) return true if and only if after such a move  it is possible that the average value of b is equal to the average value of c  and b and c are both non-empty  hard math 
easy and concise solution ［c++ java python］  split array with same average in a given integer array a  we must move every element of a to either list b or list c  (b and c initially start empty ) return true if and only if after such a move  it is possible that the average value of b is equal to the average value of c  and b and c are both non-empty  hard math 
the description of the question has to be updated number of lines to write string we are to write the letters of a given string s  from left to right into lines  each line has maximum width 100 units  and if writing a letter would cause the width of the line to exceed 100 units  it is written on the next line  we are given an array widths  an array where widths[0] is the width of 'a'  widths[1] is the width of 'b'       and widths[25] is the width of 'z'  now answer two questions: how many lines have at least one character from s  and what is the width used by the last such line? return your answer as an integer list of length 2  easy 
easy solution 6-lines [c++ java python]  number of lines to write string we are to write the letters of a given string s  from left to right into lines  each line has maximum width 100 units  and if writing a letter would cause the width of the line to exceed 100 units  it is written on the next line  we are given an array widths  an array where widths[0] is the width of 'a'  widths[1] is the width of 'b'       and widths[25] is the width of 'z'  now answer two questions: how many lines have at least one character from s  and what is the width used by the last such line? return your answer as an integer list of length 2  easy 
this question is so inane and badly written it should be deleted  number of lines to write string we are to write the letters of a given string s  from left to right into lines  each line has maximum width 100 units  and if writing a letter would cause the width of the line to exceed 100 units  it is written on the next line  we are given an array widths  an array where widths[0] is the width of 'a'  widths[1] is the width of 'b'       and widths[25] is the width of 'z'  now answer two questions: how many lines have at least one character from s  and what is the width used by the last such line? return your answer as an integer list of length 2  easy 
regex number of lines to write string we are to write the letters of a given string s  from left to right into lines  each line has maximum width 100 units  and if writing a letter would cause the width of the line to exceed 100 units  it is written on the next line  we are given an array widths  an array where widths[0] is the width of 'a'  widths[1] is the width of 'b'       and widths[25] is the width of 'z'  now answer two questions: how many lines have at least one character from s  and what is the width used by the last such line? return your answer as an integer list of length 2  easy 
c++  straightforward  number of lines to write string we are to write the letters of a given string s  from left to right into lines  each line has maximum width 100 units  and if writing a letter would cause the width of the line to exceed 100 units  it is written on the next line  we are given an array widths  an array where widths[0] is the width of 'a'  widths[1] is the width of 'b'       and widths[25] is the width of 'z'  now answer two questions: how many lines have at least one character from s  and what is the width used by the last such line? return your answer as an integer list of length 2  easy 
easy and concise solution [c++ java python]  max increase to keep city skyline in a 2 dimensional array grid  each value grid[i][j] represents the height of a building located there  we are allowed to increase the height of any number of buildings  by any amount (the amounts can be different for different buildings)  height 0 is considered to be a building as well  at the end  the "skyline" when viewed from all four directions of the grid  i e  top  bottom  left  and right  must be the same as the skyline of the original grid  a city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance  see the following medium 
what is this question?  max increase to keep city skyline in a 2 dimensional array grid  each value grid[i][j] represents the height of a building located there  we are allowed to increase the height of any number of buildings  by any amount (the amounts can be different for different buildings)  height 0 is considered to be a building as well  at the end  the "skyline" when viewed from all four directions of the grid  i e  top  bottom  left  and right  must be the same as the skyline of the original grid  a city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance  see the following medium 
48ms python3 solution max increase to keep city skyline in a 2 dimensional array grid  each value grid[i][j] represents the height of a building located there  we are allowed to increase the height of any number of buildings  by any amount (the amounts can be different for different buildings)  height 0 is considered to be a building as well  at the end  the "skyline" when viewed from all four directions of the grid  i e  top  bottom  left  and right  must be the same as the skyline of the original grid  a city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance  see the following medium 
c++  straightforward o(m n) time max increase to keep city skyline in a 2 dimensional array grid  each value grid[i][j] represents the height of a building located there  we are allowed to increase the height of any number of buildings  by any amount (the amounts can be different for different buildings)  height 0 is considered to be a building as well  at the end  the "skyline" when viewed from all four directions of the grid  i e  top  bottom  left  and right  must be the same as the skyline of the original grid  a city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance  see the following medium 
simple python solution max increase to keep city skyline in a 2 dimensional array grid  each value grid[i][j] represents the height of a building located there  we are allowed to increase the height of any number of buildings  by any amount (the amounts can be different for different buildings)  height 0 is considered to be a building as well  at the end  the "skyline" when viewed from all four directions of the grid  i e  top  bottom  left  and right  must be the same as the skyline of the original grid  a city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance  see the following medium 
[c++ java python] when n >= 4800  just return 1 soup servings there are two types of soup: type a and type b  initially we have n ml of each type of soup  there are four kinds of operations: serve 100 ml of soup a and 0 ml of soup b serve 75 ml of soup a and 25 ml of soup b serve 50 ml of soup a and 50 ml of soup b serve 25 ml of soup a and 75 ml of soup b when we serve some soup  we give it to someone and we no longer have it  each turn  we will choose from the four operations with equal probability 0 25  if the remaining volume of soup is not enough to complete the operation  we will serve as much as we can  we stop once we no longer have some quantity of both types of soup  note that we do not have the operation where all 100 ml's of soup b are used first  return the probability that soup a will be empty first  plus half the probability that a and b become empty at the same time  medium dynamic programming 
straightforward java recursion with memorization soup servings there are two types of soup: type a and type b  initially we have n ml of each type of soup  there are four kinds of operations: serve 100 ml of soup a and 0 ml of soup b serve 75 ml of soup a and 25 ml of soup b serve 50 ml of soup a and 50 ml of soup b serve 25 ml of soup a and 75 ml of soup b when we serve some soup  we give it to someone and we no longer have it  each turn  we will choose from the four operations with equal probability 0 25  if the remaining volume of soup is not enough to complete the operation  we will serve as much as we can  we stop once we no longer have some quantity of both types of soup  note that we do not have the operation where all 100 ml's of soup b are used first  return the probability that soup a will be empty first  plus half the probability that a and b become empty at the same time  medium dynamic programming 
easy understand c++ recursive solution soup servings there are two types of soup: type a and type b  initially we have n ml of each type of soup  there are four kinds of operations: serve 100 ml of soup a and 0 ml of soup b serve 75 ml of soup a and 25 ml of soup b serve 50 ml of soup a and 50 ml of soup b serve 25 ml of soup a and 75 ml of soup b when we serve some soup  we give it to someone and we no longer have it  each turn  we will choose from the four operations with equal probability 0 25  if the remaining volume of soup is not enough to complete the operation  we will serve as much as we can  we stop once we no longer have some quantity of both types of soup  note that we do not have the operation where all 100 ml's of soup b are used first  return the probability that soup a will be empty first  plus half the probability that a and b become empty at the same time  medium dynamic programming 
python    7 lines clear dp solution    44 ms    beats 97 5 % soup servings there are two types of soup: type a and type b  initially we have n ml of each type of soup  there are four kinds of operations: serve 100 ml of soup a and 0 ml of soup b serve 75 ml of soup a and 25 ml of soup b serve 50 ml of soup a and 50 ml of soup b serve 25 ml of soup a and 75 ml of soup b when we serve some soup  we give it to someone and we no longer have it  each turn  we will choose from the four operations with equal probability 0 25  if the remaining volume of soup is not enough to complete the operation  we will serve as much as we can  we stop once we no longer have some quantity of both types of soup  note that we do not have the operation where all 100 ml's of soup b are used first  return the probability that soup a will be empty first  plus half the probability that a and b become empty at the same time  medium dynamic programming 
[java]top down search with hashmap memorized soup servings there are two types of soup: type a and type b  initially we have n ml of each type of soup  there are four kinds of operations: serve 100 ml of soup a and 0 ml of soup b serve 75 ml of soup a and 25 ml of soup b serve 50 ml of soup a and 50 ml of soup b serve 25 ml of soup a and 75 ml of soup b when we serve some soup  we give it to someone and we no longer have it  each turn  we will choose from the four operations with equal probability 0 25  if the remaining volume of soup is not enough to complete the operation  we will serve as much as we can  we stop once we no longer have some quantity of both types of soup  note that we do not have the operation where all 100 ml's of soup b are used first  return the probability that soup a will be empty first  plus half the probability that a and b become empty at the same time  medium dynamic programming 
[c++ java python] 2 pointers and 4 pointers expressive words sometimes people repeat letters to represent extra feeling  such as "hello" -> "heeellooo"  "hi" -> "hiiii"  here  we have groups  of adjacent letters that are all the same character  and adjacent characters to the group are different  a group is extended if that group is length 3 or more  so "e" and "o" would be extended in the first medium string 
short straight-forward c++ solution  two pointers one pass scan expressive words sometimes people repeat letters to represent extra feeling  such as "hello" -> "heeellooo"  "hi" -> "hiiii"  here  we have groups  of adjacent letters that are all the same character  and adjacent characters to the group are different  a group is extended if that group is length 3 or more  so "e" and "o" would be extended in the first medium string 
some test case have problems? expressive words sometimes people repeat letters to represent extra feeling  such as "hello" -> "heeellooo"  "hi" -> "hiiii"  here  we have groups  of adjacent letters that are all the same character  and adjacent characters to the group are different  a group is extended if that group is length 3 or more  so "e" and "o" would be extended in the first medium string 
15 lines java code - 2 pointers 1 pass  expressive words sometimes people repeat letters to represent extra feeling  such as "hello" -> "heeellooo"  "hi" -> "hiiii"  here  we have groups  of adjacent letters that are all the same character  and adjacent characters to the group are different  a group is extended if that group is length 3 or more  so "e" and "o" would be extended in the first medium string 
simple and clear solution with detailed exaplanation expressive words sometimes people repeat letters to represent extra feeling  such as "hello" -> "heeellooo"  "hi" -> "hiiii"  here  we have groups  of adjacent letters that are all the same character  and adjacent characters to the group are different  a group is extended if that group is length 3 or more  so "e" and "o" would be extended in the first medium string 
why [1 2 3] return true? chalkboard xor game we are given non-negative integers nums[i] which are written on a chalkboard  alice and bob take turns erasing exactly one number from the chalkboard  with alice starting first  if erasing a number causes the bitwise xor of all the elements of the chalkboard to become 0  then that player loses  (also  we'll say the bitwise xor of one element is that element itself  and the bitwise xor of no elements is 0 ) also  if any player starts their turn with the bitwise xor of all the elements of the chalkboard equal to 0  then that player wins  return true if and only if alice wins the game  assuming both players play optimally  hard math 
[c++ java python] 3-lines easy solution with complaint and explanation chalkboard xor game we are given non-negative integers nums[i] which are written on a chalkboard  alice and bob take turns erasing exactly one number from the chalkboard  with alice starting first  if erasing a number causes the bitwise xor of all the elements of the chalkboard to become 0  then that player loses  (also  we'll say the bitwise xor of one element is that element itself  and the bitwise xor of no elements is 0 ) also  if any player starts their turn with the bitwise xor of all the elements of the chalkboard equal to 0  then that player wins  return true if and only if alice wins the game  assuming both players play optimally  hard math 
[810 chalkboard xor game] c++ ac chalkboard xor game we are given non-negative integers nums[i] which are written on a chalkboard  alice and bob take turns erasing exactly one number from the chalkboard  with alice starting first  if erasing a number causes the bitwise xor of all the elements of the chalkboard to become 0  then that player loses  (also  we'll say the bitwise xor of one element is that element itself  and the bitwise xor of no elements is 0 ) also  if any player starts their turn with the bitwise xor of all the elements of the chalkboard equal to 0  then that player wins  return true if and only if alice wins the game  assuming both players play optimally  hard math 
solution based on minimax   but returns false for [1 2 3] so not accepted in oj chalkboard xor game we are given non-negative integers nums[i] which are written on a chalkboard  alice and bob take turns erasing exactly one number from the chalkboard  with alice starting first  if erasing a number causes the bitwise xor of all the elements of the chalkboard to become 0  then that player loses  (also  we'll say the bitwise xor of one element is that element itself  and the bitwise xor of no elements is 0 ) also  if any player starts their turn with the bitwise xor of all the elements of the chalkboard equal to 0  then that player wins  return true if and only if alice wins the game  assuming both players play optimally  hard math 
o(n) simple python3 with explanation -- beats 100% chalkboard xor game we are given non-negative integers nums[i] which are written on a chalkboard  alice and bob take turns erasing exactly one number from the chalkboard  with alice starting first  if erasing a number causes the bitwise xor of all the elements of the chalkboard to become 0  then that player loses  (also  we'll say the bitwise xor of one element is that element itself  and the bitwise xor of no elements is 0 ) also  if any player starts their turn with the bitwise xor of all the elements of the chalkboard equal to 0  then that player wins  return true if and only if alice wins the game  assuming both players play optimally  hard math 
[c++ java python] easy understood solution subdomain visit count a website domain like "discuss leetcode com" consists of various subdomains  at the top level  we have "com"  at the next level  we have "leetcode com"  and at the lowest level  "discuss leetcode com"  when we visit a domain like "discuss leetcode com"  we will also visit the parent domains "leetcode com" and "com" implicitly  now  call a "count-paired domain" to be a count (representing the number of visits this domain received)  followed by a space  followed by the address  an easy hash table 
java: do not use string split() to handle the string in this case and the code will run faster subdomain visit count a website domain like "discuss leetcode com" consists of various subdomains  at the top level  we have "com"  at the next level  we have "leetcode com"  and at the lowest level  "discuss leetcode com"  when we visit a domain like "discuss leetcode com"  we will also visit the parent domains "leetcode com" and "com" implicitly  now  call a "count-paired domain" to be a count (representing the number of visits this domain received)  followed by a space  followed by the address  an easy hash table 
python short & understandable solution [68 ms] subdomain visit count a website domain like "discuss leetcode com" consists of various subdomains  at the top level  we have "com"  at the next level  we have "leetcode com"  and at the lowest level  "discuss leetcode com"  when we visit a domain like "discuss leetcode com"  we will also visit the parent domains "leetcode com" and "com" implicitly  now  call a "count-paired domain" to be a count (representing the number of visits this domain received)  followed by a space  followed by the address  an easy hash table 
c++ 10 line solution w  explanation subdomain visit count a website domain like "discuss leetcode com" consists of various subdomains  at the top level  we have "com"  at the next level  we have "leetcode com"  and at the lowest level  "discuss leetcode com"  when we visit a domain like "discuss leetcode com"  we will also visit the parent domains "leetcode com" and "com" implicitly  now  call a "count-paired domain" to be a count (representing the number of visits this domain received)  followed by a space  followed by the address  an easy hash table 
java solution very easy to understand! subdomain visit count a website domain like "discuss leetcode com" consists of various subdomains  at the top level  we have "com"  at the next level  we have "leetcode com"  and at the lowest level  "discuss leetcode com"  when we visit a domain like "discuss leetcode com"  we will also visit the parent domains "leetcode com" and "com" implicitly  now  call a "count-paired domain" to be a count (representing the number of visits this domain received)  followed by a space  followed by the address  an easy hash table 
[c++ java python] solution with explanation and prove largest triangle area you have a list of points in the plane  return the area of the largest triangle that can be formed by any 3 of the points  easy math 
bad problem  solution is brute force largest triangle area you have a list of points in the plane  return the area of the largest triangle that can be formed by any 3 of the points  easy math 
simple java - easy understand  largest triangle area you have a list of points in the plane  return the area of the largest triangle that can be formed by any 3 of the points  easy math 
[python] another convex hull solution (44ms) to reduce the search space   largest triangle area you have a list of points in the plane  return the area of the largest triangle that can be formed by any 3 of the points  easy math 
javascript t(n^3) s(1) largest triangle area you have a list of points in the plane  return the area of the largest triangle that can be formed by any 3 of the points  easy math 
[c++ java python] easy understood solution with explanation largest sum of averages we partition a row of numbers a into at most k adjacent (non-empty) groups  then our score is the sum of the average of each group  what is the largest score we can achieve? note that our partition must use every number in a  and that scores are not necessarily integers  medium dynamic programming 
[naive] detailed step by step approach from recursive to dp o(n) solution largest sum of averages we partition a row of numbers a into at most k adjacent (non-empty) groups  then our score is the sum of the average of each group  what is the largest score we can achieve? note that our partition must use every number in a  and that scores are not necessarily integers  medium dynamic programming 
java bottom-up dp with explanation largest sum of averages we partition a row of numbers a into at most k adjacent (non-empty) groups  then our score is the sum of the average of each group  what is the largest score we can achieve? note that our partition must use every number in a  and that scores are not necessarily integers  medium dynamic programming 
c++ dp largest sum of averages we partition a row of numbers a into at most k adjacent (non-empty) groups  then our score is the sum of the average of each group  what is the largest score we can achieve? note that our partition must use every number in a  and that scores are not necessarily integers  medium dynamic programming 
c++ dp simple solution use o(n k) space and o(k n^2) time with detailed explanation largest sum of averages we partition a row of numbers a into at most k adjacent (non-empty) groups  then our score is the sum of the average of each group  what is the largest score we can achieve? note that our partition must use every number in a  and that scores are not necessarily integers  medium dynamic programming 
[c++ java python]  self-explaining solution and 2-lines binary tree pruning we are given the head node root of a binary tree  where additionally every node's value is either a 0 or a 1  return the same tree where every subtree (of the given tree) not containing a 1 has been removed  (recall that the subtree of a node x is x  plus every node that is a descendant of x ) medium tree 
3 recursive lines dedicated to python binary tree pruning we are given the head node root of a binary tree  where additionally every node's value is either a 0 or a 1  return the same tree where every subtree (of the given tree) not containing a 1 has been removed  (recall that the subtree of a node x is x  plus every node that is a descendant of x ) medium tree 
java 4 lines solution using recursion binary tree pruning we are given the head node root of a binary tree  where additionally every node's value is either a 0 or a 1  return the same tree where every subtree (of the given tree) not containing a 1 has been removed  (recall that the subtree of a node x is x  plus every node that is a descendant of x ) medium tree 
clean recursive - python binary tree pruning we are given the head node root of a binary tree  where additionally every node's value is either a 0 or a 1  return the same tree where every subtree (of the given tree) not containing a 1 has been removed  (recall that the subtree of a node x is x  plus every node that is a descendant of x ) medium tree 
java backtracking with o(n) time complexity binary tree pruning we are given the head node root of a binary tree  where additionally every node's value is either a 0 or a 1  return the same tree where every subtree (of the given tree) not containing a 1 has been removed  (recall that the subtree of a node x is x  plus every node that is a descendant of x ) medium tree 
simple java solution using bfs bus routes we have a list of bus routes  each routes[i] is a bus route that the i-th bus repeats forever  for hard breadth-first search 
[c++ java python] bfs solution bus routes we have a list of bus routes  each routes[i] is a bus route that the i-th bus repeats forever  for hard breadth-first search 
data invaild? bus routes we have a list of bus routes  each routes[i] is a bus route that the i-th bus repeats forever  for hard breadth-first search 
python bfs with explanation bus routes we have a list of bus routes  each routes[i] is a bus route that the i-th bus repeats forever  for hard breadth-first search 
python    short & simple & readable & self-explanatory bfs solution    ~170 ms bus routes we have a list of bus routes  each routes[i] is a bus route that the i-th bus repeats forever  for hard breadth-first search 
[c++ java python] solution with explanation ambiguous coordinates we had some 2-dimensional coordinates  like "(1  3)" or "(2  0 5)"  then  we removed all commas  decimal points  and spaces  and ended up with the string s  return a list of strings representing all possibilities for what our original coordinates could have been  our original representation never had extraneous zeroes  so we never started with numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  or any other number that can be represented with less digits  also  a decimal point within a number never occurs without at least one digit occuring before it  so we never started with numbers like " 1"  the final answer list can be returned in any order  also note that all coordinates in the final answer have exactly one space between them (occurring after the comma ) medium string 
really clear java code ambiguous coordinates we had some 2-dimensional coordinates  like "(1  3)" or "(2  0 5)"  then  we removed all commas  decimal points  and spaces  and ended up with the string s  return a list of strings representing all possibilities for what our original coordinates could have been  our original representation never had extraneous zeroes  so we never started with numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  or any other number that can be represented with less digits  also  a decimal point within a number never occurs without at least one digit occuring before it  so we never started with numbers like " 1"  the final answer list can be returned in any order  also note that all coordinates in the final answer have exactly one space between them (occurring after the comma ) medium string 
concise c++ solution with comments ambiguous coordinates we had some 2-dimensional coordinates  like "(1  3)" or "(2  0 5)"  then  we removed all commas  decimal points  and spaces  and ended up with the string s  return a list of strings representing all possibilities for what our original coordinates could have been  our original representation never had extraneous zeroes  so we never started with numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  or any other number that can be represented with less digits  also  a decimal point within a number never occurs without at least one digit occuring before it  so we never started with numbers like " 1"  the final answer list can be returned in any order  also note that all coordinates in the final answer have exactly one space between them (occurring after the comma ) medium string 
kotlin solution ambiguous coordinates we had some 2-dimensional coordinates  like "(1  3)" or "(2  0 5)"  then  we removed all commas  decimal points  and spaces  and ended up with the string s  return a list of strings representing all possibilities for what our original coordinates could have been  our original representation never had extraneous zeroes  so we never started with numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  or any other number that can be represented with less digits  also  a decimal point within a number never occurs without at least one digit occuring before it  so we never started with numbers like " 1"  the final answer list can be returned in any order  also note that all coordinates in the final answer have exactly one space between them (occurring after the comma ) medium string 
64ms intuitive python solution that beats 99% ambiguous coordinates we had some 2-dimensional coordinates  like "(1  3)" or "(2  0 5)"  then  we removed all commas  decimal points  and spaces  and ended up with the string s  return a list of strings representing all possibilities for what our original coordinates could have been  our original representation never had extraneous zeroes  so we never started with numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  or any other number that can be represented with less digits  also  a decimal point within a number never occurs without at least one digit occuring before it  so we never started with numbers like " 1"  the final answer list can be returned in any order  also note that all coordinates in the final answer have exactly one space between them (occurring after the comma ) medium string 
[c++ java python] easy and concise solution with explanation linked list components we are given head  the head node of a linked list containing unique integer values  we are also given the list g  a subset of the values in the linked list  return the number of connected components in g  where two values are connected if they appear consecutively in the linked list  medium linked list 
can someone explain the test case linked list components we are given head  the head node of a linked list containing unique integer values  we are also given the list g  a subset of the values in the linked list  return the number of connected components in g  where two values are connected if they appear consecutively in the linked list  medium linked list 
how is 3  a connected component in this example statement linked list components we are given head  the head node of a linked list containing unique integer values  we are also given the list g  a subset of the values in the linked list  return the number of connected components in g  where two values are connected if they appear consecutively in the linked list  medium linked list 
java solution using hashset linked list components we are given head  the head node of a linked list containing unique integer values  we are also given the list g  a subset of the values in the linked list  return the number of connected components in g  where two values are connected if they appear consecutively in the linked list  medium linked list 
python using two pointers linked list components we are given head  the head node of a linked list containing unique integer values  we are also given the list g  a subset of the values in the linked list  return the number of connected components in g  where two values are connected if they appear consecutively in the linked list  medium linked list 
summary of the bfs and dp solutions with intuitive explanation race car your car starts at position 0 and speed +1 on an infinite number line  (your car can go into negative positions ) your car drives automatically according to a sequence of instructions a (accelerate) and r (reverse)  when you get an instruction "a"  your car does the following: position += speed  speed  = 2  when you get an instruction "r"  your car does the following: if your speed is positive then speed = -1   otherwise speed = 1  (your position stays the same ) for hard dynamic programming heap 
[c++ javapython] dp solution race car your car starts at position 0 and speed +1 on an infinite number line  (your car can go into negative positions ) your car drives automatically according to a sequence of instructions a (accelerate) and r (reverse)  when you get an instruction "a"  your car does the following: position += speed  speed  = 2  when you get an instruction "r"  your car does the following: if your speed is positive then speed = -1   otherwise speed = 1  (your position stays the same ) for hard dynamic programming heap 
accepted java solution with bfs race car your car starts at position 0 and speed +1 on an infinite number line  (your car can go into negative positions ) your car drives automatically according to a sequence of instructions a (accelerate) and r (reverse)  when you get an instruction "a"  your car does the following: position += speed  speed  = 2  when you get an instruction "r"  your car does the following: if your speed is positive then speed = -1   otherwise speed = 1  (your position stays the same ) for hard dynamic programming heap 
accepted plain bfs race car your car starts at position 0 and speed +1 on an infinite number line  (your car can go into negative positions ) your car drives automatically according to a sequence of instructions a (accelerate) and r (reverse)  when you get an instruction "a"  your car does the following: position += speed  speed  = 2  when you get an instruction "r"  your car does the following: if your speed is positive then speed = -1   otherwise speed = 1  (your position stays the same ) for hard dynamic programming heap 
straightforward c++ bfs solution with explanation race car your car starts at position 0 and speed +1 on an infinite number line  (your car can go into negative positions ) your car drives automatically according to a sequence of instructions a (accelerate) and r (reverse)  when you get an instruction "a"  your car does the following: position += speed  speed  = 2  when you get an instruction "r"  your car does the following: if your speed is positive then speed = -1   otherwise speed = 1  (your position stays the same ) for hard dynamic programming heap 
[c++ java python] easy solution with explanation most common word given a paragraph and a list of banned words  return the most frequent word that is not in the list of banned words  it is guaranteed there is at least one word that isn't banned  and that the answer is unique  words in the list of banned words are given in lowercase  and free of punctuation  words in the paragraph are not case sensitive  the answer is in lowercase  easy string 
last test case is weird most common word given a paragraph and a list of banned words  return the most frequent word that is not in the list of banned words  it is guaranteed there is at least one word that isn't banned  and that the answer is unique  words in the list of banned words are given in lowercase  and free of punctuation  words in the paragraph are not case sensitive  the answer is in lowercase  easy string 
clean 6ms c++ solution most common word given a paragraph and a list of banned words  return the most frequent word that is not in the list of banned words  it is guaranteed there is at least one word that isn't banned  and that the answer is unique  words in the list of banned words are given in lowercase  and free of punctuation  words in the paragraph are not case sensitive  the answer is in lowercase  easy string 
simple java solution most common word given a paragraph and a list of banned words  return the most frequent word that is not in the list of banned words  it is guaranteed there is at least one word that isn't banned  and that the answer is unique  words in the list of banned words are given in lowercase  and free of punctuation  words in the paragraph are not case sensitive  the answer is in lowercase  easy string 
[java] simple solution using hashmaps along with asserts to test most common word given a paragraph and a list of banned words  return the most frequent word that is not in the list of banned words  it is guaranteed there is at least one word that isn't banned  and that the answer is unique  words in the list of banned words are given in lowercase  and free of punctuation  words in the paragraph are not case sensitive  the answer is in lowercase  easy string 
[c++ java python] easy understood solution with explanation short encoding of words given a list of words  we may encode it by writing a reference string s and a list of indexes a  for medium 
trie solution short encoding of words given a list of words  we may encode it by writing a reference string s and a list of indexes a  for medium 
simple concept using trie short encoding of words given a list of words  we may encode it by writing a reference string s and a list of indexes a  for medium 
the problem description should be improved short encoding of words given a list of words  we may encode it by writing a reference string s and a list of indexes a  for medium 
problem statement is ambiguous: substring vs  suffix short encoding of words given a list of words  we may encode it by writing a reference string s and a list of indexes a  for medium 
[c++ java python] 2-pass with explanation shortest distance to a character given a string s and a character c  return an array of integers representing the shortest distance from the character c in the string  easy 
explanation of description without solution shortest distance to a character given a string s and a character c  return an array of integers representing the shortest distance from the character c in the string  easy 
concise java solution with detailed explanation  easy understand!!! shortest distance to a character given a string s and a character c  return an array of integers representing the shortest distance from the character c in the string  easy 
java - single pass with trailing pointer (concise) shortest distance to a character given a string s and a character c  return an array of integers representing the shortest distance from the character c in the string  easy 
python 3 shortest distance to a character given a string s and a character c  return an array of integers representing the shortest distance from the character c in the string  easy 
problem statement is so confusing! card flipping game on a table are n cards  with a positive integer printed on the front and back of each card (possibly different)  we flip any number of cards  and after we choose one card  if the number x on the back of the chosen card is not on the front of any card  then this number x is good  what is the smallest number that is good? if no number is good  output 0  here  fronts[i] and backs[i] represent the number on the front and back of card i  a flip swaps the front and back numbers  so the value on the front is now on the back and vice versa  medium 
[c++ java python] easy and concise with explanation card flipping game on a table are n cards  with a positive integer printed on the front and back of each card (possibly different)  we flip any number of cards  and after we choose one card  if the number x on the back of the chosen card is not on the front of any card  then this number x is good  what is the smallest number that is good? if no number is good  output 0  here  fronts[i] and backs[i] represent the number on the front and back of card i  a flip swaps the front and back numbers  so the value on the front is now on the back and vice versa  medium 
java solution using hashset (the description in the problem really confuses me   ) card flipping game on a table are n cards  with a positive integer printed on the front and back of each card (possibly different)  we flip any number of cards  and after we choose one card  if the number x on the back of the chosen card is not on the front of any card  then this number x is good  what is the smallest number that is good? if no number is good  output 0  here  fronts[i] and backs[i] represent the number on the front and back of card i  a flip swaps the front and back numbers  so the value on the front is now on the back and vice versa  medium 
python 2 lines card flipping game on a table are n cards  with a positive integer printed on the front and back of each card (possibly different)  we flip any number of cards  and after we choose one card  if the number x on the back of the chosen card is not on the front of any card  then this number x is good  what is the smallest number that is good? if no number is good  output 0  here  fronts[i] and backs[i] represent the number on the front and back of card i  a flip swaps the front and back numbers  so the value on the front is now on the back and vice versa  medium 
simple java solution - 19ms card flipping game on a table are n cards  with a positive integer printed on the front and back of each card (possibly different)  we flip any number of cards  and after we choose one card  if the number x on the back of the chosen card is not on the front of any card  then this number x is good  what is the smallest number that is good? if no number is good  output 0  here  fronts[i] and backs[i] represent the number on the front and back of card i  a flip swaps the front and back numbers  so the value on the front is now on the back and vice versa  medium 
[c++ java python] dp solution binary trees with factors given an array of unique integers  each integer is strictly greater than 1  we make a binary tree using these integers and each number may be used for any number of times  each non-leaf node's value should be equal to the product of the values of it's children  how many binary trees can we make? return the answer modulo 10    9 + 7  medium 
concise java solution using hashmap with detailed explanation  easily understand!!! binary trees with factors given an array of unique integers  each integer is strictly greater than 1  we make a binary tree using these integers and each number may be used for any number of times  each non-leaf node's value should be equal to the product of the values of it's children  how many binary trees can we make? return the answer modulo 10    9 + 7  medium 
short simple python binary trees with factors given an array of unique integers  each integer is strictly greater than 1  we make a binary tree using these integers and each number may be used for any number of times  each non-leaf node's value should be equal to the product of the values of it's children  how many binary trees can we make? return the answer modulo 10    9 + 7  medium 
java accepted solution binary trees with factors given an array of unique integers  each integer is strictly greater than 1  we make a binary tree using these integers and each number may be used for any number of times  each non-leaf node's value should be equal to the product of the values of it's children  how many binary trees can we make? return the answer modulo 10    9 + 7  medium 
java easy understanding dp solution with explanation binary trees with factors given an array of unique integers  each integer is strictly greater than 1  we make a binary tree using these integers and each number may be used for any number of times  each non-leaf node's value should be equal to the product of the values of it's children  how many binary trees can we make? return the answer modulo 10    9 + 7  medium 
short c++ solution using i o stringstream goat latin a sentence s is given  composed of words separated by spaces  each word consists of lowercase and uppercase letters only  we would like to convert the sentence to "goat latin" (a made-up language similar to pig latin ) the rules of goat latin are as follows: if a word begins with a vowel (a  e  i  o  or u)  append "ma" to the end of the word  for easy string 
java 5 ms solution with time and space complexity explanation goat latin a sentence s is given  composed of words separated by spaces  each word consists of lowercase and uppercase letters only  we would like to convert the sentence to "goat latin" (a made-up language similar to pig latin ) the rules of goat latin are as follows: if a word begins with a vowel (a  e  i  o  or u)  append "ma" to the end of the word  for easy string 
c++  easy to understand  just as we think! goat latin a sentence s is given  composed of words separated by spaces  each word consists of lowercase and uppercase letters only  we would like to convert the sentence to "goat latin" (a made-up language similar to pig latin ) the rules of goat latin are as follows: if a word begins with a vowel (a  e  i  o  or u)  append "ma" to the end of the word  for easy string 
[c++ java python] straight forward solution goat latin a sentence s is given  composed of words separated by spaces  each word consists of lowercase and uppercase letters only  we would like to convert the sentence to "goat latin" (a made-up language similar to pig latin ) the rules of goat latin are as follows: if a word begins with a vowel (a  e  i  o  or u)  append "ma" to the end of the word  for easy string 
concise python solution goat latin a sentence s is given  composed of words separated by spaces  each word consists of lowercase and uppercase letters only  we would like to convert the sentence to "goat latin" (a made-up language similar to pig latin ) the rules of goat latin are as follows: if a word begins with a vowel (a  e  i  o  or u)  append "ma" to the end of the word  for easy string 
age[b] > age[a] and age[b] > 100 && age[a] < 100  isn't the latter redundant? friends of appropriate ages some people will make friend requests  the list of their ages is given and ages[i] is the age of the ith person  person a will not friend request person b (b != a) if any of the following conditions are true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  a will friend request b  note that if a requests b  b does not necessarily request a  also  people will not friend request themselves  how many total friend requests are made? medium array 
10ms concise java  solution  o(n) time and o(1) space friends of appropriate ages some people will make friend requests  the list of their ages is given and ages[i] is the age of the ith person  person a will not friend request person b (b != a) if any of the following conditions are true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  a will friend request b  note that if a requests b  b does not necessarily request a  also  people will not friend request themselves  how many total friend requests are made? medium array 
c++ 5 lines o(n)  sliding sum friends of appropriate ages some people will make friend requests  the list of their ages is given and ages[i] is the age of the ith person  person a will not friend request person b (b != a) if any of the following conditions are true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  a will friend request b  note that if a requests b  b does not necessarily request a  also  people will not friend request themselves  how many total friend requests are made? medium array 
[c++ java python] easy and straight forward friends of appropriate ages some people will make friend requests  the list of their ages is given and ages[i] is the age of the ith person  person a will not friend request person b (b != a) if any of the following conditions are true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  a will friend request b  note that if a requests b  b does not necessarily request a  also  people will not friend request themselves  how many total friend requests are made? medium array 
super clear explanation on both o(nlgn) and o(n) solution step by step friends of appropriate ages some people will make friend requests  the list of their ages is given and ages[i] is the age of the ith person  person a will not friend request person b (b != a) if any of the following conditions are true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  a will friend request b  note that if a requests b  b does not necessarily request a  also  people will not friend request themselves  how many total friend requests are made? medium array 
[c++ java python] sort and two pointer most profit assigning work we have jobs: difficulty[i] is the difficulty of the ith job  and profit[i] is the profit of the ith job  now we have some workers  worker[i] is the ability of the ith worker  which means that this worker can only complete a job with difficulty at most worker[i]  every worker can be assigned at most one job  but one job can be completed multiple times  for medium two pointers 
java solution with treemap most profit assigning work we have jobs: difficulty[i] is the difficulty of the ith job  and profit[i] is the profit of the ith job  now we have some workers  worker[i] is the ability of the ith worker  which means that this worker can only complete a job with difficulty at most worker[i]  every worker can be assigned at most one job  but one job can be completed multiple times  for medium two pointers 
c++ 4 lines  sort  bucket sort  and bucked sort with two pointers most profit assigning work we have jobs: difficulty[i] is the difficulty of the ith job  and profit[i] is the profit of the ith job  now we have some workers  worker[i] is the ability of the ith worker  which means that this worker can only complete a job with difficulty at most worker[i]  every worker can be assigned at most one job  but one job can be completed multiple times  for medium two pointers 
extremely simple using priority queue most profit assigning work we have jobs: difficulty[i] is the difficulty of the ith job  and profit[i] is the profit of the ith job  now we have some workers  worker[i] is the ability of the ith worker  which means that this worker can only complete a job with difficulty at most worker[i]  every worker can be assigned at most one job  but one job can be completed multiple times  for medium two pointers 
python sort based most profit assigning work we have jobs: difficulty[i] is the difficulty of the ith job  and profit[i] is the profit of the ith job  now we have some workers  worker[i] is the ability of the ith worker  which means that this worker can only complete a job with difficulty at most worker[i]  every worker can be assigned at most one job  but one job can be completed multiple times  for medium two pointers 
c++ o(n m) 15 ms  colorful islands making a large island in a 2d grid of 0s and 1s  we change at most one 0 to a 1  after  what is the size of the largest island? (an island is a 4-directionally connected group of 1s)  hard depth-first search 
[c++ java python] straight forward o(n^2) with explanations making a large island in a 2d grid of 0s and 1s  we change at most one 0 to a 1  after  what is the size of the largest island? (an island is a 4-directionally connected group of 1s)  hard depth-first search 
dfs java ac concise solution making a large island in a 2d grid of 0s and 1s  we change at most one 0 to a 1  after  what is the size of the largest island? (an island is a 4-directionally connected group of 1s)  hard depth-first search 
c++ disjoint set or union find making a large island in a 2d grid of 0s and 1s  we change at most one 0 to a 1  after  what is the size of the largest island? (an island is a 4-directionally connected group of 1s)  hard depth-first search 
extremely simple concept using marker making a large island in a 2d grid of 0s and 1s  we change at most one 0 to a 1  after  what is the size of the largest island? (an island is a 4-directionally connected group of 1s)  hard depth-first search 
one pass o(n)  straight forward unique letter string a character is unique in string s if it occurs exactly once in it  for hard two pointers 
o(n) java solution  dp  clear and easy to understand unique letter string a character is unique in string s if it occurs exactly once in it  for hard two pointers 
simple java 2 pointer unique letter string a character is unique in string s if it occurs exactly once in it  for hard two pointers 
very simple o(n) with prev and next unique letter string a character is unique in string s if it occurs exactly once in it  for hard two pointers 
concise dp o(n) solution unique letter string a character is unique in string s if it occurs exactly once in it  for hard two pointers 
5 lines c++ solution with detailed mathematical explanation  consecutive numbers sum given a positive integer n  how many ways can we write it as a sum of consecutive positive integers? hard math 
5 line o(n ^ 0 5) java code - math method consecutive numbers sum given a positive integer n  how many ways can we write it as a sum of consecutive positive integers? hard math 
[c++ java python] 4-lines and o(logn)  count odd factors consecutive numbers sum given a positive integer n  how many ways can we write it as a sum of consecutive positive integers? hard math 
c++ 2 lines o(sqrt n) consecutive numbers sum given a positive integer n  how many ways can we write it as a sum of consecutive positive integers? hard math 
c++ solution with strict and detailed proof consecutive numbers sum given a positive integer n  how many ways can we write it as a sum of consecutive positive integers? hard math 
[c++ java python] straight forward positions of large groups in a string s of lowercase letters  these letters form consecutive groups of the same character  for easy array 
oneline python using regex positions of large groups in a string s of lowercase letters  these letters form consecutive groups of the same character  for easy array 
ambiguous: "the final answer should be in lexicographic order " positions of large groups in a string s of lowercase letters  these letters form consecutive groups of the same character  for easy array 
java solution - two pointers positions of large groups in a string s of lowercase letters  these letters form consecutive groups of the same character  for easy array 
python concise positions of large groups in a string s of lowercase letters  these letters form consecutive groups of the same character  for easy array 
[c++ java python] easy and concise  masking personal information we are given a personal information string s  which may represent either an email address or a phone number  we would like to mask this personal information according to the following rules: 1  email address: we define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters a-z  an email address starts with a name  followed by the symbol '@'  followed by a name  followed by the dot ' ' and followed by a name  all email addresses are guaranteed to be valid and in the format of "name1@name2 name3"  to mask an email  all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ' '  2  phone number: a phone number is a string consisting of only the digits 0-9 or the characters from the set {'+'  '-'  '('  ')'  ' '}  you may assume a phone number contains 10 to 13 digits  the last 10 digits make up the local number  while the digits before those make up the country code  note that the country code is optional  we want to expose only the last 4 digits and mask all other digits  the local number should be formatted and masked as "   -   -1111"  where 1 represents the exposed digits  to mask a phone number with country code like "+111 111 111 1111"  we write it in the form "+   -   -   -1111"  the '+' sign and the first '-' sign before the local number should only exist if there is a country code  for medium string 
short python solution masking personal information we are given a personal information string s  which may represent either an email address or a phone number  we would like to mask this personal information according to the following rules: 1  email address: we define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters a-z  an email address starts with a name  followed by the symbol '@'  followed by a name  followed by the dot ' ' and followed by a name  all email addresses are guaranteed to be valid and in the format of "name1@name2 name3"  to mask an email  all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ' '  2  phone number: a phone number is a string consisting of only the digits 0-9 or the characters from the set {'+'  '-'  '('  ')'  ' '}  you may assume a phone number contains 10 to 13 digits  the last 10 digits make up the local number  while the digits before those make up the country code  note that the country code is optional  we want to expose only the last 4 digits and mask all other digits  the local number should be formatted and masked as "   -   -1111"  where 1 represents the exposed digits  to mask a phone number with country code like "+111 111 111 1111"  we write it in the form "+   -   -   -1111"  the '+' sign and the first '-' sign before the local number should only exist if there is a country code  for medium string 
straightforward c++ masking personal information we are given a personal information string s  which may represent either an email address or a phone number  we would like to mask this personal information according to the following rules: 1  email address: we define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters a-z  an email address starts with a name  followed by the symbol '@'  followed by a name  followed by the dot ' ' and followed by a name  all email addresses are guaranteed to be valid and in the format of "name1@name2 name3"  to mask an email  all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ' '  2  phone number: a phone number is a string consisting of only the digits 0-9 or the characters from the set {'+'  '-'  '('  ')'  ' '}  you may assume a phone number contains 10 to 13 digits  the last 10 digits make up the local number  while the digits before those make up the country code  note that the country code is optional  we want to expose only the last 4 digits and mask all other digits  the local number should be formatted and masked as "   -   -1111"  where 1 represents the exposed digits  to mask a phone number with country code like "+111 111 111 1111"  we write it in the form "+   -   -   -1111"  the '+' sign and the first '-' sign before the local number should only exist if there is a country code  for medium string 
readable java code  masking personal information we are given a personal information string s  which may represent either an email address or a phone number  we would like to mask this personal information according to the following rules: 1  email address: we define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters a-z  an email address starts with a name  followed by the symbol '@'  followed by a name  followed by the dot ' ' and followed by a name  all email addresses are guaranteed to be valid and in the format of "name1@name2 name3"  to mask an email  all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ' '  2  phone number: a phone number is a string consisting of only the digits 0-9 or the characters from the set {'+'  '-'  '('  ')'  ' '}  you may assume a phone number contains 10 to 13 digits  the last 10 digits make up the local number  while the digits before those make up the country code  note that the country code is optional  we want to expose only the last 4 digits and mask all other digits  the local number should be formatted and masked as "   -   -1111"  where 1 represents the exposed digits  to mask a phone number with country code like "+111 111 111 1111"  we write it in the form "+   -   -   -1111"  the '+' sign and the first '-' sign before the local number should only exist if there is a country code  for medium string 
python with regular expressions masking personal information we are given a personal information string s  which may represent either an email address or a phone number  we would like to mask this personal information according to the following rules: 1  email address: we define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters a-z  an email address starts with a name  followed by the symbol '@'  followed by a name  followed by the dot ' ' and followed by a name  all email addresses are guaranteed to be valid and in the format of "name1@name2 name3"  to mask an email  all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ' '  2  phone number: a phone number is a string consisting of only the digits 0-9 or the characters from the set {'+'  '-'  '('  ')'  ' '}  you may assume a phone number contains 10 to 13 digits  the last 10 digits make up the local number  while the digits before those make up the country code  note that the country code is optional  we want to expose only the last 4 digits and mask all other digits  the local number should be formatted and masked as "   -   -1111"  where 1 represents the exposed digits  to mask a phone number with country code like "+111 111 111 1111"  we write it in the form "+   -   -   -1111"  the '+' sign and the first '-' sign before the local number should only exist if there is a country code  for medium string 
[c++ java python] reverse and toggle flipping an image given a binary matrix a  we want to flip the image horizontally  then invert it  and return the resulting image  to flip an image horizontally means that each row of the image is reversed  for easy array 
python 1 line flipping an image given a binary matrix a  we want to flip the image horizontally  then invert it  and return the resulting image  to flip an image horizontally means that each row of the image is reversed  for easy array 
one pass in place java solution flipping an image given a binary matrix a  we want to flip the image horizontally  then invert it  and return the resulting image  to flip an image horizontally means that each row of the image is reversed  for easy array 
one-liner javascript solution flipping an image given a binary matrix a  we want to flip the image horizontally  then invert it  and return the resulting image  to flip an image horizontally means that each row of the image is reversed  for easy array 
what are the c parameters?  flipping an image given a binary matrix a  we want to flip the image horizontally  then invert it  and return the resulting image  to flip an image horizontally means that each row of the image is reversed  for easy array 
[c++ java python] replace s from right to left find and replace in string to some string s  we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size)  each replacement operation has 3 parameters: a starting index i  a source word x and a target word y  the rule is that if x starts at position i in the original string s  then we will replace that occurrence of x with y  if not  we do nothing  for medium string 
java 10 line 14ms and 13 line 7ms  codes - both use stringbuilder replace from end  find and replace in string to some string s  we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size)  each replacement operation has 3 parameters: a starting index i  a source word x and a target word y  the rule is that if x starts at position i in the original string s  then we will replace that occurrence of x with y  if not  we do nothing  for medium string 
java o(n) solution find and replace in string to some string s  we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size)  each replacement operation has 3 parameters: a starting index i  a source word x and a target word y  the rule is that if x starts at position i in the original string s  then we will replace that occurrence of x with y  if not  we do nothing  for medium string 
c++ 5 lines  6 ms bucket sort o(n) find and replace in string to some string s  we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size)  each replacement operation has 3 parameters: a starting index i  a source word x and a target word y  the rule is that if x starts at position i in the original string s  then we will replace that occurrence of x with y  if not  we do nothing  for medium string 
short java treemap solution! find and replace in string to some string s  we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size)  each replacement operation has 3 parameters: a starting index i  a source word x and a target word y  the rule is that if x starts at position i in the original string s  then we will replace that occurrence of x with y  if not  we do nothing  for medium string 
[c++ java python] straight forward image overlap two images a and b are given  represented as binary  square matrices of the same size  (a binary matrix has only 0s and 1s as values ) we translate one image however we choose (sliding it left  right  up  or down any number of units)  and place it on top of the other image  after  the overlap of this translation is the number of positions that have a 1 in both images  (note also that a translation does not include any kind of rotation ) what is the largest possible overlap? medium array 
python easy logic image overlap two images a and b are given  represented as binary  square matrices of the same size  (a binary matrix has only 0s and 1s as values ) we translate one image however we choose (sliding it left  right  up  or down any number of units)  and place it on top of the other image  after  the overlap of this translation is the number of positions that have a 1 in both images  (note also that a translation does not include any kind of rotation ) what is the largest possible overlap? medium array 
a generic and easy to understand method image overlap two images a and b are given  represented as binary  square matrices of the same size  (a binary matrix has only 0s and 1s as values ) we translate one image however we choose (sliding it left  right  up  or down any number of units)  and place it on top of the other image  after  the overlap of this translation is the number of positions that have a 1 in both images  (note also that a translation does not include any kind of rotation ) what is the largest possible overlap? medium array 
short and lazy  just expand the graph image overlap two images a and b are given  represented as binary  square matrices of the same size  (a binary matrix has only 0s and 1s as values ) we translate one image however we choose (sliding it left  right  up  or down any number of units)  and place it on top of the other image  after  the overlap of this translation is the number of positions that have a 1 in both images  (note also that a translation does not include any kind of rotation ) what is the largest possible overlap? medium array 
an interesting solution: let us think about it as "convolution" image overlap two images a and b are given  represented as binary  square matrices of the same size  (a binary matrix has only 0s and 1s as values ) we translate one image however we choose (sliding it left  right  up  or down any number of units)  and place it on top of the other image  after  the overlap of this translation is the number of positions that have a 1 in both images  (note also that a translation does not include any kind of rotation ) what is the largest possible overlap? medium array 
[c++ java python] 1-line solution  1d to 2d rectangle overlap a rectangle is represented as a list [x1  y1  x2  y2]  where (x1  y1) are the coordinates of its bottom-left corner  and (x2  y2) are the coordinates of its top-right corner  two rectangles overlap if the area of their intersection is positive  to be clear  two rectangles that only touch at the corner or edges do not overlap  given two (axis-aligned) rectangles  return whether they overlap  easy math 
c++ solution with easy explanation rectangle overlap a rectangle is represented as a list [x1  y1  x2  y2]  where (x1  y1) are the coordinates of its bottom-left corner  and (x2  y2) are the coordinates of its top-right corner  two rectangles overlap if the area of their intersection is positive  to be clear  two rectangles that only touch at the corner or edges do not overlap  given two (axis-aligned) rectangles  return whether they overlap  easy math 
de morgan's law and boolean algebra rectangle overlap a rectangle is represented as a list [x1  y1  x2  y2]  where (x1  y1) are the coordinates of its bottom-left corner  and (x2  y2) are the coordinates of its top-right corner  two rectangles overlap if the area of their intersection is positive  to be clear  two rectangles that only touch at the corner or edges do not overlap  given two (axis-aligned) rectangles  return whether they overlap  easy math 
java one line with explanation rectangle overlap a rectangle is represented as a list [x1  y1  x2  y2]  where (x1  y1) are the coordinates of its bottom-left corner  and (x2  y2) are the coordinates of its top-right corner  two rectangles overlap if the area of their intersection is positive  to be clear  two rectangles that only touch at the corner or edges do not overlap  given two (axis-aligned) rectangles  return whether they overlap  easy math 
clear java code x 2 rectangle overlap a rectangle is represented as a list [x1  y1  x2  y2]  where (x1  y1) are the coordinates of its bottom-left corner  and (x2  y2) are the coordinates of its top-right corner  two rectangles overlap if the area of their intersection is positive  to be clear  two rectangles that only touch at the corner or edges do not overlap  given two (axis-aligned) rectangles  return whether they overlap  easy math 
one pass dp o(n) new 21 game alice plays the following game  loosely based on the card game "21"  alice starts with 0 points  and draws numbers while she has less than k points  during each draw  she gains an integer number of points randomly from the range [1  w]  where w is an integer  each draw is independent and the outcomes have equal probabilities  alice stops drawing numbers when she gets k or more points  what is the probability that she has n or less points? medium dynamic programming 
please make sure your description is correct before you publish it  otherwise you create a disaster new 21 game alice plays the following game  loosely based on the card game "21"  alice starts with 0 points  and draws numbers while she has less than k points  during each draw  she gains an integer number of points randomly from the range [1  w]  where w is an integer  each draw is independent and the outcomes have equal probabilities  alice stops drawing numbers when she gets k or more points  what is the probability that she has n or less points? medium dynamic programming 
java o(k + w) dp solution with explanation new 21 game alice plays the following game  loosely based on the card game "21"  alice starts with 0 points  and draws numbers while she has less than k points  during each draw  she gains an integer number of points randomly from the range [1  w]  where w is an integer  each draw is independent and the outcomes have equal probabilities  alice stops drawing numbers when she gets k or more points  what is the probability that she has n or less points? medium dynamic programming 
my take on how to reach at solution new 21 game alice plays the following game  loosely based on the card game "21"  alice starts with 0 points  and draws numbers while she has less than k points  during each draw  she gains an integer number of points randomly from the range [1  w]  where w is an integer  each draw is independent and the outcomes have equal probabilities  alice stops drawing numbers when she gets k or more points  what is the probability that she has n or less points? medium dynamic programming 
i think the answer provided isn't correct  we need to consider conditional probability new 21 game alice plays the following game  loosely based on the card game "21"  alice starts with 0 points  and draws numbers while she has less than k points  during each draw  she gains an integer number of points randomly from the range [1  w]  where w is an integer  each draw is independent and the outcomes have equal probabilities  alice stops drawing numbers when she gets k or more points  what is the probability that she has n or less points? medium dynamic programming 
[c++ java python] two pointers push dominoes there are n dominoes in a line  and we place each domino vertically upright  in the beginning  we simultaneously push some of the dominoes either to the left or to the right  after each second  each domino that is falling to the left pushes the adjacent domino on the left  similarly  the dominoes falling to the right push their adjacent dominoes standing on the right  when a vertical domino has dominoes falling on it from both sides  it stays still due to the balance of the forces  for the purposes of this question  we will consider that a falling domino expends no additional force to a falling or already fallen domino  given a string "s" representing the initial state  s[i] = 'l'  if the i-th domino has been pushed to the left; s[i] = 'r'  if the i-th domino has been pushed to the right; s[i] = ' '  if the i-th domino has not been pushed  return a string representing the final state  medium two pointers dynamic programming 
funny idea but passed within time limit (python) push dominoes there are n dominoes in a line  and we place each domino vertically upright  in the beginning  we simultaneously push some of the dominoes either to the left or to the right  after each second  each domino that is falling to the left pushes the adjacent domino on the left  similarly  the dominoes falling to the right push their adjacent dominoes standing on the right  when a vertical domino has dominoes falling on it from both sides  it stays still due to the balance of the forces  for the purposes of this question  we will consider that a falling domino expends no additional force to a falling or already fallen domino  given a string "s" representing the initial state  s[i] = 'l'  if the i-th domino has been pushed to the left; s[i] = 'r'  if the i-th domino has been pushed to the right; s[i] = ' '  if the i-th domino has not been pushed  return a string representing the final state  medium two pointers dynamic programming 
java  one pass  in-place  13ms push dominoes there are n dominoes in a line  and we place each domino vertically upright  in the beginning  we simultaneously push some of the dominoes either to the left or to the right  after each second  each domino that is falling to the left pushes the adjacent domino on the left  similarly  the dominoes falling to the right push their adjacent dominoes standing on the right  when a vertical domino has dominoes falling on it from both sides  it stays still due to the balance of the forces  for the purposes of this question  we will consider that a falling domino expends no additional force to a falling or already fallen domino  given a string "s" representing the initial state  s[i] = 'l'  if the i-th domino has been pushed to the left; s[i] = 'r'  if the i-th domino has been pushed to the right; s[i] = ' '  if the i-th domino has not been pushed  return a string representing the final state  medium two pointers dynamic programming 
[python] o(n) solution  go through array twice push dominoes there are n dominoes in a line  and we place each domino vertically upright  in the beginning  we simultaneously push some of the dominoes either to the left or to the right  after each second  each domino that is falling to the left pushes the adjacent domino on the left  similarly  the dominoes falling to the right push their adjacent dominoes standing on the right  when a vertical domino has dominoes falling on it from both sides  it stays still due to the balance of the forces  for the purposes of this question  we will consider that a falling domino expends no additional force to a falling or already fallen domino  given a string "s" representing the initial state  s[i] = 'l'  if the i-th domino has been pushed to the left; s[i] = 'r'  if the i-th domino has been pushed to the right; s[i] = ' '  if the i-th domino has not been pushed  return a string representing the final state  medium two pointers dynamic programming 
java  one pass  no extra storage  detailed explanation push dominoes there are n dominoes in a line  and we place each domino vertically upright  in the beginning  we simultaneously push some of the dominoes either to the left or to the right  after each second  each domino that is falling to the left pushes the adjacent domino on the left  similarly  the dominoes falling to the right push their adjacent dominoes standing on the right  when a vertical domino has dominoes falling on it from both sides  it stays still due to the balance of the forces  for the purposes of this question  we will consider that a falling domino expends no additional force to a falling or already fallen domino  given a string "s" representing the initial state  s[i] = 'l'  if the i-th domino has been pushed to the left; s[i] = 'r'  if the i-th domino has been pushed to the right; s[i] = ' '  if the i-th domino has not been pushed  return a string representing the final state  medium two pointers dynamic programming 
short c++ solution at 220ms  using disjoint set similar string groups two strings x and y are similar if we can swap two letters (in different positions) of x  so that it equals y  for hard depth-first search union find graph 
simple java solution using dfs similar string groups two strings x and y are similar if we can swap two letters (in different positions) of x  so that it equals y  for hard depth-first search union find graph 
python  union find solution with tricky  min(o(mn^2)  o(nm^2)) similar string groups two strings x and y are similar if we can swap two letters (in different positions) of x  so that it equals y  for hard depth-first search union find graph 
simple java with bfs similar string groups two strings x and y are similar if we can swap two letters (in different positions) of x  so that it equals y  for hard depth-first search union find graph 
simple java 8   python union find  similar string groups two strings x and y are similar if we can swap two letters (in different positions) of x  so that it equals y  for hard depth-first search union find graph 
python  5 and 43816729 magic squares in grid a 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row  column  and both diagonals all have the same sum  given an grid of integers  how many 3 x 3 "magic square" subgrids are there? (each subgrid is contiguous)  easy array 
one misleading problem magic squares in grid a 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row  column  and both diagonals all have the same sum  given an grid of integers  how many 3 x 3 "magic square" subgrids are there? (each subgrid is contiguous)  easy array 
java 8 ms straightforward & ugly  solution magic squares in grid a 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row  column  and both diagonals all have the same sum  given an grid of integers  how many 3 x 3 "magic square" subgrids are there? (each subgrid is contiguous)  easy array 
why is this test case yielding 0? magic squares in grid a 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row  column  and both diagonals all have the same sum  given an grid of integers  how many 3 x 3 "magic square" subgrids are there? (each subgrid is contiguous)  easy array 
straightforward java solution magic squares in grid a 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row  column  and both diagonals all have the same sum  given an grid of integers  how many 3 x 3 "magic square" subgrids are there? (each subgrid is contiguous)  easy array 
clean code keys and rooms there are n rooms and you start in room 0  each room has a distinct number in 0  1  2       n-1  and each room may have some keys to access the next room  formally  each room i has a list of keys rooms[i]  and each key rooms[i][j] is an integer in [0  1       n-1] where n = rooms length  a key rooms[i][j] = v opens the room with number v  initially  all the rooms start locked (except for room 0)  you can walk back and forth between rooms freely  return true if and only if you can enter every room  medium depth-first search graph 
straight forward keys and rooms there are n rooms and you start in room 0  each room has a distinct number in 0  1  2       n-1  and each room may have some keys to access the next room  formally  each room i has a list of keys rooms[i]  and each key rooms[i][j] is an integer in [0  1       n-1] where n = rooms length  a key rooms[i][j] = v opens the room with number v  initially  all the rooms start locked (except for room 0)  you can walk back and forth between rooms freely  return true if and only if you can enter every room  medium depth-first search graph 
python simple recursive dfs keys and rooms there are n rooms and you start in room 0  each room has a distinct number in 0  1  2       n-1  and each room may have some keys to access the next room  formally  each room i has a list of keys rooms[i]  and each key rooms[i][j] is an integer in [0  1       n-1] where n = rooms length  a key rooms[i][j] = v opens the room with number v  initially  all the rooms start locked (except for room 0)  you can walk back and forth between rooms freely  return true if and only if you can enter every room  medium depth-first search graph 
bfs (9 lines  10ms) and dfs (7 lines  18ms) in c++ w  beginner friendly explanation keys and rooms there are n rooms and you start in room 0  each room has a distinct number in 0  1  2       n-1  and each room may have some keys to access the next room  formally  each room i has a list of keys rooms[i]  and each key rooms[i][j] is an integer in [0  1       n-1] where n = rooms length  a key rooms[i][j] = v opens the room with number v  initially  all the rooms start locked (except for room 0)  you can walk back and forth between rooms freely  return true if and only if you can enter every room  medium depth-first search graph 
java   8 lines keys and rooms there are n rooms and you start in room 0  each room has a distinct number in 0  1  2       n-1  and each room may have some keys to access the next room  formally  each room i has a list of keys rooms[i]  and each key rooms[i][j] is an integer in [0  1       n-1] where n = rooms length  a key rooms[i][j] = v opens the room with number v  initially  all the rooms start locked (except for room 0)  you can walk back and forth between rooms freely  return true if and only if you can enter every room  medium depth-first search graph 
short and fast backtracking solution split array into fibonacci sequence given a string s of digits  such as s = "123456579"  we can split it into a fibonacci-like sequence [123  456  579]  formally  a fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] <= 2^31 - 1  (that is  each integer fits a 32-bit signed integer type); f length >= 3; and f[i] + f[i+1] = f[i+2] for all 0 <= i < f length - 2  also  note that when splitting the string into pieces  each piece must not have extra leading zeroes  except if the piece is the number 0 itself  return any fibonacci-like sequence split from s  or return [] if it cannot be done  medium string backtracking greedy 
well commented c++ backtracking solution split array into fibonacci sequence given a string s of digits  such as s = "123456579"  we can split it into a fibonacci-like sequence [123  456  579]  formally  a fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] <= 2^31 - 1  (that is  each integer fits a 32-bit signed integer type); f length >= 3; and f[i] + f[i+1] = f[i+2] for all 0 <= i < f length - 2  also  note that when splitting the string into pieces  each piece must not have extra leading zeroes  except if the piece is the number 0 itself  return any fibonacci-like sequence split from s  or return [] if it cannot be done  medium string backtracking greedy 
what is wrong with this testcase? split array into fibonacci sequence given a string s of digits  such as s = "123456579"  we can split it into a fibonacci-like sequence [123  456  579]  formally  a fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] <= 2^31 - 1  (that is  each integer fits a 32-bit signed integer type); f length >= 3; and f[i] + f[i+1] = f[i+2] for all 0 <= i < f length - 2  also  note that when splitting the string into pieces  each piece must not have extra leading zeroes  except if the piece is the number 0 itself  return any fibonacci-like sequence split from s  or return [] if it cannot be done  medium string backtracking greedy 
backtracking with memoization split array into fibonacci sequence given a string s of digits  such as s = "123456579"  we can split it into a fibonacci-like sequence [123  456  579]  formally  a fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] <= 2^31 - 1  (that is  each integer fits a 32-bit signed integer type); f length >= 3; and f[i] + f[i+1] = f[i+2] for all 0 <= i < f length - 2  also  note that when splitting the string into pieces  each piece must not have extra leading zeroes  except if the piece is the number 0 itself  return any fibonacci-like sequence split from s  or return [] if it cannot be done  medium string backtracking greedy 
simple java solution using dfs split array into fibonacci sequence given a string s of digits  such as s = "123456579"  we can split it into a fibonacci-like sequence [123  456  579]  formally  a fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] <= 2^31 - 1  (that is  each integer fits a 32-bit signed integer type); f length >= 3; and f[i] + f[i+1] = f[i+2] for all 0 <= i < f length - 2  also  note that when splitting the string into pieces  each piece must not have extra leading zeroes  except if the piece is the number 0 itself  return any fibonacci-like sequence split from s  or return [] if it cannot be done  medium string backtracking greedy 
random guess and minimax guess with comparison guess the word this problem is an interactive problem new to the leetcode platform  we are given a word list of unique words  each word is 6 letters long  and one word in this list is chosen as secret  you may call master guess(word) to guess a word  the guessed word should have type string and must be from the original list with 6 lowercase letters  this function returns an integer type  representing the number of exact matches (value and position) of your guess to the secret word  also  if your guess is not in the given wordlist  it will return -1 instead  for each test case  you have 10 guesses to guess the word  at the end of any number of calls  if you have made 10 or less calls to master guess and at least one of these guesses was the secret  you pass the testcase  besides the hard minimax 
optimal minmax solution (+ extra challenging test cases) guess the word this problem is an interactive problem new to the leetcode platform  we are given a word list of unique words  each word is 6 letters long  and one word in this list is chosen as secret  you may call master guess(word) to guess a word  the guessed word should have type string and must be from the original list with 6 lowercase letters  this function returns an integer type  representing the number of exact matches (value and position) of your guess to the secret word  also  if your guess is not in the given wordlist  it will return -1 instead  for each test case  you have 10 guesses to guess the word  at the end of any number of calls  if you have made 10 or less calls to master guess and at least one of these guesses was the secret  you pass the testcase  besides the hard minimax 
screencast of leetcode weekly contest 86 guess the word this problem is an interactive problem new to the leetcode platform  we are given a word list of unique words  each word is 6 letters long  and one word in this list is chosen as secret  you may call master guess(word) to guess a word  the guessed word should have type string and must be from the original list with 6 lowercase letters  this function returns an integer type  representing the number of exact matches (value and position) of your guess to the secret word  also  if your guess is not in the given wordlist  it will return -1 instead  for each test case  you have 10 guesses to guess the word  at the end of any number of calls  if you have made 10 or less calls to master guess and at least one of these guesses was the secret  you pass the testcase  besides the hard minimax 
c++ elimination histogram  beats minimax guess the word this problem is an interactive problem new to the leetcode platform  we are given a word list of unique words  each word is 6 letters long  and one word in this list is chosen as secret  you may call master guess(word) to guess a word  the guessed word should have type string and must be from the original list with 6 lowercase letters  this function returns an integer type  representing the number of exact matches (value and position) of your guess to the secret word  also  if your guess is not in the given wordlist  it will return -1 instead  for each test case  you have 10 guesses to guess the word  at the end of any number of calls  if you have made 10 or less calls to master guess and at least one of these guesses was the secret  you pass the testcase  besides the hard minimax 
python o(n) with maximum overlap heuristic guess the word this problem is an interactive problem new to the leetcode platform  we are given a word list of unique words  each word is 6 letters long  and one word in this list is chosen as secret  you may call master guess(word) to guess a word  the guessed word should have type string and must be from the original list with 6 lowercase letters  this function returns an integer type  representing the number of exact matches (value and position) of your guess to the secret word  also  if your guess is not in the given wordlist  it will return -1 instead  for each test case  you have 10 guesses to guess the word  at the end of any number of calls  if you have made 10 or less calls to master guess and at least one of these guesses was the secret  you pass the testcase  besides the hard minimax 
[c++ java python] o(n) time and o(1) space backspace string compare given two strings s and t  return if they are equal when both are typed into empty text editors  # means a backspace character  easy two pointers stack 
[java c++] efficient and simple solution without stack etc backspace string compare given two strings s and t  return if they are equal when both are typed into empty text editors  # means a backspace character  easy two pointers stack 
java two pointer with explanation - beat 98% backspace string compare given two strings s and t  return if they are equal when both are typed into empty text editors  # means a backspace character  easy two pointers stack 
8 lines c++ o(1) space easy to understand backspace string compare given two strings s and t  return if they are equal when both are typed into empty text editors  # means a backspace character  easy two pointers stack 
python o(1) space backspace string compare given two strings s and t  return if they are equal when both are typed into empty text editors  # means a backspace character  easy two pointers stack 
[c++ java python] 1-pass and o(1) space longest mountain in array let's call any (contiguous) subarray b (of a) a mountain if the following properties hold: b length >= 3 there exists some 0 < i < b length - 1 such that b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note that b could be any subarray of a  including the entire array a ) given an array a of integers  return the length of the longest mountain  return 0 if there is no mountain  medium two pointers 
simple java solution longest mountain in array let's call any (contiguous) subarray b (of a) a mountain if the following properties hold: b length >= 3 there exists some 0 < i < b length - 1 such that b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note that b could be any subarray of a  including the entire array a ) given an array a of integers  return the length of the longest mountain  return 0 if there is no mountain  medium two pointers 
1-pass java two point solution longest mountain in array let's call any (contiguous) subarray b (of a) a mountain if the following properties hold: b length >= 3 there exists some 0 < i < b length - 1 such that b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note that b could be any subarray of a  including the entire array a ) given an array a of integers  return the length of the longest mountain  return 0 if there is no mountain  medium two pointers 
simple o(n) one pass o(1) space java ac solution beats 99 05  longest mountain in array let's call any (contiguous) subarray b (of a) a mountain if the following properties hold: b length >= 3 there exists some 0 < i < b length - 1 such that b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note that b could be any subarray of a  including the entire array a ) given an array a of integers  return the length of the longest mountain  return 0 if there is no mountain  medium two pointers 
easy to understand - find peaks and then find max length mountain o(n) longest mountain in array let's call any (contiguous) subarray b (of a) a mountain if the following properties hold: b length >= 3 there exists some 0 < i < b length - 1 such that b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note that b could be any subarray of a  including the entire array a ) given an array a of integers  return the length of the longest mountain  return 0 if there is no mountain  medium two pointers 
[c++ java python] o(mlogm) complexity hand of straights alice has a hand of cards  given as an array of integers  now she wants to rearrange the cards into groups so that each group is size w  and consists of w consecutive cards  return true if and only if she can  medium map 
short and clear python solution + b站讲解 hand of straights alice has a hand of cards  given as an array of integers  now she wants to rearrange the cards into groups so that each group is size w  and consists of w consecutive cards  return true if and only if she can  medium map 
simple java solution using priority queue hand of straights alice has a hand of cards  given as an array of integers  now she wants to rearrange the cards into groups so that each group is size w  and consists of w consecutive cards  return true if and only if she can  medium map 
short java solution! hand of straights alice has a hand of cards  given as an array of integers  now she wants to rearrange the cards into groups so that each group is size w  and consists of w consecutive cards  return true if and only if she can  medium map 
python o(nlgn) simple solution with intuition hand of straights alice has a hand of cards  given as an array of integers  now she wants to rearrange the cards into groups so that each group is size w  and consists of w consecutive cards  return true if and only if she can  medium map 
screencast of leetcode weekly contest 87 shortest path visiting all nodes an undirected  connected graph of n nodes (labeled 0  1  2       n-1) is given as graph  graph length = n  and j != i is in the list graph[i] exactly once  if and only if nodes i and j are connected  return the length of the shortest path that visits every node  you may start and stop at any node  you may revisit nodes multiple times  and you may reuse edges  hard dynamic programming breadth-first search 
fast bfs solution (46ms) -- clear  detailed explanation included shortest path visiting all nodes an undirected  connected graph of n nodes (labeled 0  1  2       n-1) is given as graph  graph length = n  and j != i is in the list graph[i] exactly once  if and only if nodes i and j are connected  return the length of the shortest path that visits every node  you may start and stop at any node  you may revisit nodes multiple times  and you may reuse edges  hard dynamic programming breadth-first search 
java dp solution shortest path visiting all nodes an undirected  connected graph of n nodes (labeled 0  1  2       n-1) is given as graph  graph length = n  and j != i is in the list graph[i] exactly once  if and only if nodes i and j are connected  return the length of the shortest path that visits every node  you may start and stop at any node  you may revisit nodes multiple times  and you may reuse edges  hard dynamic programming breadth-first search 
python 8 lines heapq & bfs & deque solutions shortest path visiting all nodes an undirected  connected graph of n nodes (labeled 0  1  2       n-1) is given as graph  graph length = n  and j != i is in the list graph[i] exactly once  if and only if nodes i and j are connected  return the length of the shortest path that visits every node  you may start and stop at any node  you may revisit nodes multiple times  and you may reuse edges  hard dynamic programming breadth-first search 
can't understand the description what's the meaning of the given array[][] shortest path visiting all nodes an undirected  connected graph of n nodes (labeled 0  1  2       n-1) is given as graph  graph length = n  and j != i is in the list graph[i] exactly once  if and only if nodes i and j are connected  return the length of the shortest path that visits every node  you may start and stop at any node  you may revisit nodes multiple times  and you may reuse edges  hard dynamic programming breadth-first search 
[c++ java python] easy understood shifting letters we have a string s of lowercase letters  and an integer array shifts  call the shift of a letter  the next letter in the alphabet  (wrapping around so that 'z' becomes 'a')  for medium string 
java clean solution shifting letters we have a string s of lowercase letters  and an integer array shifts  call the shift of a letter  the next letter in the alphabet  (wrapping around so that 'z' becomes 'a')  for medium string 
short and concise c++ solution  3 lines shifting letters we have a string s of lowercase letters  and an integer array shifts  call the shift of a letter  the next letter in the alphabet  (wrapping around so that 'z' becomes 'a')  for medium string 
c++ 2 lines  o(n) shifting letters we have a string s of lowercase letters  and an integer array shifts  call the shift of a letter  the next letter in the alphabet  (wrapping around so that 'z' becomes 'a')  for medium string 
linear one pass solution beats 100% best solution and clean  explanation shifting letters we have a string s of lowercase letters  and an integer array shifts  call the shift of a letter  the next letter in the alphabet  (wrapping around so that 'z' becomes 'a')  for medium string 
[c++ java] 1 pass solution maximize distance to closest person in a row of seats  1 represents a person sitting in that seat  and 0 represents that the seat is empty  there is at least one empty seat  and at least one person sitting  alex wants to sit in the seat such that the distance between him and the closest person to him is maximized  return that maximum distance to closest person  easy array 
clean   one pass   two pointers   java solution maximize distance to closest person in a row of seats  1 represents a person sitting in that seat  and 0 represents that the seat is empty  there is at least one empty seat  and at least one person sitting  alex wants to sit in the seat such that the distance between him and the closest person to him is maximized  return that maximum distance to closest person  easy array 
3 lines c++ one pass maximize distance to closest person in a row of seats  1 represents a person sitting in that seat  and 0 represents that the seat is empty  there is at least one empty seat  and at least one person sitting  alex wants to sit in the seat such that the distance between him and the closest person to him is maximized  return that maximum distance to closest person  easy array 
java one pass easy understand maximize distance to closest person in a row of seats  1 represents a person sitting in that seat  and 0 represents that the seat is empty  there is at least one empty seat  and at least one person sitting  alex wants to sit in the seat such that the distance between him and the closest person to him is maximized  return that maximum distance to closest person  easy array 
python and c++ solution using two pointers  short and elegant  beats 98% maximize distance to closest person in a row of seats  1 represents a person sitting in that seat  and 0 represents that the seat is empty  there is at least one empty seat  and at least one person sitting  alex wants to sit in the seat such that the distance between him and the closest person to him is maximized  return that maximum distance to closest person  easy array 
leetcode weekly contest 88 screencast rectangle area ii we are given a list of (axis-aligned) rectangles  each rectangle[i] = [x1  y1  x2  y2]   where (x1  y1) are the coordinates of the bottom-left corner  and (x2  y2) are the coordinates of the top-right corner of the ith rectangle  find the total area covered by all rectangles in the plane  since the answer may be too large  return it modulo 10^9 + 7  hard segment tree 
【top】java solution with detailed explaination  check this one !  rectangle area ii we are given a list of (axis-aligned) rectangles  each rectangle[i] = [x1  y1  x2  y2]   where (x1  y1) are the coordinates of the bottom-left corner  and (x2  y2) are the coordinates of the top-right corner of the ith rectangle  find the total area covered by all rectangles in the plane  since the answer may be too large  return it modulo 10^9 + 7  hard segment tree 
[c++ python] discretization and o(nlogn) rectangle area ii we are given a list of (axis-aligned) rectangles  each rectangle[i] = [x1  y1  x2  y2]   where (x1  y1) are the coordinates of the bottom-left corner  and (x2  y2) are the coordinates of the top-right corner of the ith rectangle  find the total area covered by all rectangles in the plane  since the answer may be too large  return it modulo 10^9 + 7  hard segment tree 
java treemap solution inspired by skyline and meeting room rectangle area ii we are given a list of (axis-aligned) rectangles  each rectangle[i] = [x1  y1  x2  y2]   where (x1  y1) are the coordinates of the bottom-left corner  and (x2  y2) are the coordinates of the top-right corner of the ith rectangle  find the total area covered by all rectangles in the plane  since the answer may be too large  return it modulo 10^9 + 7  hard segment tree 
clean recursive solution [java] rectangle area ii we are given a list of (axis-aligned) rectangles  each rectangle[i] = [x1  y1  x2  y2]   where (x1  y1) are the coordinates of the bottom-left corner  and (x2  y2) are the coordinates of the top-right corner of the ith rectangle  find the total area covered by all rectangles in the plane  since the answer may be too large  return it modulo 10^9 + 7  hard segment tree 
[c++ java python] concise dfs  loud and rich in a group of n people (labelled 0  1  2       n-1)  each person has different amounts of money  and different levels of quietness  for convenience  we'll call the person with label x  simply "person x"  we'll say that richer[i] = [x  y] if person x definitely has more money than person y  note that richer may only be a subset of valid observations  also  we'll say quiet[x] = q if person x has quietness q  now  return answer  where answer[x] = y if y is the least quiet person (that is  the person y with the smallest value of quiet[y])  among all people who definitely have equal to or more money than person x  medium depth-first search 
example is confusing loud and rich in a group of n people (labelled 0  1  2       n-1)  each person has different amounts of money  and different levels of quietness  for convenience  we'll call the person with label x  simply "person x"  we'll say that richer[i] = [x  y] if person x definitely has more money than person y  note that richer may only be a subset of valid observations  also  we'll say quiet[x] = q if person x has quietness q  now  return answer  where answer[x] = y if y is the least quiet person (that is  the person y with the smallest value of quiet[y])  among all people who definitely have equal to or more money than person x  medium depth-first search 
dfs with memory loud and rich in a group of n people (labelled 0  1  2       n-1)  each person has different amounts of money  and different levels of quietness  for convenience  we'll call the person with label x  simply "person x"  we'll say that richer[i] = [x  y] if person x definitely has more money than person y  note that richer may only be a subset of valid observations  also  we'll say quiet[x] = q if person x has quietness q  now  return answer  where answer[x] = y if y is the least quiet person (that is  the person y with the smallest value of quiet[y])  among all people who definitely have equal to or more money than person x  medium depth-first search 
c++ with topological sorting loud and rich in a group of n people (labelled 0  1  2       n-1)  each person has different amounts of money  and different levels of quietness  for convenience  we'll call the person with label x  simply "person x"  we'll say that richer[i] = [x  y] if person x definitely has more money than person y  note that richer may only be a subset of valid observations  also  we'll say quiet[x] = q if person x has quietness q  now  return answer  where answer[x] = y if y is the least quiet person (that is  the person y with the smallest value of quiet[y])  among all people who definitely have equal to or more money than person x  medium depth-first search 
java bfs loud and rich in a group of n people (labelled 0  1  2       n-1)  each person has different amounts of money  and different levels of quietness  for convenience  we'll call the person with label x  simply "person x"  we'll say that richer[i] = [x  y] if person x definitely has more money than person y  note that richer may only be a subset of valid observations  also  we'll say quiet[x] = q if person x has quietness q  now  return answer  where answer[x] = y if y is the least quiet person (that is  the person y with the smallest value of quiet[y])  among all people who definitely have equal to or more money than person x  medium depth-first search 
[c++ java python] better than binary search peak index in a mountain array let's call an array a a mountain if the following properties hold: a length >= 3 there exists some 0 < i < a length - 1 such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given an array that is definitely a mountain  return any i such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
java o(n) and o(log(n)) code peak index in a mountain array let's call an array a a mountain if the following properties hold: a length >= 3 there exists some 0 < i < a length - 1 such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given an array that is definitely a mountain  return any i such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
java - basic binary search solution peak index in a mountain array let's call an array a a mountain if the following properties hold: a length >= 3 there exists some 0 < i < a length - 1 such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given an array that is definitely a mountain  return any i such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
python & javascript 1-liner peak index in a mountain array let's call an array a a mountain if the following properties hold: a length >= 3 there exists some 0 < i < a length - 1 such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given an array that is definitely a mountain  return any i such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
python3 binary search peak index in a mountain array let's call an array a a mountain if the following properties hold: a length >= 3 there exists some 0 < i < a length - 1 such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given an array that is definitely a mountain  return any i such that a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
[c++ java python] straight forward car fleet n cars are going to the same destination along a one lane road  the destination is target miles away  each car i has a constant speed speed[i] (in miles per hour)  and initial position position[i] miles towards the target along the road  a car can never pass another car ahead of it  but it can catch up to it  and drive bumper to bumper at the same speed  the distance between these two cars is ignored - they are assumed to have the same position  a car fleet is some non-empty set of cars driving at the same position and same speed  note that a single car is also a car fleet  if a car catches up to a car fleet right at the destination point  it will still be considered as one car fleet  how many car fleets will arrive at the destination? medium stack 
easy understanding java treemap solution with explanation & comment car fleet n cars are going to the same destination along a one lane road  the destination is target miles away  each car i has a constant speed speed[i] (in miles per hour)  and initial position position[i] miles towards the target along the road  a car can never pass another car ahead of it  but it can catch up to it  and drive bumper to bumper at the same speed  the distance between these two cars is ignored - they are assumed to have the same position  a car fleet is some non-empty set of cars driving at the same position and same speed  note that a single car is also a car fleet  if a car catches up to a car fleet right at the destination point  it will still be considered as one car fleet  how many car fleets will arrive at the destination? medium stack 
java 10 and 11 liner with comment  both time o(nlog(n)) space o(n) car fleet n cars are going to the same destination along a one lane road  the destination is target miles away  each car i has a constant speed speed[i] (in miles per hour)  and initial position position[i] miles towards the target along the road  a car can never pass another car ahead of it  but it can catch up to it  and drive bumper to bumper at the same speed  the distance between these two cars is ignored - they are assumed to have the same position  a car fleet is some non-empty set of cars driving at the same position and same speed  note that a single car is also a car fleet  if a car catches up to a car fleet right at the destination point  it will still be considered as one car fleet  how many car fleets will arrive at the destination? medium stack 
solution without map car fleet n cars are going to the same destination along a one lane road  the destination is target miles away  each car i has a constant speed speed[i] (in miles per hour)  and initial position position[i] miles towards the target along the road  a car can never pass another car ahead of it  but it can catch up to it  and drive bumper to bumper at the same speed  the distance between these two cars is ignored - they are assumed to have the same position  a car fleet is some non-empty set of cars driving at the same position and same speed  note that a single car is also a car fleet  if a car catches up to a car fleet right at the destination point  it will still be considered as one car fleet  how many car fleets will arrive at the destination? medium stack 
java o(n) without sorting car fleet n cars are going to the same destination along a one lane road  the destination is target miles away  each car i has a constant speed speed[i] (in miles per hour)  and initial position position[i] miles towards the target along the road  a car can never pass another car ahead of it  but it can catch up to it  and drive bumper to bumper at the same speed  the distance between these two cars is ignored - they are assumed to have the same position  a car fleet is some non-empty set of cars driving at the same position and same speed  note that a single car is also a car fleet  if a car catches up to a car fleet right at the destination point  it will still be considered as one car fleet  how many car fleets will arrive at the destination? medium stack 
java bfs 32 ms clean concise explanation whatever k-similar strings strings a and b are k-similar (for some non-negative integer k) if we can swap the positions of two letters in a exactly k times so that the resulting string equals b  given two anagrams a and b  return the smallest k for which a and b are k-similar  hard breadth-first search graph 
java backtracking with memorization k-similar strings strings a and b are k-similar (for some non-negative integer k) if we can swap the positions of two letters in a exactly k times so that the resulting string equals b  given two anagrams a and b  return the smallest k for which a and b are k-similar  hard breadth-first search graph 
c++ 6ms solution k-similar strings strings a and b are k-similar (for some non-negative integer k) if we can swap the positions of two letters in a exactly k times so that the resulting string equals b  given two anagrams a and b  return the smallest k for which a and b are k-similar  hard breadth-first search graph 
c++ bfs solution k-similar strings strings a and b are k-similar (for some non-negative integer k) if we can swap the positions of two letters in a exactly k times so that the resulting string equals b  given two anagrams a and b  return the smallest k for which a and b are k-similar  hard breadth-first search graph 
problem statement was wrong k-similar strings strings a and b are k-similar (for some non-negative integer k) if we can swap the positions of two letters in a exactly k times so that the resulting string equals b  given two anagrams a and b  return the smallest k for which a and b are k-similar  hard breadth-first search graph 
[java] priorityqueue with customized object  seat: o(logn)  leave o(n) with explanation exam room in an exam room  there are n seats in a single row  numbered 0  1  2       n-1  when a student enters the room  they must sit in the seat that maximizes the distance to the closest person  if there are multiple such seats  they sit in the seat with the lowest number  (also  if no one is in the room  then the student sits at seat number 0 ) return a class examroom(int n) that exposes two functions: examroom seat() returning an int representing what seat the student sat in  and examroom leave(int p) representing that the student in seat number p now leaves the room  it is guaranteed that any calls to examroom leave(p) have a student sitting in seat p  medium map 
[c++ java python] straight forward exam room in an exam room  there are n seats in a single row  numbered 0  1  2       n-1  when a student enters the room  they must sit in the seat that maximizes the distance to the closest person  if there are multiple such seats  they sit in the seat with the lowest number  (also  if no one is in the room  then the student sits at seat number 0 ) return a class examroom(int n) that exposes two functions: examroom seat() returning an int representing what seat the student sat in  and examroom leave(int p) representing that the student in seat number p now leaves the room  it is guaranteed that any calls to examroom leave(p) have a student sitting in seat p  medium map 
[python] o(log n) time for both seat() and leave() with heapq and dicts - detailed explanation exam room in an exam room  there are n seats in a single row  numbered 0  1  2       n-1  when a student enters the room  they must sit in the seat that maximizes the distance to the closest person  if there are multiple such seats  they sit in the seat with the lowest number  (also  if no one is in the room  then the student sits at seat number 0 ) return a class examroom(int n) that exposes two functions: examroom seat() returning an int representing what seat the student sat in  and examroom leave(int p) representing that the student in seat number p now leaves the room  it is guaranteed that any calls to examroom leave(p) have a student sitting in seat p  medium map 
java solution based on treeset exam room in an exam room  there are n seats in a single row  numbered 0  1  2       n-1  when a student enters the room  they must sit in the seat that maximizes the distance to the closest person  if there are multiple such seats  they sit in the seat with the lowest number  (also  if no one is in the room  then the student sits at seat number 0 ) return a class examroom(int n) that exposes two functions: examroom seat() returning an int representing what seat the student sat in  and examroom leave(int p) representing that the student in seat number p now leaves the room  it is guaranteed that any calls to examroom leave(p) have a student sitting in seat p  medium map 
c++ o(logn) seat() and o(logn) leave() with stl set and map exam room in an exam room  there are n seats in a single row  numbered 0  1  2       n-1  when a student enters the room  they must sit in the seat that maximizes the distance to the closest person  if there are multiple such seats  they sit in the seat with the lowest number  (also  if no one is in the room  then the student sits at seat number 0 ) return a class examroom(int n) that exposes two functions: examroom seat() returning an int representing what seat the student sat in  and examroom leave(int p) representing that the student in seat number p now leaves the room  it is guaranteed that any calls to examroom leave(p) have a student sitting in seat p  medium map 
[c++ java python] concise o(1) space score of parentheses given a balanced parentheses string s  compute the score of the string based on the following rule: () has score 1 ab has score a + b  where a and b are balanced parentheses strings  (a) has score 2   a  where a is a balanced parentheses string  medium string stack 
java solution using stack score of parentheses given a balanced parentheses string s  compute the score of the string based on the following rule: () has score 1 ab has score a + b  where a and b are balanced parentheses strings  (a) has score 2   a  where a is a balanced parentheses string  medium string stack 
1-line python score of parentheses given a balanced parentheses string s  compute the score of the string based on the following rule: () has score 1 ab has score a + b  where a and b are balanced parentheses strings  (a) has score 2   a  where a is a balanced parentheses string  medium string stack 
python & javascript    simple and readable    stack solution score of parentheses given a balanced parentheses string s  compute the score of the string based on the following rule: () has score 1 ab has score a + b  where a and b are balanced parentheses strings  (a) has score 2   a  where a is a balanced parentheses string  medium string stack 
java 8ms 11 lines recursion with explanation score of parentheses given a balanced parentheses string s  compute the score of the string based on the following rule: () has score 1 ab has score a + b  where a and b are balanced parentheses strings  (a) has score 2   a  where a is a balanced parentheses string  medium string stack 
detailed explanation o(nlogn) minimum cost to hire k workers there are n workers  the i-th worker has a quality[i] and a minimum wage expectation wage[i]  now we want to hire exactly k workers to form a paid group  when hiring a group of k workers  we must pay them according to the following rules: every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group  every worker in the paid group must be paid at least their minimum wage expectation  return the least amount of money needed to form a paid group satisfying the above conditions  hard heap 
o(nlogn) c++ code using priority queue with explanation minimum cost to hire k workers there are n workers  the i-th worker has a quality[i] and a minimum wage expectation wage[i]  now we want to hire exactly k workers to form a paid group  when hiring a group of k workers  we must pay them according to the following rules: every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group  every worker in the paid group must be paid at least their minimum wage expectation  return the least amount of money needed to form a paid group satisfying the above conditions  hard heap 
n log n explanation  no code minimum cost to hire k workers there are n workers  the i-th worker has a quality[i] and a minimum wage expectation wage[i]  now we want to hire exactly k workers to form a paid group  when hiring a group of k workers  we must pay them according to the following rules: every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group  every worker in the paid group must be paid at least their minimum wage expectation  return the least amount of money needed to form a paid group satisfying the above conditions  hard heap 
75ms java with explanations minimum cost to hire k workers there are n workers  the i-th worker has a quality[i] and a minimum wage expectation wage[i]  now we want to hire exactly k workers to form a paid group  when hiring a group of k workers  we must pay them according to the following rules: every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group  every worker in the paid group must be paid at least their minimum wage expectation  return the least amount of money needed to form a paid group satisfying the above conditions  hard heap 
detailed plain english explanation with very simple readable code  minimum cost to hire k workers there are n workers  the i-th worker has a quality[i] and a minimum wage expectation wage[i]  now we want to hire exactly k workers to form a paid group  when hiring a group of k workers  we must pay them according to the following rules: every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group  every worker in the paid group must be paid at least their minimum wage expectation  return the least amount of money needed to form a paid group satisfying the above conditions  hard heap 
java short solution with a sample drawing mirror reflection there is a special square room with mirrors on each of the four walls  except for the southwest corner  there are receptors on each of the remaining corners  numbered 0  1  and 2  the square room has walls of length p  and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor  return the number of the receptor that the ray meets first  (it is guaranteed that the ray will meet a receptor eventually ) medium math 
[c++ java python] 1-line without using any package or ✖️➗% mirror reflection there is a special square room with mirrors on each of the four walls  except for the southwest corner  there are receptors on each of the remaining corners  numbered 0  1  and 2  the square room has walls of length p  and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor  return the number of the receptor that the ray meets first  (it is guaranteed that the ray will meet a receptor eventually ) medium math 
一看就懂 mirror reflection there is a special square room with mirrors on each of the four walls  except for the southwest corner  there are receptors on each of the remaining corners  numbered 0  1  and 2  the square room has walls of length p  and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor  return the number of the receptor that the ray meets first  (it is guaranteed that the ray will meet a receptor eventually ) medium math 
the most straight forward solution pure math only 13ms mirror reflection there is a special square room with mirrors on each of the four walls  except for the southwest corner  there are receptors on each of the remaining corners  numbered 0  1  and 2  the square room has walls of length p  and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor  return the number of the receptor that the ray meets first  (it is guaranteed that the ray will meet a receptor eventually ) medium math 
java solution with an easy-to-understand explanation mirror reflection there is a special square room with mirrors on each of the four walls  except for the southwest corner  there are receptors on each of the remaining corners  numbered 0  1  and 2  the square room has walls of length p  and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor  return the number of the receptor that the ray meets first  (it is guaranteed that the ray will meet a receptor eventually ) medium math 
easy understood buddy strings given two strings a and b of lowercase letters  return true if and only if we can swap two letters in a so that the result equals b  easy string 
java o(1) space  o(n) time buddy strings given two strings a and b of lowercase letters  return true if and only if we can swap two letters in a so that the result equals b  easy string 
clear c++ solution buddy strings given two strings a and b of lowercase letters  return true if and only if we can swap two letters in a so that the result equals b  easy string 
very simple python solution with detailed explanation [o(n) time  o(1) space with 40 ms runtime] buddy strings given two strings a and b of lowercase letters  return true if and only if we can swap two letters in a so that the result equals b  easy string 
javascript straightforward buddy strings given two strings a and b of lowercase letters  return true if and only if we can swap two letters in a so that the result equals b  easy string 
[c++ java python] straight forward lemonade change at a lemonade stand  each lemonade costs $5  customers are standing in a queue to buy from you  and order one at a time (in the order specified by bills)  each customer will only buy one lemonade and pay with either a $5  $10  or $20 bill  you must provide the correct change to each customer  so that the net transaction is that the customer pays $5  note that you don't have any change in hand at first  return true if and only if you can provide every customer with correct change  easy greedy 
python simple & readable lemonade change at a lemonade stand  each lemonade costs $5  customers are standing in a queue to buy from you  and order one at a time (in the order specified by bills)  each customer will only buy one lemonade and pay with either a $5  $10  or $20 bill  you must provide the correct change to each customer  so that the net transaction is that the customer pays $5  note that you don't have any change in hand at first  return true if and only if you can provide every customer with correct change  easy greedy 
java easy undersand lemonade change at a lemonade stand  each lemonade costs $5  customers are standing in a queue to buy from you  and order one at a time (in the order specified by bills)  each customer will only buy one lemonade and pay with either a $5  $10  or $20 bill  you must provide the correct change to each customer  so that the net transaction is that the customer pays $5  note that you don't have any change in hand at first  return true if and only if you can provide every customer with correct change  easy greedy 
easy to understand java solution lemonade change at a lemonade stand  each lemonade costs $5  customers are standing in a queue to buy from you  and order one at a time (in the order specified by bills)  each customer will only buy one lemonade and pay with either a $5  $10  or $20 bill  you must provide the correct change to each customer  so that the net transaction is that the customer pays $5  note that you don't have any change in hand at first  return true if and only if you can provide every customer with correct change  easy greedy 
7ms java solution with readable code and explanation lemonade change at a lemonade stand  each lemonade costs $5  customers are standing in a queue to buy from you  and order one at a time (in the order specified by bills)  each customer will only buy one lemonade and pay with either a $5  $10  or $20 bill  you must provide the correct change to each customer  so that the net transaction is that the customer pays $5  note that you don't have any change in hand at first  return true if and only if you can provide every customer with correct change  easy greedy 
[c++ java python] easy and concise score after flipping matrix we have a two dimensional matrix a where each value is 0 or 1  a move consists of choosing any row or column  and toggling each value in that row or column: changing all 0s to 1s  and all 1s to 0s  after making any number of moves  every row of this matrix is interpreted as a binary number  and the score of the matrix is the sum of these numbers  return the highest possible score  medium greedy 
[c++ java] from intuition  un-optimized code to optimized code with detailed explanation  score after flipping matrix we have a two dimensional matrix a where each value is 0 or 1  a move consists of choosing any row or column  and toggling each value in that row or column: changing all 0s to 1s  and all 1s to 0s  after making any number of moves  every row of this matrix is interpreted as a binary number  and the score of the matrix is the sum of these numbers  return the highest possible score  medium greedy 
java  two steps  o(mn) score after flipping matrix we have a two dimensional matrix a where each value is 0 or 1  a move consists of choosing any row or column  and toggling each value in that row or column: changing all 0s to 1s  and all 1s to 0s  after making any number of moves  every row of this matrix is interpreted as a binary number  and the score of the matrix is the sum of these numbers  return the highest possible score  medium greedy 
python o(n m) greedy solution score after flipping matrix we have a two dimensional matrix a where each value is 0 or 1  a move consists of choosing any row or column  and toggling each value in that row or column: changing all 0s to 1s  and all 1s to 0s  after making any number of moves  every row of this matrix is interpreted as a binary number  and the score of the matrix is the sum of these numbers  return the highest possible score  medium greedy 
c++ easy understand greedy method with explanation score after flipping matrix we have a two dimensional matrix a where each value is 0 or 1  a move consists of choosing any row or column  and toggling each value in that row or column: changing all 0s to 1s  and all 1s to 0s  after making any number of moves  every row of this matrix is interpreted as a binary number  and the score of the matrix is the sum of these numbers  return the highest possible score  medium greedy 
[c++ java python] o(n) using deque shortest subarray with sum at least k return the length of the shortest  non-empty  contiguous subarray of a with sum at least k  if there is no non-empty subarray with sum at least k  return -1  hard binary search queue 
simple java solution using treemap shortest subarray with sum at least k return the length of the shortest  non-empty  contiguous subarray of a with sum at least k  if there is no non-empty subarray with sum at least k  return -1  hard binary search queue 
python simple & readable    ac heapq solution w  detailed explanation  shortest subarray with sum at least k return the length of the shortest  non-empty  contiguous subarray of a with sum at least k  if there is no non-empty subarray with sum at least k  return -1  hard binary search queue 
detailed intuition behind deque solution shortest subarray with sum at least k return the length of the shortest  non-empty  contiguous subarray of a with sum at least k  if there is no non-empty subarray with sum at least k  return -1  hard binary search queue 
a java deque solution time o(n) space o(n) shortest subarray with sum at least k return the length of the shortest  non-empty  contiguous subarray of a with sum at least k  if there is no non-empty subarray with sum at least k  return -1  hard binary search queue 
java bfs solution shortest path to get all keys we are given a 2-dimensional grid  " " is an empty cell  "#" is a wall  "@" is the starting point  ("a"  "b"     ) are keys  and ("a"  "b"     ) are locks  we start at the starting point  and one move consists of walking one space in one of the 4 cardinal directions  we cannot walk outside the grid  or walk into a wall  if we walk over a key  we pick it up  we can't walk over a lock unless we have the corresponding key  for some 1 <= k <= 6  there is exactly one lowercase and one uppercase letter of the first k letters of the english alphabet in the grid  this means that there is exactly one key for each lock  and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the english alphabet  return the lowest number of moves to acquire all keys  if it's impossible  return -1  hard heap breadth-first search 
leetcode weekly contest 92 screencast shortest path to get all keys we are given a 2-dimensional grid  " " is an empty cell  "#" is a wall  "@" is the starting point  ("a"  "b"     ) are keys  and ("a"  "b"     ) are locks  we start at the starting point  and one move consists of walking one space in one of the 4 cardinal directions  we cannot walk outside the grid  or walk into a wall  if we walk over a key  we pick it up  we can't walk over a lock unless we have the corresponding key  for some 1 <= k <= 6  there is exactly one lowercase and one uppercase letter of the first k letters of the english alphabet in the grid  this means that there is exactly one key for each lock  and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the english alphabet  return the lowest number of moves to acquire all keys  if it's impossible  return -1  hard heap breadth-first search 
o(mn2^k) 500ms python bfs easy to understand solution shortest path to get all keys we are given a 2-dimensional grid  " " is an empty cell  "#" is a wall  "@" is the starting point  ("a"  "b"     ) are keys  and ("a"  "b"     ) are locks  we start at the starting point  and one move consists of walking one space in one of the 4 cardinal directions  we cannot walk outside the grid  or walk into a wall  if we walk over a key  we pick it up  we can't walk over a lock unless we have the corresponding key  for some 1 <= k <= 6  there is exactly one lowercase and one uppercase letter of the first k letters of the english alphabet in the grid  this means that there is exactly one key for each lock  and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the english alphabet  return the lowest number of moves to acquire all keys  if it's impossible  return -1  hard heap breadth-first search 
[c++] bfs with current key recorded visited map (12ms) shortest path to get all keys we are given a 2-dimensional grid  " " is an empty cell  "#" is a wall  "@" is the starting point  ("a"  "b"     ) are keys  and ("a"  "b"     ) are locks  we start at the starting point  and one move consists of walking one space in one of the 4 cardinal directions  we cannot walk outside the grid  or walk into a wall  if we walk over a key  we pick it up  we can't walk over a lock unless we have the corresponding key  for some 1 <= k <= 6  there is exactly one lowercase and one uppercase letter of the first k letters of the english alphabet in the grid  this means that there is exactly one key for each lock  and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the english alphabet  return the lowest number of moves to acquire all keys  if it's impossible  return -1  hard heap breadth-first search 
python heapq solution w  memoization  shortest path to get all keys we are given a 2-dimensional grid  " " is an empty cell  "#" is a wall  "@" is the starting point  ("a"  "b"     ) are keys  and ("a"  "b"     ) are locks  we start at the starting point  and one move consists of walking one space in one of the 4 cardinal directions  we cannot walk outside the grid  or walk into a wall  if we walk over a key  we pick it up  we can't walk over a lock unless we have the corresponding key  for some 1 <= k <= 6  there is exactly one lowercase and one uppercase letter of the first k letters of the english alphabet in the grid  this means that there is exactly one key for each lock  and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the english alphabet  return the lowest number of moves to acquire all keys  if it's impossible  return -1  hard heap breadth-first search 
one pass smallest subtree with all the deepest nodes given a binary tree rooted at root  the depth of each node is the shortest distance to the root  a node is deepest if it has the largest depth possible among any node in the entire tree  the subtree of a node is that node  plus the set of all descendants of that node  return the node with the largest depth such that it contains all the deepest nodes in its subtree  medium tree 
simple recursive java solution  smallest subtree with all the deepest nodes given a binary tree rooted at root  the depth of each node is the shortest distance to the root  a node is deepest if it has the largest depth possible among any node in the entire tree  the subtree of a node is that node  plus the set of all descendants of that node  return the node with the largest depth such that it contains all the deepest nodes in its subtree  medium tree 
description of what the problem is asking is unclear smallest subtree with all the deepest nodes given a binary tree rooted at root  the depth of each node is the shortest distance to the root  a node is deepest if it has the largest depth possible among any node in the entire tree  the subtree of a node is that node  plus the set of all descendants of that node  return the node with the largest depth such that it contains all the deepest nodes in its subtree  medium tree 
short and concise c++ solution using dfs  3~5 lines smallest subtree with all the deepest nodes given a binary tree rooted at root  the depth of each node is the shortest distance to the root  a node is deepest if it has the largest depth possible among any node in the entire tree  the subtree of a node is that node  plus the set of all descendants of that node  return the node with the largest depth such that it contains all the deepest nodes in its subtree  medium tree 
unclear problem description  smallest subtree with all the deepest nodes given a binary tree rooted at root  the depth of each node is the shortest distance to the root  a node is deepest if it has the largest depth possible among any node in the entire tree  the subtree of a node is that node  plus the set of all descendants of that node  return the node with the largest depth such that it contains all the deepest nodes in its subtree  medium tree 
search palindrome with even digits prime palindrome find the smallest prime palindrome greater than or equal to n  recall that a number is prime if it's only divisors are 1 and itself  and it is greater than 1  for medium math 
c++ o(1) 0ms prime palindrome find the smallest prime palindrome greater than or equal to n  recall that a number is prime if it's only divisors are 1 and itself  and it is greater than 1  for medium math 
getting one over the system (o(1) solution in java) prime palindrome find the smallest prime palindrome greater than or equal to n  recall that a number is prime if it's only divisors are 1 and itself  and it is greater than 1  for medium math 
faster way to find palindrome  accepted c++ solution  prime palindrome find the smallest prime palindrome greater than or equal to n  recall that a number is prime if it's only divisors are 1 and itself  and it is greater than 1  for medium math 
java solution 6ms prime palindrome find the smallest prime palindrome greater than or equal to n  recall that a number is prime if it's only divisors are 1 and itself  and it is greater than 1  for medium math 
python - 1 liner transpose matrix given a matrix a  return the transpose of a  the transpose of a matrix is the matrix flipped over it's main diagonal  switching the row and column indices of the matrix  easy array 
python self-explanatory 1 line solution transpose matrix given a matrix a  return the transpose of a  the transpose of a matrix is the matrix flipped over it's main diagonal  switching the row and column indices of the matrix  easy array 
[c++ java python] easy understood transpose matrix given a matrix a  return the transpose of a  the transpose of a matrix is the matrix flipped over it's main diagonal  switching the row and column indices of the matrix  easy array 
simple java solution transpose matrix given a matrix a  return the transpose of a  the transpose of a matrix is the matrix flipped over it's main diagonal  switching the row and column indices of the matrix  easy array 
java solution   transpose matrix given a matrix a  return the transpose of a  the transpose of a matrix is the matrix flipped over it's main diagonal  switching the row and column indices of the matrix  easy array 
[c++ java python] dividing by 2 binary gap given a positive integer n  find and return the longest distance between two consecutive 1's in the binary representation of n  if there aren't two consecutive 1's  return 0  easy math 
who can tell me  what does "distance" means? binary gap given a positive integer n  find and return the longest distance between two consecutive 1's in the binary representation of n  if there aren't two consecutive 1's  return 0  easy math 
simple java (10 ms) binary gap given a positive integer n  find and return the longest distance between two consecutive 1's in the binary representation of n  if there aren't two consecutive 1's  return 0  easy math 
python 1-line solution binary gap given a positive integer n  find and return the longest distance between two consecutive 1's in the binary representation of n  if there aren't two consecutive 1's  return 0  easy math 
python simple solution binary gap given a positive integer n  find and return the longest distance between two consecutive 1's in the binary representation of n  if there aren't two consecutive 1's  return 0  easy math 
[c++ java python] straight forward reordered power of 2 starting with a positive integer n  we reorder the digits in any order (including the original order) such that the leading digit is not zero  return true if and only if we can do this in a way such that the resulting number is a power of 2  medium math 
java naive backtracking 15 lines reordered power of 2 starting with a positive integer n  we reorder the digits in any order (including the original order) such that the leading digit is not zero  return true if and only if we can do this in a way such that the resulting number is a power of 2  medium math 
possibly fastest c++ solution using multiset  0ms runtime  reordered power of 2 starting with a positive integer n  we reorder the digits in any order (including the original order) such that the leading digit is not zero  return true if and only if we can do this in a way such that the resulting number is a power of 2  medium math 
one line python beats 70% reordered power of 2 starting with a positive integer n  we reorder the digits in any order (including the original order) such that the leading digit is not zero  return true if and only if we can do this in a way such that the resulting number is a power of 2  medium math 
simple java solution based on string sorting reordered power of 2 starting with a positive integer n  we reorder the digits in any order (including the original order) such that the leading digit is not zero  return true if and only if we can do this in a way such that the resulting number is a power of 2  medium math 
java greedy 6 lines with explanation advantage shuffle given two arrays a and b of equal size  the advantage of a with respect to b is the number of indices i for which a[i] > b[i]  return any permutation of a that maximizes its advantage with respect to b  medium array greedy 
simple java solution with the idea of 田忌赛马 advantage shuffle given two arrays a and b of equal size  the advantage of a with respect to b is the number of indices i for which a[i] > b[i]  return any permutation of a that maximizes its advantage with respect to b  medium array greedy 
c++ 6 lines greedy  o(n log n) advantage shuffle given two arrays a and b of equal size  the advantage of a with respect to b is the number of indices i for which a[i] > b[i]  return any permutation of a that maximizes its advantage with respect to b  medium array greedy 
[python] greedy solution using sort advantage shuffle given two arrays a and b of equal size  the advantage of a with respect to b is the number of indices i for which a[i] > b[i]  return any permutation of a that maximizes its advantage with respect to b  medium array greedy 
[c++ java] greedy solution using map advantage shuffle given two arrays a and b of equal size  the advantage of a with respect to b is the number of indices i for which a[i] > b[i]  return any permutation of a that maximizes its advantage with respect to b  medium array greedy 
dp o(n^2) and priority queue o(nlogn) minimum number of refueling stops a car travels from a starting position to a destination which is target miles east of the starting position  along the way  there are gas stations  each station[i] represents a gas station that is station[i][0] miles east of the starting position  and has station[i][1] liters of gas  the car starts with an infinite tank of gas  which initially has startfuel liters of fuel in it  it uses 1 liter of gas per 1 mile that it drives  when the car reaches a gas station  it may stop and refuel  transferring all the gas from the station into the car  what is the least number of refueling stops the car must make in order to reach its destination? if it cannot reach the destination  return -1  note that if the car reaches a gas station with 0 fuel left  the car can still refuel there  if the car reaches the destination with 0 fuel left  it is still considered to have arrived  hard dynamic programming heap 
simple java solution using priorityqueue o(nlogn) minimum number of refueling stops a car travels from a starting position to a destination which is target miles east of the starting position  along the way  there are gas stations  each station[i] represents a gas station that is station[i][0] miles east of the starting position  and has station[i][1] liters of gas  the car starts with an infinite tank of gas  which initially has startfuel liters of fuel in it  it uses 1 liter of gas per 1 mile that it drives  when the car reaches a gas station  it may stop and refuel  transferring all the gas from the station into the car  what is the least number of refueling stops the car must make in order to reach its destination? if it cannot reach the destination  return -1  note that if the car reaches a gas station with 0 fuel left  the car can still refuel there  if the car reaches the destination with 0 fuel left  it is still considered to have arrived  hard dynamic programming heap 
c++ dp solution space complexity from o(n^2) to o(n)  minimum number of refueling stops a car travels from a starting position to a destination which is target miles east of the starting position  along the way  there are gas stations  each station[i] represents a gas station that is station[i][0] miles east of the starting position  and has station[i][1] liters of gas  the car starts with an infinite tank of gas  which initially has startfuel liters of fuel in it  it uses 1 liter of gas per 1 mile that it drives  when the car reaches a gas station  it may stop and refuel  transferring all the gas from the station into the car  what is the least number of refueling stops the car must make in order to reach its destination? if it cannot reach the destination  return -1  note that if the car reaches a gas station with 0 fuel left  the car can still refuel there  if the car reaches the destination with 0 fuel left  it is still considered to have arrived  hard dynamic programming heap 
python o(nlogn)  minimum number of refueling stops a car travels from a starting position to a destination which is target miles east of the starting position  along the way  there are gas stations  each station[i] represents a gas station that is station[i][0] miles east of the starting position  and has station[i][1] liters of gas  the car starts with an infinite tank of gas  which initially has startfuel liters of fuel in it  it uses 1 liter of gas per 1 mile that it drives  when the car reaches a gas station  it may stop and refuel  transferring all the gas from the station into the car  what is the least number of refueling stops the car must make in order to reach its destination? if it cannot reach the destination  return -1  note that if the car reaches a gas station with 0 fuel left  the car can still refuel there  if the car reaches the destination with 0 fuel left  it is still considered to have arrived  hard dynamic programming heap 
o(n) simple and concise c++ solution using priority_queue  need no comment minimum number of refueling stops a car travels from a starting position to a destination which is target miles east of the starting position  along the way  there are gas stations  each station[i] represents a gas station that is station[i][0] miles east of the starting position  and has station[i][1] liters of gas  the car starts with an infinite tank of gas  which initially has startfuel liters of fuel in it  it uses 1 liter of gas per 1 mile that it drives  when the car reaches a gas station  it may stop and refuel  transferring all the gas from the station into the car  what is the least number of refueling stops the car must make in order to reach its destination? if it cannot reach the destination  return -1  note that if the car reaches a gas station with 0 fuel left  the car can still refuel there  if the car reaches the destination with 0 fuel left  it is still considered to have arrived  hard dynamic programming heap 
[c++ java python] o(logn) space leaf-similar trees consider all the leaves of a binary tree  from left to right order  the values of those leaves form a leaf value sequence  for easy tree depth-first search 
4 line python solution leaf-similar trees consider all the leaves of a binary tree  from left to right order  the values of those leaves form a leaf value sequence  for easy tree depth-first search 
simple 6 lines java  stringbuilder + traverse with explanation leaf-similar trees consider all the leaves of a binary tree  from left to right order  the values of those leaves form a leaf value sequence  for easy tree depth-first search 
c++ super easy 0ms short solution  beats 100%! leaf-similar trees consider all the leaves of a binary tree  from left to right order  the values of those leaves form a leaf value sequence  for easy tree depth-first search 
c++ solution based on hashing leaf-similar trees consider all the leaves of a binary tree  from left to right order  the values of those leaves form a leaf value sequence  for easy tree depth-first search 
[c++ java python] check pair length of longest fibonacci subsequence a sequence x_1  x_2       x_n is fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} for all i + 2 <= n given a strictly increasing array a of positive integers forming a sequence  find the length of the longest fibonacci-like subsequence of a  if one does not exist  return 0  (recall that a subsequence is derived from another sequence a by deleting any number of elements (including none) from a  without changing the order of the remaining elements  for medium array dynamic programming 
leetcode weekly contest 94 screencast length of longest fibonacci subsequence a sequence x_1  x_2       x_n is fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} for all i + 2 <= n given a strictly increasing array a of positive integers forming a sequence  find the length of the longest fibonacci-like subsequence of a  if one does not exist  return 0  (recall that a subsequence is derived from another sequence a by deleting any number of elements (including none) from a  without changing the order of the remaining elements  for medium array dynamic programming 
java clean dp o(n^2) time o(n^2) space length of longest fibonacci subsequence a sequence x_1  x_2       x_n is fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} for all i + 2 <= n given a strictly increasing array a of positive integers forming a sequence  find the length of the longest fibonacci-like subsequence of a  if one does not exist  return 0  (recall that a subsequence is derived from another sequence a by deleting any number of elements (including none) from a  without changing the order of the remaining elements  for medium array dynamic programming 
c++ dp solution length of longest fibonacci subsequence a sequence x_1  x_2       x_n is fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} for all i + 2 <= n given a strictly increasing array a of positive integers forming a sequence  find the length of the longest fibonacci-like subsequence of a  if one does not exist  return 0  (recall that a subsequence is derived from another sequence a by deleting any number of elements (including none) from a  without changing the order of the remaining elements  for medium array dynamic programming 
java hashmap straightforward length of longest fibonacci subsequence a sequence x_1  x_2       x_n is fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} for all i + 2 <= n given a strictly increasing array a of positive integers forming a sequence  find the length of the longest fibonacci-like subsequence of a  if one does not exist  return 0  (recall that a subsequence is derived from another sequence a by deleting any number of elements (including none) from a  without changing the order of the remaining elements  for medium array dynamic programming 
maximum?! this is crazy! walking robot simulation a robot on an infinite grid starts at point (0  0) and faces north  the robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units some of the grid squares are obstacles  the i-th obstacle is at grid point (obstacles[i][0]  obstacles[i][1]) if the robot would try to move onto them  the robot stays on the previous grid square instead (but still continues following the rest of the route ) return the square of the maximum euclidean distance that the robot will be from the origin  easy greedy 
logical thinking with clear code walking robot simulation a robot on an infinite grid starts at point (0  0) and faces north  the robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units some of the grid squares are obstacles  the i-th obstacle is at grid point (obstacles[i][0]  obstacles[i][1]) if the robot would try to move onto them  the robot stays on the previous grid square instead (but still continues following the rest of the route ) return the square of the maximum euclidean distance that the robot will be from the origin  easy greedy 
python short & straightforward solution w  explanation & statement is wrong in the question !!! walking robot simulation a robot on an infinite grid starts at point (0  0) and faces north  the robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units some of the grid squares are obstacles  the i-th obstacle is at grid point (obstacles[i][0]  obstacles[i][1]) if the robot would try to move onto them  the robot stays on the previous grid square instead (but still continues following the rest of the route ) return the square of the maximum euclidean distance that the robot will be from the origin  easy greedy 
any 1160(x) 1954(o)? walking robot simulation a robot on an infinite grid starts at point (0  0) and faces north  the robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units some of the grid squares are obstacles  the i-th obstacle is at grid point (obstacles[i][0]  obstacles[i][1]) if the robot would try to move onto them  the robot stays on the previous grid square instead (but still continues following the rest of the route ) return the square of the maximum euclidean distance that the robot will be from the origin  easy greedy 
obstacle at origin walking robot simulation a robot on an infinite grid starts at point (0  0) and faces north  the robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units some of the grid squares are obstacles  the i-th obstacle is at grid point (obstacles[i][0]  obstacles[i][1]) if the robot would try to move onto them  the robot stays on the previous grid square instead (but still continues following the rest of the route ) return the square of the maximum euclidean distance that the robot will be from the origin  easy greedy 
logical thinking with java code  koko eating bananas koko loves to eat bananas  there are n piles of bananas  the i-th pile has piles[i] bananas  the guards have gone and will come back in h hours  koko can decide her bananas-per-hour eating speed of k  each hour  she chooses some pile of bananas  and eats k bananas from that pile  if the pile has less than k bananas  she eats all of them instead  and won't eat any more bananas during this hour  koko likes to eat slowly  but still wants to finish eating all the bananas before the guards come back  return the minimum integer k such that she can eat all the bananas within h hours  medium binary search 
[c++ java python] binary search koko eating bananas koko loves to eat bananas  there are n piles of bananas  the i-th pile has piles[i] bananas  the guards have gone and will come back in h hours  koko can decide her bananas-per-hour eating speed of k  each hour  she chooses some pile of bananas  and eats k bananas from that pile  if the pile has less than k bananas  she eats all of them instead  and won't eat any more bananas during this hour  koko likes to eat slowly  but still wants to finish eating all the bananas before the guards come back  return the minimum integer k such that she can eat all the bananas within h hours  medium binary search 
java concise binary search 10 lines with explanation koko eating bananas koko loves to eat bananas  there are n piles of bananas  the i-th pile has piles[i] bananas  the guards have gone and will come back in h hours  koko can decide her bananas-per-hour eating speed of k  each hour  she chooses some pile of bananas  and eats k bananas from that pile  if the pile has less than k bananas  she eats all of them instead  and won't eat any more bananas during this hour  koko likes to eat slowly  but still wants to finish eating all the bananas before the guards come back  return the minimum integer k such that she can eat all the bananas within h hours  medium binary search 
binary search with optimized runtime koko eating bananas koko loves to eat bananas  there are n piles of bananas  the i-th pile has piles[i] bananas  the guards have gone and will come back in h hours  koko can decide her bananas-per-hour eating speed of k  each hour  she chooses some pile of bananas  and eats k bananas from that pile  if the pile has less than k bananas  she eats all of them instead  and won't eat any more bananas during this hour  koko likes to eat slowly  but still wants to finish eating all the bananas before the guards come back  return the minimum integer k such that she can eat all the bananas within h hours  medium binary search 
python solution with chinese explanation koko eating bananas koko loves to eat bananas  there are n piles of bananas  the i-th pile has piles[i] bananas  the guards have gone and will come back in h hours  koko can decide her bananas-per-hour eating speed of k  each hour  she chooses some pile of bananas  and eats k bananas from that pile  if the pile has less than k bananas  she eats all of them instead  and won't eat any more bananas during this hour  koko likes to eat slowly  but still wants to finish eating all the bananas before the guards come back  return the minimum integer k such that she can eat all the bananas within h hours  medium binary search 
[c++ java python] slow and fast pointers middle of the linked list given a non-empty  singly linked list with head node head  return a middle node of linked list  if there are two middle nodes  return the second middle node  easy linked list 
remember this pattern for problems that require middle finding in a linked list  middle of the linked list given a non-empty  singly linked list with head node head  return a middle node of linked list  if there are two middle nodes  return the second middle node  easy linked list 
python two pointer  extremely simple  with explaination middle of the linked list given a non-empty  singly linked list with head node head  return a middle node of linked list  if there are two middle nodes  return the second middle node  easy linked list 
java o(n) time & o(1) space solution without using fast slow pointer middle of the linked list given a non-empty  singly linked list with head node head  return a middle node of linked list  if there are two middle nodes  return the second middle node  easy linked list 
[java] 5 liner with explanations middle of the linked list given a non-empty  singly linked list with head node head  return a middle node of linked list  if there are two middle nodes  return the second middle node  easy linked list 
[c++ java python] dp or just return true stone game alex and lee play a game with piles of stones  there are an even number of piles arranged in a row  and each pile has a positive integer number of stones piles[i]  the objective of the game is to end with the most stones  the total number of stones is odd  so there are no ties  alex and lee take turns  with alex starting first  each turn  a player takes the entire pile of stones from either the beginning or the end of the row  this continues until there are no more piles left  at which point the person with the most stones wins  assuming alex and lee play optimally  return true if and only if alex wins the game  medium math dynamic programming 
[java] this is minimax + dp (fully detailed explanation + generalization + easy understand code) stone game alex and lee play a game with piles of stones  there are an even number of piles arranged in a row  and each pile has a positive integer number of stones piles[i]  the objective of the game is to end with the most stones  the total number of stones is odd  so there are no ties  alex and lee take turns  with alex starting first  each turn  a player takes the entire pile of stones from either the beginning or the end of the row  this continues until there are no more piles left  at which point the person with the most stones wins  assuming alex and lee play optimally  return true if and only if alex wins the game  medium math dynamic programming 
alex won't lose stone game alex and lee play a game with piles of stones  there are an even number of piles arranged in a row  and each pile has a positive integer number of stones piles[i]  the objective of the game is to end with the most stones  the total number of stones is odd  so there are no ties  alex and lee take turns  with alex starting first  each turn  a player takes the entire pile of stones from either the beginning or the end of the row  this continues until there are no more piles left  at which point the person with the most stones wins  assuming alex and lee play optimally  return true if and only if alex wins the game  medium math dynamic programming 
python solution using memorization with chinese explanation stone game alex and lee play a game with piles of stones  there are an even number of piles arranged in a row  and each pile has a positive integer number of stones piles[i]  the objective of the game is to end with the most stones  the total number of stones is odd  so there are no ties  alex and lee take turns  with alex starting first  each turn  a player takes the entire pile of stones from either the beginning or the end of the row  this continues until there are no more piles left  at which point the person with the most stones wins  assuming alex and lee play optimally  return true if and only if alex wins the game  medium math dynamic programming 
alex can take all piles with odd (even) indices  thus he always wins stone game alex and lee play a game with piles of stones  there are an even number of piles arranged in a row  and each pile has a positive integer number of stones piles[i]  the objective of the game is to end with the most stones  the total number of stones is odd  so there are no ties  alex and lee take turns  with alex starting first  each turn  a player takes the entire pile of stones from either the beginning or the end of the row  this continues until there are no more piles left  at which point the person with the most stones wins  assuming alex and lee play optimally  return true if and only if alex wins the game  medium math dynamic programming 
[c++ java python] binary search nth magical number a positive integer is magical if it is divisible by either a or b  return the n-th magical number  since the answer may be very large  return it modulo 10^9 + 7  hard math binary search 
o(1) mathematical solution without binary or brute force search nth magical number a positive integer is magical if it is divisible by either a or b  return the n-th magical number  since the answer may be very large  return it modulo 10^9 + 7  hard math binary search 
python using gcd and lcm  no search needed nth magical number a positive integer is magical if it is divisible by either a or b  return the n-th magical number  since the answer may be very large  return it modulo 10^9 + 7  hard math binary search 
python leverage gcd and lcm to search nth magical number a positive integer is magical if it is divisible by either a or b  return the n-th magical number  since the answer may be very large  return it modulo 10^9 + 7  hard math binary search 
python simple & readable binary search solution nth magical number a positive integer is magical if it is divisible by either a or b  return the n-th magical number  since the answer may be very large  return it modulo 10^9 + 7  hard math binary search 
[c++ java python] dp profitable schemes there are g people in a gang  and a list of various crimes they could commit  the i-th crime generates a profit[i] and requires group[i] gang members to participate  if a gang member participates in one crime  that member can't participate in another crime  let's call a profitable scheme any subset of these crimes that generates at least p profit  and the total number of gang members participating in that subset of crimes is at most g  how many schemes can be chosen? since the answer may be very large  return it modulo 10^9 + 7  hard dynamic programming 
java original 3d to 2d dp solution profitable schemes there are g people in a gang  and a list of various crimes they could commit  the i-th crime generates a profit[i] and requires group[i] gang members to participate  if a gang member participates in one crime  that member can't participate in another crime  let's call a profitable scheme any subset of these crimes that generates at least p profit  and the total number of gang members participating in that subset of crimes is at most g  how many schemes can be chosen? since the answer may be very large  return it modulo 10^9 + 7  hard dynamic programming 
leetcode weekly contest 95 screencast profitable schemes there are g people in a gang  and a list of various crimes they could commit  the i-th crime generates a profit[i] and requires group[i] gang members to participate  if a gang member participates in one crime  that member can't participate in another crime  let's call a profitable scheme any subset of these crimes that generates at least p profit  and the total number of gang members participating in that subset of crimes is at most g  how many schemes can be chosen? since the answer may be very large  return it modulo 10^9 + 7  hard dynamic programming 
c++ o(pgn) top-down dp solution profitable schemes there are g people in a gang  and a list of various crimes they could commit  the i-th crime generates a profit[i] and requires group[i] gang members to participate  if a gang member participates in one crime  that member can't participate in another crime  let's call a profitable scheme any subset of these crimes that generates at least p profit  and the total number of gang members participating in that subset of crimes is at most g  how many schemes can be chosen? since the answer may be very large  return it modulo 10^9 + 7  hard dynamic programming 
simple dp o(pgn) profitable schemes there are g people in a gang  and a list of various crimes they could commit  the i-th crime generates a profit[i] and requires group[i] gang members to participate  if a gang member participates in one crime  that member can't participate in another crime  let's call a profitable scheme any subset of these crimes that generates at least p profit  and the total number of gang members participating in that subset of crimes is at most g  how many schemes can be chosen? since the answer may be very large  return it modulo 10^9 + 7  hard dynamic programming 
[c++ python] o(n) time o(1) space decoded string at index an encoded string s is given  to find and write the decoded string to a tape  the encoded string is read one character at a time and the following steps are taken: if the character read is a letter  that letter is written onto the tape  if the character read is a digit (say d)  the entire current tape is repeatedly written d-1 more times in total  now for some encoded string s  and an index k  find and return the k-th letter (1 indexed) in the decoded string  medium stack 
easy to understand java solution decoded string at index an encoded string s is given  to find and write the decoded string to a tape  the encoded string is read one character at a time and the following steps are taken: if the character read is a letter  that letter is written onto the tape  if the character read is a digit (say d)  the entire current tape is repeatedly written d-1 more times in total  now for some encoded string s  and an index k  find and return the k-th letter (1 indexed) in the decoded string  medium stack 
c++ simple recursion decoded string at index an encoded string s is given  to find and write the decoded string to a tape  the encoded string is read one character at a time and the following steps are taken: if the character read is a letter  that letter is written onto the tape  if the character read is a digit (say d)  the entire current tape is repeatedly written d-1 more times in total  now for some encoded string s  and an index k  find and return the k-th letter (1 indexed) in the decoded string  medium stack 
logical thinking with clear code decoded string at index an encoded string s is given  to find and write the decoded string to a tape  the encoded string is read one character at a time and the following steps are taken: if the character read is a letter  that letter is written onto the tape  if the character read is a digit (say d)  the entire current tape is repeatedly written d-1 more times in total  now for some encoded string s  and an index k  find and return the k-th letter (1 indexed) in the decoded string  medium stack 
15 lines clear code decoded string at index an encoded string s is given  to find and write the decoded string to a tape  the encoded string is read one character at a time and the following steps are taken: if the character read is a letter  that letter is written onto the tape  if the character read is a digit (say d)  the entire current tape is repeatedly written d-1 more times in total  now for some encoded string s  and an index k  find and return the k-th letter (1 indexed) in the decoded string  medium stack 
6 lines [java] o(nlogn) code  sorting + greedy  with greedy algorithm proof   boats to save people the i-th person has weight people[i]  and each boat can carry a maximum weight of limit  each boat carries at most 2 people at the same time  provided the sum of the weight of those people is at most limit  return the minimum number of boats to carry every given person  (it is guaranteed each person can be carried by a boat ) medium two pointers greedy 
[c++ java python] two pointers boats to save people the i-th person has weight people[i]  and each boat can carry a maximum weight of limit  each boat carries at most 2 people at the same time  provided the sum of the weight of those people is at most limit  return the minimum number of boats to carry every given person  (it is guaranteed each person can be carried by a boat ) medium two pointers greedy 
python short 2 pointer solution & some thoughts boats to save people the i-th person has weight people[i]  and each boat can carry a maximum weight of limit  each boat carries at most 2 people at the same time  provided the sum of the weight of those people is at most limit  return the minimum number of boats to carry every given person  (it is guaranteed each person can be carried by a boat ) medium two pointers greedy 
[java] o(n(people)) + o(limit) solution boats to save people the i-th person has weight people[i]  and each boat can carry a maximum weight of limit  each boat carries at most 2 people at the same time  provided the sum of the weight of those people is at most limit  return the minimum number of boats to carry every given person  (it is guaranteed each person can be carried by a boat ) medium two pointers greedy 
what if each boat carries at most k people (instead of 2 people) at the same time boats to save people the i-th person has weight people[i]  and each boat can carry a maximum weight of limit  each boat carries at most 2 people at the same time  provided the sum of the weight of those people is at most limit  return the minimum number of boats to carry every given person  (it is guaranteed each person can be carried by a boat ) medium two pointers greedy 
java dijkstra solution reachable nodes in subdivided graph starting with an undirected graph (the "original graph") with nodes from 0 to n-1  subdivisions are made to some of the edges  the graph is given as follows: edges[k] is a list of integer pairs (i  j  n) such that (i  j) is an edge of the original graph  and n is the total number of new nodes on that edge  then  the edge (i  j) is deleted from the original graph  n new nodes (x_1  x_2       x_n) are added to the original graph  and n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) are added to the original graph  now  you start at node 0 from the original graph  and in each move  you travel along one edge  return how many nodes you can reach in at most m moves  hard heap 
[c++ java python] dijkstra + priority queue reachable nodes in subdivided graph starting with an undirected graph (the "original graph") with nodes from 0 to n-1  subdivisions are made to some of the edges  the graph is given as follows: edges[k] is a list of integer pairs (i  j  n) such that (i  j) is an edge of the original graph  and n is the total number of new nodes on that edge  then  the edge (i  j) is deleted from the original graph  n new nodes (x_1  x_2       x_n) are added to the original graph  and n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) are added to the original graph  now  you start at node 0 from the original graph  and in each move  you travel along one edge  return how many nodes you can reach in at most m moves  hard heap 
god  the description of this problem just confuses me!! reachable nodes in subdivided graph starting with an undirected graph (the "original graph") with nodes from 0 to n-1  subdivisions are made to some of the edges  the graph is given as follows: edges[k] is a list of integer pairs (i  j  n) such that (i  j) is an edge of the original graph  and n is the total number of new nodes on that edge  then  the edge (i  j) is deleted from the original graph  n new nodes (x_1  x_2       x_n) are added to the original graph  and n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) are added to the original graph  now  you start at node 0 from the original graph  and in each move  you travel along one edge  return how many nodes you can reach in at most m moves  hard heap 
logical thinking with clear code reachable nodes in subdivided graph starting with an undirected graph (the "original graph") with nodes from 0 to n-1  subdivisions are made to some of the edges  the graph is given as follows: edges[k] is a list of integer pairs (i  j  n) such that (i  j) is an edge of the original graph  and n is the total number of new nodes on that edge  then  the edge (i  j) is deleted from the original graph  n new nodes (x_1  x_2       x_n) are added to the original graph  and n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) are added to the original graph  now  you start at node 0 from the original graph  and in each move  you travel along one edge  return how many nodes you can reach in at most m moves  hard heap 
indecipherable description reachable nodes in subdivided graph starting with an undirected graph (the "original graph") with nodes from 0 to n-1  subdivisions are made to some of the edges  the graph is given as follows: edges[k] is a list of integer pairs (i  j  n) such that (i  j) is an edge of the original graph  and n is the total number of new nodes on that edge  then  the edge (i  j) is deleted from the original graph  n new nodes (x_1  x_2       x_n) are added to the original graph  and n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) are added to the original graph  now  you start at node 0 from the original graph  and in each move  you travel along one edge  return how many nodes you can reach in at most m moves  hard heap 
please change the description of the problem projection area of 3d shapes on a n   n grid  we place some 1   1   1 cubes that are axis-aligned with the x  y  and z axes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  now we view the projection of these cubes onto the xy  yz  and zx planes  a projection is like a shadow  that maps our 3 dimensional figure to a 2 dimensional plane  here  we are viewing the "shadow" when looking at the cubes from the top  the front  and the side  return the total area of all three projections  easy math 
i don't even understand the description projection area of 3d shapes on a n   n grid  we place some 1   1   1 cubes that are axis-aligned with the x  y  and z axes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  now we view the projection of these cubes onto the xy  yz  and zx planes  a projection is like a shadow  that maps our 3 dimensional figure to a 2 dimensional plane  here  we are viewing the "shadow" when looking at the cubes from the top  the front  and the side  return the total area of all three projections  easy math 
11 line 1 pass [java] code and  explanation of the problem  time o(n ^ 2) space o(1)  projection area of 3d shapes on a n   n grid  we place some 1   1   1 cubes that are axis-aligned with the x  y  and z axes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  now we view the projection of these cubes onto the xy  yz  and zx planes  a projection is like a shadow  that maps our 3 dimensional figure to a 2 dimensional plane  here  we are viewing the "shadow" when looking at the cubes from the top  the front  and the side  return the total area of all three projections  easy math 
[c++ java python] straight forward projection area of 3d shapes on a n   n grid  we place some 1   1   1 cubes that are axis-aligned with the x  y  and z axes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  now we view the projection of these cubes onto the xy  yz  and zx planes  a projection is like a shadow  that maps our 3 dimensional figure to a 2 dimensional plane  here  we are viewing the "shadow" when looking at the cubes from the top  the front  and the side  return the total area of all three projections  easy math 
it drove me nuts  what the hell is it talking about    projection area of 3d shapes on a n   n grid  we place some 1   1   1 cubes that are axis-aligned with the x  y  and z axes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  now we view the projection of these cubes onto the xy  yz  and zx planes  a projection is like a shadow  that maps our 3 dimensional figure to a 2 dimensional plane  here  we are viewing the "shadow" when looking at the cubes from the top  the front  and the side  return the total area of all three projections  easy math 
[c++ java python] easy solution with explanation uncommon words from two sentences we are given two sentences a and b  (a sentence is a string of space separated words  each word consists only of lowercase letters ) a word is uncommon if it appears exactly once in one of the sentences  and does not appear in the other sentence  return a list of all uncommon words  you may return the list in any order  easy hash table 
[java] 3 liner and 5 liner  using hashmap and hashsets  respectively   uncommon words from two sentences we are given two sentences a and b  (a sentence is a string of space separated words  each word consists only of lowercase letters ) a word is uncommon if it appears exactly once in one of the sentences  and does not appear in the other sentence  return a list of all uncommon words  you may return the list in any order  easy hash table 
c++ 100% with unordered_map uncommon words from two sentences we are given two sentences a and b  (a sentence is a string of space separated words  each word consists only of lowercase letters ) a word is uncommon if it appears exactly once in one of the sentences  and does not appear in the other sentence  return a list of all uncommon words  you may return the list in any order  easy hash table 
two c++ solutions uncommon words from two sentences we are given two sentences a and b  (a sentence is a string of space separated words  each word consists only of lowercase letters ) a word is uncommon if it appears exactly once in one of the sentences  and does not appear in the other sentence  return a list of all uncommon words  you may return the list in any order  easy hash table 
[c# solution] 2 lines of code  beat 100% submission running time uncommon words from two sentences we are given two sentences a and b  (a sentence is a string of space separated words  each word consists only of lowercase letters ) a word is uncommon if it appears exactly once in one of the sentences  and does not appear in the other sentence  return a list of all uncommon words  you may return the list in any order  easy hash table 
[c++ java python] 1 1 2 2 3 3 steps spiral matrix iii on a 2 dimensional grid with r rows and c columns  we start at (r0  c0) facing east  here  the north-west corner of the grid is at the first row and column  and the south-east corner of the grid is at the last row and column  now  we walk in a clockwise spiral shape to visit every position in this grid  whenever we would move outside the boundary of the grid  we continue our walk outside the grid (but may return to the grid boundary later ) eventually  we reach all r   c spaces of the grid  return a list of coordinates representing the positions of the grid in the order they were visited  medium math 
java 15 lines concise solution with comments spiral matrix iii on a 2 dimensional grid with r rows and c columns  we start at (r0  c0) facing east  here  the north-west corner of the grid is at the first row and column  and the south-east corner of the grid is at the last row and column  now  we walk in a clockwise spiral shape to visit every position in this grid  whenever we would move outside the boundary of the grid  we continue our walk outside the grid (but may return to the grid boundary later ) eventually  we reach all r   c spaces of the grid  return a list of coordinates representing the positions of the grid in the order they were visited  medium math 
[python] sort all coordinates spiral matrix iii on a 2 dimensional grid with r rows and c columns  we start at (r0  c0) facing east  here  the north-west corner of the grid is at the first row and column  and the south-east corner of the grid is at the last row and column  now  we walk in a clockwise spiral shape to visit every position in this grid  whenever we would move outside the boundary of the grid  we continue our walk outside the grid (but may return to the grid boundary later ) eventually  we reach all r   c spaces of the grid  return a list of coordinates representing the positions of the grid in the order they were visited  medium math 
simple east to understand java solution  spiral matrix iii on a 2 dimensional grid with r rows and c columns  we start at (r0  c0) facing east  here  the north-west corner of the grid is at the first row and column  and the south-east corner of the grid is at the last row and column  now  we walk in a clockwise spiral shape to visit every position in this grid  whenever we would move outside the boundary of the grid  we continue our walk outside the grid (but may return to the grid boundary later ) eventually  we reach all r   c spaces of the grid  return a list of coordinates representing the positions of the grid in the order they were visited  medium math 
java simulation 17 lines with line-by-line explanation spiral matrix iii on a 2 dimensional grid with r rows and c columns  we start at (r0  c0) facing east  here  the north-west corner of the grid is at the first row and column  and the south-east corner of the grid is at the last row and column  now  we walk in a clockwise spiral shape to visit every position in this grid  whenever we would move outside the boundary of the grid  we continue our walk outside the grid (but may return to the grid boundary later ) eventually  we reach all r   c spaces of the grid  return a list of coordinates representing the positions of the grid in the order they were visited  medium math 
java dfs solution possible bipartition given a set of n people (numbered 1  2       n)  we would like to split everyone into two groups of any size  each person may dislike some other people  and they should not go into the same group  formally  if dislikes[i] = [a  b]  it means it is not allowed to put the people numbered a and b into the same group  return true if and only if it is possible to split everyone into two groups in this way  medium depth-first search 
java graph  possible bipartition given a set of n people (numbered 1  2       n)  we would like to split everyone into two groups of any size  each person may dislike some other people  and they should not go into the same group  formally  if dislikes[i] = [a  b]  it means it is not allowed to put the people numbered a and b into the same group  return true if and only if it is possible to split everyone into two groups in this way  medium depth-first search 
[python] decide if a graph is bipartite by checking the existence of odd cycles  possible bipartition given a set of n people (numbered 1  2       n)  we would like to split everyone into two groups of any size  each person may dislike some other people  and they should not go into the same group  formally  if dislikes[i] = [a  b]  it means it is not allowed to put the people numbered a and b into the same group  return true if and only if it is possible to split everyone into two groups in this way  medium depth-first search 
python dfs with explanation possible bipartition given a set of n people (numbered 1  2       n)  we would like to split everyone into two groups of any size  each person may dislike some other people  and they should not go into the same group  formally  if dislikes[i] = [a  b]  it means it is not allowed to put the people numbered a and b into the same group  return true if and only if it is possible to split everyone into two groups in this way  medium depth-first search 
graph bipartite problem + dfs possible bipartition given a set of n people (numbered 1  2       n)  we would like to split everyone into two groups of any size  each person may dislike some other people  and they should not go into the same group  formally  if dislikes[i] = [a  b]  it means it is not allowed to put the people numbered a and b into the same group  return true if and only if it is possible to split everyone into two groups in this way  medium depth-first search 
[c++ java python] 2d and 1d dp  o(klogn) super egg drop you are given k eggs  and you have access to a building with n floors from 1 to n  each egg is identical in function  and if an egg breaks  you cannot drop it again  you know that there exists a floor f with 0 <= f <= n such that any egg dropped at a floor higher than f will break  and any egg dropped at or below floor f will not break  each move  you may take an egg (if you have an unbroken one) and drop it from any floor x (with 1 <= x <= n)  your goal is to know with certainty what the value of f is  what is the minimum number of moves that you need to know with certainty what f is  regardless of the initial value of f? hard math binary search dynamic programming 
python dp from kn^2 to knlogn to kn super egg drop you are given k eggs  and you have access to a building with n floors from 1 to n  each egg is identical in function  and if an egg breaks  you cannot drop it again  you know that there exists a floor f with 0 <= f <= n such that any egg dropped at a floor higher than f will break  and any egg dropped at or below floor f will not break  each move  you may take an egg (if you have an unbroken one) and drop it from any floor x (with 1 <= x <= n)  your goal is to know with certainty what the value of f is  what is the minimum number of moves that you need to know with certainty what f is  regardless of the initial value of f? hard math binary search dynamic programming 
java dp solution from o(kn^2) to o(knlogn) super egg drop you are given k eggs  and you have access to a building with n floors from 1 to n  each egg is identical in function  and if an egg breaks  you cannot drop it again  you know that there exists a floor f with 0 <= f <= n such that any egg dropped at a floor higher than f will break  and any egg dropped at or below floor f will not break  each move  you may take an egg (if you have an unbroken one) and drop it from any floor x (with 1 <= x <= n)  your goal is to know with certainty what the value of f is  what is the minimum number of moves that you need to know with certainty what f is  regardless of the initial value of f? hard math binary search dynamic programming 
easy to understand super egg drop you are given k eggs  and you have access to a building with n floors from 1 to n  each egg is identical in function  and if an egg breaks  you cannot drop it again  you know that there exists a floor f with 0 <= f <= n such that any egg dropped at a floor higher than f will break  and any egg dropped at or below floor f will not break  each move  you may take an egg (if you have an unbroken one) and drop it from any floor x (with 1 <= x <= n)  your goal is to know with certainty what the value of f is  what is the minimum number of moves that you need to know with certainty what f is  regardless of the initial value of f? hard math binary search dynamic programming 
leetcode weekly contest 97 screencast super egg drop you are given k eggs  and you have access to a building with n floors from 1 to n  each egg is identical in function  and if an egg breaks  you cannot drop it again  you know that there exists a floor f with 0 <= f <= n such that any egg dropped at a floor higher than f will break  and any egg dropped at or below floor f will not break  each move  you may take an egg (if you have an unbroken one) and drop it from any floor x (with 1 <= x <= n)  your goal is to know with certainty what the value of f is  what is the minimum number of moves that you need to know with certainty what f is  regardless of the initial value of f? hard math binary search dynamic programming 
[c++ java python] straight forward fair candy swap alice and bob have candy bars of different sizes: a[i] is the size of the i-th bar of candy that alice has  and b[j] is the size of the j-th bar of candy that bob has  since they are friends  they would like to exchange one candy bar each so that after the exchange  they both have the same total amount of candy  (the total amount of candy a person has is the sum of the sizes of candy bars they have ) return an integer array ans where ans[0] is the size of the candy bar that alice must exchange  and ans[1] is the size of the candy bar that bob must exchange  if there are multiple answers  you may return any one of them  it is guaranteed an answer exists  easy array 
java 2 solutions clear explanation with illustration fair candy swap alice and bob have candy bars of different sizes: a[i] is the size of the i-th bar of candy that alice has  and b[j] is the size of the j-th bar of candy that bob has  since they are friends  they would like to exchange one candy bar each so that after the exchange  they both have the same total amount of candy  (the total amount of candy a person has is the sum of the sizes of candy bars they have ) return an integer array ans where ans[0] is the size of the candy bar that alice must exchange  and ans[1] is the size of the candy bar that bob must exchange  if there are multiple answers  you may return any one of them  it is guaranteed an answer exists  easy array 
python simple and quick solution without loop fair candy swap alice and bob have candy bars of different sizes: a[i] is the size of the i-th bar of candy that alice has  and b[j] is the size of the j-th bar of candy that bob has  since they are friends  they would like to exchange one candy bar each so that after the exchange  they both have the same total amount of candy  (the total amount of candy a person has is the sum of the sizes of candy bars they have ) return an integer array ans where ans[0] is the size of the candy bar that alice must exchange  and ans[1] is the size of the candy bar that bob must exchange  if there are multiple answers  you may return any one of them  it is guaranteed an answer exists  easy array 
python solution using set (similar to twosum concept) fair candy swap alice and bob have candy bars of different sizes: a[i] is the size of the i-th bar of candy that alice has  and b[j] is the size of the j-th bar of candy that bob has  since they are friends  they would like to exchange one candy bar each so that after the exchange  they both have the same total amount of candy  (the total amount of candy a person has is the sum of the sizes of candy bars they have ) return an integer array ans where ans[0] is the size of the candy bar that alice must exchange  and ans[1] is the size of the candy bar that bob must exchange  if there are multiple answers  you may return any one of them  it is guaranteed an answer exists  easy array 
python simple solution fair candy swap alice and bob have candy bars of different sizes: a[i] is the size of the i-th bar of candy that alice has  and b[j] is the size of the j-th bar of candy that bob has  since they are friends  they would like to exchange one candy bar each so that after the exchange  they both have the same total amount of candy  (the total amount of candy a person has is the sum of the sizes of candy bars they have ) return an integer array ans where ans[0] is the size of the candy bar that alice must exchange  and ans[1] is the size of the candy bar that bob must exchange  if there are multiple answers  you may return any one of them  it is guaranteed an answer exists  easy array 
[c++ java python] one pass  real o(n) construct binary tree from preorder and postorder traversal return any binary tree that matches the given preorder and postorder traversals  values in the traversals pre and post are distinct positive integers  medium tree 
logical thinking with code beats 99 89% construct binary tree from preorder and postorder traversal return any binary tree that matches the given preorder and postorder traversals  values in the traversals pre and post are distinct positive integers  medium tree 
c++ o(n) recursive solution construct binary tree from preorder and postorder traversal return any binary tree that matches the given preorder and postorder traversals  values in the traversals pre and post are distinct positive integers  medium tree 
clean java o(n) construct binary tree from preorder and postorder traversal return any binary tree that matches the given preorder and postorder traversals  values in the traversals pre and post are distinct positive integers  medium tree 
easy python recursive solution with explanation construct binary tree from preorder and postorder traversal return any binary tree that matches the given preorder and postorder traversals  values in the traversals pre and post are distinct positive integers  medium tree 
[c++ java python] normalise word find and replace pattern you have a list of words and a pattern  and you want to know which words in words matches the pattern  a word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x)  we get the desired word  (recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter  and no two letters map to the same letter ) return a list of the words in words that match the given pattern  you may return the answer in any order  medium string 
short python isomorphism solution find and replace pattern you have a list of words and a pattern  and you want to know which words in words matches the pattern  a word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x)  we get the desired word  (recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter  and no two letters map to the same letter ) return a list of the words in words that match the given pattern  you may return the answer in any order  medium string 
java 3ms clear code find and replace pattern you have a list of words and a pattern  and you want to know which words in words matches the pattern  a word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x)  we get the desired word  (recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter  and no two letters map to the same letter ) return a list of the words in words that match the given pattern  you may return the answer in any order  medium string 
java two maps solution find and replace pattern you have a list of words and a pattern  and you want to know which words in words matches the pattern  a word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x)  we get the desired word  (recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter  and no two letters map to the same letter ) return a list of the words in words that match the given pattern  you may return the answer in any order  medium string 
python double-dictionary simplest logics beat 99% find and replace pattern you have a list of words and a pattern  and you want to know which words in words matches the pattern  a word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x)  we get the desired word  (recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter  and no two letters map to the same letter ) return a list of the words in words that match the given pattern  you may return the answer in any order  medium string 
[c++ java 1-line python] sort and one pass sum of subsequence widths given an array of integers a  consider all non-empty subsequences of a  for any sequence s  let the width of s be the difference between the maximum and minimum element of s  return the sum of the widths of all subsequences of a  as the answer may be very large  return the answer modulo 10^9 + 7  hard array math 
leetcode weekly contest 98 screencast sum of subsequence widths given an array of integers a  consider all non-empty subsequences of a  for any sequence s  let the width of s be the difference between the maximum and minimum element of s  return the sum of the widths of all subsequences of a  as the answer may be very large  return the answer modulo 10^9 + 7  hard array math 
c++ solution  o(n log n) sort + o(n) calculate sum of subsequence widths given an array of integers a  consider all non-empty subsequences of a  for any sequence s  let the width of s be the difference between the maximum and minimum element of s  return the sum of the widths of all subsequences of a  as the answer may be very large  return the answer modulo 10^9 + 7  hard array math 
pythonic o(nlogn) sorting sum of subsequence widths given an array of integers a  consider all non-empty subsequences of a  for any sequence s  let the width of s be the difference between the maximum and minimum element of s  return the sum of the widths of all subsequences of a  as the answer may be very large  return the answer modulo 10^9 + 7  hard array math 
o(nlogn) solution sum of subsequence widths given an array of integers a  consider all non-empty subsequences of a  for any sequence s  let the width of s be the difference between the maximum and minimum element of s  return the sum of the widths of all subsequences of a  as the answer may be very large  return the answer modulo 10^9 + 7  hard array math 
[c++ java 1-line python] minus hidden area surface area of 3d shapes on a n   n grid  we place some 1   1   1 cubes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  return the total surface area of the resulting shapes  easy math geometry 
java simple solution surface area of 3d shapes on a n   n grid  we place some 1   1   1 cubes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  return the total surface area of the resulting shapes  easy math geometry 
difficulty should be medium not easy surface area of 3d shapes on a n   n grid  we place some 1   1   1 cubes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  return the total surface area of the resulting shapes  easy math geometry 
java solution surface area of 3d shapes on a n   n grid  we place some 1   1   1 cubes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  return the total surface area of the resulting shapes  easy math geometry 
java solution with explanation surface area of 3d shapes on a n   n grid  we place some 1   1   1 cubes  each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i  j)  return the total surface area of the resulting shapes  easy math geometry 
java concise set solution groups of special-equivalent strings you are given an array a of strings  two strings s and t are special-equivalent if after any number of moves  s == t  a move consists of choosing two indices i and j with i % 2 == j % 2  and swapping s[i] with s[j]  now  a group of special-equivalent strings from a is a non-empty subset s of a such that any string not in s is not special-equivalent with any string in s  return the number of groups of special-equivalent strings from a  easy string 
misleading description during the contest groups of special-equivalent strings you are given an array a of strings  two strings s and t are special-equivalent if after any number of moves  s == t  a move consists of choosing two indices i and j with i % 2 == j % 2  and swapping s[i] with s[j]  now  a group of special-equivalent strings from a is a non-empty subset s of a such that any string not in s is not special-equivalent with any string in s  return the number of groups of special-equivalent strings from a  easy string 
python 1-liner groups of special-equivalent strings you are given an array a of strings  two strings s and t are special-equivalent if after any number of moves  s == t  a move consists of choosing two indices i and j with i % 2 == j % 2  and swapping s[i] with s[j]  now  a group of special-equivalent strings from a is a non-empty subset s of a such that any string not in s is not special-equivalent with any string in s  return the number of groups of special-equivalent strings from a  easy string 
python extremely simple solution groups of special-equivalent strings you are given an array a of strings  two strings s and t are special-equivalent if after any number of moves  s == t  a move consists of choosing two indices i and j with i % 2 == j % 2  and swapping s[i] with s[j]  now  a group of special-equivalent strings from a is a non-empty subset s of a such that any string not in s is not special-equivalent with any string in s  return the number of groups of special-equivalent strings from a  easy string 
c++ simple solution groups of special-equivalent strings you are given an array a of strings  two strings s and t are special-equivalent if after any number of moves  s == t  a move consists of choosing two indices i and j with i % 2 == j % 2  and swapping s[i] with s[j]  now  a group of special-equivalent strings from a is a non-empty subset s of a such that any string not in s is not special-equivalent with any string in s  return the number of groups of special-equivalent strings from a  easy string 
[c++ java python] o(1) maximum frequency stack implement freqstack  a class which simulates the operation of a stack-like data structure  freqstack has two functions: push(int x)  which pushes an integer x onto the stack  pop()  which removes and returns the most frequent element in the stack  if there is a tie for most frequent element  the element closest to the top of the stack is removed and returned  hard hash table stack 
python simple priorityqueue maximum frequency stack implement freqstack  a class which simulates the operation of a stack-like data structure  freqstack has two functions: push(int x)  which pushes an integer x onto the stack  pop()  which removes and returns the most frequent element in the stack  if there is a tie for most frequent element  the element closest to the top of the stack is removed and returned  hard hash table stack 
java o(1) solution easy understand using bucket sort maximum frequency stack implement freqstack  a class which simulates the operation of a stack-like data structure  freqstack has two functions: push(int x)  which pushes an integer x onto the stack  pop()  which removes and returns the most frequent element in the stack  if there is a tie for most frequent element  the element closest to the top of the stack is removed and returned  hard hash table stack 
leetcode weekly contest 99 screencast maximum frequency stack implement freqstack  a class which simulates the operation of a stack-like data structure  freqstack has two functions: push(int x)  which pushes an integer x onto the stack  pop()  which removes and returns the most frequent element in the stack  if there is a tie for most frequent element  the element closest to the top of the stack is removed and returned  hard hash table stack 
java priority queue easy understand maximum frequency stack implement freqstack  a class which simulates the operation of a stack-like data structure  freqstack has two functions: push(int x)  which pushes an integer x onto the stack  pop()  which removes and returns the most frequent element in the stack  if there is a tie for most frequent element  the element closest to the top of the stack is removed and returned  hard hash table stack 
[c++ java python] one pass o(n) monotonic array an array is monotonic if it is either monotone increasing or monotone decreasing  an array a is monotone increasing if for all i <= j  a[i] <= a[j]  an array a is monotone decreasing if for all i <= j  a[i] >= a[j]  return true if and only if the given array a is monotonic  easy array 
python solution  easy to understand monotonic array an array is monotonic if it is either monotone increasing or monotone decreasing  an array a is monotone increasing if for all i <= j  a[i] <= a[j]  an array a is monotone decreasing if for all i <= j  a[i] >= a[j]  return true if and only if the given array a is monotonic  easy array 
java tricky solution monotonic array an array is monotonic if it is either monotone increasing or monotone decreasing  an array a is monotone increasing if for all i <= j  a[i] <= a[j]  an array a is monotone decreasing if for all i <= j  a[i] >= a[j]  return true if and only if the given array a is monotonic  easy array 
1-liner c++ monotonic array an array is monotonic if it is either monotone increasing or monotone decreasing  an array a is monotone increasing if for all i <= j  a[i] <= a[j]  an array a is monotone decreasing if for all i <= j  a[i] >= a[j]  return true if and only if the given array a is monotonic  easy array 
[java] 1 pass 7 lines straight forward code  monotonic array an array is monotonic if it is either monotone increasing or monotone decreasing  an array a is monotone increasing if for all i <= j  a[i] <= a[j]  an array a is monotone decreasing if for all i <= j  a[i] >= a[j]  return true if and only if the given array a is monotonic  easy array 
[c++ java python] self-explained  5-line  o(n) increasing order search tree given a tree  rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree  and every node has no left child and only 1 right child  easy tree depth-first search 
can someone explain this test case? increasing order search tree given a tree  rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree  and every node has no left child and only 1 right child  easy tree depth-first search 
java simple inorder traversal- with explanation increasing order search tree given a tree  rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree  and every node has no left child and only 1 right child  easy tree depth-first search 
6-line python o(n) solution  increasing order search tree given a tree  rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree  and every node has no left child and only 1 right child  easy tree depth-first search 
inorder traversal increasing order search tree given a tree  rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree  and every node has no left child and only 1 right child  easy tree depth-first search 
[c++ java python] o(30n) bitwise ors of subarrays we have an array a of non-negative integers  for every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with i <= j)  we take the bitwise or of all the elements in b  obtaining a result a[i] | a[i+1] |     | a[j]  return the number of possible results  (results that occur more than once are only counted once in the final answer ) medium dynamic programming bit manipulation 
c++ o(kn) solution bitwise ors of subarrays we have an array a of non-negative integers  for every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with i <= j)  we take the bitwise or of all the elements in b  obtaining a result a[i] | a[i+1] |     | a[j]  return the number of possible results  (results that occur more than once are only counted once in the final answer ) medium dynamic programming bit manipulation 
[python] dynamic programming solution with indepth explanation of intuition  bitwise ors of subarrays we have an array a of non-negative integers  for every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with i <= j)  we take the bitwise or of all the elements in b  obtaining a result a[i] | a[i+1] |     | a[j]  return the number of possible results  (results that occur more than once are only counted once in the final answer ) medium dynamic programming bit manipulation 
c++ simplest  fastest ;) (224 ms) bitwise ors of subarrays we have an array a of non-negative integers  for every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with i <= j)  we take the bitwise or of all the elements in b  obtaining a result a[i] | a[i+1] |     | a[j]  return the number of possible results  (results that occur more than once are only counted once in the final answer ) medium dynamic programming bit manipulation 
the exactly same code can pass now  so sad bitwise ors of subarrays we have an array a of non-negative integers  for every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with i <= j)  we take the bitwise or of all the elements in b  obtaining a result a[i] | a[i+1] |     | a[j]  return the number of possible results  (results that occur more than once are only counted once in the final answer ) medium dynamic programming bit manipulation 
[c++ java python] sort string or rotate string orderly queue a string s of lowercase letters is given  then  we may make any number of moves  in each move  we choose one of the first k letters (starting from the left)  remove it  and place it at the end of the string  return the lexicographically smallest string we could have after any number of moves  hard math string 
k>1 is bubblesort orderly queue a string s of lowercase letters is given  then  we may make any number of moves  in each move  we choose one of the first k letters (starting from the left)  remove it  and place it at the end of the string  return the lexicographically smallest string we could have after any number of moves  hard math string 
[c++] solution sort rotate orderly queue a string s of lowercase letters is given  then  we may make any number of moves  in each move  we choose one of the first k letters (starting from the left)  remove it  and place it at the end of the string  return the lexicographically smallest string we could have after any number of moves  hard math string 
when k > 1 you can reorder any way you like [proof] orderly queue a string s of lowercase letters is given  then  we may make any number of moves  in each move  we choose one of the first k letters (starting from the left)  remove it  and place it at the end of the string  return the lexicographically smallest string we could have after any number of moves  hard math string 
java simple solution  12 ms orderly queue a string s of lowercase letters is given  then  we may make any number of moves  in each move  we choose one of the first k letters (starting from the left)  remove it  and place it at the end of the string  return the lexicographically smallest string we could have after any number of moves  hard math string 
java straightforward solution  o(n) time  o(1) space rle iterator write an iterator that iterates through a run-length encoded sequence  the iterator is initialized by rleiterator(int[] a)  where a is a run-length encoding of some sequence  more specifically  for all even i  a[i] tells us the number of times that the non-negative integer value a[i+1] is repeated in the sequence  the iterator supports one function: next(int n)  which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way  if there is no element left to exhaust  next returns -1 instead  for medium array 
[java] straightforward code with comment -- o(n) time and o(1) space rle iterator write an iterator that iterates through a run-length encoded sequence  the iterator is initialized by rleiterator(int[] a)  where a is a run-length encoding of some sequence  more specifically  for all even i  a[i] tells us the number of times that the non-negative integer value a[i+1] is repeated in the sequence  the iterator supports one function: next(int n)  which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way  if there is no element left to exhaust  next returns -1 instead  for medium array 
python simple solution beats 95% python codes - o(n) rle iterator write an iterator that iterates through a run-length encoded sequence  the iterator is initialized by rleiterator(int[] a)  where a is a run-length encoding of some sequence  more specifically  for all even i  a[i] tells us the number of times that the non-negative integer value a[i+1] is repeated in the sequence  the iterator supports one function: next(int n)  which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way  if there is no element left to exhaust  next returns -1 instead  for medium array 
c interface error  rleiterator  rleiteratorcreate(int  a)  missing length for c  rle iterator write an iterator that iterates through a run-length encoded sequence  the iterator is initialized by rleiterator(int[] a)  where a is a run-length encoding of some sequence  more specifically  for all even i  a[i] tells us the number of times that the non-negative integer value a[i+1] is repeated in the sequence  the iterator supports one function: next(int n)  which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way  if there is no element left to exhaust  next returns -1 instead  for medium array 
python3 beats 100% rle iterator write an iterator that iterates through a run-length encoded sequence  the iterator is initialized by rleiterator(int[] a)  where a is a run-length encoding of some sequence  more specifically  for all even i  a[i] tells us the number of times that the non-negative integer value a[i+1] is repeated in the sequence  the iterator supports one function: next(int n)  which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way  if there is no element left to exhaust  next returns -1 instead  for medium array 
[c++ java python] o(1) online stock span write a class stockspanner which collects daily price quotes for some stock  and returns the span of that stock's price for the current day  the span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price  for medium stack 
simple c++ solution with stack o(n)  with explanation online stock span write a class stockspanner which collects daily price quotes for some stock  and returns the span of that stock's price for the current day  the span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price  for medium stack 
short java solution online stock span write a class stockspanner which collects daily price quotes for some stock  and returns the span of that stock's price for the current day  the span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price  for medium stack 
java short solution using list with explanation online stock span write a class stockspanner which collects daily price quotes for some stock  and returns the span of that stock's price for the current day  the span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price  for medium stack 
simple python solution with comment online stock span write a class stockspanner which collects daily price quotes for some stock  and returns the span of that stock's price for the current day  the span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price  for medium stack 
python o(logn) numbers at most n given digit set we have a sorted set of digits d  a non-empty subset of {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note that '0' is not included ) now  we write numbers using these digits  using each digit as many times as we want  for hard math dynamic programming 
c++ o(logn) clear code with explanation numbers at most n given digit set we have a sorted set of digits d  a non-empty subset of {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note that '0' is not included ) now  we write numbers using these digits  using each digit as many times as we want  for hard math dynamic programming 
java solution with explanation numbers at most n given digit set we have a sorted set of digits d  a non-empty subset of {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note that '0' is not included ) now  we write numbers using these digits  using each digit as many times as we want  for hard math dynamic programming 
my straightforward self-explanatory python solution numbers at most n given digit set we have a sorted set of digits d  a non-empty subset of {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note that '0' is not included ) now  we write numbers using these digits  using each digit as many times as we want  for hard math dynamic programming 
simple c++ solution ( 0 ms  o(logn) )  with line by line explanation numbers at most n given digit set we have a sorted set of digits d  a non-empty subset of {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note that '0' is not included ) now  we write numbers using these digits  using each digit as many times as we want  for hard math dynamic programming 
[c++ java python] dp solution o(n^2)  valid permutations for di sequence we are given s  a length n string of characters from the set {'d'  'i'}  (these letters stand for "decreasing" and "increasing" ) a valid permutation is a permutation p[0]  p[1]       p[n] of integers {0  1       n}  such that for all i: if s[i] == 'd'  then p[i] > p[i+1]  and; if s[i] == 'i'  then p[i] < p[i+1]  how many valid permutations are there? since the answer may be large  return your answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
share my o(n^3) => o(n^2) c++ dp solution  including the thoughts of improvement  valid permutations for di sequence we are given s  a length n string of characters from the set {'d'  'i'}  (these letters stand for "decreasing" and "increasing" ) a valid permutation is a permutation p[0]  p[1]       p[n] of integers {0  1       n}  such that for all i: if s[i] == 'd'  then p[i] > p[i+1]  and; if s[i] == 'i'  then p[i] < p[i+1]  how many valid permutations are there? since the answer may be large  return your answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
top-down with memo -> bottom-up dp -> n^3 dp -> n^2 dp -> o(n) space valid permutations for di sequence we are given s  a length n string of characters from the set {'d'  'i'}  (these letters stand for "decreasing" and "increasing" ) a valid permutation is a permutation p[0]  p[1]       p[n] of integers {0  1       n}  such that for all i: if s[i] == 'd'  then p[i] > p[i+1]  and; if s[i] == 'i'  then p[i] < p[i+1]  how many valid permutations are there? since the answer may be large  return your answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
python o(n^3) o(n) space dp solution with explanation valid permutations for di sequence we are given s  a length n string of characters from the set {'d'  'i'}  (these letters stand for "decreasing" and "increasing" ) a valid permutation is a permutation p[0]  p[1]       p[n] of integers {0  1       n}  such that for all i: if s[i] == 'd'  then p[i] > p[i+1]  and; if s[i] == 'i'  then p[i] < p[i+1]  how many valid permutations are there? since the answer may be large  return your answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
[visualization] key to the dp solution: imagine cutting a piece of paper and separating the halves valid permutations for di sequence we are given s  a length n string of characters from the set {'d'  'i'}  (these letters stand for "decreasing" and "increasing" ) a valid permutation is a permutation p[0]  p[1]       p[n] of integers {0  1       n}  such that for all i: if s[i] == 'd'  then p[i] > p[i+1]  and; if s[i] == 'i'  then p[i] < p[i+1]  how many valid permutations are there? since the answer may be large  return your answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
another poorly worded question fruit into baskets in a row of trees  the i-th tree produces fruit with type tree[i]  you start at any tree of your choice  then repeatedly perform the following steps: add one piece of fruit from this tree to your baskets  if you cannot  stop  move to the next tree to the right of the current tree  if there is no tree to the right  stop  note that you do not have any choice after the initial choice of starting tree: you must perform step 1  then step 2  then back to step 1  then step 2  and so on until you stop  you have two baskets  and each basket can carry any quantity of fruit  but you want each basket to only carry one type of fruit each  what is the total amount of fruit you can collect with this procedure? medium two pointers 
problem: longest subarray with 2 elements fruit into baskets in a row of trees  the i-th tree produces fruit with type tree[i]  you start at any tree of your choice  then repeatedly perform the following steps: add one piece of fruit from this tree to your baskets  if you cannot  stop  move to the next tree to the right of the current tree  if there is no tree to the right  stop  note that you do not have any choice after the initial choice of starting tree: you must perform step 1  then step 2  then back to step 1  then step 2  and so on until you stop  you have two baskets  and each basket can carry any quantity of fruit  but you want each basket to only carry one type of fruit each  what is the total amount of fruit you can collect with this procedure? medium two pointers 
sliding window fruit into baskets in a row of trees  the i-th tree produces fruit with type tree[i]  you start at any tree of your choice  then repeatedly perform the following steps: add one piece of fruit from this tree to your baskets  if you cannot  stop  move to the next tree to the right of the current tree  if there is no tree to the right  stop  note that you do not have any choice after the initial choice of starting tree: you must perform step 1  then step 2  then back to step 1  then step 2  and so on until you stop  you have two baskets  and each basket can carry any quantity of fruit  but you want each basket to only carry one type of fruit each  what is the total amount of fruit you can collect with this procedure? medium two pointers 
what the fuck?what is meaning?i really cann't understand fruit into baskets in a row of trees  the i-th tree produces fruit with type tree[i]  you start at any tree of your choice  then repeatedly perform the following steps: add one piece of fruit from this tree to your baskets  if you cannot  stop  move to the next tree to the right of the current tree  if there is no tree to the right  stop  note that you do not have any choice after the initial choice of starting tree: you must perform step 1  then step 2  then back to step 1  then step 2  and so on until you stop  you have two baskets  and each basket can carry any quantity of fruit  but you want each basket to only carry one type of fruit each  what is the total amount of fruit you can collect with this procedure? medium two pointers 
java - longest subarray with atmost 2 distinct elements fruit into baskets in a row of trees  the i-th tree produces fruit with type tree[i]  you start at any tree of your choice  then repeatedly perform the following steps: add one piece of fruit from this tree to your baskets  if you cannot  stop  move to the next tree to the right of the current tree  if there is no tree to the right  stop  note that you do not have any choice after the initial choice of starting tree: you must perform step 1  then step 2  then back to step 1  then step 2  and so on until you stop  you have two baskets  and each basket can carry any quantity of fruit  but you want each basket to only carry one type of fruit each  what is the total amount of fruit you can collect with this procedure? medium two pointers 
[c++ java] in place swap sort array by parity given an array a of non-negative integers  return an array consisting of all the even elements of a  followed by all the odd elements of a  you may return any answer array that satisfies this condition  easy array 
very simple c++ python java o(n) soln (avoid in-place swapping as the input is passed as reference) sort array by parity given an array a of non-negative integers  return an array consisting of all the even elements of a  followed by all the odd elements of a  you may return any answer array that satisfies this condition  easy array 
my simple java solution sort array by parity given an array a of non-negative integers  return an array consisting of all the even elements of a  followed by all the odd elements of a  you may return any answer array that satisfies this condition  easy array 
python 2 pointer in place swap  beats 99% sort array by parity given an array a of non-negative integers  return an array consisting of all the even elements of a  followed by all the odd elements of a  you may return any answer array that satisfies this condition  easy array 
one line javascript   sort array by parity given an array a of non-negative integers  return an array consisting of all the even elements of a  followed by all the odd elements of a  you may return any answer array that satisfies this condition  easy array 
java building the next palindrome super palindromes let's say a positive integer is a superpalindrome if it is a palindrome  and it is also the square of a palindrome  now  given two positive integers l and r (represented as strings)  return the number of superpalindromes in the inclusive range [l  r]  hard math 
no more this type questions for contest! super palindromes let's say a positive integer is a superpalindrome if it is a palindrome  and it is also the square of a palindrome  now  given two positive integers l and r (represented as strings)  return the number of superpalindromes in the inclusive range [l  r]  hard math 
python super easy to understand  10^5 complexity  no cheating super palindromes let's say a positive integer is a superpalindrome if it is a palindrome  and it is also the square of a palindrome  now  given two positive integers l and r (represented as strings)  return the number of superpalindromes in the inclusive range [l  r]  hard math 
python ac  bfs  detail explanation super palindromes let's say a positive integer is a superpalindrome if it is a palindrome  and it is also the square of a palindrome  now  given two positive integers l and r (represented as strings)  return the number of superpalindromes in the inclusive range [l  r]  hard math 
[c++] straightforward backtracking solution super palindromes let's say a positive integer is a superpalindrome if it is a palindrome  and it is also the square of a palindrome  now  given two positive integers l and r (represented as strings)  return the number of superpalindromes in the inclusive range [l  r]  hard math 
[c++ java python] stack solution sum of subarray minimums given an array of integers a  find the sum of min(b)  where b ranges over every (contiguous) subarray of a  since the answer may be large  return the answer modulo 10^9 + 7  medium array stack 
stack solution with very  detailed explanation step by step sum of subarray minimums given an array of integers a  find the sum of min(b)  where b ranges over every (contiguous) subarray of a  since the answer may be large  return the answer modulo 10^9 + 7  medium array stack 
python simple stack o(n) solution - 10 lines  sum of subarray minimums given an array of integers a  find the sum of min(b)  where b ranges over every (contiguous) subarray of a  since the answer may be large  return the answer modulo 10^9 + 7  medium array stack 
java o(n) building preprocessed scope array with explanation sum of subarray minimums given an array of integers a  find the sum of min(b)  where b ranges over every (contiguous) subarray of a  since the answer may be large  return the answer modulo 10^9 + 7  medium array stack 
one stack solution sum of subarray minimums given an array of integers a  find the sum of min(b)  where b ranges over every (contiguous) subarray of a  since the answer may be large  return the answer modulo 10^9 + 7  medium array stack 
very confusing question! smallest range i given an array a of integers  for each integer a[i] we may choose any x with -k <= x <= k  and add x to a[i]  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  easy 
[c++ java python] check max - min smallest range i given an array a of integers  for each integer a[i] we may choose any x with -k <= x <= k  and add x to a[i]  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  easy 
 [java] simple single pass solution smallest range i given an array a of integers  for each integer a[i] we may choose any x with -k <= x <= k  and add x to a[i]  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  easy 
c++ 1-liner smallest range i given an array a of integers  for each integer a[i] we may choose any x with -k <= x <= k  and add x to a[i]  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  easy 
java easy to understand solution smallest range i given an array a of integers  for each integer a[i] we may choose any x with -k <= x <= k  and add x to a[i]  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  easy 
diagram and bfs snakes and ladders on an n x n board  the numbers from 1 to n n are written boustrophedonically starting from the bottom left of the board  and alternating direction each row  for medium 
change to 1d array then bfs snakes and ladders on an n x n board  the numbers from 1 to n n are written boustrophedonically starting from the bottom left of the board  and alternating direction each row  for medium 
java concise solution easy to understand snakes and ladders on an n x n board  the numbers from 1 to n n are written boustrophedonically starting from the bottom left of the board  and alternating direction each row  for medium 
dude    it is literally 1-6 steps  not an example of 1-n steps when n = 6 snakes and ladders on an n x n board  the numbers from 1 to n n are written boustrophedonically starting from the bottom left of the board  and alternating direction each row  for medium 
how does this input gives 2? snakes and ladders on an n x n board  the numbers from 1 to n n are written boustrophedonically starting from the bottom left of the board  and alternating direction each row  for medium 
[c++ java python] add 0 or 2   k smallest range ii given an array a of integers  for each integer a[i] we need to choose either x = -k or x = k  and add x to a[i] (only once)  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  medium 
simple c++ solution with explanation smallest range ii given an array a of integers  for each integer a[i] we need to choose either x = -k or x = k  and add x to a[i] (only once)  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  medium 
c++  o(n) time solution! take the challenge! with very  very  detail description and comments smallest range ii given an array a of integers  for each integer a[i] we need to choose either x = -k or x = k  and add x to a[i] (only once)  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  medium 
java solution with the picture to explain it smallest range ii given an array a of integers  for each integer a[i] we need to choose either x = -k or x = k  and add x to a[i] (only once)  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  medium 
java solution very easy to understand - [sliding window] smallest range ii given an array a of integers  for each integer a[i] we need to choose either x = -k or x = k  and add x to a[i] (only once)  after this process  we have some array b  return the smallest possible difference between the maximum value of b and the minimum value of b  medium 
[c++ java python] binary search in times online election in an election  the i-th vote was cast for persons[i] at time times[i]  now  we would like to implement the following query function: topvotedcandidate q(int t) will return the number of the person that was leading the election at time t  votes cast at time t will count towards our query  in the case of a tie  the most recent vote (among tied candidates) wins  medium 
anyone else just find this question really confusing? online election in an election  the i-th vote was cast for persons[i] at time times[i]  now  we would like to implement the following query function: topvotedcandidate q(int t) will return the number of the person that was leading the election at time t  votes cast at time t will count towards our query  in the case of a tie  the most recent vote (among tied candidates) wins  medium 
[java] two methods with comment- using treemap and binary search  respectively online election in an election  the i-th vote was cast for persons[i] at time times[i]  now  we would like to implement the following query function: topvotedcandidate q(int t) will return the number of the person that was leading the election at time t  votes cast at time t will count towards our query  in the case of a tie  the most recent vote (among tied candidates) wins  medium 
python readable short bisect solution online election in an election  the i-th vote was cast for persons[i] at time times[i]  now  we would like to implement the following query function: topvotedcandidate q(int t) will return the number of the person that was leading the election at time t  votes cast at time t will count towards our query  in the case of a tie  the most recent vote (among tied candidates) wins  medium 
[java] treemap: o(nlogn) + o(logn)  and binary search: o(n) + o(logn) online election in an election  the i-th vote was cast for persons[i] at time times[i]  now  we would like to implement the following query function: topvotedcandidate q(int t) will return the number of the person that was leading the election at time t  votes cast at time t will count towards our query  in the case of a tie  the most recent vote (among tied candidates) wins  medium 
most of the dfs solutions are wrong  check this case cat and mouse a game on an undirected graph is played by two players  mouse and cat  who alternate turns  the graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph  mouse starts at node 1 and goes first  cat starts at node 2 and goes second  and there is a hole at node 0  during each player's turn  they must travel along one edge of the graph that meets where they are  for hard breadth-first search minimax 
perfect wrong dfs dp code explained in detail (revised) cat and mouse a game on an undirected graph is played by two players  mouse and cat  who alternate turns  the graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph  mouse starts at node 1 and goes first  cat starts at node 2 and goes second  and there is a hole at node 0  during each player's turn  they must travel along one edge of the graph that meets where they are  for hard breadth-first search minimax 
5ms java solution with brief comment  cat and mouse a game on an undirected graph is played by two players  mouse and cat  who alternate turns  the graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph  mouse starts at node 1 and goes first  cat starts at node 2 and goes second  and there is a hole at node 0  during each player's turn  they must travel along one edge of the graph that meets where they are  for hard breadth-first search minimax 
so confusing the last case  can't believe it! cat and mouse a game on an undirected graph is played by two players  mouse and cat  who alternate turns  the graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph  mouse starts at node 1 and goes first  cat starts at node 2 and goes second  and there is a hole at node 0  during each player's turn  they must travel along one edge of the graph that meets where they are  for hard breadth-first search minimax 
share my thoughts and code so confused by the last case cat and mouse a game on an undirected graph is played by two players  mouse and cat  who alternate turns  the graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph  mouse starts at node 1 and goes first  cat starts at node 2 and goes second  and there is a hole at node 0  during each player's turn  they must travel along one edge of the graph that meets where they are  for hard breadth-first search minimax 
[c++ java python] greatest common divisor x of a kind in a deck of cards in a deck of cards  each card has an integer written on it  return true if and only if you can choose x >= 2 such that it is possible to split the entire deck into 1 or more groups of cards  where: each group has exactly x cards  all the cards in each group have the same integer  easy array math 
c++ solutions using binary method for gcd and the power of stl  3 lines if you use __gcd x of a kind in a deck of cards in a deck of cards  each card has an integer written on it  return true if and only if you can choose x >= 2 such that it is possible to split the entire deck into 1 or more groups of cards  where: each group has exactly x cards  all the cards in each group have the same integer  easy array math 
need updated cases - bad code passed [9 29 2018] x of a kind in a deck of cards in a deck of cards  each card has an integer written on it  return true if and only if you can choose x >= 2 such that it is possible to split the entire deck into 1 or more groups of cards  where: each group has exactly x cards  all the cards in each group have the same integer  easy array math 
map plus gcd solution x of a kind in a deck of cards in a deck of cards  each card has an integer written on it  return true if and only if you can choose x >= 2 such that it is possible to split the entire deck into 1 or more groups of cards  where: each group has exactly x cards  all the cards in each group have the same integer  easy array math 
java gcd x of a kind in a deck of cards in a deck of cards  each card has an integer written on it  return true if and only if you can choose x >= 2 such that it is possible to split the entire deck into 1 or more groups of cards  where: each group has exactly x cards  all the cards in each group have the same integer  easy array math 
java  one pass  7 lines partition array into disjoint intervals given an array a  partition it into two (contiguous) subarrays left and right so that: every element in left is less than or equal to every element in right  left and right are non-empty  left has the smallest possible size  return the length of left after such a partitioning  it is guaranteed that such a partitioning exists  medium array 
[c++ java python] straight forward partition array into disjoint intervals given an array a  partition it into two (contiguous) subarrays left and right so that: every element in left is less than or equal to every element in right  left and right are non-empty  left has the smallest possible size  return the length of left after such a partitioning  it is guaranteed that such a partitioning exists  medium array 
explained - python simple o(n) time o(1) space partition array into disjoint intervals given an array a  partition it into two (contiguous) subarrays left and right so that: every element in left is less than or equal to every element in right  left and right are non-empty  left has the smallest possible size  return the length of left after such a partitioning  it is guaranteed that such a partitioning exists  medium array 
java easiest simplest partition array into disjoint intervals given an array a  partition it into two (contiguous) subarrays left and right so that: every element in left is less than or equal to every element in right  left and right are non-empty  left has the smallest possible size  return the length of left after such a partitioning  it is guaranteed that such a partitioning exists  medium array 
o(n) one pass solution partition array into disjoint intervals given an array a  partition it into two (contiguous) subarrays left and right so that: every element in left is less than or equal to every element in right  left and right are non-empty  left has the smallest possible size  return the length of left after such a partitioning  it is guaranteed that such a partitioning exists  medium array 
[c++ java python] straight forward word subsets we are given two arrays a and b of words  each word is a string of lowercase letters  now  say that word b is a subset of word a if every letter in b occurs in a  including multiplicity  for medium string 
[java] 14 line clean code - count the most frequent char of words in b word subsets we are given two arrays a and b of words  each word is a string of lowercase letters  now  say that word b is a subset of word a if every letter in b occurs in a  including multiplicity  for medium string 
[16ms] fastest solution - prime number subset step in o(1) (detailed explanation) word subsets we are given two arrays a and b of words  each word is a string of lowercase letters  now  say that word b is a subset of word a if every letter in b occurs in a  including multiplicity  for medium string 
my python solution  beats 98 4%  word subsets we are given two arrays a and b of words  each word is a string of lowercase letters  now  say that word b is a subset of word a if every letter in b occurs in a  including multiplicity  for medium string 
cpp easy understand solution o(max(na nb) strlen) word subsets we are given two arrays a and b of words  each word is a string of lowercase letters  now  say that word b is a subset of word a if every letter in b occurs in a  including multiplicity  for medium string 
[c++ java python] two pointers reverse only letters given a string s  return the "reversed" string where all characters that are not a letter stay in the same place  and all letters reverse their positions  easy 
[java] 5 line clean code - very simple logic reverse only letters given a string s  return the "reversed" string where all characters that are not a letter stay in the same place  and all letters reverse their positions  easy 
java two pointers reverse only letters given a string s  return the "reversed" string where all characters that are not a letter stay in the same place  and all letters reverse their positions  easy 
my 2-liner python stack solution  reverse only letters given a string s  return the "reversed" string where all characters that are not a letter stay in the same place  and all letters reverse their positions  easy 
java 6ms simple solution reverse only letters given a string s  return the "reversed" string where all characters that are not a letter stay in the same place  and all letters reverse their positions  easy 
[c++ java python] one pass maximum sum circular subarray given a circular array c of integers represented by a  find the maximum possible sum of a non-empty subarray of c  here  a circular array means the end of the array connects to the beginning of the array  (formally  c[i] = a[i] when 0 <= i < a length  and c[i+a length] = c[i] when i >= 0 ) also  a subarray may only include each element of the fixed buffer a at most once  (formally  for a subarray c[i]  c[i+1]       c[j]  there does not exist i <= k1  k2 <= j with k1 % a length = k2 % a length ) medium 
c++ single pass o(n) linear time o(1) constant space maximum sum circular subarray given a circular array c of integers represented by a  find the maximum possible sum of a non-empty subarray of c  here  a circular array means the end of the array connects to the beginning of the array  (formally  c[i] = a[i] when 0 <= i < a length  and c[i+a length] = c[i] when i >= 0 ) also  a subarray may only include each element of the fixed buffer a at most once  (formally  for a subarray c[i]  c[i+1]       c[j]  there does not exist i <= k1  k2 <= j with k1 % a length = k2 % a length ) medium 
c++ o(n) solution maximum sum circular subarray given a circular array c of integers represented by a  find the maximum possible sum of a non-empty subarray of c  here  a circular array means the end of the array connects to the beginning of the array  (formally  c[i] = a[i] when 0 <= i < a length  and c[i+a length] = c[i] when i >= 0 ) also  a subarray may only include each element of the fixed buffer a at most once  (formally  for a subarray c[i]  c[i+1]       c[j]  there does not exist i <= k1  k2 <= j with k1 % a length = k2 % a length ) medium 
java one pass  o(n) with very detailed chinese explanation maximum sum circular subarray given a circular array c of integers represented by a  find the maximum possible sum of a non-empty subarray of c  here  a circular array means the end of the array connects to the beginning of the array  (formally  c[i] = a[i] when 0 <= i < a length  and c[i+a length] = c[i] when i >= 0 ) also  a subarray may only include each element of the fixed buffer a at most once  (formally  for a subarray c[i]  c[i+1]       c[j]  there does not exist i <= k1  k2 <= j with k1 % a length = k2 % a length ) medium 
short java solution!!! maximum sum circular subarray given a circular array c of integers represented by a  find the maximum possible sum of a non-empty subarray of c  here  a circular array means the end of the array connects to the beginning of the array  (formally  c[i] = a[i] when 0 <= i < a length  and c[i+a length] = c[i] when i >= 0 ) also  a subarray may only include each element of the fixed buffer a at most once  (formally  for a subarray c[i]  c[i+1]       c[j]  there does not exist i <= k1  k2 <= j with k1 % a length = k2 % a length ) medium 
[c++ java python] o(1) insert complete binary tree inserter a complete binary tree is a binary tree in which every level  except possibly the last  is completely filled  and all nodes are as far left as possible  write a data structure cbtinserter that is initialized with a complete binary tree and supports the following operations: cbtinserter(treenode root) initializes the data structure on a given tree with head node root; cbtinserter insert(int v) will insert a treenode into the tree with value node val = v so that the tree remains complete  and returns the value of the parent of the inserted treenode; cbtinserter get_root() will return the head node of the tree  medium 
[java] bfs straightforward code  two methods  initialization and insert time o(1)  respectively  complete binary tree inserter a complete binary tree is a binary tree in which every level  except possibly the last  is completely filled  and all nodes are as far left as possible  write a data structure cbtinserter that is initialized with a complete binary tree and supports the following operations: cbtinserter(treenode root) initializes the data structure on a given tree with head node root; cbtinserter insert(int v) will insert a treenode into the tree with value node val = v so that the tree remains complete  and returns the value of the parent of the inserted treenode; cbtinserter get_root() will return the head node of the tree  medium 
javascript always get a runtime error even do nothing changes to template complete binary tree inserter a complete binary tree is a binary tree in which every level  except possibly the last  is completely filled  and all nodes are as far left as possible  write a data structure cbtinserter that is initialized with a complete binary tree and supports the following operations: cbtinserter(treenode root) initializes the data structure on a given tree with head node root; cbtinserter insert(int v) will insert a treenode into the tree with value node val = v so that the tree remains complete  and returns the value of the parent of the inserted treenode; cbtinserter get_root() will return the head node of the tree  medium 
java solution: o(1) insert vs  o(1) pre-process trade off complete binary tree inserter a complete binary tree is a binary tree in which every level  except possibly the last  is completely filled  and all nodes are as far left as possible  write a data structure cbtinserter that is initialized with a complete binary tree and supports the following operations: cbtinserter(treenode root) initializes the data structure on a given tree with head node root; cbtinserter insert(int v) will insert a treenode into the tree with value node val = v so that the tree remains complete  and returns the value of the parent of the inserted treenode; cbtinserter get_root() will return the head node of the tree  medium 
c++ 12 ms using queue complete binary tree inserter a complete binary tree is a binary tree in which every level  except possibly the last  is completely filled  and all nodes are as far left as possible  write a data structure cbtinserter that is initialized with a complete binary tree and supports the following operations: cbtinserter(treenode root) initializes the data structure on a given tree with head node root; cbtinserter insert(int v) will insert a treenode into the tree with value node val = v so that the tree remains complete  and returns the value of the parent of the inserted treenode; cbtinserter get_root() will return the head node of the tree  medium 
[c++ java python] dp solution number of music playlists your music player contains n different songs and she wants to listen to l (not necessarily different) songs during your trip  you create a playlist so that: every song is played at least once a song can only be played again only if k other songs have been played return the number of possible playlists  as the answer can be very large  return it modulo 10^9 + 7  hard 
dp solution that is easy to understand number of music playlists your music player contains n different songs and she wants to listen to l (not necessarily different) songs during your trip  you create a playlist so that: every song is played at least once a song can only be played again only if k other songs have been played return the number of possible playlists  as the answer can be very large  return it modulo 10^9 + 7  hard 
[c++] straight forward dp  with explanation number of music playlists your music player contains n different songs and she wants to listen to l (not necessarily different) songs during your trip  you create a playlist so that: every song is played at least once a song can only be played again only if k other songs have been played return the number of possible playlists  as the answer can be very large  return it modulo 10^9 + 7  hard 
[python3] a math solution o((n - k)   log(l - k)) number of music playlists your music player contains n different songs and she wants to listen to l (not necessarily different) songs during your trip  you create a playlist so that: every song is played at least once a song can only be played again only if k other songs have been played return the number of possible playlists  as the answer can be very large  return it modulo 10^9 + 7  hard 
java dp solution (i think the description of the problem could be clearer) number of music playlists your music player contains n different songs and she wants to listen to l (not necessarily different) songs during your trip  you create a playlist so that: every song is played at least once a song can only be played again only if k other songs have been played return the number of possible playlists  as the answer can be very large  return it modulo 10^9 + 7  hard 
[java] two one pass 7 liners - space o(n) and o(1)  respectively minimum add to make parentheses valid given a string s of '(' and ')' parentheses  we add the minimum number of parentheses ( '(' or ')'  and in any positions ) so that the resulting parentheses string is valid  formally  a parentheses string is valid if and only if: it is the empty string  or it can be written as ab (a concatenated with b)  where a and b are valid strings  or it can be written as (a)  where a is a valid string  given a parentheses string  return the minimum number of parentheses we must add to make the resulting string valid  medium 
[c++ java python] straight forward one pass minimum add to make parentheses valid given a string s of '(' and ')' parentheses  we add the minimum number of parentheses ( '(' or ')'  and in any positions ) so that the resulting parentheses string is valid  formally  a parentheses string is valid if and only if: it is the empty string  or it can be written as ab (a concatenated with b)  where a and b are valid strings  or it can be written as (a)  where a is a valid string  given a parentheses string  return the minimum number of parentheses we must add to make the resulting string valid  medium 
python classic valid paranthesis solution minimum add to make parentheses valid given a string s of '(' and ')' parentheses  we add the minimum number of parentheses ( '(' or ')'  and in any positions ) so that the resulting parentheses string is valid  formally  a parentheses string is valid if and only if: it is the empty string  or it can be written as ab (a concatenated with b)  where a and b are valid strings  or it can be written as (a)  where a is a valid string  given a parentheses string  return the minimum number of parentheses we must add to make the resulting string valid  medium 
[java] easy to understand stack solution (8ms)  minimum add to make parentheses valid given a string s of '(' and ')' parentheses  we add the minimum number of parentheses ( '(' or ')'  and in any positions ) so that the resulting parentheses string is valid  formally  a parentheses string is valid if and only if: it is the empty string  or it can be written as ab (a concatenated with b)  where a and b are valid strings  or it can be written as (a)  where a is a valid string  given a parentheses string  return the minimum number of parentheses we must add to make the resulting string valid  medium 
python 3-line mathematically optimal solution with explanation  one-pass o(n) time o(1) space minimum add to make parentheses valid given a string s of '(' and ')' parentheses  we add the minimum number of parentheses ( '(' or ')'  and in any positions ) so that the resulting parentheses string is valid  formally  a parentheses string is valid if and only if: it is the empty string  or it can be written as ab (a concatenated with b)  where a and b are valid strings  or it can be written as (a)  where a is a valid string  given a parentheses string  return the minimum number of parentheses we must add to make the resulting string valid  medium 
java two pointer one pass inplace sort array by parity ii given an array a of non-negative integers  half of the integers in a are odd  and half of the integers are even  sort the array so that whenever a[i] is odd  i is odd; and whenever a[i] is even  i is even  you may return any answer array that satisfies this condition  easy 
python easy 2-liner sort array by parity ii given an array a of non-negative integers  half of the integers in a are odd  and half of the integers are even  sort the array so that whenever a[i] is odd  i is odd; and whenever a[i] is even  i is even  you may return any answer array that satisfies this condition  easy 
c++ 5 lines  two pointers + 2-liner bonus sort array by parity ii given an array a of non-negative integers  half of the integers in a are odd  and half of the integers are even  sort the array so that whenever a[i] is odd  i is odd; and whenever a[i] is even  i is even  you may return any answer array that satisfies this condition  easy 
[java] two pointers inplace o(n) time simple & straightforward sort array by parity ii given an array a of non-negative integers  half of the integers in a are odd  and half of the integers are even  sort the array so that whenever a[i] is odd  i is odd; and whenever a[i] is even  i is even  you may return any answer array that satisfies this condition  easy 
[java] simple code - swap odd and even indices elements  sort array by parity ii given an array a of non-negative integers  half of the integers in a are odd  and half of the integers are even  sort the array so that whenever a[i] is odd  i is odd; and whenever a[i] is even  i is even  you may return any answer array that satisfies this condition  easy 
[c++ java python] o(101^2) 3sum with multiplicity given an integer array a  and an integer target  return the number of tuples i  j  k such that i < j < k and a[i] + a[j] + a[k] == target  as the answer can be very large  return it modulo 10^9 + 7  medium 
10 lines super super easy java solution 3sum with multiplicity given an integer array a  and an integer target  return the number of tuples i  j  k such that i < j < k and a[i] + a[j] + a[k] == target  as the answer can be very large  return it modulo 10^9 + 7  medium 
knapsack o(n   target) or straightforward o(n^2) 3sum with multiplicity given an integer array a  and an integer target  return the number of tuples i  j  k such that i < j < k and a[i] + a[j] + a[k] == target  as the answer can be very large  return it modulo 10^9 + 7  medium 
[java] o(n^2) code - sort and match  3sum with multiplicity given an integer array a  and an integer target  return the number of tuples i  j  k such that i < j < k and a[i] + a[j] + a[k] == target  as the answer can be very large  return it modulo 10^9 + 7  medium 
dp  python 3sum with multiplicity given an integer array a  and an integer target  return the number of tuples i  j  k such that i < j < k and a[i] + a[j] + a[k] == target  as the answer can be very large  return it modulo 10^9 + 7  medium 
[python] union found minimize malware spread in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  note that if a node was removed from the initial list of infected nodes  it may still be infected later as a result of the malware spread  hard 
python short dfs solution minimize malware spread in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  note that if a node was removed from the initial list of infected nodes  it may still be infected later as a result of the malware spread  hard 
how to explain this test case? minimize malware spread in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  note that if a node was removed from the initial list of infected nodes  it may still be infected later as a result of the malware spread  hard 
brute force or union find minimize malware spread in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  note that if a node was removed from the initial list of infected nodes  it may still be infected later as a result of the malware spread  hard 
c++ union find with explanation minimize malware spread in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  note that if a node was removed from the initial list of infected nodes  it may still be infected later as a result of the malware spread  hard 
[c++ java python] two pointers long pressed name your friend is typing his name into a keyboard  sometimes  when typing a character c  the key might get long pressed  and the character will be typed 1 or more times  you examine the typed characters of the keyboard  return true if it is possible that it was your friends name  with some characters (possibly none) being long pressed  easy 
java one pass solution 4ms with o(1) extra space long pressed name your friend is typing his name into a keyboard  sometimes  when typing a character c  the key might get long pressed  and the character will be typed 1 or more times  you examine the typed characters of the keyboard  return true if it is possible that it was your friends name  with some characters (possibly none) being long pressed  easy 
c++ 2 lines accepted and 5 lines accurate long pressed name your friend is typing his name into a keyboard  sometimes  when typing a character c  the key might get long pressed  and the character will be typed 1 or more times  you examine the typed characters of the keyboard  return true if it is possible that it was your friends name  with some characters (possibly none) being long pressed  easy 
java simple solution -3 ms long pressed name your friend is typing his name into a keyboard  sometimes  when typing a character c  the key might get long pressed  and the character will be typed 1 or more times  you examine the typed characters of the keyboard  return true if it is possible that it was your friends name  with some characters (possibly none) being long pressed  easy 
short java solution long pressed name your friend is typing his name into a keyboard  sometimes  when typing a character c  the key might get long pressed  and the character will be typed 1 or more times  you examine the typed characters of the keyboard  return true if it is possible that it was your friends name  with some characters (possibly none) being long pressed  easy 
prefix-suffix java o(n) one pass solution - space o(1) flip string to monotone increasing a string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0)  followed by some number of '1's (also possibly 0 ) we are given a string s of '0's and '1's  and we may flip any '0' to a '1' or a '1' to a '0'  return the minimum number of flips to make s monotone increasing  medium 
c++ java 4 lines o(n) | o(1)  dp flip string to monotone increasing a string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0)  followed by some number of '1's (also possibly 0 ) we are given a string s of '0's and '1's  and we may flip any '0' to a '1' or a '1' to a '0'  return the minimum number of flips to make s monotone increasing  medium 
java dp solution o(n) time o(1) space flip string to monotone increasing a string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0)  followed by some number of '1's (also possibly 0 ) we are given a string s of '0's and '1's  and we may flip any '0' to a '1' or a '1' to a '0'  return the minimum number of flips to make s monotone increasing  medium 
python o(n) time o(1) space solution with explanation(with extra chinese explanation) flip string to monotone increasing a string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0)  followed by some number of '1's (also possibly 0 ) we are given a string s of '0's and '1's  and we may flip any '0' to a '1' or a '1' to a '0'  return the minimum number of flips to make s monotone increasing  medium 
c++ one-pass dp solution  0ms o(n) | o(1)  one line  with explaination  flip string to monotone increasing a string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0)  followed by some number of '1's (also possibly 0 ) we are given a string s of '0's and '1's  and we may flip any '0' to a '1' or a '1' to a '0'  return the minimum number of flips to make s monotone increasing  medium 
[c++] o(n) time  o(1) space  12 ms with explanation & comments three equal parts given an array a of 0s and 1s  divide the array into 3 non-empty parts such that all of these parts represent the same binary value  if it is possible  return any [i  j] with i+1 < j  such that: a[0]  a[1]       a[i] is the first part; a[i+1]  a[i+2]       a[j-1] is the second part  and a[j]  a[j+1]       a[a length - 1] is the third part  all three parts have equal binary value  if it is not possible  return [-1  -1]  note that the entire part is used when considering what binary value it represents  for hard math 
java o(n) solution three equal parts given an array a of 0s and 1s  divide the array into 3 non-empty parts such that all of these parts represent the same binary value  if it is possible  return any [i  j] with i+1 < j  such that: a[0]  a[1]       a[i] is the first part; a[i+1]  a[i+2]       a[j-1] is the second part  and a[j]  a[j+1]       a[a length - 1] is the third part  all three parts have equal binary value  if it is not possible  return [-1  -1]  note that the entire part is used when considering what binary value it represents  for hard math 
[c++] o(n) time o(n) space  40ms  14 lines  2 loops  easy understand with explanation three equal parts given an array a of 0s and 1s  divide the array into 3 non-empty parts such that all of these parts represent the same binary value  if it is possible  return any [i  j] with i+1 < j  such that: a[0]  a[1]       a[i] is the first part; a[i+1]  a[i+2]       a[j-1] is the second part  and a[j]  a[j+1]       a[a length - 1] is the third part  all three parts have equal binary value  if it is not possible  return [-1  -1]  note that the entire part is used when considering what binary value it represents  for hard math 
java 50ms with my thinking process three equal parts given an array a of 0s and 1s  divide the array into 3 non-empty parts such that all of these parts represent the same binary value  if it is possible  return any [i  j] with i+1 < j  such that: a[0]  a[1]       a[i] is the first part; a[i+1]  a[i+2]       a[j-1] is the second part  and a[j]  a[j+1]       a[a length - 1] is the third part  all three parts have equal binary value  if it is not possible  return [-1  -1]  note that the entire part is used when considering what binary value it represents  for hard math 
java 10ms solution with o(n) time and o(1)space three equal parts given an array a of 0s and 1s  divide the array into 3 non-empty parts such that all of these parts represent the same binary value  if it is possible  return any [i  j] with i+1 < j  such that: a[0]  a[1]       a[i] is the first part; a[i+1]  a[i+2]       a[j-1] is the second part  and a[j]  a[j+1]       a[a length - 1] is the third part  all three parts have equal binary value  if it is not possible  return [-1  -1]  note that the entire part is used when considering what binary value it represents  for hard math 
python solution with my thinking process (with extra chinese explanation) minimize malware spread ii (this problem is the same as minimize malware spread  with the differences bolded ) in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  completely removing it and any connections from this node to any other node  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  hard depth-first search union find graph 
分享一个详细中文c++讲解 minimize malware spread ii (this problem is the same as minimize malware spread  with the differences bolded ) in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  completely removing it and any connections from this node to any other node  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  hard depth-first search union find graph 
short python dfs solution w  short explanation ~290 ms minimize malware spread ii (this problem is the same as minimize malware spread  with the differences bolded ) in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  completely removing it and any connections from this node to any other node  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  hard depth-first search union find graph 
java (42ms) using union find set and brute force with explaination minimize malware spread ii (this problem is the same as minimize malware spread  with the differences bolded ) in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  completely removing it and any connections from this node to any other node  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  hard depth-first search union find graph 
java bfs without copy graph minimize malware spread ii (this problem is the same as minimize malware spread  with the differences bolded ) in a network of nodes  each node i is directly connected to another node j if and only if graph[i][j] = 1  some nodes initial are initially infected by malware  whenever two nodes are directly connected and at least one of those two nodes is infected by malware  both nodes will be infected by malware  this spread of malware will continue until no more nodes can be infected in this manner  suppose m(initial) is the final number of nodes infected with malware in the entire network  after the spread of malware stops  we will remove one node from the initial list  completely removing it and any connections from this node to any other node  return the node that if removed  would minimize m(initial)  if multiple nodes could be removed to minimize m(initial)  return such a node with the smallest index  hard depth-first search union find graph 
[java] 7 liner with comment  unique email addresses every email consists of a local name and a domain name  separated by the @ sign  for easy string 
python solution unique email addresses every email consists of a local name and a domain name  separated by the @ sign  for easy string 
concise c++ unique email addresses every email consists of a local name and a domain name  separated by the @ sign  for easy string 
[java] clean o(n maxstringlen) with and without split() unique email addresses every email consists of a local name and a domain name  separated by the @ sign  for easy string 
python solution beat 91% unique email addresses every email consists of a local name and a domain name  separated by the @ sign  for easy string 
[c++ java python] straight forward binary subarrays with sum in an array a of 0s and 1s  how many non-empty subarrays have sum s? medium hash table two pointers 
[java] clean solution 2 sum + prefix sum caching binary subarrays with sum in an array a of 0s and 1s  how many non-empty subarrays have sum s? medium hash table two pointers 
java o(n) time o(n) space  counting contiguous zeros binary subarrays with sum in an array a of 0s and 1s  how many non-empty subarrays have sum s? medium hash table two pointers 
3 ways to solve this kind of problem  binary subarrays with sum in an array a of 0s and 1s  how many non-empty subarrays have sum s? medium hash table two pointers 
python easy & short binary subarrays with sum in an array a of 0s and 1s  how many non-empty subarrays have sum s? medium hash table two pointers 
java dp solution  with graph illustrated explanations minimum falling path sum given a square array of integers a  we want the minimum sum of a falling path through a  a falling path starts at any element in the first row  and chooses one element from each row  the next row's choice must be in a column that is different from the previous row's column by at most one  medium dynamic programming 
c++ java 4 lines dp minimum falling path sum given a square array of integers a  we want the minimum sum of a falling path through a  a falling path starts at any element in the first row  and chooses one element from each row  the next row's choice must be in a column that is different from the previous row's column by at most one  medium dynamic programming 
[java] two clean dp codes - input modified and not  time o(n ^ 2)  space o(1) & o(n) minimum falling path sum given a square array of integers a  we want the minimum sum of a falling path through a  a falling path starts at any element in the first row  and chooses one element from each row  the next row's choice must be in a column that is different from the previous row's column by at most one  medium dynamic programming 
c 4ms dp solution with explanation minimum falling path sum given a square array of integers a  we want the minimum sum of a falling path through a  a falling path starts at any element in the first row  and chooses one element from each row  the next row's choice must be in a column that is different from the previous row's column by at most one  medium dynamic programming 
golang dp solution minimum falling path sum given a square array of integers a  we want the minimum sum of a falling path through a  a falling path starts at any element in the first row  and chooses one element from each row  the next row's choice must be in a column that is different from the previous row's column by at most one  medium dynamic programming 
[c++ java python] odd + even pattern  o(n) beautiful array for some fixed n  an array a is beautiful if it is a permutation of the integers 1  2       n  such that: for every i < j  there is no k with i < k < j such that a[k]   2 = a[i] + a[j]  given n  return any beautiful array a  (it is guaranteed that one exists ) medium divide and conquer 
leetcode weekly contest 108 screencast (only record 10 mins) beautiful array for some fixed n  an array a is beautiful if it is a permutation of the integers 1  2       n  such that: for every i < j  there is no k with i < k < j such that a[k]   2 = a[i] + a[j]  given n  return any beautiful array a  (it is guaranteed that one exists ) medium divide and conquer 
python 1-line solutions beautiful array for some fixed n  an array a is beautiful if it is a permutation of the integers 1  2       n  such that: for every i < j  there is no k with i < k < j such that a[k]   2 = a[i] + a[j]  given n  return any beautiful array a  (it is guaranteed that one exists ) medium divide and conquer 
[3 solutions] 4 lines in python (divide & conquer) + dp (top-down and bottom-up) beautiful array for some fixed n  an array a is beautiful if it is a permutation of the integers 1  2       n  such that: for every i < j  there is no k with i < k < j such that a[k]   2 = a[i] + a[j]  given n  return any beautiful array a  (it is guaranteed that one exists ) medium divide and conquer 
[javascript] how i understand the solution (with verification of the solution) beautiful array for some fixed n  an array a is beautiful if it is a permutation of the integers 1  2       n  such that: for every i < j  there is no k with i < k < j such that a[k]   2 = a[i] + a[j]  given n  return any beautiful array a  (it is guaranteed that one exists ) medium divide and conquer 
[java] three solutions: treemap   treeset  arraylist; all time o(logn)  number of recent calls write a class recentcounter to count recent requests  it has only one method: ping(int t)  where t represents some time in milliseconds  return the number of pings that have been made from 3000 milliseconds ago until now  any ping with time in [t - 3000  t] will count  including the current ping  it is guaranteed that every call to ping uses a strictly larger value of t than before  easy queue 
c++ easy and clean solution using queue number of recent calls write a class recentcounter to count recent requests  it has only one method: ping(int t)  where t represents some time in milliseconds  return the number of pings that have been made from 3000 milliseconds ago until now  any ping with time in [t - 3000  t] will count  including the current ping  it is guaranteed that every call to ping uses a strictly larger value of t than before  easy queue 
python straightforward solution number of recent calls write a class recentcounter to count recent requests  it has only one method: ping(int t)  where t represents some time in milliseconds  return the number of pings that have been made from 3000 milliseconds ago until now  any ping with time in [t - 3000  t] will count  including the current ping  it is guaranteed that every call to ping uses a strictly larger value of t than before  easy queue 
simple javascript solution (3 lines) number of recent calls write a class recentcounter to count recent requests  it has only one method: ping(int t)  where t represents some time in milliseconds  return the number of pings that have been made from 3000 milliseconds ago until now  any ping with time in [t - 3000  t] will count  including the current ping  it is guaranteed that every call to ping uses a strictly larger value of t than before  easy queue 
[java] array + binary search  111 ms  o(log(3000)) time  o(logn) space number of recent calls write a class recentcounter to count recent requests  it has only one method: ping(int t)  where t represents some time in milliseconds  return the number of pings that have been made from 3000 milliseconds ago until now  any ping with time in [t - 3000  t] will count  including the current ping  it is guaranteed that every call to ping uses a strictly larger value of t than before  easy queue 
c++ bfs island expansion + uf bonus shortest bridge in a given 2d binary array a  there are two islands  (an island is a 4-directionally connected group of 1s not connected to any other 1s ) now  we may change 0s to 1s so as to connect the two islands together to form 1 island  return the smallest number of 0s that must be flipped  (it is guaranteed that the answer is at least 1 ) medium depth-first search breadth-first search 
python concise dfs & bfs in 1 solution shortest bridge in a given 2d binary array a  there are two islands  (an island is a 4-directionally connected group of 1s not connected to any other 1s ) now  we may change 0s to 1s so as to connect the two islands together to form 1 island  return the smallest number of 0s that must be flipped  (it is guaranteed that the answer is at least 1 ) medium depth-first search breadth-first search 
java dfs find the island -> bfs expand the island shortest bridge in a given 2d binary array a  there are two islands  (an island is a 4-directionally connected group of 1s not connected to any other 1s ) now  we may change 0s to 1s so as to connect the two islands together to form 1 island  return the smallest number of 0s that must be flipped  (it is guaranteed that the answer is at least 1 ) medium depth-first search breadth-first search 
java dfs+bfs  traverse the 2d array once shortest bridge in a given 2d binary array a  there are two islands  (an island is a 4-directionally connected group of 1s not connected to any other 1s ) now  we may change 0s to 1s so as to connect the two islands together to form 1 island  return the smallest number of 0s that must be flipped  (it is guaranteed that the answer is at least 1 ) medium depth-first search breadth-first search 
java extremely easy to understand with comment (bfs to find answer and dfs to paint the matrix) shortest bridge in a given 2d binary array a  there are two islands  (an island is a 4-directionally connected group of 1s not connected to any other 1s ) now  we may change 0s to 1s so as to connect the two islands together to form 1 island  return the smallest number of 0s that must be flipped  (it is guaranteed that the answer is at least 1 ) medium depth-first search breadth-first search 
o(logn) knight dialer a chess knight can move as indicated in the chess diagram below:   this time  we place our chess knight on any numbered key of a phone pad (indicated above)  and the knight makes n-1 hops  each hop must be from one key to another numbered key  each time it lands on a key (including the initial placement of the knight)  it presses the number of that key  pressing n digits total  how many distinct numbers can you dial in this manner? since the answer may be large  output the answer modulo 10^9 + 7  medium dynamic programming 
[java] top down memo dp o(n) knight dialer a chess knight can move as indicated in the chess diagram below:   this time  we place our chess knight on any numbered key of a phone pad (indicated above)  and the knight makes n-1 hops  each hop must be from one key to another numbered key  each time it lands on a key (including the initial placement of the knight)  it presses the number of that key  pressing n digits total  how many distinct numbers can you dial in this manner? since the answer may be large  output the answer modulo 10^9 + 7  medium dynamic programming 
o(n) time o(1) space dp solution + google interview question writeup knight dialer a chess knight can move as indicated in the chess diagram below:   this time  we place our chess knight on any numbered key of a phone pad (indicated above)  and the knight makes n-1 hops  each hop must be from one key to another numbered key  each time it lands on a key (including the initial placement of the knight)  it presses the number of that key  pressing n digits total  how many distinct numbers can you dial in this manner? since the answer may be large  output the answer modulo 10^9 + 7  medium dynamic programming 
how to solve this problem explained for noobs!!! knight dialer a chess knight can move as indicated in the chess diagram below:   this time  we place our chess knight on any numbered key of a phone pad (indicated above)  and the knight makes n-1 hops  each hop must be from one key to another numbered key  each time it lands on a key (including the initial placement of the knight)  it presses the number of that key  pressing n digits total  how many distinct numbers can you dial in this manner? since the answer may be large  output the answer modulo 10^9 + 7  medium dynamic programming 
c++ 5 lines dp knight dialer a chess knight can move as indicated in the chess diagram below:   this time  we place our chess knight on any numbered key of a phone pad (indicated above)  and the knight makes n-1 hops  each hop must be from one key to another numbered key  each time it lands on a key (including the initial placement of the knight)  it presses the number of that key  pressing n digits total  how many distinct numbers can you dial in this manner? since the answer may be large  output the answer modulo 10^9 + 7  medium dynamic programming 
[c++] reverse operation  30 ms  better than dfs stamping the sequence you want to form a target string of lowercase letters  at the beginning  your sequence is target length '?' marks  you also have a stamp of lowercase letters  on each turn  you may place the stamp over the sequence  and replace every letter in the sequence with the corresponding letter from the stamp  you can make up to 10   target length turns  for hard string greedy 
c++ simple greedy stamping the sequence you want to form a target string of lowercase letters  at the beginning  your sequence is target length '?' marks  you also have a stamp of lowercase letters  on each turn  you may place the stamp over the sequence  and replace every letter in the sequence with the corresponding letter from the stamp  you can make up to 10   target length turns  for hard string greedy 
python ac greedy simple solution for everyone ~200 ms stamping the sequence you want to form a target string of lowercase letters  at the beginning  your sequence is target length '?' marks  you also have a stamp of lowercase letters  on each turn  you may place the stamp over the sequence  and replace every letter in the sequence with the corresponding letter from the stamp  you can make up to 10   target length turns  for hard string greedy 
useless screencast (only 1 min  for promoting my youtube channel) stamping the sequence you want to form a target string of lowercase letters  at the beginning  your sequence is target length '?' marks  you also have a stamp of lowercase letters  on each turn  you may place the stamp over the sequence  and replace every letter in the sequence with the corresponding letter from the stamp  you can make up to 10   target length turns  for hard string greedy 
python solutions stamping the sequence you want to form a target string of lowercase letters  at the beginning  your sequence is target length '?' marks  you also have a stamp of lowercase letters  on each turn  you may place the stamp over the sequence  and replace every letter in the sequence with the corresponding letter from the stamp  you can make up to 10   target length turns  for hard string greedy 
python 1-liner reorder log files you have an array of logs  each log is a space delimited string of words  for each log  the first word in each log is an alphanumeric identifier  then  either: each word after the identifier will consist only of lowercase letters  or; each word after the identifier will consist only of digits  we will call these two varieties of logs letter-logs and digit-logs  it is guaranteed that each log has at least one word after its identifier  reorder the logs so that all of the letter-logs come before any digit-log  the letter-logs are ordered lexicographically ignoring identifier  with the identifier used in case of ties  the digit-logs should be put in their original order  return the final order of the logs  easy string 
c++ stable_sort easy to understand reorder log files you have an array of logs  each log is a space delimited string of words  for each log  the first word in each log is an alphanumeric identifier  then  either: each word after the identifier will consist only of lowercase letters  or; each word after the identifier will consist only of digits  we will call these two varieties of logs letter-logs and digit-logs  it is guaranteed that each log has at least one word after its identifier  reorder the logs so that all of the letter-logs come before any digit-log  the letter-logs are ordered lexicographically ignoring identifier  with the identifier used in case of ties  the digit-logs should be put in their original order  return the final order of the logs  easy string 
java - nothing fancy  15 lines  5ms  all clear  reorder log files you have an array of logs  each log is a space delimited string of words  for each log  the first word in each log is an alphanumeric identifier  then  either: each word after the identifier will consist only of lowercase letters  or; each word after the identifier will consist only of digits  we will call these two varieties of logs letter-logs and digit-logs  it is guaranteed that each log has at least one word after its identifier  reorder the logs so that all of the letter-logs come before any digit-log  the letter-logs are ordered lexicographically ignoring identifier  with the identifier used in case of ties  the digit-logs should be put in their original order  return the final order of the logs  easy string 
few lines c++ version  8ms reorder log files you have an array of logs  each log is a space delimited string of words  for each log  the first word in each log is an alphanumeric identifier  then  either: each word after the identifier will consist only of lowercase letters  or; each word after the identifier will consist only of digits  we will call these two varieties of logs letter-logs and digit-logs  it is guaranteed that each log has at least one word after its identifier  reorder the logs so that all of the letter-logs come before any digit-log  the letter-logs are ordered lexicographically ignoring identifier  with the identifier used in case of ties  the digit-logs should be put in their original order  return the final order of the logs  easy string 
c++ stable_sort and lambdas reorder log files you have an array of logs  each log is a space delimited string of words  for each log  the first word in each log is an alphanumeric identifier  then  either: each word after the identifier will consist only of lowercase letters  or; each word after the identifier will consist only of digits  we will call these two varieties of logs letter-logs and digit-logs  it is guaranteed that each log has at least one word after its identifier  reorder the logs so that all of the letter-logs come before any digit-log  the letter-logs are ordered lexicographically ignoring identifier  with the identifier used in case of ties  the digit-logs should be put in their original order  return the final order of the logs  easy string 
[java] 3 recursive methods with comment  range sum of bst given the root node of a binary search tree  return the sum of values of all nodes with value between l and r (inclusive)  the binary search tree is guaranteed to have unique values  medium binary search tree 
python 1-liner range sum of bst given the root node of a binary search tree  return the sum of values of all nodes with value between l and r (inclusive)  the binary search tree is guaranteed to have unique values  medium binary search tree 
jave easy to understand 2ms solution (tree pruning) range sum of bst given the root node of a binary search tree  return the sum of values of all nodes with value between l and r (inclusive)  the binary search tree is guaranteed to have unique values  medium binary search tree 
medium??? i don't think so range sum of bst given the root node of a binary search tree  return the sum of values of all nodes with value between l and r (inclusive)  the binary search tree is guaranteed to have unique values  medium binary search tree 
python3 | easy to understand | inorder traversal range sum of bst given the root node of a binary search tree  return the sum of values of all nodes with value between l and r (inclusive)  the binary search tree is guaranteed to have unique values  medium binary search tree 
java n^2 hashmap minimum area rectangle given a set of points in the xy-plane  determine the minimum area of a rectangle formed from these points  with sides parallel to the x and y axes  if there isn't any rectangle  return 0  medium hash table 
python o(n^1 5)  80ms minimum area rectangle given a set of points in the xy-plane  determine the minimum area of a rectangle formed from these points  with sides parallel to the x and y axes  if there isn't any rectangle  return 0  medium hash table 
c++ hash-map + set intersection 56 ms minimum area rectangle given a set of points in the xy-plane  determine the minimum area of a rectangle formed from these points  with sides parallel to the x and y axes  if there isn't any rectangle  return 0  medium hash table 
simple af java solution  with explanation o(n2) minimum area rectangle given a set of points in the xy-plane  determine the minimum area of a rectangle formed from these points  with sides parallel to the x and y axes  if there isn't any rectangle  return 0  medium hash table 
python straightforward & concise minimum area rectangle given a set of points in the xy-plane  determine the minimum area of a rectangle formed from these points  with sides parallel to the x and y axes  if there isn't any rectangle  return 0  medium hash table 
[c++ java python] 4 lines o(n) time  o(1) space distinct subsequences ii given a string s  count the number of distinct  non-empty subsequences of s   since the result may be large  return the answer modulo 10^9 + 7  hard dynamic programming 
java dp o(n^2) time -> o(n) time -> o(1) space distinct subsequences ii given a string s  count the number of distinct  non-empty subsequences of s   since the result may be large  return the answer modulo 10^9 + 7  hard dynamic programming 
c++ o(n) | o (n) geeks4geeks improved to o(n) | o(1) distinct subsequences ii given a string s  count the number of distinct  non-empty subsequences of s   since the result may be large  return the answer modulo 10^9 + 7  hard dynamic programming 
leetcode weekly contest 110 screencast (rank 26) distinct subsequences ii given a string s  count the number of distinct  non-empty subsequences of s   since the result may be large  return the answer modulo 10^9 + 7  hard dynamic programming 
python solution with chinese explanation showing my thinking process distinct subsequences ii given a string s  count the number of distinct  non-empty subsequences of s   since the result may be large  return the answer modulo 10^9 + 7  hard dynamic programming 
[c++ java python] climb mountain valid mountain array given an array a of integers  return true if and only if it is a valid mountain array  recall that a is a mountain array if and only if: a length >= 3 there exists some i with 0 < i < a length - 1 such that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
c++ track peak valid mountain array given an array a of integers  return true if and only if it is a valid mountain array  recall that a is a mountain array if and only if: a length >= 3 there exists some i with 0 < i < a length - 1 such that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
python 2-liner valid mountain array given an array a of integers  return true if and only if it is a valid mountain array  recall that a is a mountain array if and only if: a length >= 3 there exists some i with 0 < i < a length - 1 such that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
concise c++ valid mountain array given an array a of integers  return true if and only if it is a valid mountain array  recall that a is a mountain array if and only if: a length >= 3 there exists some i with 0 < i < a length - 1 such that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
the 'stupid' but fast(3ms) method :) valid mountain array given an array a of integers  return true if and only if it is a valid mountain array  recall that a is a mountain array if and only if: a length >= 3 there exists some i with 0 < i < a length - 1 such that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
[c++ java python] straight forward di string match given a string s that only contains "i" (increase) or "d" (decrease)  let n = s length  return any permutation a of [0  1       n] such that for all i = 0       n-1: if s[i] == "i"  then a[i] < a[i+1] if s[i] == "d"  then a[i] > a[i+1] easy math 
c++ 5 lines high-low pointers di string match given a string s that only contains "i" (increase) or "d" (decrease)  let n = s length  return any permutation a of [0  1       n] such that for all i = 0       n-1: if s[i] == "i"  then a[i] < a[i+1] if s[i] == "d"  then a[i] > a[i+1] easy math 
python 5-liner easy to understand di string match given a string s that only contains "i" (increase) or "d" (decrease)  let n = s length  return any permutation a of [0  1       n] such that for all i = 0       n-1: if s[i] == "i"  then a[i] < a[i+1] if s[i] == "d"  then a[i] > a[i+1] easy math 
probably the easiest java solution di string match given a string s that only contains "i" (increase) or "d" (decrease)  let n = s length  return any permutation a of [0  1       n] such that for all i = 0       n-1: if s[i] == "i"  then a[i] < a[i+1] if s[i] == "d"  then a[i] > a[i+1] easy math 
c++ implement  simple and straightforward  beats 99% di string match given a string s that only contains "i" (increase) or "d" (decrease)  let n = s length  return any permutation a of [0  1       n] such that for all i = 0       n-1: if s[i] == "i"  then a[i] < a[i+1] if s[i] == "d"  then a[i] > a[i+1] easy math 
travelling salesman problem find the shortest superstring given an array a of strings  find any smallest string that contains each string in a as a substring  we may assume that no string in a is substring of another string in a  hard dynamic programming 
leetcode weekly contest 111 screencast (rank 12) find the shortest superstring given an array a of strings  find any smallest string that contains each string in a as a substring  we may assume that no string in a is substring of another string in a  hard dynamic programming 
greedy solution is wrong  if your greedy solution gets ac it only means you are lucky enough  find the shortest superstring given an array a of strings  find any smallest string that contains each string in a as a substring  we may assume that no string in a is substring of another string in a  hard dynamic programming 
is this an interview level problem or not? find the shortest superstring given an array a of strings  find any smallest string that contains each string in a as a substring  we may assume that no string in a is substring of another string in a  hard dynamic programming 
python ac concise solution ~132 ms find the shortest superstring given an array a of strings  find any smallest string that contains each string in a as a substring  we may assume that no string in a is substring of another string in a  hard dynamic programming 
really bad example in the description delete columns to make sorted we are given an array a of n lowercase letter strings  all of the same length  now  we may choose any set of deletion indices  and for each string  we delete all the characters in those indices  the remaining rows of strings form columns when read north to south  for easy greedy 
why this problem is medium? delete columns to make sorted we are given an array a of n lowercase letter strings  all of the same length  now  we may choose any set of deletion indices  and for each string  we delete all the characters in those indices  the remaining rows of strings form columns when read north to south  for easy greedy 
c++ brute force o(n   m) delete columns to make sorted we are given an array a of n lowercase letter strings  all of the same length  now  we may choose any set of deletion indices  and for each string  we delete all the characters in those indices  the remaining rows of strings form columns when read north to south  for easy greedy 
python  count unsorted columns delete columns to make sorted we are given an array a of n lowercase letter strings  all of the same length  now  we may choose any set of deletion indices  and for each string  we delete all the characters in those indices  the remaining rows of strings form columns when read north to south  for easy greedy 
python easy 1-liner o(n   m) delete columns to make sorted we are given an array a of n lowercase letter strings  all of the same length  now  we may choose any set of deletion indices  and for each string  we delete all the characters in those indices  the remaining rows of strings form columns when read north to south  for easy greedy 
