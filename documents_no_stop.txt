is this algorithm optimal or what? add two numbers given two non-empty linked lists representing two non-negative integers  digits stored reverse order nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  medium linked list math 
[c++] sharing my 11-line c++ solution  can someone make it even more concise? add two numbers given two non-empty linked lists representing two non-negative integers  digits stored reverse order nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  medium linked list math 
clear python code  straight forward add two numbers given two non-empty linked lists representing two non-negative integers  digits stored reverse order nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  medium linked list math 
my accepted java solution add two numbers given two non-empty linked lists representing two non-negative integers  digits stored reverse order nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  medium linked list math 
python concise solution  add two numbers given two non-empty linked lists representing two non-negative integers  digits stored reverse order nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  medium linked list math 
11-line simple java solution  o(n) with explanation longest substring without repeating characters given string  find length longest substring without repeating characters  medium hash table two pointers string 
c++ code in 9 lines  longest substring without repeating characters given string  find length longest substring without repeating characters  medium hash table two pointers string 
share my java solution using hashset longest substring without repeating characters given string  find length longest substring without repeating characters  medium hash table two pointers string 
a python solution - 85ms - o(n) longest substring without repeating characters given string  find length longest substring without repeating characters  medium hash table two pointers string 
shortest o(n) dp solution with explanations longest substring without repeating characters given string  find length longest substring without repeating characters  medium hash table two pointers string 
share my o(log(min(m n)) solution with explanation median of two sorted arrays two sorted arrays nums1 nums2 size n respectively  find median two sorted arrays  overall run time complexity o(log (m+n))  may assume nums1 nums2 cannot empty  hard array binary search divide and conquer 
very concise o(log(min(m n))) iterative solution with detailed explanation median of two sorted arrays two sorted arrays nums1 nums2 size n respectively  find median two sorted arrays  overall run time complexity o(log (m+n))  may assume nums1 nums2 cannot empty  hard array binary search divide and conquer 
share my simple o(log(m+n)) solution for your reference median of two sorted arrays two sorted arrays nums1 nums2 size n respectively  find median two sorted arrays  overall run time complexity o(log (m+n))  may assume nums1 nums2 cannot empty  hard array binary search divide and conquer 
concise java solution based on binary search median of two sorted arrays two sorted arrays nums1 nums2 size n respectively  find median two sorted arrays  overall run time complexity o(log (m+n))  may assume nums1 nums2 cannot empty  hard array binary search divide and conquer 
share my iterative solution with o(log(min(n  m))) median of two sorted arrays two sorted arrays nums1 nums2 size n respectively  find median two sorted arrays  overall run time complexity o(log (m+n))  may assume nums1 nums2 cannot empty  hard array binary search divide and conquer 
very simple clean java solution longest palindromic substring given string s  find longest palindromic substring s  may assume maximum length 1000  medium string dynamic programming 
simple c++ solution (8ms  13 lines) longest palindromic substring given string s  find longest palindromic substring s  may assume maximum length 1000  medium string dynamic programming 
share my java solution using dynamic programming longest palindromic substring given string s  find longest palindromic substring s  may assume maximum length 1000  medium string dynamic programming 
(ac) relatively short and very clear java solution longest palindromic substring given string s  find longest palindromic substring s  may assume maximum length 1000  medium string dynamic programming 
python easy to understand solution with comments (from middle to two ends)  longest palindromic substring given string s  find longest palindromic substring s  may assume maximum length 1000  medium string dynamic programming 
easy to understand java solution zigzag conversion string "paypalishiring" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility) p h n p l g r read line line: "pahnaplsiigyir" write code take string make conversion given number rows: string convert(string s  int numrows); medium string 
if you are confused with zigzag pattern come and see! zigzag conversion string "paypalishiring" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility) p h n p l g r read line line: "pahnaplsiigyir" write code take string make conversion given number rows: string convert(string s  int numrows); medium string 
python o(n) solution in 96ms (99 43%) zigzag conversion string "paypalishiring" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility) p h n p l g r read line line: "pahnaplsiigyir" write code take string make conversion given number rows: string convert(string s  int numrows); medium string 
share simple c++ solution zigzag conversion string "paypalishiring" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility) p h n p l g r read line line: "pahnaplsiigyir" write code take string make conversion given number rows: string convert(string s  int numrows); medium string 
java solution--easy and clear ( interesting approach ) zigzag conversion string "paypalishiring" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility) p h n p l g r read line line: "pahnaplsiigyir" write code take string make conversion given number rows: string convert(string s  int numrows); medium string 
my accepted 15 lines of code for java reverse integer given 32-bit signed integer  reverse digits integer  easy math 
very short (7 lines) and elegant solution reverse integer given 32-bit signed integer  reverse digits integer  easy math 
golfing in python reverse integer given 32-bit signed integer  reverse digits integer  easy math 
shortest code possible in c++ reverse integer given 32-bit signed integer  reverse digits integer  easy math 
8 ms simple c++ solution which checks overflow reverse integer given 32-bit signed integer  reverse digits integer  easy math 
such a shitty problem string to integer (atoi) implement atoi converts string integer  function first discards many whitespace characters necessary first non-whitespace character found  then  starting character  takes optional initial plus minus sign followed many numerical digits possible  interprets numerical value  string contain additional characters form integral number  ignored effect behavior function  first sequence non-whitespace characters str valid integral number  sequence exists either str empty contains whitespace characters  conversion performed  valid conversion could performed  zero value returned  note: space character ' ' considered whitespace character  assume dealing environment could store integers within 32-bit signed integer range: [−231  231 − 1]  numerical value range representable values  int_max (231 − 1) int_min (−231) returned  medium math string 
my simple solution string to integer (atoi) implement atoi converts string integer  function first discards many whitespace characters necessary first non-whitespace character found  then  starting character  takes optional initial plus minus sign followed many numerical digits possible  interprets numerical value  string contain additional characters form integral number  ignored effect behavior function  first sequence non-whitespace characters str valid integral number  sequence exists either str empty contains whitespace characters  conversion performed  valid conversion could performed  zero value returned  note: space character ' ' considered whitespace character  assume dealing environment could store integers within 32-bit signed integer range: [−231  231 − 1]  numerical value range representable values  int_max (231 − 1) int_min (−231) returned  medium math string 
java solution with 4 steps explanations string to integer (atoi) implement atoi converts string integer  function first discards many whitespace characters necessary first non-whitespace character found  then  starting character  takes optional initial plus minus sign followed many numerical digits possible  interprets numerical value  string contain additional characters form integral number  ignored effect behavior function  first sequence non-whitespace characters str valid integral number  sequence exists either str empty contains whitespace characters  conversion performed  valid conversion could performed  zero value returned  note: space character ' ' considered whitespace character  assume dealing environment could store integers within 32-bit signed integer range: [−231  231 − 1]  numerical value range representable values  int_max (231 − 1) int_min (−231) returned  medium math string 
java-------easy  version to understand!!!!!!!!!! string to integer (atoi) implement atoi converts string integer  function first discards many whitespace characters necessary first non-whitespace character found  then  starting character  takes optional initial plus minus sign followed many numerical digits possible  interprets numerical value  string contain additional characters form integral number  ignored effect behavior function  first sequence non-whitespace characters str valid integral number  sequence exists either str empty contains whitespace characters  conversion performed  valid conversion could performed  zero value returned  note: space character ' ' considered whitespace character  assume dealing environment could store integers within 32-bit signed integer range: [−231  231 − 1]  numerical value range representable values  int_max (231 − 1) int_min (−231) returned  medium math string 
8ms c++ solution  easy to understand string to integer (atoi) implement atoi converts string integer  function first discards many whitespace characters necessary first non-whitespace character found  then  starting character  takes optional initial plus minus sign followed many numerical digits possible  interprets numerical value  string contain additional characters form integral number  ignored effect behavior function  first sequence non-whitespace characters str valid integral number  sequence exists either str empty contains whitespace characters  conversion performed  valid conversion could performed  zero value returned  note: space character ' ' considered whitespace character  assume dealing environment could store integers within 32-bit signed integer range: [−231  231 − 1]  numerical value range representable values  int_max (231 − 1) int_min (−231) returned  medium math string 
easy dp java solution with detailed explanation regular expression matching given input string (s) pattern (p)  implement regular expression matching support ' ' ' '  ' ' matches single character  ' ' matches zero preceding element  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like      hard string dynamic programming backtracking 
my concise recursive and dp solutions with full explanation in c++ regular expression matching given input string (s) pattern (p)  implement regular expression matching support ' ' ' '  ' ' matches single character  ' ' matches zero preceding element  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like      hard string dynamic programming backtracking 
in the given examples  the last one ismatch("aab"  "c a b")  u2192 true; don't understand why it is true? regular expression matching given input string (s) pattern (p)  implement regular expression matching support ' ' ' '  ' ' matches single character  ' ' matches zero preceding element  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like      hard string dynamic programming backtracking 
9-lines 16ms c++ dp solutions with explanations regular expression matching given input string (s) pattern (p)  implement regular expression matching support ' ' ' '  ' ' matches single character  ' ' matches zero preceding element  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like      hard string dynamic programming backtracking 
my dp approach in python with comments and unittest regular expression matching given input string (s) pattern (p)  implement regular expression matching support ' ' ' '  ' ' matches single character  ' ' matches zero preceding element  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like      hard string dynamic programming backtracking 
yet another way to see what happens in the o(n) algorithm container with most water given n non-negative integers a1  a2         represents point coordinate (i  ai)  n vertical lines drawn two endpoints line (i  ai) (i  0)  find two lines  together x-axis forms container  container contains water  note: may slant container n least 2  vertical lines represented array [1 8 6 2 5 4 8 3 7]  case  max area water (blue section) container contain 49  medium array two pointers 
simple and fast c++ c with explanation container with most water given n non-negative integers a1  a2         represents point coordinate (i  ai)  n vertical lines drawn two endpoints line (i  ai) (i  0)  find two lines  together x-axis forms container  container contains water  note: may slant container n least 2  vertical lines represented array [1 8 6 2 5 4 8 3 7]  case  max area water (blue section) container contain 49  medium array two pointers 
simple and clear proof explanation container with most water given n non-negative integers a1  a2         represents point coordinate (i  ai)  n vertical lines drawn two endpoints line (i  ai) (i  0)  find two lines  together x-axis forms container  container contains water  note: may slant container n least 2  vertical lines represented array [1 8 6 2 5 4 8 3 7]  case  max area water (blue section) container contain 49  medium array two pointers 
easy concise java o(n) solution with proof and explanation container with most water given n non-negative integers a1  a2         represents point coordinate (i  ai)  n vertical lines drawn two endpoints line (i  ai) (i  0)  find two lines  together x-axis forms container  container contains water  note: may slant container n least 2  vertical lines represented array [1 8 6 2 5 4 8 3 7]  case  max area water (blue section) container contain 49  medium array two pointers 
very simple o(n) solution container with most water given n non-negative integers a1  a2         represents point coordinate (i  ai)  n vertical lines drawn two endpoints line (i  ai) (i  0)  find two lines  together x-axis forms container  container contains water  note: may slant container n least 2  vertical lines represented array [1 8 6 2 5 4 8 3 7]  case  max area water (blue section) container contain 49  medium array two pointers 
simple solution integer to roman roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 medium math string 
my java solution easy to understand integer to roman roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 medium math string 
two lines can do the job integer to roman roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 medium math string 
share my python solution 96ms integer to roman roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 medium math string 
simple java solution integer to roman roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 medium math string 
my solution for this question but i don't know is there any easier way? roman to integer roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 easy math string 
clean o(n) c++ solution roman to integer roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 easy math string 
my straightforward python solution roman to integer roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 easy math string 
i strongly suggest leetcode explains the conversion rule clearer  roman to integer roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 easy math string 
7ms solution in java  easy to understand roman to integer roman numerals represented seven different symbols: i  v  x  l  c  m  symbol value 1 v 5 x 10 l 50 c 100 500 1000 easy math string 
java code with 13 lines longest common prefix write function find longest common prefix string amongst array strings  common prefix  return empty string ""  easy string 
what does longest common prefix mean ? longest common prefix write function find longest common prefix string amongst array strings  common prefix  return empty string ""  easy string 
sorted the array  java solution  2 ms longest common prefix write function find longest common prefix string amongst array strings  common prefix  return empty string ""  easy string 
simple python solution longest common prefix write function find longest common prefix string amongst array strings  common prefix  return empty string ""  easy string 
short python solution longest common prefix write function find longest common prefix string amongst array strings  common prefix  return empty string ""  easy string 
concise o(n^2) java solution 3sum given array nums n integers  elements a  b  c nums + b + c = 0? find unique triplets array gives sum zero  note: solution set must contain duplicate triplets  medium array two pointers 
share my ac c++ solution  around 50ms  o(n n)  with explanation and comments 3sum given array nums n integers  elements a  b  c nums + b + c = 0? find unique triplets array gives sum zero  note: solution set must contain duplicate triplets  medium array two pointers 
python easy to understand solution (o(n n) time)  3sum given array nums n integers  elements a  b  c nums + b + c = 0? find unique triplets array gives sum zero  note: solution set must contain duplicate triplets  medium array two pointers 
easiest java solution 3sum given array nums n integers  elements a  b  c nums + b + c = 0? find unique triplets array gives sum zero  note: solution set must contain duplicate triplets  medium array two pointers 
share my simple java solution 3sum given array nums n integers  elements a  b  c nums + b + c = 0? find unique triplets array gives sum zero  note: solution set must contain duplicate triplets  medium array two pointers 
java solution with o(n2) for reference 3sum closest given array nums n integers integer target  find three integers nums sum closest target  return sum three integers  may assume input would exactly one solution  medium array two pointers 
a n^2 solution  can we do better ? 3sum closest given array nums n integers integer target  find three integers nums sum closest target  return sum three integers  may assume input would exactly one solution  medium array two pointers 
c++ solution o(n^2) using sort 3sum closest given array nums n integers integer target  find three integers nums sum closest target  return sum three integers  may assume input would exactly one solution  medium array two pointers 
python o(n^2) solution 3sum closest given array nums n integers integer target  find three integers nums sum closest target  return sum three integers  may assume input would exactly one solution  medium array two pointers 
12 lines concise and easy understand c++ solultion 3sum closest given array nums n integers integer target  find three integers nums sum closest target  return sum three integers  may assume input would exactly one solution  medium array two pointers 
7ms java code win over 100% 4sum given array nums n integers integer target  elements a  b  c  nums + b + c + = target? find unique quadruplets array gives sum target  note: solution set must contain duplicate quadruplets  medium array hash table two pointers 
python 140ms beats 100%  and works for n-sum (n>=2) 4sum given array nums n integers integer target  elements a  b  c  nums + b + c + = target? find unique quadruplets array gives sum target  note: solution set must contain duplicate quadruplets  medium array hash table two pointers 
my 16ms c++ code 4sum given array nums n integers integer target  elements a  b  c  nums + b + c + = target? find unique quadruplets array gives sum target  note: solution set must contain duplicate quadruplets  medium array hash table two pointers 
clean accepted java o(n^3) solution based on 3sum 4sum given array nums n integers integer target  elements a  b  c  nums + b + c + = target? find unique quadruplets array gives sum target  note: solution set must contain duplicate quadruplets  medium array hash table two pointers 
my solution generalized for ksums in java 4sum given array nums n integers integer target  elements a  b  c  nums + b + c + = target? find unique quadruplets array gives sum target  note: solution set must contain duplicate quadruplets  medium array hash table two pointers 
simple java solution in one pass remove nth node from end of list given linked list  remove n-th node end list return head  medium linked list two pointers 
my short c++ solution remove nth node from end of list given linked list  remove n-th node end list return head  medium linked list two pointers 
3 short python solutions remove nth node from end of list given linked list  remove n-th node end list return head  medium linked list two pointers 
my one pass solution remove nth node from end of list given linked list  remove n-th node end list return head  medium linked list two pointers 
c++ solution  easy to understand with explanations  remove nth node from end of list given linked list  remove n-th node end list return head  medium linked list two pointers 
short java solution valid parentheses given string containing characters '('  ')'  '{'  '}'  '[' ']'  determine input string valid  input string valid if: open brackets must closed type brackets  open brackets must closed correct order  note empty string also considered valid  easy string stack 
simple python solution with stack valid parentheses given string containing characters '('  ')'  '{'  '}'  '[' ']'  determine input string valid  input string valid if: open brackets must closed type brackets  open brackets must closed correct order  note empty string also considered valid  easy string stack 
my easy to understand java solution with one stack valid parentheses given string containing characters '('  ')'  '{'  '}'  '[' ']'  determine input string valid  input string valid if: open brackets must closed type brackets  open brackets must closed correct order  note empty string also considered valid  easy string stack 
[python] is this a cheating method? accepted with 40ms  easy to understand  but valid parentheses given string containing characters '('  ')'  '{'  '}'  '[' ']'  determine input string valid  input string valid if: open brackets must closed type brackets  open brackets must closed correct order  note empty string also considered valid  easy string stack 
2ms c++ sloution valid parentheses given string containing characters '('  ')'  '{'  '}'  '[' ']'  determine input string valid  input string valid if: open brackets must closed type brackets  open brackets must closed correct order  note empty string also considered valid  easy string stack 
easy to understand java backtracking solution generate parentheses given n pairs parentheses  write function generate combinations well-formed parentheses  medium string backtracking 
concise recursive c++ solution generate parentheses given n pairs parentheses  write function generate combinations well-formed parentheses  medium string backtracking 
an iterative method  generate parentheses given n pairs parentheses  write function generate combinations well-formed parentheses  medium string backtracking 
4-7 lines python generate parentheses given n pairs parentheses  write function generate combinations well-formed parentheses  medium string backtracking 
simple python dfs solution with explanation generate parentheses given n pairs parentheses  write function generate combinations well-formed parentheses  medium string backtracking 
a java solution based on priority queue merge k sorted lists merge k sorted linked lists return one sorted list  analyze describe complexity  hard linked list divide and conquer heap 
my simple java solution use recursion merge k sorted lists merge k sorted linked lists return one sorted list  analyze describe complexity  hard linked list divide and conquer heap 
sharing my straightforward c++ solution without data structure other than vector merge k sorted lists merge k sorted linked lists return one sorted list  analyze describe complexity  hard linked list divide and conquer heap 
difference between priority-queue and heap  and c++ implementation merge k sorted lists merge k sorted linked lists return one sorted list  analyze describe complexity  hard linked list divide and conquer heap 
10-line python solution with priority queue merge k sorted lists merge k sorted linked lists return one sorted list  analyze describe complexity  hard linked list divide and conquer heap 
my accepted java code  used recursion  swap nodes in pairs given linked list  swap every two adjacent nodes return head  medium linked list 
my simple java solution for share swap nodes in pairs given linked list  swap every two adjacent nodes return head  medium linked list 
7-8 lines c++   python   ruby swap nodes in pairs given linked list  swap every two adjacent nodes return head  medium linked list 
java simple recursive solution swap nodes in pairs given linked list  swap every two adjacent nodes return head  medium linked list 
simple implementation with c++ swap nodes in pairs given linked list  swap every two adjacent nodes return head  medium linked list 
short but recursive java code with comments reverse nodes in k-group given linked list  reverse nodes linked list k time return modified list  k positive integer less equal length linked list  number nodes multiple k left-out nodes end remain is  hard linked list 
share my java solution with comments in line reverse nodes in k-group given linked list  reverse nodes linked list k time return modified list  k positive integer less equal length linked list  number nodes multiple k left-out nodes end remain is  hard linked list 
non-recursive java solution and idea reverse nodes in k-group given linked list  reverse nodes linked list k time return modified list  k positive integer less equal length linked list  number nodes multiple k left-out nodes end remain is  hard linked list 
20-line iterative c++ solution reverse nodes in k-group given linked list  reverse nodes linked list k time return modified list  k positive integer less equal length linked list  number nodes multiple k left-out nodes end remain is  hard linked list 
succinct iterative python  o(n) time o(1) space reverse nodes in k-group given linked list  reverse nodes linked list k time return modified list  k positive integer less equal length linked list  number nodes multiple k left-out nodes end remain is  hard linked list 
my solution : time o(n)  space o(1) remove duplicates from sorted array given sorted array nums  remove duplicates in-place element appear return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  easy array two pointers 
share my clean c++ code remove duplicates from sorted array given sorted array nums  remove duplicates in-place element appear return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  easy array two pointers 
5 lines c++ java  nicer loops remove duplicates from sorted array given sorted array nums  remove duplicates in-place element appear return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  easy array two pointers 
simple python solution - o(n) remove duplicates from sorted array given sorted array nums  remove duplicates in-place element appear return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  easy array two pointers 
5 lines java solution remove duplicates from sorted array given sorted array nums  remove duplicates in-place element appear return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  easy array two pointers 
elegant java solution implement strstr() implement strstr()  return index first occurrence needle haystack  -1 needle part haystack  easy two pointers string 
share my accepted java solution implement strstr() implement strstr()  return index first occurrence needle haystack  -1 needle part haystack  easy two pointers string 
c++ brute-force and kmp implement strstr() implement strstr()  return index first occurrence needle haystack  -1 needle part haystack  easy two pointers string 
my answer by python implement strstr() implement strstr()  return index first occurrence needle haystack  -1 needle part haystack  easy two pointers string 
a very clean solution  brute-force implement strstr() implement strstr()  return index first occurrence needle haystack  -1 needle part haystack  easy two pointers string 
detailed explained 8ms c++ solution divide two integers given two integers dividend divisor  divide two integers without using multiplication  division mod operator  return quotient dividing dividend divisor  integer division truncate toward zero  medium math binary search 
clean java solution with some comment  divide two integers given two integers dividend divisor  divide two integers without using multiplication  division mod operator  return quotient dividing dividend divisor  integer division truncate toward zero  medium math binary search 
clear python code divide two integers given two integers dividend divisor  divide two integers without using multiplication  division mod operator  return quotient dividing dividend divisor  integer division truncate toward zero  medium math binary search 
simple o((log n) ^ 2) c++ solution divide two integers given two integers dividend divisor  divide two integers without using multiplication  division mod operator  return quotient dividing dividend divisor  integer division truncate toward zero  medium math binary search 
no use of long java solution divide two integers given two integers dividend divisor  divide two integers without using multiplication  division mod operator  return quotient dividing dividend divisor  integer division truncate toward zero  medium math binary search 
easy two-map solution (c++ java) substring with concatenation of all words given string  s  list words  words  length  find starting indices substring(s) concatenation word words exactly without intervening characters  hard hash table two pointers string 
an o(n) solution with detailed explanation substring with concatenation of all words given string  s  list words  words  length  find starting indices substring(s) concatenation word words exactly without intervening characters  hard hash table two pointers string 
accepted java solution 12ms with explanation substring with concatenation of all words given string  s  list words  words  length  find starting indices substring(s) concatenation word words exactly without intervening characters  hard hash table two pointers string 
simple java solution with two pointers and map substring with concatenation of all words given string  s  list words  words  length  find starting indices substring(s) concatenation word words exactly without intervening characters  hard hash table two pointers string 
why does the second example have words with different length? substring with concatenation of all words given string  s  list words  words  length  find starting indices substring(s) concatenation word words exactly without intervening characters  hard hash table two pointers string 
share my o(n) time solution next permutation implement next permutation  rearranges numbers lexicographically next greater permutation numbers  arrangement possible  must rearrange lowest possible order (ie  sorted ascending order)  replacement must in-place use constant extra memory  medium array 
c++ from wikipedia next permutation implement next permutation  rearranges numbers lexicographically next greater permutation numbers  arrangement possible  must rearrange lowest possible order (ie  sorted ascending order)  replacement must in-place use constant extra memory  medium array 
sharing my clean and easy-understand java code with explanation next permutation implement next permutation  rearranges numbers lexicographically next greater permutation numbers  arrangement possible  must rearrange lowest possible order (ie  sorted ascending order)  replacement must in-place use constant extra memory  medium array 
easiest java solution next permutation implement next permutation  rearranges numbers lexicographically next greater permutation numbers  arrangement possible  must rearrange lowest possible order (ie  sorted ascending order)  replacement must in-place use constant extra memory  medium array 
1  4  11 lines c++ next permutation implement next permutation  rearranges numbers lexicographically next greater permutation numbers  arrangement possible  must rearrange lowest possible order (ie  sorted ascending order)  replacement must in-place use constant extra memory  medium array 
my o(n) solution using a stack longest valid parentheses given string containing characters '(' ')'  find length longest valid (well-formed) parentheses substring  hard string dynamic programming 
my dp  o(n) solution without using stack longest valid parentheses given string containing characters '(' ')'  find length longest valid (well-formed) parentheses substring  hard string dynamic programming 
simple java solution  o(n) time  one stack longest valid parentheses given string containing characters '(' ')'  find length longest valid (well-formed) parentheses substring  hard string dynamic programming 
my simple 8ms c++ code longest valid parentheses given string containing characters '(' ')'  find length longest valid (well-formed) parentheses substring  hard string dynamic programming 
my solution using one stack in one pass longest valid parentheses given string containing characters '(' ')'  find length longest valid (well-formed) parentheses substring  hard string dynamic programming 
concise o(log n) binary search solution search in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  given target value search  found array return index  otherwise return -1  may assume duplicate exists array  algorithm's runtime complexity must order o(log n)  medium array binary search 
clever idea making it simple search in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  given target value search  found array return index  otherwise return -1  may assume duplicate exists array  algorithm's runtime complexity must order o(log n)  medium array binary search 
revised binary search search in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  given target value search  found array return index  otherwise return -1  may assume duplicate exists array  algorithm's runtime complexity must order o(log n)  medium array binary search 
java ac solution using once binary search search in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  given target value search  found array return index  otherwise return -1  may assume duplicate exists array  algorithm's runtime complexity must order o(log n)  medium array binary search 
python binary search solution - o(logn) - 48ms search in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  given target value search  found array return index  otherwise return -1  may assume duplicate exists array  algorithm's runtime complexity must order o(log n)  medium array binary search 
clean iterative solution with two binary searches (with explanation) find first and last position of element in sorted array given array integers nums sorted ascending order  find starting ending position given target value  algorithm's runtime complexity must order o(log n)  target found array  return [-1  -1]  medium array binary search 
a very simple java solution  with only one binary search algorithm find first and last position of element in sorted array given array integers nums sorted ascending order  find starting ending position given target value  algorithm's runtime complexity must order o(log n)  target found array  return [-1  -1]  medium array binary search 
9-11 lines o(log n) find first and last position of element in sorted array given array integers nums sorted ascending order  find starting ending position given target value  algorithm's runtime complexity must order o(log n)  target found array  return [-1  -1]  medium array binary search 
easy java o(logn) solution find first and last position of element in sorted array given array integers nums sorted ascending order  find starting ending position given target value  algorithm's runtime complexity must order o(log n)  target found array  return [-1  -1]  medium array binary search 
simple and strict o(logn) solution in java using recursion find first and last position of element in sorted array given array integers nums sorted ascending order  find starting ending position given target value  algorithm's runtime complexity must order o(log n)  target found array  return [-1  -1]  medium array binary search 
short+simple java using strings valid sudoku determine 9x9 sudoku board valid  filled cells need validated according following rules: row must contain digits 1-9 without repetition  column must contain digits 1-9 without repetition  9 3x3 sub-boxes grid must contain digits 1-9 without repetition  partially filled sudoku valid  sudoku board could partially filled  empty cells filled character ' '  medium hash table 
shared my concise java code valid sudoku determine 9x9 sudoku board valid  filled cells need validated according following rules: row must contain digits 1-9 without repetition  column must contain digits 1-9 without repetition  9 3x3 sub-boxes grid must contain digits 1-9 without repetition  partially filled sudoku valid  sudoku board could partially filled  empty cells filled character ' '  medium hash table 
my short solution by c++  o(n2) valid sudoku determine 9x9 sudoku board valid  filled cells need validated according following rules: row must contain digits 1-9 without repetition  column must contain digits 1-9 without repetition  9 3x3 sub-boxes grid must contain digits 1-9 without repetition  partially filled sudoku valid  sudoku board could partially filled  empty cells filled character ' '  medium hash table 
sharing my easy-understand java solution using set valid sudoku determine 9x9 sudoku board valid  filled cells need validated according following rules: row must contain digits 1-9 without repetition  column must contain digits 1-9 without repetition  9 3x3 sub-boxes grid must contain digits 1-9 without repetition  partially filled sudoku valid  sudoku board could partially filled  empty cells filled character ' '  medium hash table 
a readable python solution valid sudoku determine 9x9 sudoku board valid  filled cells need validated according following rules: row must contain digits 1-9 without repetition  column must contain digits 1-9 without repetition  9 3x3 sub-boxes grid must contain digits 1-9 without repetition  partially filled sudoku valid  sudoku board could partially filled  empty cells filled character ' '  medium hash table 
please change the misleading description count and say count-and-say sequence sequence integers first five terms following: 1  1 2  11 3  21 4  1211 5  111221 1 read "one 1" 11  11 read "two 1s" 21  21 read "one 2  one 1" 1211  given integer n 1 ≤ n ≤ 30  generate nth term count-and-say sequence  note: term sequence integers represented string  easy string 
examples of nth sequence count and say count-and-say sequence sequence integers first five terms following: 1  1 2  11 3  21 4  1211 5  111221 1 read "one 1" 11  11 read "two 1s" 21  21 read "one 2  one 1" 1211  given integer n 1 ≤ n ≤ 30  generate nth term count-and-say sequence  note: term sequence integers represented string  easy string 
show an answer in java count and say count-and-say sequence sequence integers first five terms following: 1  1 2  11 3  21 4  1211 5  111221 1 read "one 1" 11  11 read "two 1s" 21  21 read "one 2  one 1" 1211  given integer n 1 ≤ n ≤ 30  generate nth term count-and-say sequence  note: term sequence integers represented string  easy string 
4-5 lines python solutions count and say count-and-say sequence sequence integers first five terms following: 1  1 2  11 3  21 4  1211 5  111221 1 read "one 1" 11  11 read "two 1s" 21  21 read "one 2  one 1" 1211  given integer n 1 ≤ n ≤ 30  generate nth term count-and-say sequence  note: term sequence integers represented string  easy string 
c++ solution easy-understand count and say count-and-say sequence sequence integers first five terms following: 1  1 2  11 3  21 4  1211 5  111221 1 read "one 1" 11  11 read "two 1s" 21  21 read "one 2  one 1" 1211  given integer n 1 ≤ n ≤ 30  generate nth term count-and-say sequence  note: term sequence integers represented string  easy string 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partitioning) combination sum given set candidate numbers (candidates) (without duplicates) target number (target)  find unique combinations candidates candidate numbers sums target  repeated number may chosen candidates unlimited number times  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
accepted 16ms c++ solution use backtracking  easy understand  combination sum given set candidate numbers (candidates) (without duplicates) target number (target)  find unique combinations candidates candidate numbers sums target  repeated number may chosen candidates unlimited number times  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
python dfs solution  combination sum given set candidate numbers (candidates) (without duplicates) target number (target)  find unique combinations candidates candidate numbers sums target  repeated number may chosen candidates unlimited number times  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
java solution using recursive combination sum given set candidate numbers (candidates) (without duplicates) target number (target)  find unique combinations candidates candidate numbers sums target  repeated number may chosen candidates unlimited number times  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
iterative java dp solution combination sum given set candidate numbers (candidates) (without duplicates) target number (target)  find unique combinations candidates candidate numbers sums target  repeated number may chosen candidates unlimited number times  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
java solution using dfs  easy understand combination sum ii given collection candidate numbers (candidates) target number (target)  find unique combinations candidates candidate numbers sums target  number candidates may used combination  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
combination sum i  ii and iii java solution (see the similarities yourself) combination sum ii given collection candidate numbers (candidates) target number (target)  find unique combinations candidates candidate numbers sums target  number candidates may used combination  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
c++ backtracking solution with detailed explanation combination sum ii given collection candidate numbers (candidates) target number (target)  find unique combinations candidates candidate numbers sums target  number candidates may used combination  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
beating 98%  python solution using recursion with comments combination sum ii given collection candidate numbers (candidates) target number (target)  find unique combinations candidates candidate numbers sums target  number candidates may used combination  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
dp solution in python combination sum ii given collection candidate numbers (candidates) target number (target)  find unique combinations candidates candidate numbers sums target  number candidates may used combination  note: numbers (including target) positive integers  solution set must contain duplicate combinations  medium array backtracking 
my short c++ solution  o(1) space  and o(n) time first missing positive given unsorted integer array  find smallest missing positive integer  hard array 
share my o(n) time  o(1) space solution first missing positive given unsorted integer array  find smallest missing positive integer  hard array 
o(1) space java solution first missing positive given unsorted integer array  find smallest missing positive integer  hard array 
python o(1) space   o(n) time solution with explanation first missing positive given unsorted integer array  find smallest missing positive integer  hard array 
a very nice solution (from ants aasma @stackoverflow) first missing positive given unsorted integer array  find smallest missing positive integer  hard array 
sharing my simple c++ code: o(n) time  o(1) space trapping rain water given n non-negative integers representing elevation map width bar 1  compute much water able trap raining  elevation map represented array [0 1 0 2 1 0 1 3 2 1 2 1]  case  6 units rain water (blue section) trapped  thanks marcos contributing image! hard array two pointers stack 
share my short solution  trapping rain water given n non-negative integers representing elevation map width bar 1  compute much water able trap raining  elevation map represented array [0 1 0 2 1 0 1 3 2 1 2 1]  case  6 units rain water (blue section) trapped  thanks marcos contributing image! hard array two pointers stack 
7 lines c   c++ trapping rain water given n non-negative integers representing elevation map width bar 1  compute much water able trap raining  elevation map represented array [0 1 0 2 1 0 1 3 2 1 2 1]  case  6 units rain water (blue section) trapped  thanks marcos contributing image! hard array two pointers stack 
a stack based solution for reference  inspired by histogram trapping rain water given n non-negative integers representing elevation map width bar 1  compute much water able trap raining  elevation map represented array [0 1 0 2 1 0 1 3 2 1 2 1]  case  6 units rain water (blue section) trapped  thanks marcos contributing image! hard array two pointers stack 
sharing my java code: o(n) time  o(1) space trapping rain water given n non-negative integers representing elevation map width bar 1  compute much water able trap raining  elevation map represented array [0 1 0 2 1 0 1 3 2 1 2 1]  case  6 units rain water (blue section) trapped  thanks marcos contributing image! hard array two pointers stack 
easiest java solution with graph explanation multiply strings given two non-negative integers num1 num2 represented strings  return product num1 num2  also represented string  medium math string 
brief c++ solution using only strings and without reversal multiply strings given two non-negative integers num1 num2 represented strings  return product num1 num2  also represented string  medium math string 
ac solution in java with explanation multiply strings given two non-negative integers num1 num2 represented strings  return product num1 num2  also represented string  medium math string 
one easy solution with c++ multiply strings given two non-negative integers num1 num2 represented strings  return product num1 num2  also represented string  medium math string 
clear java solution without reversal multiply strings given two non-negative integers num1 num2 represented strings  return product num1 num2  also represented string  medium math string 
linear runtime and constant space solution wildcard matching given input string (s) pattern (p)  implement wildcard pattern matching support '?' ' '  '?' matches single character  ' ' matches sequence characters (including empty sequence)  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like ?    hard string dynamic programming backtracking greedy 
my java dp solution using 2d table wildcard matching given input string (s) pattern (p)  implement wildcard pattern matching support '?' ' '  '?' matches single character  ' ' matches sequence characters (including empty sequence)  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like ?    hard string dynamic programming backtracking greedy 
accepted c++ dp solution with a trick wildcard matching given input string (s) pattern (p)  implement wildcard pattern matching support '?' ' '  '?' matches single character  ' ' matches sequence characters (including empty sequence)  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like ?    hard string dynamic programming backtracking greedy 
python dp solution wildcard matching given input string (s) pattern (p)  implement wildcard pattern matching support '?' ' '  '?' matches single character  ' ' matches sequence characters (including empty sequence)  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like ?    hard string dynamic programming backtracking greedy 
my three c++ solutions (iterative (16ms) & dp (180ms) & modified recursion (88ms)) wildcard matching given input string (s) pattern (p)  implement wildcard pattern matching support '?' ' '  '?' matches single character  ' ' matches sequence characters (including empty sequence)  matching cover entire input string (not partial)  note: could empty contains lowercase letters a-z  p could empty contains lowercase letters a-z  characters like ?    hard string dynamic programming backtracking greedy 
o(n)  bfs solution jump game ii given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  goal reach last index minimum number jumps  hard array greedy 
concise o(n) one loop java solution based on greedy jump game ii given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  goal reach last index minimum number jumps  hard array greedy 
single loop simple java solution jump game ii given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  goal reach last index minimum number jumps  hard array greedy 
10-lines c++ (16ms)   python bfs solutions with explanations jump game ii given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  goal reach last index minimum number jumps  hard array greedy 
sharing my ac java solution jump game ii given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  goal reach last index minimum number jumps  hard array greedy 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partioning) permutations given collection distinct integers  return possible permutations  medium backtracking 
my elegant recursive c++ solution with inline explanation permutations given collection distinct integers  return possible permutations  medium backtracking 
my ac simple iterative java python solution permutations given collection distinct integers  return possible permutations  medium backtracking 
one-liners in python permutations given collection distinct integers  return possible permutations  medium backtracking 
simple python solution (dfs)  permutations given collection distinct integers  return possible permutations  medium backtracking 
really easy java solution  much easier than the solutions with very high vote permutations ii given collection numbers might contain duplicates  return possible unique permutations  medium backtracking 
a simple c++ solution in only 20 lines permutations ii given collection numbers might contain duplicates  return possible unique permutations  medium backtracking 
share my java code with detailed explanantion permutations ii given collection numbers might contain duplicates  return possible unique permutations  medium backtracking 
9-line python solution with 1 line to handle duplication  beat 99% of others :-) permutations ii given collection numbers might contain duplicates  return possible unique permutations  medium backtracking 
a non-recursive c++ implementation with o(1) space cost permutations ii given collection numbers might contain duplicates  return possible unique permutations  medium backtracking 
a common method to rotate the image rotate image given n x n 2d matrix representing image  rotate image 90 degrees (clockwise)  note: rotate image in-place  means modify input 2d matrix directly  allocate another 2d matrix rotation  medium array 
ac java in place solution with explanation easy to understand  rotate image given n x n 2d matrix representing image  rotate image 90 degrees (clockwise)  note: rotate image in-place  means modify input 2d matrix directly  allocate another 2d matrix rotation  medium array 
seven short solutions (1 to 7 lines) rotate image given n x n 2d matrix representing image  rotate image 90 degrees (clockwise)  note: rotate image in-place  means modify input 2d matrix directly  allocate another 2d matrix rotation  medium array 
4ms few lines c++ code rotate image 90 degree for o(1) space rotate image given n x n 2d matrix representing image  rotate image 90 degrees (clockwise)  note: rotate image in-place  means modify input 2d matrix directly  allocate another 2d matrix rotation  medium array 
clear java solution rotate image given n x n 2d matrix representing image  rotate image 90 degrees (clockwise)  note: rotate image in-place  means modify input 2d matrix directly  allocate another 2d matrix rotation  medium array 
share my short java solution group anagrams given array strings  group anagrams together  medium hash table string 
java beat 100%!!! use prime number group anagrams given array strings  group anagrams together  medium hash table string 
10-lines 76ms easy c++ solution (updated function signature) group anagrams given array strings  group anagrams together  medium hash table string 
what does it mean "return all groups"? but the return result is vector<string>? how can we return all groups? group anagrams given array strings  group anagrams together  medium hash table string 
o(m   n) algorithm using hash  without sort() group anagrams given array strings  group anagrams together  medium hash table string 
short and easy to understand solution pow(x  n) implement pow(x  n)  calculates x raised power n (xn)  medium math binary search 
5 different choices when talk with interviewers pow(x  n) implement pow(x  n)  calculates x raised power n (xn)  medium math binary search 
iterative log(n) solution with clear explanation pow(x  n) implement pow(x  n)  calculates x raised power n (xn)  medium math binary search 
shortest python - guaranteed pow(x  n) implement pow(x  n)  calculates x raised power n (xn)  medium math binary search 
o (logn) solution in java pow(x  n) implement pow(x  n)  calculates x raised power n (xn)  medium math binary search 
accepted 4ms c++ solution use backtracking and bitmask  easy understand  n-queens n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return distinct solutions n-queens puzzle  solution contains distinct board configuration n-queens' placement  'q' ' ' indicate queen empty space respectively  hard backtracking 
my easy understanding java solution n-queens n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return distinct solutions n-queens puzzle  solution contains distinct board configuration n-queens' placement  'q' ' ' indicate queen empty space respectively  hard backtracking 
fast  short  and easy-to-understand python solution  11 lines  76ms n-queens n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return distinct solutions n-queens puzzle  solution contains distinct board configuration n-queens' placement  'q' ' ' indicate queen empty space respectively  hard backtracking 
the description should give a clear explanation of the problem of "n-queens" n-queens n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return distinct solutions n-queens puzzle  solution contains distinct board configuration n-queens' placement  'q' ' ' indicate queen empty space respectively  hard backtracking 
comparably concise java code n-queens n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return distinct solutions n-queens puzzle  solution contains distinct board configuration n-queens' placement  'q' ' ' indicate queen empty space respectively  hard backtracking 
accepted java solution n-queens ii n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return number distinct solutions n-queens puzzle  hard backtracking 
easiest java solution (1ms  98 22%) n-queens ii n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return number distinct solutions n-queens puzzle  hard backtracking 
share my java code (beats 97 83% run times) n-queens ii n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return number distinct solutions n-queens puzzle  hard backtracking 
c++ solution - dfs - easy understanding n-queens ii n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return number distinct solutions n-queens puzzle  hard backtracking 
python recursive dfs solution  n-queens ii n-queens puzzle problem placing n queens n×n chessboard two queens attack other  given integer n  return number distinct solutions n-queens puzzle  hard backtracking 
dp solution & some thoughts maximum subarray given integer array nums  find contiguous subarray (containing least one number) largest sum return sum  easy array divide and conquer dynamic programming 
accepted o(n) solution in java maximum subarray given integer array nums  find contiguous subarray (containing least one number) largest sum return sum  easy array divide and conquer dynamic programming 
a python solution maximum subarray given integer array nums  find contiguous subarray (containing least one number) largest sum return sum  easy array divide and conquer dynamic programming 
easy python way maximum subarray given integer array nums  find contiguous subarray (containing least one number) largest sum return sum  easy array divide and conquer dynamic programming 
simplest and fastest o(n) c++ solution maximum subarray given integer array nums  find contiguous subarray (containing least one number) largest sum return sum  easy array divide and conquer dynamic programming 
super simple and easy to understand solution spiral matrix given matrix x n elements (m rows  n columns)  return elements matrix spiral order  medium array 
1-liner in python + ruby spiral matrix given matrix x n elements (m rows  n columns)  return elements matrix spiral order  medium array 
a concise c++ implementation based on directions spiral matrix given matrix x n elements (m rows  n columns)  return elements matrix spiral order  medium array 
0ms clear c++ solution spiral matrix given matrix x n elements (m rows  n columns)  return elements matrix spiral order  medium array 
clean java  readable  human friendly code spiral matrix given matrix x n elements (m rows  n columns)  return elements matrix spiral order  medium array 
linear and simple solution in c++ jump game given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  determine able reach last index  medium array greedy 
simplest o(n) solution with constant space jump game given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  determine able reach last index  medium array greedy 
java solution easy to understand jump game given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  determine able reach last index  medium array greedy 
6 line java solution in o(n) jump game given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  determine able reach last index  medium array greedy 
1-6 lines  o(n) time  o(1) space jump game given array non-negative integers  initially positioned first index array  element array represents maximum jump length position  determine able reach last index  medium array greedy 
a simple java solution merge intervals given collection intervals  merge overlapping intervals  medium array sort 
7 lines  easy  python merge intervals given collection intervals  merge overlapping intervals  medium array sort 
c++ 10 line solution  easing understanding merge intervals given collection intervals  merge overlapping intervals  medium array sort 
beat 98% java  sort start & end respectively  merge intervals given collection intervals  merge overlapping intervals  medium array sort 
a clean java solution merge intervals given collection intervals  merge overlapping intervals  medium array sort 
short and straight-forward java solution insert interval given set non-overlapping intervals  insert new interval intervals (merge necessary)  may assume intervals initially sorted according start times  hard array sort 
7+ lines  3 easy solutions insert interval given set non-overlapping intervals  insert new interval intervals (merge necessary)  may assume intervals initially sorted according start times  hard array sort 
short java code insert interval given set non-overlapping intervals  insert new interval intervals (merge necessary)  may assume intervals initially sorted according start times  hard array sort 
elegant c++ stl solution  using "equal_range" to find overlapped intervals  insert interval given set non-overlapping intervals  insert new interval intervals (merge necessary)  may assume intervals initially sorted according start times  hard array sort 
easy and clean o(n) c++ solution insert interval given set non-overlapping intervals  insert new interval intervals (merge necessary)  may assume intervals initially sorted according start times  hard array sort 
7-lines 4ms c++ solution length of last word given string consists upper lower-case alphabets empty space characters ' '  return length last word string  last word exist  return 0  note: word defined character sequence consists non-space characters only  easy string 
my simple solution in c++ length of last word given string consists upper lower-case alphabets empty space characters ' '  return length last word string  last word exist  return 0  note: word defined character sequence consists non-space characters only  easy string 
a single line of code in java length of last word given string consists upper lower-case alphabets empty space characters ' '  return length last word string  last word exist  return 0  note: word defined character sequence consists non-space characters only  easy string 
this problem is not fun at all  length of last word given string consists upper lower-case alphabets empty space characters ' '  return length last word string  last word exist  return 0  note: word defined character sequence consists non-space characters only  easy string 
one line python solution length of last word given string consists upper lower-case alphabets empty space characters ' '  return length last word string  last word exist  return 0  note: word defined character sequence consists non-space characters only  easy string 
4-9 lines python solutions spiral matrix ii given positive integer n  generate square matrix filled elements 1 n2 spiral order  medium array 
my super simple solution  can be used for both spiral matrix i and ii spiral matrix ii given positive integer n  generate square matrix filled elements 1 n2 spiral order  medium array 
simple c++ solution(with explaination) spiral matrix ii given positive integer n  generate square matrix filled elements 1 n2 spiral order  medium array 
share my java solution spiral matrix ii given positive integer n  generate square matrix filled elements 1 n2 spiral order  medium array 
my ac solution with using direction variable spiral matrix ii given positive integer n  generate square matrix filled elements 1 n2 spiral order  medium array 
"explain-like-i'm-five" java solution in o(n) permutation sequence set [1 2 3     n] contains total n! unique permutations  listing labeling permutations order  get following sequence n = 3: "123" "132" "213" "231" "312" "321" given n k  return kth permutation sequence  note: given n 1 9 inclusive  given k 1 n! inclusive  medium math backtracking 
an iterative solution for reference permutation sequence set [1 2 3     n] contains total n! unique permutations  listing labeling permutations order  get following sequence n = 3: "123" "132" "213" "231" "312" "321" given n k  return kth permutation sequence  note: given n 1 9 inclusive  given k 1 n! inclusive  medium math backtracking 
most concise c++ solution  minimal memory required permutation sequence set [1 2 3     n] contains total n! unique permutations  listing labeling permutations order  get following sequence n = 3: "123" "132" "213" "231" "312" "321" given n k  return kth permutation sequence  note: given n 1 9 inclusive  given k 1 n! inclusive  medium math backtracking 
share my python solution with detailed explanation permutation sequence set [1 2 3     n] contains total n! unique permutations  listing labeling permutations order  get following sequence n = 3: "123" "132" "213" "231" "312" "321" given n k  return kth permutation sequence  note: given n 1 9 inclusive  given k 1 n! inclusive  medium math backtracking 
sharing my straightforward c++ solution with explanation permutation sequence set [1 2 3     n] contains total n! unique permutations  listing labeling permutations order  get following sequence n = 3: "123" "132" "213" "231" "312" "321" given n k  return kth permutation sequence  note: given n 1 9 inclusive  given k 1 n! inclusive  medium math backtracking 
my clean c++ code  quite standard (find tail and reconnect the list) rotate list given linked list  rotate list right k places  k non-negative  medium linked list two pointers 
share my java solution with explanation rotate list given linked list  rotate list right k places  k non-negative  medium linked list two pointers 
anyone solve the problem without counting the length of list? rotate list given linked list  rotate list right k places  k non-negative  medium linked list two pointers 
clean java solution with brief explanation rotate list given linked list  rotate list right k places  k non-negative  medium linked list two pointers 
i think the description of this problem is misleading  rotate list given linked list  rotate list right k places  k non-negative  medium linked list two pointers 
0ms  5-lines dp solution in c++ with explanations unique paths robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  many possible unique paths there? 7 x 3 grid  many possible unique paths there? note: n 100  medium array dynamic programming 
my ac solution using formula unique paths robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  many possible unique paths there? 7 x 3 grid  many possible unique paths there? note: n 100  medium array dynamic programming 
math solution  o(1) space unique paths robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  many possible unique paths there? 7 x 3 grid  many possible unique paths there? note: n 100  medium array dynamic programming 
java dp solution with complexity o(n m) unique paths robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  many possible unique paths there? 7 x 3 grid  many possible unique paths there? note: n 100  medium array dynamic programming 
accpeted simple python dp solution  unique paths robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  many possible unique paths there? 7 x 3 grid  many possible unique paths there? note: n 100  medium array dynamic programming 
short java solution unique paths ii robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  consider obstacles added grids  many unique paths would be? obstacle empty space marked 1 0 respectively grid  note: n 100  medium array dynamic programming 
my c++ dp solution   very simple! unique paths ii robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  consider obstacles added grids  many unique paths would be? obstacle empty space marked 1 0 respectively grid  note: n 100  medium array dynamic programming 
4ms o(n) dp solution in c++ with explanations unique paths ii robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  consider obstacles added grids  many unique paths would be? obstacle empty space marked 1 0 respectively grid  note: n 100  medium array dynamic programming 
java solution using dynamic programming  o(1) space unique paths ii robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  consider obstacles added grids  many unique paths would be? obstacle empty space marked 1 0 respectively grid  note: n 100  medium array dynamic programming 
easy java solution  in-place  dp unique paths ii robot located top-left corner x n grid (marked 'start' diagram below)  robot move either right point time  robot trying reach bottom-right corner grid (marked 'finish' diagram below)  consider obstacles added grids  many unique paths would be? obstacle empty space marked 1 0 respectively grid  note: n 100  medium array dynamic programming 
10-lines 28ms o(n)-space dp solution in c++ with explanations minimum path sum given x n grid filled non-negative numbers  find path top left bottom right minimizes sum numbers along path  note: move either right point time  medium array dynamic programming 
my java solution using dp and no extra space minimum path sum given x n grid filled non-negative numbers  find path top left bottom right minimizes sum numbers along path  note: move either right point time  medium array dynamic programming 
simple python dp 70ms minimum path sum given x n grid filled non-negative numbers  find path top left bottom right minimizes sum numbers along path  note: move either right point time  medium array dynamic programming 
dp solution  linear space minimum path sum given x n grid filled non-negative numbers  find path top left bottom right minimizes sum numbers along path  note: move either right point time  medium array dynamic programming 
my 8 lines simple solution minimum path sum given x n grid filled non-negative numbers  find path top left bottom right minimizes sum numbers along path  note: move either right point time  medium array dynamic programming 
the worst problem i have ever met in this oj valid number validate given string interpreted decimal number  hard math string 
clear java solution with ifs valid number validate given string interpreted decimal number  hard math string 
a simple solution in python based on dfa valid number validate given string interpreted decimal number  hard math string 
a simple solution in cpp valid number validate given string interpreted decimal number  hard math string 
a clean design solution by using design pattern valid number validate given string interpreted decimal number  hard math string 
my simple java solution plus one given non-empty array digits representing non-negative integer  plus one integer  digits stored significant digit head list  element array contain single digit  may assume integer contain leading zero  except number 0 itself  easy array math 
is it a simple code(c++)? plus one given non-empty array digits representing non-negative integer  plus one integer  digits stored significant digit head list  element array contain single digit  may assume integer contain leading zero  except number 0 itself  easy array math 
i cannot fully understand the meaning of question 'plus one' plus one given non-empty array digits representing non-negative integer  plus one integer  digits stored significant digit head list  element array contain single digit  may assume integer contain leading zero  except number 0 itself  easy array math 
simple java solution plus one given non-empty array digits representing non-negative integer  plus one integer  digits stored significant digit head list  element array contain single digit  may assume integer contain leading zero  except number 0 itself  easy array math 
simple python solution with explanation (plus one) plus one given non-empty array digits representing non-negative integer  plus one integer  digits stored significant digit head list  element array contain single digit  may assume integer contain leading zero  except number 0 itself  easy array math 
short code by c++ add binary given two binary strings  return sum (also binary string)  input strings non-empty contains characters 1 0  easy math string 
short ac solution in java with explanation add binary given two binary strings  return sum (also binary string)  input strings non-empty contains characters 1 0  easy math string 
simple accepted java solution add binary given two binary strings  return sum (also binary string)  input strings non-empty contains characters 1 0  easy math string 
an accepted concise python recursive solution 10 lines add binary given two binary strings  return sum (also binary string)  input strings non-empty contains characters 1 0  easy math string 
very concise c++ solution without calculating longest string add binary given two binary strings  return sum (also binary string)  input strings non-empty contains characters 1 0  easy math string 
share my concise c++ solution - less than 20 lines text justification given array words width maxwidth  format text line exactly maxwidth characters fully (left right) justified  pack words greedy approach; is  pack many words line  pad extra spaces ' ' necessary line exactly maxwidth characters  extra spaces words distributed evenly possible  number spaces line divide evenly words  empty slots left assigned spaces slots right  last line text  left justified extra space inserted words  note: word defined character sequence consisting non-space characters only  word's length guaranteed greater 0 exceed maxwidth  input array words contains least one word  hard string 
concise python solution  10 lines  text justification given array words width maxwidth  format text line exactly maxwidth characters fully (left right) justified  pack words greedy approach; is  pack many words line  pad extra spaces ' ' necessary line exactly maxwidth characters  extra spaces words distributed evenly possible  number spaces line divide evenly words  empty slots left assigned spaces slots right  last line text  left justified extra space inserted words  note: word defined character sequence consisting non-space characters only  word's length guaranteed greater 0 exceed maxwidth  input array words contains least one word  hard string 
simple java solution text justification given array words width maxwidth  format text line exactly maxwidth characters fully (left right) justified  pack words greedy approach; is  pack many words line  pad extra spaces ' ' necessary line exactly maxwidth characters  extra spaces words distributed evenly possible  number spaces line divide evenly words  empty slots left assigned spaces slots right  last line text  left justified extra space inserted words  note: word defined character sequence consisting non-space characters only  word's length guaranteed greater 0 exceed maxwidth  input array words contains least one word  hard string 
what does this question aim to teach? text justification given array words width maxwidth  format text line exactly maxwidth characters fully (left right) justified  pack words greedy approach; is  pack many words line  pad extra spaces ' ' necessary line exactly maxwidth characters  extra spaces words distributed evenly possible  number spaces line divide evenly words  empty slots left assigned spaces slots right  last line text  left justified extra space inserted words  note: word defined character sequence consisting non-space characters only  word's length guaranteed greater 0 exceed maxwidth  input array words contains least one word  hard string 
easy understanding solution text justification given array words width maxwidth  format text line exactly maxwidth characters fully (left right) justified  pack words greedy approach; is  pack many words line  pad extra spaces ' ' necessary line exactly maxwidth characters  extra spaces words distributed evenly possible  number spaces line divide evenly words  empty slots left assigned spaces slots right  last line text  left justified extra space inserted words  note: word defined character sequence consisting non-space characters only  word's length guaranteed greater 0 exceed maxwidth  input array words contains least one word  hard string 
c++ 10-lines solution simplify path given absolute path file (unix-style)  simplify it  medium string stack 
java 10-lines solution with stack simplify path given absolute path file (unix-style)  simplify it  medium string stack 
can someone please explain what does simplify means in this context? simplify path given absolute path file (unix-style)  simplify it  medium string stack 
9 lines of python code simplify path given absolute path file (unix-style)  simplify it  medium string stack 
my o(n) ac code   just need to handle two special cases  simplify path given absolute path file (unix-style)  simplify it  medium string stack 
20ms detailed explained c++ solutions (o(n) space) edit distance given two words word1 word2  find minimum number operations required convert word1 word2  following 3 operations permitted word: insert character delete character replace character hard string dynamic programming 
java dp solution - o(nm) edit distance given two words word1 word2  find minimum number operations required convert word1 word2  following 3 operations permitted word: insert character delete character replace character hard string dynamic programming 
my o(mn) time and o(n) space solution using dp with explanation edit distance given two words word1 word2  find minimum number operations required convert word1 word2  following 3 operations permitted word: insert character delete character replace character hard string dynamic programming 
good pdf on edit distance problem  may be helpful  edit distance given two words word1 word2  find minimum number operations required convert word1 word2  following 3 operations permitted word: insert character delete character replace character hard string dynamic programming 
python solutions and intuition edit distance given two words word1 word2  find minimum number operations required convert word1 word2  following 3 operations permitted word: insert character delete character replace character hard string dynamic programming 
any shorter o(1) space solution? set matrix zeroes given x n matrix  element 0  set entire row column 0  in-place  medium array 
my ac java o(1) solution (easy to read) set matrix zeroes given x n matrix  element 0  set entire row column 0  in-place  medium array 
my c++ o(1) yoooooo set matrix zeroes given x n matrix  element 0  set entire row column 0  in-place  medium array 
my java o(1) solution (easy to understand) set matrix zeroes given x n matrix  element 0  set entire row column 0  in-place  medium array 
21 lines concise and easy understand c++ solution  o(1) space  three steps set matrix zeroes given x n matrix  element 0  set entire row column 0  in-place  medium array 
don't treat it as a 2d matrix  just treat it as a sorted list search a 2d matrix write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted left right  first integer row greater last integer previous row  medium array binary search 
binary search on an ordered matrix search a 2d matrix write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted left right  first integer row greater last integer previous row  medium array binary search 
java clear solution search a 2d matrix write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted left right  first integer row greater last integer previous row  medium array binary search 
a python binary search solution - o(logn) search a 2d matrix write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted left right  first integer row greater last integer previous row  medium array binary search 
c++ 12ms  o(log(mn))  no library functions  treat matrix as an array search a 2d matrix write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted left right  first integer row greater last integer previous row  medium array binary search 
share my at most two-pass constant space 10-line solution sort colors given array n objects colored red  white blue  sort in-place objects color adjacent  colors order red  white blue  here  use integers 0  1  2 represent color red  white  blue respectively  note: suppose use library's sort function problem  medium array two pointers sort 
four different solutions sort colors given array n objects colored red  white blue  sort in-place objects color adjacent  colors order red  white blue  here  use integers 0  1  2 represent color red  white  blue respectively  note: suppose use library's sort function problem  medium array two pointers sort 
ac python in place one pass solution o(n) time o(1) space  no swap no count sort colors given array n objects colored red  white blue  sort in-place objects color adjacent  colors order red  white blue  here  use integers 0  1  2 represent color red  white  blue respectively  note: suppose use library's sort function problem  medium array two pointers sort 
sharing c++ solution with good explanation sort colors given array n objects colored red  white blue  sort in-place objects color adjacent  colors order red  white blue  here  use integers 0  1  2 represent color red  white  blue respectively  note: suppose use library's sort function problem  medium array two pointers sort 
java solution  both 2-pass and 1-pass sort colors given array n objects colored red  white blue  sort in-place objects color adjacent  colors order red  white blue  here  use integers 0  1  2 represent color red  white  blue respectively  note: suppose use library's sort function problem  medium array two pointers sort 
here is a 10-line template that can solve most 'substring' problems minimum window substring given string string t  find minimum window contain characters complexity o(n)  hard hash table two pointers string 
12 lines python minimum window substring given string string t  find minimum window contain characters complexity o(n)  hard hash table two pointers string 
accepted o(n) solution minimum window substring given string string t  find minimum window contain characters complexity o(n)  hard hash table two pointers string 
java solution  using two pointers + hashmap minimum window substring given string string t  find minimum window contain characters complexity o(n)  hard hash table two pointers string 
can t have characters repeating ? minimum window substring given string string t  find minimum window contain characters complexity o(n)  hard hash table two pointers string 
short iterative c++ answer 8ms combinations given two integers n k  return possible combinations k numbers 1     n  medium backtracking 
backtracking solution java combinations given two integers n k  return possible combinations k numbers 1     n  medium backtracking 
a short recursive java solution based on c(n k)=c(n-1 k-1)+c(n-1 k) combinations given two integers n k  return possible combinations k numbers 1     n  medium backtracking 
1-liner  3-liner  4-liner combinations given two integers n k  return possible combinations k numbers 1     n  medium backtracking 
my shortest c++ solution using dfs combinations given two integers n k  return possible combinations k numbers 1     n  medium backtracking 
a general approach to backtracking questions in java (subsets  permutations  combination sum  palindrome partitioning) subsets given set distinct integers  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking bit manipulation 
my solution using bit manipulation subsets given set distinct integers  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking bit manipulation 
c++ recursive iterative bit-manipulation subsets given set distinct integers  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking bit manipulation 
python easy to understand solutions (dfs recursively  bit manipulation  iteratively)  subsets given set distinct integers  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking bit manipulation 
3ms  easiest solution  no backtracking  no bit manipulation  no dfs  no bullshit subsets given set distinct integers  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking bit manipulation 
accepted very short java solution  no additional space  word search given 2d board word  find word exists grid  word constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used once  medium array backtracking 
my java solution word search given 2d board word  find word exists grid  word constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used once  medium array backtracking 
python dfs solution with comments  word search given 2d board word  find word exists grid  word constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used once  medium array backtracking 
my 19ms accepted c++ code word search given 2d board word  find word exists grid  word constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used once  medium array backtracking 
simple solution word search given 2d board word  find word exists grid  word constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used once  medium array backtracking 
3-6 easy lines  c++  java  python  ruby remove duplicates from sorted array ii given sorted array nums  remove duplicates in-place duplicates appeared twice return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  medium array two pointers 
share my o(n) time and o(1) solution when duplicates are allowed at most k times remove duplicates from sorted array ii given sorted array nums  remove duplicates in-place duplicates appeared twice return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  medium array two pointers 
short and simple java solution (easy to understand) remove duplicates from sorted array ii given sorted array nums  remove duplicates in-place duplicates appeared twice return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  medium array two pointers 
my c++ solution  16ms  5 lines remove duplicates from sorted array ii given sorted array nums  remove duplicates in-place duplicates appeared twice return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  medium array two pointers 
o(n) time and o(1) java solution when allowed at most k times of duplicates remove duplicates from sorted array ii given sorted array nums  remove duplicates in-place duplicates appeared twice return new length  allocate extra space another array  must modifying input array in-place o(1) extra memory  medium array two pointers 
my 8ms c++ solution (o(logn) on average  o(n) worst case) search in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  given target value search  found array return true  otherwise return false  medium array binary search 
c++ concise log(n) solution search in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  given target value search  found array return true  otherwise return false  medium array binary search 
neat java solution using binary search search in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  given target value search  found array return true  otherwise return false  medium array binary search 
python easy to understand solution (with comments)  search in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  given target value search  found array return true  otherwise return false  medium array binary search 
when there are duplicates  the worst case is o(n)  could we do better? search in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 0 1 2 2 5 6] might become [2 5 6 0 0 1 2])  given target value search  found array return true  otherwise return false  medium array binary search 
my accepted java code remove duplicates from sorted list ii given sorted linked list  delete nodes duplicate numbers  leaving distinct numbers original list  medium linked list 
my recursive java solution remove duplicates from sorted list ii given sorted linked list  delete nodes duplicate numbers  leaving distinct numbers original list  medium linked list 
java simple and clean code with comment remove duplicates from sorted list ii given sorted linked list  delete nodes duplicate numbers  leaving distinct numbers original list  medium linked list 
simple and clear c++ recursive solution remove duplicates from sorted list ii given sorted linked list  delete nodes duplicate numbers  leaving distinct numbers original list  medium linked list 
python in-place solution with dummy head node  remove duplicates from sorted list ii given sorted linked list  delete nodes duplicate numbers  leaving distinct numbers original list  medium linked list 
3 line java recursive solution remove duplicates from sorted list given sorted linked list  delete duplicates element appear once  easy linked list 
my pretty solution  java  remove duplicates from sorted list given sorted linked list  delete duplicates element appear once  easy linked list 
concise solution and memory freeing remove duplicates from sorted list given sorted linked list  delete duplicates element appear once  easy linked list 
simple iterative python 6 lines  60 ms remove duplicates from sorted list given sorted linked list  delete duplicates element appear once  easy linked list 
clean java solution remove duplicates from sorted list given sorted linked list  delete duplicates element appear once  easy linked list 
my concise c++ solution  ac 90 ms largest rectangle in histogram given n non-negative integers representing histogram's bar height width bar 1  find area largest rectangle histogram  histogram width bar 1  given height = [2 1 5 6 2 3]  largest rectangle shown shaded area  area = 10 unit  hard array stack 
o(n) stack based java solution largest rectangle in histogram given n non-negative integers representing histogram's bar height width bar 1  find area largest rectangle histogram  histogram width bar 1  given height = [2 1 5 6 2 3]  largest rectangle shown shaded area  area = 10 unit  hard array stack 
5ms o(n) java solution explained (beats 96%) largest rectangle in histogram given n non-negative integers representing histogram's bar height width bar 1  find area largest rectangle histogram  histogram width bar 1  given height = [2 1 5 6 2 3]  largest rectangle shown shaded area  area = 10 unit  hard array stack 
ac python clean solution using stack 76ms largest rectangle in histogram given n non-negative integers representing histogram's bar height width bar 1  find area largest rectangle histogram  histogram width bar 1  given height = [2 1 5 6 2 3]  largest rectangle shown shaded area  area = 10 unit  hard array stack 
simple divide and conquer ac solution without segment tree largest rectangle in histogram given n non-negative integers representing histogram's bar height width bar 1  find area largest rectangle histogram  histogram width bar 1  given height = [2 1 5 6 2 3]  largest rectangle shown shaded area  area = 10 unit  hard array stack 
share my dp solution maximal rectangle given 2d binary matrix filled 0's 1's  find largest rectangle containing 1's return area  hard array hash table dynamic programming stack 
a o(n^2) solution based on largest rectangle in histogram maximal rectangle given 2d binary matrix filled 0's 1's  find largest rectangle containing 1's return area  hard array hash table dynamic programming stack 
my java solution based on maximum rectangle in histogram with explanation maximal rectangle given 2d binary matrix filled 0's 1's  find largest rectangle containing 1's return area  hard array hash table dynamic programming stack 
ac python dp solutioin 120ms based on largest rectangle in histogram maximal rectangle given 2d binary matrix filled 0's 1's  find largest rectangle containing 1's return area  hard array hash table dynamic programming stack 
sharing my straightforward c++ solution with o(n^2) time with explanation maximal rectangle given 2d binary matrix filled 0's 1's  find largest rectangle containing 1's return area  hard array hash table dynamic programming stack 
very concise one pass solution partition list given linked list value x  partition nodes less x come nodes greater equal x  preserve original relative order nodes two partitions  medium linked list two pointers 
concise java code with explanation  one pass partition list given linked list value x  partition nodes less x come nodes greater equal x  preserve original relative order nodes two partitions  medium linked list two pointers 
python concise solution with dummy nodes  partition list given linked list value x  partition nodes less x come nodes greater equal x  preserve original relative order nodes two partitions  medium linked list two pointers 
10 lines concise c++ solution partition list given linked list value x  partition nodes less x come nodes greater equal x  preserve original relative order nodes two partitions  medium linked list two pointers 
my accepted solution  any improvement? partition list given linked list value x  partition nodes less x come nodes greater equal x  preserve original relative order nodes two partitions  medium linked list two pointers 
share my 4ms c++ recursive solution scramble string given string s1  may represent binary tree partitioning two non-empty substrings recursively  one possible representation s1 = "great": great     gr eat         g r e     scramble string  may choose non-leaf node swap two children  hard string dynamic programming 
accepted java solution scramble string given string s1  may represent binary tree partitioning two non-empty substrings recursively  one possible representation s1 = "great": great     gr eat         g r e     scramble string  may choose non-leaf node swap two children  hard string dynamic programming 
my c++ solutions (recursion with cache   dp  recursion with cache and pruning) with explanation (4ms) scramble string given string s1  may represent binary tree partitioning two non-empty substrings recursively  one possible representation s1 = "great": great     gr eat         g r e     scramble string  may choose non-leaf node swap two children  hard string dynamic programming 
simple iterative dp java solution with explanation scramble string given string s1  may represent binary tree partitioning two non-empty substrings recursively  one possible representation s1 = "great": great     gr eat         g r e     scramble string  may choose non-leaf node swap two children  hard string dynamic programming 
can you partition a string at any index at any time in producing a scramble? scramble string given string s1  may represent binary tree partitioning two non-empty substrings recursively  one possible representation s1 = "great": great     gr eat         g r e     scramble string  may choose non-leaf node swap two children  hard string dynamic programming 
this is my ac code  may help you merge sorted array given two sorted integer arrays nums1 nums2  merge nums2 nums1 one sorted array  note: number elements initialized nums1 nums2 n respectively  may assume nums1 enough space (size greater equal + n) hold additional elements nums2  easy array two pointers 
beautiful python solution merge sorted array given two sorted integer arrays nums1 nums2  merge nums2 nums1 one sorted array  note: number elements initialized nums1 nums2 n respectively  may assume nums1 enough space (size greater equal + n) hold additional elements nums2  easy array two pointers 
4ms c++ solution with single loop merge sorted array given two sorted integer arrays nums1 nums2  merge nums2 nums1 one sorted array  note: number elements initialized nums1 nums2 n respectively  may assume nums1 enough space (size greater equal + n) hold additional elements nums2  easy array two pointers 
3 line java solution merge sorted array given two sorted integer arrays nums1 nums2  merge nums2 nums1 one sorted array  note: number elements initialized nums1 nums2 n respectively  may assume nums1 enough space (size greater equal + n) hold additional elements nums2  easy array two pointers 
1 line solution merge sorted array given two sorted integer arrays nums1 nums2  merge nums2 nums1 one sorted array  note: number elements initialized nums1 nums2 n respectively  may assume nums1 enough space (size greater equal + n) hold additional elements nums2  easy array two pointers 
an accepted three line solution in java gray code gray code binary numeral system two successive values differ one bit  given non-negative integer n representing total number bits code  print sequence gray code  gray code sequence must begin 0  medium backtracking 
share my solution gray code gray code binary numeral system two successive values differ one bit  given non-negative integer n representing total number bits code  print sequence gray code  gray code sequence must begin 0  medium backtracking 
one-liner python solution (with demo in comments) gray code gray code binary numeral system two successive values differ one bit  given non-negative integer n representing total number bits code  print sequence gray code  gray code sequence must begin 0  medium backtracking 
what is the best solution for gray code problem? no extra space used and no recursion? gray code gray code binary numeral system two successive values differ one bit  given non-negative integer n representing total number bits code  print sequence gray code  gray code sequence must begin 0  medium backtracking 
backtracking c++ solution gray code gray code binary numeral system two successive values differ one bit  given non-negative integer n representing total number bits code  print sequence gray code  gray code sequence must begin 0  medium backtracking 
c++ solution and explanation subsets ii given collection integers might contain duplicates  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking 
simple iterative solution subsets ii given collection integers might contain duplicates  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking 
simple python solution without extra space  subsets ii given collection integers might contain duplicates  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking 
accepted 10ms c++ solution use backtracking  only 10 lines  easy understand  subsets ii given collection integers might contain duplicates  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking 
very simple and fast java solution subsets ii given collection integers might contain duplicates  nums  return possible subsets (the power set)  note: solution set must contain duplicate subsets  medium array backtracking 
dp solution (java) for reference decode ways message containing letters a-z encoded numbers using following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given non-empty string containing digits  determine total number ways decode it  medium string dynamic programming 
java clean dp solution with explanation decode ways message containing letters a-z encoded numbers using following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given non-empty string containing digits  determine total number ways decode it  medium string dynamic programming 
a concise dp solution decode ways message containing letters a-z encoded numbers using following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given non-empty string containing digits  determine total number ways decode it  medium string dynamic programming 
evolve from recursion to dp decode ways message containing letters a-z encoded numbers using following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given non-empty string containing digits  determine total number ways decode it  medium string dynamic programming 
java 2ms dp solution with detailed explanation and inline comments decode ways message containing letters a-z encoded numbers using following mapping: 'a' -> 1 'b' -> 2     'z' -> 26 given non-empty string containing digits  determine total number ways decode it  medium string dynamic programming 
simple java solution with clear explanation reverse linked list ii reverse linked list position n  one-pass  note: 1 ≤ ≤ n ≤ length list  medium linked list 
12-lines 4ms c++ reverse linked list ii reverse linked list position n  one-pass  note: 1 ≤ ≤ n ≤ length list  medium linked list 
share my 14 lines c++ solution reverse linked list ii reverse linked list position n  one-pass  note: 1 ≤ ≤ n ≤ length list  medium linked list 
talk is cheap  show me the code (and drawing) reverse linked list ii reverse linked list position n  one-pass  note: 1 ≤ ≤ n ≤ length list  medium linked list 
python one pass iterative solution reverse linked list ii reverse linked list position n  one-pass  note: 1 ≤ ≤ n ≤ length list  medium linked list 
my code in java restore ip addresses given string containing digits  restore returning possible valid ip address combinations  medium string backtracking 
who can beat this code ? restore ip addresses given string containing digits  restore returning possible valid ip address combinations  medium string backtracking 
very simple dfs solution restore ip addresses given string containing digits  restore returning possible valid ip address combinations  medium string backtracking 
what is the definition of a valid ip address? restore ip addresses given string containing digits  restore returning possible valid ip address combinations  medium string backtracking 
my concise ac java code restore ip addresses given string containing digits  restore returning possible valid ip address combinations  medium string backtracking 
iterative solution in java - simple and readable binary tree inorder traversal given binary tree  return inorder traversal nodes' values  medium hash table stack tree 
three methods to solve (c++) binary tree inorder traversal given binary tree  return inorder traversal nodes' values  medium hash table stack tree 
python recursive and iterative solutions  binary tree inorder traversal given binary tree  return inorder traversal nodes' values  medium hash table stack tree 
c++ ierative  recursive and morris traversal binary tree inorder traversal given binary tree  return inorder traversal nodes' values  medium hash table stack tree 
concise java solution based on stack binary tree inorder traversal given binary tree  return inorder traversal nodes' values  medium hash table stack tree 
a simple recursive solution unique binary search trees ii given integer n  generate structurally unique bst's (binary search trees) store values 1     n  medium dynamic programming tree 
java solution with dp unique binary search trees ii given integer n  generate structurally unique bst's (binary search trees) store values 1     n  medium dynamic programming tree 
divide-and-conquer   f(i) = g(i-1)   g(n-i) unique binary search trees ii given integer n  generate structurally unique bst's (binary search trees) store values 1     n  medium dynamic programming tree 
should-be-6-liner unique binary search trees ii given integer n  generate structurally unique bst's (binary search trees) store values 1     n  medium dynamic programming tree 
share a c++ dp solution with o(1) space unique binary search trees ii given integer n  generate structurally unique bst's (binary search trees) store values 1     n  medium dynamic programming tree 
dp solution in 6 lines with explanation  f(i  n) = g(i-1)   g(n-i) unique binary search trees given n  many structurally unique bst's (binary search trees) store values 1     n? medium dynamic programming tree 
fantastic clean java dp solution with detail explaination unique binary search trees given n  many structurally unique bst's (binary search trees) store values 1     n? medium dynamic programming tree 
dp problem  10+ lines with comments unique binary search trees given n  many structurally unique bst's (binary search trees) store values 1     n? medium dynamic programming tree 
a very simple and straight ans based on math catalan number  o(n) times o(1)space unique binary search trees given n  many structurally unique bst's (binary search trees) store values 1     n? medium dynamic programming tree 
simple solution with easy explaination unique binary search trees given n  many structurally unique bst's (binary search trees) store values 1     n? medium dynamic programming tree 
my dp solution in c++ interleaving string given s1  s2  s3  find whether s3 formed interleaving s1 s2  hard string dynamic programming 
8ms c++ solution using bfs  with explanation interleaving string given s1  s2  s3  find whether s3 formed interleaving s1 s2  hard string dynamic programming 
dp solution in java interleaving string given s1  s2  s3  find whether s3 formed interleaving s1 s2  hard string dynamic programming 
1ms tiny dfs beats 94 57% interleaving string given s1  s2  s3  find whether s3 formed interleaving s1 s2  hard string dynamic programming 
python dp solutions (o(m n)  o(n) space)  bfs  dfs  interleaving string given s1  s2  s3  find whether s3 formed interleaving s1 s2  hard string dynamic programming 
learn one iterative inorder traversal  apply it to multiple tree questions (java solution) validate binary search tree given binary tree  determine valid binary search tree (bst)  assume bst defined follows: left subtree node contains nodes keys less node's key  right subtree node contains nodes keys greater node's key  left right subtrees must also binary search trees  medium tree depth-first search 
my simple java solution in 3 lines validate binary search tree given binary tree  determine valid binary search tree (bst)  assume bst defined follows: left subtree node contains nodes keys less node's key  right subtree node contains nodes keys greater node's key  left right subtrees must also binary search trees  medium tree depth-first search 
c++ in-order traversal  and please do not rely on buggy int_max  int_min solutions any more validate binary search tree given binary tree  determine valid binary search tree (bst)  assume bst defined follows: left subtree node contains nodes keys less node's key  right subtree node contains nodes keys greater node's key  left right subtrees must also binary search trees  medium tree depth-first search 
c++ simple recursive solution validate binary search tree given binary tree  determine valid binary search tree (bst)  assume bst defined follows: left subtree node contains nodes keys less node's key  right subtree node contains nodes keys greater node's key  left right subtrees must also binary search trees  medium tree depth-first search 
my java inorder iteration solution validate binary search tree given binary tree  determine valid binary search tree (bst)  assume bst defined follows: left subtree node contains nodes keys less node's key  right subtree node contains nodes keys greater node's key  left right subtrees must also binary search trees  medium tree depth-first search 
no fancy algorithm  just simple and powerful in-order traversal recover binary search tree two elements binary search tree (bst) swapped mistake  recover tree without changing structure  hard tree depth-first search 
detail explain about how morris traversal finds two incorrect pointer recover binary search tree two elements binary search tree (bst) swapped mistake  recover tree without changing structure  hard tree depth-first search 
tree deserializer and visualizer for python recover binary search tree two elements binary search tree (bst) swapped mistake  recover tree without changing structure  hard tree depth-first search 
share my solutions and detailed explanation with recursive iterative in-order-traversal and morris-traversal recover binary search tree two elements binary search tree (bst) swapped mistake  recover tree without changing structure  hard tree depth-first search 
[recommend for beginners]clean c++ implementation with detailed explaination recover binary search tree two elements binary search tree (bst) swapped mistake  recover tree without changing structure  hard tree depth-first search 
five line java solution with recursion same tree given two binary trees  write function check not  two binary trees considered structurally identical nodes value  easy tree depth-first search 
here's a c++ recursion solution in minimal lines of code same tree given two binary trees  write function check not  two binary trees considered structurally identical nodes value  easy tree depth-first search 
my non-recursive method same tree given two binary trees  write function check not  two binary trees considered structurally identical nodes value  easy tree depth-first search 
shortest+simplest python same tree given two binary trees  write function check not  two binary trees considered structurally identical nodes value  easy tree depth-first search 
python recursive solution and dfs iterative solution with stack and bfs iterative solution with queue same tree given two binary trees  write function check not  two binary trees considered structurally identical nodes value  easy tree depth-first search 
recursive and non-recursive solutions in java symmetric tree given binary tree  check whether mirror (ie  symmetric around center)  easy tree depth-first search breadth-first search 
1ms recursive java solution  easy to understand symmetric tree given binary tree  check whether mirror (ie  symmetric around center)  easy tree depth-first search breadth-first search 
my c++ accepted code in 16ms with iteration solution symmetric tree given binary tree  check whether mirror (ie  symmetric around center)  easy tree depth-first search breadth-first search 
recursively and iteratively solution in python symmetric tree given binary tree  check whether mirror (ie  symmetric around center)  easy tree depth-first search breadth-first search 
short and clean java iterative solution symmetric tree given binary tree  check whether mirror (ie  symmetric around center)  easy tree depth-first search breadth-first search 
java solution with a queue used binary tree level order traversal given binary tree  return level order traversal nodes' values  (ie  left right  level level)  medium tree breadth-first search 
java solution using dfs binary tree level order traversal given binary tree  return level order traversal nodes' values  (ie  left right  level level)  medium tree breadth-first search 
one of c++ solutions (preorder) binary tree level order traversal given binary tree  return level order traversal nodes' values  (ie  left right  level level)  medium tree breadth-first search 
c++ solution using only one queue   use a marker null binary tree level order traversal given binary tree  return level order traversal nodes' values  (ie  left right  level level)  medium tree breadth-first search 
5-6 lines fast python solution (48 ms) binary tree level order traversal given binary tree  return level order traversal nodes' values  (ie  left right  level level)  medium tree breadth-first search 
my accepted java solution binary tree zigzag level order traversal given binary tree  return zigzag level order traversal nodes' values  (ie  left right  right left next level alternate between)  medium stack tree breadth-first search 
[c++] 5ms version: one queue and without reverse operation by using size of each level binary tree zigzag level order traversal given binary tree  return zigzag level order traversal nodes' values  (ie  left right  right left next level alternate between)  medium stack tree breadth-first search 
a concise and easy understanding java solution binary tree zigzag level order traversal given binary tree  return zigzag level order traversal nodes' values  (ie  left right  right left next level alternate between)  medium stack tree breadth-first search 
java double stack solution binary tree zigzag level order traversal given binary tree  return zigzag level order traversal nodes' values  (ie  left right  right left next level alternate between)  medium stack tree breadth-first search 
python simple bfs binary tree zigzag level order traversal given binary tree  return zigzag level order traversal nodes' values  (ie  left right  right left next level alternate between)  medium stack tree breadth-first search 
can leetcode share top performing solution(s) of problems for each supported language ? maximum depth of binary tree given binary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  note: leaf node children  easy tree depth-first search 
simple solution using java maximum depth of binary tree given binary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  note: leaf node children  easy tree depth-first search 
my code of c++  depth-first-search and breadth-first-search maximum depth of binary tree given binary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  note: leaf node children  easy tree depth-first search 
two java iterative solution dfs and bfs maximum depth of binary tree given binary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  note: leaf node children  easy tree depth-first search 
1 line ruby and python maximum depth of binary tree given binary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  note: leaf node children  easy tree depth-first search 
my accepted java solution construct binary tree from preorder and inorder traversal given preorder inorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
python short recursive solution  construct binary tree from preorder and inorder traversal given preorder inorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
the iterative solution is easier than you think! construct binary tree from preorder and inorder traversal given preorder inorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
sharing my straightforward recursive solution construct binary tree from preorder and inorder traversal given preorder inorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
5ms java clean solution with caching construct binary tree from preorder and inorder traversal given preorder inorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
my recursive java code with o(n) time and o(n) space construct binary tree from inorder and postorder traversal given inorder postorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
a python recursive solution construct binary tree from inorder and postorder traversal given inorder postorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
sharing my straightforward recursive solution construct binary tree from inorder and postorder traversal given inorder postorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
java iterative solution with explanation construct binary tree from inorder and postorder traversal given inorder postorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
my comprehension of o(n) solution from @hongzhi construct binary tree from inorder and postorder traversal given inorder postorder traversal tree  construct binary tree  note: may assume duplicates exist tree  medium array tree depth-first search 
my dfs and bfs java solution binary tree level order traversal ii given binary tree  return bottom-up level order traversal nodes' values  (ie  left right  level level leaf root)  easy tree breadth-first search 
is there any better idea than doing regular level order traversal and reverse the result? binary tree level order traversal ii given binary tree  return bottom-up level order traversal nodes' values  (ie  left right  level level leaf root)  easy tree breadth-first search 
python solutions (dfs recursively  dfs+stack  bfs+queue)  binary tree level order traversal ii given binary tree  return bottom-up level order traversal nodes' values  (ie  left right  level level leaf root)  easy tree breadth-first search 
java solution  using queue binary tree level order traversal ii given binary tree  return bottom-up level order traversal nodes' values  (ie  left right  level level leaf root)  easy tree breadth-first search 
my neat solution in c++ binary tree level order traversal ii given binary tree  return bottom-up level order traversal nodes' values  (ie  left right  level level leaf root)  easy tree breadth-first search 
my accepted java solution convert sorted array to binary search tree given array elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
java iterative solution convert sorted array to binary search tree given array elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
an easy python solution convert sorted array to binary search tree given array elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
accepted c++ recursive solution within a single method convert sorted array to binary search tree given array elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
python optimal solution convert sorted array to binary search tree given array elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
share my java solution  1ms  very short and concise  convert sorted list to binary search tree given singly linked list elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  medium linked list depth-first search 
share my o(1) space and o(n) time java code convert sorted list to binary search tree given singly linked list elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  medium linked list depth-first search 
share my code with o(n) time and o(1) space convert sorted list to binary search tree given singly linked list elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  medium linked list depth-first search 
my accepted c++ solution convert sorted list to binary search tree given singly linked list elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  medium linked list depth-first search 
recursive bst construction using slow-fast traversal on linked list convert sorted list to binary search tree given singly linked list elements sorted ascending order  convert height balanced bst  problem  height-balanced binary tree defined binary tree depth two subtrees every node never differ 1  medium linked list depth-first search 
the bottom up o(n) solution would be better balanced binary tree given binary tree  determine height-balanced  problem  height-balanced binary tree defined as: binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
java solution based on height  check left and right node in every recursion to avoid further useless search balanced binary tree given binary tree  determine height-balanced  problem  height-balanced binary tree defined as: binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
very simple python solutions (iterative and recursive)  both beat 90% balanced binary tree given binary tree  determine height-balanced  problem  height-balanced binary tree defined as: binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
two different definitions of balanced binary tree result in two different judgments balanced binary tree given binary tree  determine height-balanced  problem  height-balanced binary tree defined as: binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
java o(n) solution based on maximum depth of binary tree balanced binary tree given binary tree  determine height-balanced  problem  height-balanced binary tree defined as: binary tree depth two subtrees every node never differ 1  easy tree depth-first search 
my 4 line java solution minimum depth of binary tree given binary tree  find minimum depth  minimum depth number nodes along shortest path root node nearest leaf node  note: leaf node children  easy tree depth-first search breadth-first search 
my concise c++ solution minimum depth of binary tree given binary tree  find minimum depth  minimum depth number nodes along shortest path root node nearest leaf node  note: leaf node children  easy tree depth-first search breadth-first search 
3 lines in every language minimum depth of binary tree given binary tree  find minimum depth  minimum depth number nodes along shortest path root node nearest leaf node  note: leaf node children  easy tree depth-first search breadth-first search 
why expected result for input of {1 2}  is 2? shouldn't it be 1? minimum depth of binary tree given binary tree  find minimum depth  minimum depth number nodes along shortest path root node nearest leaf node  note: leaf node children  easy tree depth-first search breadth-first search 
bfs  c++  8ms  beats 99 94% submissions minimum depth of binary tree given binary tree  find minimum depth  minimum depth number nodes along shortest path root node nearest leaf node  note: leaf node children  easy tree depth-first search breadth-first search 
[accepted]my recursive solution in java path sum given binary tree sum  determine tree root-to-leaf path adding values along path equals given sum  note: leaf node children  easy tree depth-first search 
3 lines of  c++ solution path sum given binary tree sum  determine tree root-to-leaf path adding values along path equals given sum  note: leaf node children  easy tree depth-first search 
short python recursive solution - o(n) path sum given binary tree sum  determine tree root-to-leaf path adding values along path equals given sum  note: leaf node children  easy tree depth-first search 
[accepted] by using postorder traversal path sum given binary tree sum  determine tree root-to-leaf path adding values along path equals given sum  note: leaf node children  easy tree depth-first search 
my java no-recursive method path sum given binary tree sum  determine tree root-to-leaf path adding values along path equals given sum  note: leaf node children  easy tree depth-first search 
dfs with one linkedlist   accepted java solution path sum ii given binary tree sum  find root-to-leaf paths path's sum equals given sum  note: leaf node children  medium tree depth-first search 
12ms 11-lines c++ solution path sum ii given binary tree sum  find root-to-leaf paths path's sum equals given sum  note: leaf node children  medium tree depth-first search 
python solutions (recursively  bfs+queue  dfs+stack) path sum ii given binary tree sum  find root-to-leaf paths path's sum equals given sum  note: leaf node children  medium tree depth-first search 
simple dfs java solution path sum ii given binary tree sum  find root-to-leaf paths path's sum equals given sum  note: leaf node children  medium tree depth-first search 
java solution: iterative and recursive path sum ii given binary tree sum  find root-to-leaf paths path's sum equals given sum  note: leaf node children  medium tree depth-first search 
my short post order traversal java solution for share flatten binary tree to linked list given binary tree  flatten linked list in-place  medium tree depth-first search 
share my simple non-recursive solution  o(1) space complexity! flatten binary tree to linked list given binary tree  flatten linked list in-place  medium tree depth-first search 
straightforward java solution flatten binary tree to linked list given binary tree  flatten linked list in-place  medium tree depth-first search 
accepted simple java solution   iterative flatten binary tree to linked list given binary tree  flatten linked list in-place  medium tree depth-first search 
8ms  non-recursive  no stack  c++ solution flatten binary tree to linked list given binary tree  flatten linked list in-place  medium tree depth-first search 
easy to understand dp in java distinct subsequences given string string t  count number distinct subsequences equals t  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  hard string dynamic programming 
any better solution that takes less than o(n^2) space while in o(n^2) time? distinct subsequences given string string t  count number distinct subsequences equals t  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  hard string dynamic programming 
task clarification distinct subsequences given string string t  count number distinct subsequences equals t  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  hard string dynamic programming 
7-10 lines c++ solutions with detailed explanations (o(m n) time and o(m) space) distinct subsequences given string string t  count number distinct subsequences equals t  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  hard string dynamic programming 
the question should be reworded  distinct subsequences given string string t  count number distinct subsequences equals t  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  hard string dynamic programming 
a simple accepted solution populating next right pointers in each node given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  may assume perfect binary tree (ie  leaves level  every parent two children)  medium tree depth-first search 
java solution with o(1) memory+ o(n) time populating next right pointers in each node given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  may assume perfect binary tree (ie  leaves level  every parent two children)  medium tree depth-first search 
my recursive solution(java) populating next right pointers in each node given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  may assume perfect binary tree (ie  leaves level  every parent two children)  medium tree depth-first search 
my simple non-iterative c++ code with o(1) memory populating next right pointers in each node given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  may assume perfect binary tree (ie  leaves level  every parent two children)  medium tree depth-first search 
7 lines  iterative  real o(1) space populating next right pointers in each node given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  may assume perfect binary tree (ie  leaves level  every parent two children)  medium tree depth-first search 
o(1) space o(n) complexity iterative solution populating next right pointers in each node ii given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  medium tree depth-first search 
simple solution using constant space populating next right pointers in each node ii given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  medium tree depth-first search 
java solution with constant space populating next right pointers in each node ii given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  medium tree depth-first search 
ac python o(1) space solution 12 lines and easy to understand populating next right pointers in each node ii given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  medium tree depth-first search 
simple 40ms c++ o(n)  o(1) solution with only one while loop populating next right pointers in each node ii given binary tree struct treelinknode { treelinknode  left; treelinknode  right; treelinknode  next; } populate next pointer point next right node  next right node  next pointer set null  initially  next pointers set null  note: may use constant extra space  recursive approach fine  implicit stack space count extra space problem  medium tree depth-first search 
my concise solution in java pascal's triangle given non-negative integer numrows  generate first numrows pascal's triangle  pascal's triangle  number sum two numbers directly it  easy array 
python 4 lines short solution using map  pascal's triangle given non-negative integer numrows  generate first numrows pascal's triangle  pascal's triangle  number sum two numbers directly it  easy array 
solution in java pascal's triangle given non-negative integer numrows  generate first numrows pascal's triangle  pascal's triangle  number sum two numbers directly it  easy array 
maybe shortest c++ solution pascal's triangle given non-negative integer numrows  generate first numrows pascal's triangle  pascal's triangle  number sum two numbers directly it  easy array 
simple python 4 lines pascal's triangle given non-negative integer numrows  generate first numrows pascal's triangle  pascal's triangle  number sum two numbers directly it  easy array 
here is my brief o(k) solution pascal's triangle ii given non-negative index k k ≤ 33  return kth index row pascal's triangle  note row index starts 0  pascal's triangle  number sum two numbers directly it  easy array 
very simple python solution pascal's triangle ii given non-negative index k k ≤ 33  return kth index row pascal's triangle  note row index starts 0  pascal's triangle  number sum two numbers directly it  easy array 
my accepted java solution  any better code? pascal's triangle ii given non-negative index k k ≤ 33  return kth index row pascal's triangle  note row index starts 0  pascal's triangle  number sum two numbers directly it  easy array 
my 8 lines java solution use arraylist pascal's triangle ii given non-negative index k k ≤ 33  return kth index row pascal's triangle  note row index starts 0  pascal's triangle  number sum two numbers directly it  easy array 
sharing my c++ code  very simple pascal's triangle ii given non-negative index k k ≤ 33  return kth index row pascal's triangle  note row index starts 0  pascal's triangle  number sum two numbers directly it  easy array 
dp solution for triangle triangle given triangle  find minimum path sum top bottom  step may move adjacent numbers row below  medium array dynamic programming 
7 lines neat java solution triangle given triangle  find minimum path sum top bottom  step may move adjacent numbers row below  medium array dynamic programming 
my 8 line dp java code(4 meaningful lines) with o(1) space triangle given triangle  find minimum path sum top bottom  step may move adjacent numbers row below  medium array dynamic programming 
python easy to understand solutions (top-down  bottom-up)  triangle given triangle  find minimum path sum top bottom  step may move adjacent numbers row below  medium array dynamic programming 
bottom up 5 line c++ solution triangle given triangle  find minimum path sum top bottom  step may move adjacent numbers row below  medium array dynamic programming 
kadane's algorithm - since no one has mentioned about this so far :) (in case if interviewer twists the input) best time to buy and sell stock say array ith element price given stock day i  permitted complete one transaction (i e   buy one sell one share stock)  design algorithm find maximum profit  note cannot sell stock buy one  easy array dynamic programming 
sharing my simple and clear c++ solution best time to buy and sell stock say array ith element price given stock day i  permitted complete one transaction (i e   buy one sell one share stock)  design algorithm find maximum profit  note cannot sell stock buy one  easy array dynamic programming 
please explain the problem more clearly!!! best time to buy and sell stock say array ith element price given stock day i  permitted complete one transaction (i e   buy one sell one share stock)  design algorithm find maximum profit  note cannot sell stock buy one  easy array dynamic programming 
my jave accepted solution with o(n) time and o(1) space best time to buy and sell stock say array ith element price given stock day i  permitted complete one transaction (i e   buy one sell one share stock)  design algorithm find maximum profit  note cannot sell stock buy one  easy array dynamic programming 
easy o(n) python solution best time to buy and sell stock say array ith element price given stock day i  permitted complete one transaction (i e   buy one sell one share stock)  design algorithm find maximum profit  note cannot sell stock buy one  easy array dynamic programming 
is this question a joke? best time to buy and sell stock ii say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (i e   buy one sell one share stock multiple times)  note: may engage multiple transactions time (i e   must sell stock buy again)  easy array greedy 
three lines in c++  with explanation best time to buy and sell stock ii say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (i e   buy one sell one share stock multiple times)  note: may engage multiple transactions time (i e   must sell stock buy again)  easy array greedy 
java o(n) solution if we're not greedy best time to buy and sell stock ii say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (i e   buy one sell one share stock multiple times)  note: may engage multiple transactions time (i e   must sell stock buy again)  easy array greedy 
clear 1-line python solution best time to buy and sell stock ii say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (i e   buy one sell one share stock multiple times)  note: may engage multiple transactions time (i e   must sell stock buy again)  easy array greedy 
shortest and fastest solution with explanation  you can never beat this  best time to buy and sell stock ii say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (i e   buy one sell one share stock multiple times)  note: may engage multiple transactions time (i e   must sell stock buy again)  easy array greedy 
is it best solution with o(n)  o(1)  best time to buy and sell stock iii say array ith element price given stock day i  design algorithm find maximum profit  may complete two transactions  note: may engage multiple transactions time (i e   must sell stock buy again)  hard array dynamic programming 
a clean dp solution which generalizes to k transactions best time to buy and sell stock iii say array ith element price given stock day i  design algorithm find maximum profit  may complete two transactions  note: may engage multiple transactions time (i e   must sell stock buy again)  hard array dynamic programming 
detail explanation of dp solution best time to buy and sell stock iii say array ith element price given stock day i  design algorithm find maximum profit  may complete two transactions  note: may engage multiple transactions time (i e   must sell stock buy again)  hard array dynamic programming 
my explanation for o(n) solution! best time to buy and sell stock iii say array ith element price given stock day i  design algorithm find maximum profit  may complete two transactions  note: may engage multiple transactions time (i e   must sell stock buy again)  hard array dynamic programming 
my c++ solution (o(n) time  o(1) space  8ms) best time to buy and sell stock iii say array ith element price given stock day i  design algorithm find maximum profit  may complete two transactions  note: may engage multiple transactions time (i e   must sell stock buy again)  hard array dynamic programming 
accepted short solution in java binary tree maximum path sum given non-empty binary tree  find maximum path sum  problem  path defined sequence nodes starting node node tree along parent-child connections  path must contain least one node need go root  hard tree depth-first search 
simple o(n) algorithm with one traversal through the tree binary tree maximum path sum given non-empty binary tree  find maximum path sum  problem  path defined sequence nodes starting node node tree along parent-child connections  path must contain least one node need go root  hard tree depth-first search 
elegant java solution binary tree maximum path sum given non-empty binary tree  find maximum path sum  problem  path defined sequence nodes starting node node tree along parent-child connections  path must contain least one node need go root  hard tree depth-first search 
a very concise recursive solution binary tree maximum path sum given non-empty binary tree  find maximum path sum  problem  path defined sequence nodes starting node node tree along parent-child connections  path must contain least one node need go root  hard tree depth-first search 
what is the meaning of path in this problem? binary tree maximum path sum given non-empty binary tree  find maximum path sum  problem  path defined sequence nodes starting node node tree along parent-child connections  path must contain least one node need go root  hard tree depth-first search 
accepted pretty java solution(271ms) valid palindrome given string  determine palindrome  considering alphanumeric characters ignoring cases  note: purpose problem  define empty string valid palindrome  easy two pointers string 
my three line java solution valid palindrome given string  determine palindrome  considering alphanumeric characters ignoring cases  note: purpose problem  define empty string valid palindrome  easy two pointers string 
here's a clean c++ solution valid palindrome given string  determine palindrome  considering alphanumeric characters ignoring cases  note: purpose problem  define empty string valid palindrome  easy two pointers string 
python in-place two-pointer solution  valid palindrome given string  determine palindrome  considering alphanumeric characters ignoring cases  note: purpose problem  define empty string valid palindrome  easy two pointers string 
passed clean c++ code valid palindrome given string  determine palindrome  considering alphanumeric characters ignoring cases  note: purpose problem  define empty string valid palindrome  easy two pointers string 
my concise java solution based on bfs and dfs word ladder ii given two words (beginword endword)  dictionary's word list  find shortest transformation sequence(s) beginword endword  that: one letter changed time transformed word must exist word list  note beginword transformed word  note: return empty list transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  hard array string backtracking breadth-first search 
share two similar java solution that accpted by oj  word ladder ii given two words (beginword endword)  dictionary's word list  find shortest transformation sequence(s) beginword endword  that: one letter changed time transformed word must exist word list  note beginword transformed word  note: return empty list transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  hard array string backtracking breadth-first search 
c++ solution using standard bfs method  no dfs or backtracking word ladder ii given two words (beginword endword)  dictionary's word list  find shortest transformation sequence(s) beginword endword  that: one letter changed time transformed word must exist word list  note beginword transformed word  note: return empty list transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  hard array string backtracking breadth-first search 
super fast java solution (two-end bfs) word ladder ii given two words (beginword endword)  dictionary's word list  find shortest transformation sequence(s) beginword endword  that: one letter changed time transformed word must exist word list  note beginword transformed word  note: return empty list transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  hard array string backtracking breadth-first search 
use defaultdict for traceback and easy writing  20 lines python code word ladder ii given two words (beginword endword)  dictionary's word list  find shortest transformation sequence(s) beginword endword  that: one letter changed time transformed word must exist word list  note beginword transformed word  note: return empty list transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  hard array string backtracking breadth-first search 
easy 76ms c++ solution using bfs word ladder given two words (beginword endword)  dictionary's word list  find length shortest transformation sequence beginword endword  that: one letter changed time  transformed word must exist word list  note beginword transformed word  note: return 0 transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  medium breadth-first search 
two-end bfs in java 31ms  word ladder given two words (beginword endword)  dictionary's word list  find length shortest transformation sequence beginword endword  that: one letter changed time  transformed word must exist word list  note beginword transformed word  note: return 0 transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  medium breadth-first search 
java solution using bfs  with explanation word ladder given two words (beginword endword)  dictionary's word list  find length shortest transformation sequence beginword endword  that: one letter changed time  transformed word must exist word list  note beginword transformed word  note: return 0 transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  medium breadth-first search 
share my two python solutions: a very concise one (12 lines  ~160ms) and an optimized solution(~100ms) word ladder given two words (beginword endword)  dictionary's word list  find length shortest transformation sequence beginword endword  that: one letter changed time  transformed word must exist word list  note beginword transformed word  note: return 0 transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  medium breadth-first search 
another accepted java solution (bfs) word ladder given two words (beginword endword)  dictionary's word list  find length shortest transformation sequence beginword endword  that: one letter changed time  transformed word must exist word list  note beginword transformed word  note: return 0 transformation sequence  words length  words contain lowercase alphabetic characters  may assume duplicates word list  may assume beginword endword non-empty same  medium breadth-first search 
my really simple java o(n) solution - accepted longest consecutive sequence given unsorted array integers  find length longest consecutive elements sequence  algorithm run o(n) complexity  hard array union find 
simple o(n) with explanation - just walk each streak longest consecutive sequence given unsorted array integers  find length longest consecutive elements sequence  algorithm run o(n) complexity  hard array union find 
possibly shortest cpp solution  only 6 lines  longest consecutive sequence given unsorted array integers  find length longest consecutive elements sequence  algorithm run o(n) complexity  hard array union find 
simple fast java solution using set longest consecutive sequence given unsorted array integers  find length longest consecutive elements sequence  algorithm run o(n) complexity  hard array union find 
a simple c++ solution using unordered_set and simple consideration about this problem longest consecutive sequence given unsorted array integers  find length longest consecutive elements sequence  algorithm run o(n) complexity  hard array union find 
short java solution  recursion  sum root to leaf numbers given binary tree containing digits 0-9 only  root-to-leaf path could represent number  medium tree depth-first search 
can you improve this algorithm? sum root to leaf numbers given binary tree containing digits 0-9 only  root-to-leaf path could represent number  medium tree depth-first search 
python solutions (dfs+stack  bfs+queue  dfs recursively)  sum root to leaf numbers given binary tree containing digits 0-9 only  root-to-leaf path could represent number  medium tree depth-first search 
clean java dfs solution (preorder traversal) sum root to leaf numbers given binary tree containing digits 0-9 only  root-to-leaf path could represent number  medium tree depth-first search 
one of the easier solution using preorder traversal (recursion) sum root to leaf numbers given binary tree containing digits 0-9 only  root-to-leaf path could represent number  medium tree depth-first search 
a really simple and readable c++ solution uff0conly cost 12ms surrounded regions given 2d board containing 'x' 'o' (the letter o)  capture regions surrounded 'x'  region captured flipping 'o's 'x's surrounded region  medium depth-first search breadth-first search union find 
solve it using union find surrounded regions given 2d board containing 'x' 'o' (the letter o)  capture regions surrounded 'x'  region captured flipping 'o's 'x's surrounded region  medium depth-first search breadth-first search union find 
9 lines  python 148 ms surrounded regions given 2d board containing 'x' 'o' (the letter o)  capture regions surrounded 'x'  region captured flipping 'o's 'x's surrounded region  medium depth-first search breadth-first search union find 
java dfs + boundary cell turning solution  simple and clean code  commented  surrounded regions given 2d board containing 'x' 'o' (the letter o)  capture regions surrounded 'x'  region captured flipping 'o's 'x's surrounded region  medium depth-first search breadth-first search union find 
my bfs solution (c++ 28ms) surrounded regions given 2d board containing 'x' 'o' (the letter o)  capture regions surrounded 'x'  region captured flipping 'o's 'x's surrounded region  medium depth-first search breadth-first search union find 
java: backtracking solution  palindrome partitioning given string s  partition every substring partition palindrome  return possible palindrome partitioning s  medium backtracking 
my java dp only solution without recursion  o(n^2) palindrome partitioning given string s  partition every substring partition palindrome  return possible palindrome partitioning s  medium backtracking 
clean c++ backtracking solution palindrome partitioning given string s  partition every substring partition palindrome  return possible palindrome partitioning s  medium backtracking 
java dp + dfs solution palindrome partitioning given string s  partition every substring partition palindrome  return possible palindrome partitioning s  medium backtracking 
python recursive iterative backtracking solution palindrome partitioning given string s  partition every substring partition palindrome  return possible palindrome partitioning s  medium backtracking 
my solution does not need a table for palindrome  is it right ? it uses only o(n) space  palindrome partitioning ii given string s  partition every substring partition palindrome  return minimum cuts needed palindrome partitioning s  hard dynamic programming 
easiest java dp solution (97 36%) palindrome partitioning ii given string s  partition every substring partition palindrome  return minimum cuts needed palindrome partitioning s  hard dynamic programming 
my dp solution ( explanation and code) palindrome partitioning ii given string s  partition every substring partition palindrome  return minimum cuts needed palindrome partitioning s  hard dynamic programming 
two c++ versions given (one dp 28ms  one manancher-like algorithm 10 ms) palindrome partitioning ii given string s  partition every substring partition palindrome  return minimum cuts needed palindrome partitioning s  hard dynamic programming 
dp solution & some thoughts palindrome partitioning ii given string s  partition every substring partition palindrome  return minimum cuts needed palindrome partitioning s  hard dynamic programming 
depth first simple java solution clone graph given head graph  return deep copy (clone) graph  node graph contains label (int) list (list[undirectedgraphnode]) neighbors  edge given node nodes neighbors  oj's undirected graph serialization (so understand error output): nodes labeled uniquely  use # separator node    separator node label neighbor node  medium depth-first search breadth-first search graph 
7-17 lines c++ bfs dfs solutions clone graph given head graph  return deep copy (clone) graph  node graph contains label (int) list (list[undirectedgraphnode]) neighbors  edge given node nodes neighbors  oj's undirected graph serialization (so understand error output): nodes labeled uniquely  use # separator node    separator node label neighbor node  medium depth-first search breadth-first search graph 
simple java iterative bfs solution with hashmap and queue clone graph given head graph  return deep copy (clone) graph  node graph contains label (int) list (list[undirectedgraphnode]) neighbors  edge given node nodes neighbors  oj's undirected graph serialization (so understand error output): nodes labeled uniquely  use # separator node    separator node label neighbor node  medium depth-first search breadth-first search graph 
9 line c++ dfs solution clone graph given head graph  return deep copy (clone) graph  node graph contains label (int) list (list[undirectedgraphnode]) neighbors  edge given node nodes neighbors  oj's undirected graph serialization (so understand error output): nodes labeled uniquely  use # separator node    separator node label neighbor node  medium depth-first search breadth-first search graph 
java bfs solution clone graph given head graph  return deep copy (clone) graph  node graph contains label (int) list (list[undirectedgraphnode]) neighbors  edge given node nodes neighbors  oj's undirected graph serialization (so understand error output): nodes labeled uniquely  use # separator node    separator node label neighbor node  medium depth-first search breadth-first search graph 
share some of my ideas  gas station n gas stations along circular route  amount gas station gas[i]  car unlimited gas tank costs cost[i] gas travel station next station (i+1)  begin journey empty tank one gas stations  return starting gas station's index travel around circuit clockwise direction  otherwise return -1  note: exists solution  guaranteed unique  input arrays non-empty length  element input arrays non-negative integer  medium greedy 
my ac is o(1) space o(n) running time solution  does anybody have posted this solution? gas station n gas stations along circular route  amount gas station gas[i]  car unlimited gas tank costs cost[i] gas travel station next station (i+1)  begin journey empty tank one gas stations  return starting gas station's index travel around circuit clockwise direction  otherwise return -1  note: exists solution  guaranteed unique  input arrays non-empty length  element input arrays non-negative integer  medium greedy 
proof of "if total gas is greater than total cost  there is a solution"  c++ gas station n gas stations along circular route  amount gas station gas[i]  car unlimited gas tank costs cost[i] gas travel station next station (i+1)  begin journey empty tank one gas stations  return starting gas station's index travel around circuit clockwise direction  otherwise return -1  note: exists solution  guaranteed unique  input arrays non-empty length  element input arrays non-negative integer  medium greedy 
my one pass solution  gas station n gas stations along circular route  amount gas station gas[i]  car unlimited gas tank costs cost[i] gas travel station next station (i+1)  begin journey empty tank one gas stations  return starting gas station's index travel around circuit clockwise direction  otherwise return -1  note: exists solution  guaranteed unique  input arrays non-empty length  element input arrays non-negative integer  medium greedy 
fully-commented o(n) c++ solution enabled by a single observation of mine gas station n gas stations along circular route  amount gas station gas[i]  car unlimited gas tank costs cost[i] gas travel station next station (i+1)  begin journey empty tank one gas stations  return starting gas station's index travel around circuit clockwise direction  otherwise return -1  note: exists solution  guaranteed unique  input arrays non-empty length  element input arrays non-negative integer  medium greedy 
a simple solution candy n children standing line  child assigned rating value  giving candies children subjected following requirements: child must least one candy  children higher rating get candies neighbors  minimum candies must give? hard greedy 
one-pass constant space java solution candy n children standing line  child assigned rating value  giving candies children subjected following requirements: child must least one candy  children higher rating get candies neighbors  minimum candies must give? hard greedy 
simple o(n) java solution with comments candy n children standing line  child assigned rating value  giving candies children subjected following requirements: child must least one candy  children higher rating get candies neighbors  minimum candies must give? hard greedy 
very simple java solution with detail explanation candy n children standing line  child assigned rating value  giving candies children subjected following requirements: child must least one candy  children higher rating get candies neighbors  minimum candies must give? hard greedy 
two c++ solutions given with explanation (both with o(n) time  one with o(1) space  the other with o(n) space) candy n children standing line  child assigned rating value  giving candies children subjected following requirements: child must least one candy  children higher rating get candies neighbors  minimum candies must give? hard greedy 
my o(n) solution using xor single number given non-empty array integers  every element appears twice except one  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? easy hash table bit manipulation 
easiest way to solve by using bit manipulation  single number given non-empty array integers  every element appears twice except one  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? easy hash table bit manipulation 
easy java solution (tell you why using bitwise xor) single number given non-empty array integers  every element appears twice except one  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? easy hash table bit manipulation 
python different solutions  single number given non-empty array integers  every element appears twice except one  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? easy hash table bit manipulation 
my very simple solution (linear time  no extra memory) single number given non-empty array integers  every element appears twice except one  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? easy hash table bit manipulation 
challenge me   thx single number ii given non-empty array integers  every element appears three times except one  appears exactly once  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? medium bit manipulation 
detailed explanation and generalization of the bitwise operation method for single numbers single number ii given non-empty array integers  every element appears three times except one  appears exactly once  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? medium bit manipulation 
an general way to handle all this sort of questions  single number ii given non-empty array integers  every element appears three times except one  appears exactly once  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? medium bit manipulation 
java o(n) easy to understand solution  easily extended to any times of occurance single number ii given non-empty array integers  every element appears three times except one  appears exactly once  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? medium bit manipulation 
accepted code with proper explaination  does anyone have a better idea? single number ii given non-empty array integers  every element appears three times except one  appears exactly once  find single one  note: algorithm linear runtime complexity  could implement without using extra memory? medium bit manipulation 
a solution with constant space complexity o(1) and linear time complexity o(n) copy list with random pointer linked list given node contains additional random pointer could point node list null  return deep copy list  medium hash table linked list 
java o(n) solution copy list with random pointer linked list given node contains additional random pointer could point node list null  return deep copy list  medium hash table linked list 
2 clean c++ algorithms without using extra array hash table   algorithms are explained step by step  copy list with random pointer linked list given node contains additional random pointer could point node list null  return deep copy list  medium hash table linked list 
clear and short python o(2n) and o(n) solution copy list with random pointer linked list given node contains additional random pointer could point node list null  return deep copy list  medium hash table linked list 
my accepted java code  o(n) but need to iterate the list 3 times copy list with random pointer linked list given node contains additional random pointer could point node list null  return deep copy list  medium hash table linked list 
java implementation using dp in two ways word break given non-empty string dictionary worddict containing list non-empty words  determine segmented space-separated sequence one dictionary words  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  medium dynamic programming 
c++ dynamic programming simple and fast solution (4ms) with optimization word break given non-empty string dictionary worddict containing list non-empty words  determine segmented space-separated sequence one dictionary words  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  medium dynamic programming 
a solution using bfs word break given non-empty string dictionary worddict containing list non-empty words  determine segmented space-separated sequence one dictionary words  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  medium dynamic programming 
simple dp solution in python with description word break given non-empty string dictionary worddict containing list non-empty words  determine segmented space-separated sequence one dictionary words  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  medium dynamic programming 
4 lines in python word break given non-empty string dictionary worddict containing list non-empty words  determine segmented space-separated sequence one dictionary words  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  medium dynamic programming 
my concise java solution based on memorized dfs word break ii given non-empty string dictionary worddict containing list non-empty words  add spaces construct sentence word valid dictionary word  return possible sentences  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  hard dynamic programming backtracking 
11ms c++ solution (concise) word break ii given non-empty string dictionary worddict containing list non-empty words  add spaces construct sentence word valid dictionary word  return possible sentences  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  hard dynamic programming backtracking 
getting rid of tle word break ii given non-empty string dictionary worddict containing list non-empty words  add spaces construct sentence word valid dictionary word  return possible sentences  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  hard dynamic programming backtracking 
9 lines python  10 lines c++ word break ii given non-empty string dictionary worddict containing list non-empty words  add spaces construct sentence word valid dictionary word  return possible sentences  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  hard dynamic programming backtracking 
python easy-to-understand solution word break ii given non-empty string dictionary worddict containing list non-empty words  add spaces construct sentence word valid dictionary word  return possible sentences  note: word dictionary may reused multiple times segmentation  may assume dictionary contain duplicate words  hard dynamic programming backtracking 
o(1) space solution linked list cycle given linked list  determine cycle it  follow up: solve without using extra space? easy linked list two pointers 
except-ionally fast python linked list cycle given linked list  determine cycle it  follow up: solve without using extra space? easy linked list two pointers 
my faster and slower runner solution linked list cycle given linked list  determine cycle it  follow up: solve without using extra space? easy linked list two pointers 
simple and easy understanding java solution  time  o(n)  space o(1) linked list cycle given linked list  determine cycle it  follow up: solve without using extra space? easy linked list two pointers 
by saying using no extra space  does it mean o(0) in space? linked list cycle given linked list  determine cycle it  follow up: solve without using extra space? easy linked list two pointers 
o(n) solution by using two pointers without change anything linked list cycle ii given linked list  return node cycle begins  cycle  return null  note: modify linked list  follow up: solve without using extra space? medium linked list two pointers 
concise o(n) solution by using c++ with detailed alogrithm description linked list cycle ii given linked list  return node cycle begins  cycle  return null  note: modify linked list  follow up: solve without using extra space? medium linked list two pointers 
java o(1) space solution with detailed explanation  linked list cycle ii given linked list  return node cycle begins  cycle  return null  note: modify linked list  follow up: solve without using extra space? medium linked list two pointers 
concise java solution based on slow fast pointers linked list cycle ii given linked list  return node cycle begins  cycle  return null  note: modify linked list  follow up: solve without using extra space? medium linked list two pointers 
share my python solution with detailed explanation linked list cycle ii given linked list  return node cycle begins  cycle  return null  note: modify linked list  follow up: solve without using extra space? medium linked list two pointers 
java solution with 3 steps reorder list given singly linked list l: l0→l1→…→ln-1→ln  reorder to: l0→ln→l1→ln-1→l2→ln-2→… may modify values list's nodes  nodes may changed  medium linked list 
a concise o(n) time  o(1) in place solution reorder list given singly linked list l: l0→l1→…→ln-1→ln  reorder to: l0→ln→l1→ln-1→l2→ln-2→… may modify values list's nodes  nodes may changed  medium linked list 
java solution with 3 steps reorder list given singly linked list l: l0→l1→…→ln-1→ln  reorder to: l0→ln→l1→ln-1→l2→ln-2→… may modify values list's nodes  nodes may changed  medium linked list 
a python solution o(n) time  o(1) space reorder list given singly linked list l: l0→l1→…→ln-1→ln  reorder to: l0→ln→l1→ln-1→l2→ln-2→… may modify values list's nodes  nodes may changed  medium linked list 
my o(n) c++ method  accepted reorder list given singly linked list l: l0→l1→…→ln-1→ln  reorder to: l0→ln→l1→ln-1→l2→ln-2→… may modify values list's nodes  nodes may changed  medium linked list 
accepted iterative solution in java using stack  binary tree preorder traversal given binary tree  return preorder traversal nodes' values  medium stack tree 
3 different solutions binary tree preorder traversal given binary tree  return preorder traversal nodes' values  medium stack tree 
accepted code  explaination with algo  binary tree preorder traversal given binary tree  return preorder traversal nodes' values  medium stack tree 
very simple iterative python solution binary tree preorder traversal given binary tree  return preorder traversal nodes' values  medium stack tree 
easy c++ solution using stack binary tree preorder traversal given binary tree  return preorder traversal nodes' values  medium stack tree 
preorder  inorder  and postorder iteratively summarization binary tree postorder traversal given binary tree  return postorder traversal nodes' values  hard stack tree 
my accepted code with explaination  does anyone have a better idea? binary tree postorder traversal given binary tree  return postorder traversal nodes' values  hard stack tree 
java simple and clean binary tree postorder traversal given binary tree  return postorder traversal nodes' values  hard stack tree 
c++ iterative  recursive and morris traversal binary tree postorder traversal given binary tree  return postorder traversal nodes' values  hard stack tree 
a very concise solution binary tree postorder traversal given binary tree  return postorder traversal nodes' values  hard stack tree 
[java] hashtable + double linked list (with a touch of pseudo nodes) lru cache design implement data structure least recently used (lru) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reached capacity  invalidate least recently used item inserting new item  follow up: could operations o(1) time complexity? hard design 
python dict + double linkedlist lru cache design implement data structure least recently used (lru) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reached capacity  invalidate least recently used item inserting new item  follow up: could operations o(1) time complexity? hard design 
laziest implementation: java's linkedhashmap takes care of everything lru cache design implement data structure least recently used (lru) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reached capacity  invalidate least recently used item inserting new item  follow up: could operations o(1) time complexity? hard design 
c++11 code 74ms - hash table + list lru cache design implement data structure least recently used (lru) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reached capacity  invalidate least recently used item inserting new item  follow up: could operations o(1) time complexity? hard design 
java-----------easy version to understand!!!! lru cache design implement data structure least recently used (lru) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reached capacity  invalidate least recently used item inserting new item  follow up: could operations o(1) time complexity? hard design 
an easy and clear way to sort ( o(1) space ) insertion sort list sort linked list using insertion sort  graphical medium linked list sort 
thoughts from a google interviewer insertion sort list sort linked list using insertion sort  graphical medium linked list sort 
explained c++ solution (24ms) insertion sort list sort linked list using insertion sort  graphical medium linked list sort 
accepted solution using java insertion sort list sort linked list using insertion sort  graphical medium linked list sort 
clean java solution using a fake head insertion sort list sort linked list using insertion sort  graphical medium linked list sort 
java merge sort solution sort list sort linked list o(n log n) time using constant space complexity  medium linked list sort 
bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity sort list sort linked list o(n log n) time using constant space complexity  medium linked list sort 
i have a pretty good mergesort method  can anyone speed up the run time or reduce the memory usage? sort list sort linked list o(n log n) time using constant space complexity  medium linked list sort 
basically  it seems like merge sort problem(really easy understand) sort list sort linked list o(n log n) time using constant space complexity  medium linked list sort 
clean python code sort list sort linked list o(n log n) time using constant space complexity  medium linked list sort 
a java solution with notes max points on a line given n points 2d plane  find maximum number points lie straight line  hard hash table math 
sharing my simple solution with explanation max points on a line given n points 2d plane  find maximum number points lie straight line  hard hash table math 
accepted java solution  easy to understand  max points on a line given n points 2d plane  find maximum number points lie straight line  hard hash table math 
c++ o(n^2) solution for your reference max points on a line given n points 2d plane  find maximum number points lie straight line  hard hash table math 
16ms 28ms c++ solutions with explanations max points on a line given n points 2d plane  find maximum number points lie straight line  hard hash table math 
6  uff08-132 uff09= 0 or -1 evaluate reverse polish notation evaluate value arithmetic expression reverse polish notation  valid operators +  -        operand may integer another expression  note: division two integers truncate toward zero  given rpn expression always valid  means expression would always evaluate result divide zero operation  medium stack 
[java] accepted code: stack implementation  evaluate reverse polish notation evaluate value arithmetic expression reverse polish notation  valid operators +  -        operand may integer another expression  note: division two integers truncate toward zero  given rpn expression always valid  means expression would always evaluate result divide zero operation  medium stack 
accepted clean java solution evaluate reverse polish notation evaluate value arithmetic expression reverse polish notation  valid operators +  -        operand may integer another expression  note: division two integers truncate toward zero  given rpn expression always valid  means expression would always evaluate result divide zero operation  medium stack 
fancy c++ lambda expression solution evaluate reverse polish notation evaluate value arithmetic expression reverse polish notation  valid operators +  -        operand may integer another expression  note: division two integers truncate toward zero  given rpn expression always valid  means expression would always evaluate result divide zero operation  medium stack 
python solution with comments (don't use eval() function)  evaluate reverse polish notation evaluate value arithmetic expression reverse polish notation  valid operators +  -        operand may integer another expression  note: division two integers truncate toward zero  given rpn expression always valid  means expression would always evaluate result divide zero operation  medium stack 
clean java two-pointers solution (no trim( )  no split( )  no stringbuilder) reverse words in a string given input string  reverse string word word  medium string 
in place simple solution reverse words in a string given input string  reverse string word word  medium string 
my accepted java solution reverse words in a string given input string  reverse string word word  medium string 
java 3-line builtin solution reverse words in a string given input string  reverse string word word  medium string 
c++ solution  in place: runtime o(n)  memory o(1) reverse words in a string given input string  reverse string word word  medium string 
possibly simplest solution with o(n) time complexity maximum product subarray given integer array nums  find contiguous subarray within array (containing least one number) largest product  medium array dynamic programming 
sharing my solution: o(1) space  o(n) running time maximum product subarray given integer array nums  find contiguous subarray within array (containing least one number) largest product  medium array dynamic programming 
simple java code maximum product subarray given integer array nums  find contiguous subarray within array (containing least one number) largest product  medium array dynamic programming 
share my c++ solution  maybe is the simplest solution maximum product subarray given integer array nums  find contiguous subarray within array (containing least one number) largest product  medium array dynamic programming 
in python  can it be more concise? maximum product subarray given integer array nums  find contiguous subarray within array (containing least one number) largest product  medium array dynamic programming 
compact and clean c++ solution find minimum in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  may assume duplicate exists array  medium array binary search 
4ms simple c++ code with explanation find minimum in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  may assume duplicate exists array  medium array binary search 
a concise solution with proof in the comment find minimum in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  may assume duplicate exists array  medium array binary search 
simplest and fastest c++ solution o(lg n)  you can't beat this! find minimum in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  may assume duplicate exists array  medium array binary search 
java solution with binary search find minimum in rotated sorted array suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  may assume duplicate exists array  medium array binary search 
my pretty simple code to solve it find minimum in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  array may contain duplicates  hard array binary search 
one simple and clear method with o(1) space and worst o(n) time find minimum in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  array may contain duplicates  hard array binary search 
super simple and clean java  binary search  find minimum in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  array may contain duplicates  hard array binary search 
stop wasting your time  it most likely has to be o(n)  find minimum in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  array may contain duplicates  hard array binary search 
only two more lines code on top of the solution for part i find minimum in rotated sorted array ii suppose array sorted ascending order rotated pivot unknown beforehand  (i e   [0 1 2 4 5 6 7] might become [4 5 6 7 0 1 2])  find minimum element  array may contain duplicates  hard array binary search 
share my java solution with only one stack min stack design stack supports push  pop  top  retrieving minimum element constant time  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  getmin() -- retrieve minimum element stack  easy stack design 
java accepted solution using one stack min stack design stack supports push  pop  top  retrieving minimum element constant time  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  getmin() -- retrieve minimum element stack  easy stack design 
clean 6ms java solution min stack design stack supports push  pop  top  retrieving minimum element constant time  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  getmin() -- retrieve minimum element stack  easy stack design 
c++ using two stacks  quite short and easy to understand min stack design stack supports push  pop  top  retrieving minimum element constant time  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  getmin() -- retrieve minimum element stack  easy stack design 
my python solution min stack design stack supports push  pop  top  retrieving minimum element constant time  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  getmin() -- retrieve minimum element stack  easy stack design 
java solution without knowing the difference in len! intersection of two linked lists write program find node intersection two singly linked lists begins  easy linked list 
my accepted simple and shortest c++ code with comments explaining the algorithm   any comments or improvements? intersection of two linked lists write program find node intersection two singly linked lists begins  easy linked list 
concise python code with comments intersection of two linked lists write program find node intersection two singly linked lists begins  easy linked list 
concise java solution  o(1) memory o(n) time intersection of two linked lists write program find node intersection two singly linked lists begins  easy linked list 
simple c++ solution (5 lines) intersection of two linked lists write program find node intersection two singly linked lists begins  easy linked list 
find the maximum by binary search (recursion and iteration) find peak element peak element element greater neighbors  given input array nums  nums[i] ≠ nums[i+1]  find peak element return index  array may contain multiple peaks  case return index one peaks fine  may imagine nums[-1] = nums[n] = -∞  medium array binary search 
o(logn) solution javacode find peak element peak element element greater neighbors  given input array nums  nums[i] ≠ nums[i+1]  find peak element return index  array may contain multiple peaks  case return index one peaks fine  may imagine nums[-1] = nums[n] = -∞  medium array binary search 
java solution and explanation using invariants find peak element peak element element greater neighbors  given input array nums  nums[i] ≠ nums[i+1]  find peak element return index  array may contain multiple peaks  case return index one peaks fine  may imagine nums[-1] = nums[n] = -∞  medium array binary search 
my clean and readable python solution find peak element peak element element greater neighbors  given input array nums  nums[i] ≠ nums[i+1]  find peak element return index  array may contain multiple peaks  case return index one peaks fine  may imagine nums[-1] = nums[n] = -∞  medium array binary search 
a concise standard binary search solution find peak element peak element element greater neighbors  given input array nums  nums[i] ≠ nums[i+1]  find peak element return index  array may contain multiple peaks  case return index one peaks fine  may imagine nums[-1] = nums[n] = -∞  medium array binary search 
[bucket sort] java solution with explanation  o(n) time and space maximum gap given unsorted array  find maximum difference successive elements sorted form  return 0 array contains less 2 elements  hard sort 
radix sort solution in java with explanation maximum gap given unsorted array  find maximum difference successive elements sorted form  return 0 array contains less 2 elements  hard sort 
pigeon hole principle maximum gap given unsorted array  find maximum difference successive elements sorted form  return 0 array contains less 2 elements  hard sort 
my c++ code (12 ms  "bucket sort"  o(n) time and space) maximum gap given unsorted array  find maximum difference successive elements sorted form  return 0 array contains less 2 elements  hard sort 
i solved it using radix sort maximum gap given unsorted array  find maximum difference successive elements sorted form  return 0 array contains less 2 elements  hard sort 
accepted small java solution  compare version numbers compare two version numbers version1 version2  version1 > version2 return 1; version1 < version2 return -1;otherwise return 0  may assume version strings non-empty contain digits   character    character represent decimal point used separate number sequences  instance  2 5 "two half" "half way version three"  fifth second-level revision second first-level revision  medium string 
my 2ms easy solution with c c++ compare version numbers compare two version numbers version1 version2  version1 > version2 return 1; version1 < version2 return -1;otherwise return 0  may assume version strings non-empty contain digits   character    character represent decimal point used separate number sequences  instance  2 5 "two half" "half way version three"  fifth second-level revision second first-level revision  medium string 
cudos on who invent such a boring question compare version numbers compare two version numbers version1 version2  version1 > version2 return 1; version1 < version2 return -1;otherwise return 0  may assume version strings non-empty contain digits   character    character represent decimal point used separate number sequences  instance  2 5 "two half" "half way version three"  fifth second-level revision second first-level revision  medium string 
my java solution without split compare version numbers compare two version numbers version1 version2  version1 > version2 return 1; version1 < version2 return -1;otherwise return 0  may assume version strings non-empty contain digits   character    character represent decimal point used separate number sequences  instance  2 5 "two half" "half way version three"  fifth second-level revision second first-level revision  medium string 
java solution with fewer if logic compare version numbers compare two version numbers version1 version2  version1 > version2 return 1; version1 < version2 return -1;otherwise return 0  may assume version strings non-empty contain digits   character    character represent decimal point used separate number sequences  instance  2 5 "two half" "half way version three"  fifth second-level revision second first-level revision  medium string 
my clean java solution fraction to recurring decimal given two integers representing numerator denominator fraction  return fraction string format  fractional part repeating  enclose repeating part parentheses  medium hash table math 
accepted cpp solution  with explainations fraction to recurring decimal given two integers representing numerator denominator fraction  return fraction string format  fractional part repeating  enclose repeating part parentheses  medium hash table math 
0ms c++ solution with detailed explanations fraction to recurring decimal given two integers representing numerator denominator fraction  return fraction string format  fractional part repeating  enclose repeating part parentheses  medium hash table math 
short java solution fraction to recurring decimal given two integers representing numerator denominator fraction  return fraction string format  fractional part repeating  enclose repeating part parentheses  medium hash table math 
accepted clean java solution fraction to recurring decimal given two integers representing numerator denominator fraction  return fraction string format  fractional part repeating  enclose repeating part parentheses  medium hash table math 
my 1 lines code in java  c++  and python excel sheet column title given positive integer  return corresponding column title appear excel sheet  easy math 
accepted java solution excel sheet column title given positive integer  return corresponding column title appear excel sheet  easy math 
python solution with explanation excel sheet column title given positive integer  return corresponding column title appear excel sheet  easy math 
share my simple solution  just a little trick to handle corner case 26 excel sheet column title given positive integer  return corresponding column title appear excel sheet  easy math 
my easy to understand java solution excel sheet column title given positive integer  return corresponding column title appear excel sheet  easy math 
o(n) time o(1) space fastest solution majority element given array size n  find majority element  majority element element appears ⌊ n 2 ⌋ times  may assume array non-empty majority element always exist array  easy array divide and conquer bit manipulation 
6 suggested solutions in c++ with explanations majority element given array size n  find majority element  majority element element appears ⌊ n 2 ⌋ times  may assume array non-empty majority element always exist array  easy array divide and conquer bit manipulation 
java solutions (sorting  hashmap  moore voting  bit manipulation)  majority element given array size n  find majority element  majority element element appears ⌊ n 2 ⌋ times  may assume array non-empty majority element always exist array  easy array divide and conquer bit manipulation 
one line solution in python majority element given array size n  find majority element  majority element element appears ⌊ n 2 ⌋ times  may assume array non-empty majority element always exist array  easy array divide and conquer bit manipulation 
share my solution [java] - count bits majority element given array size n  find majority element  majority element element appears ⌊ n 2 ⌋ times  may assume array non-empty majority element always exist array  easy array divide and conquer bit manipulation 
my solutions in 3 languages  does any one have one line solution in java or c++? excel sheet column number given column title appear excel sheet  return corresponding column number  easy math 
asked this question on an interview excel sheet column number given column title appear excel sheet  return corresponding column number  easy math 
here is my java solution excel sheet column number given column title appear excel sheet  return corresponding column number  easy math 
my 2ms java solution excel sheet column number given column title appear excel sheet  return corresponding column number  easy math 
explanation in python excel sheet column number given column title appear excel sheet  return corresponding column number  easy math 
my one-line solutions in 3 languages factorial trailing zeroes given integer n  return number trailing zeroes n!  easy math 
simple c c++ solution (with detailed explaination) factorial trailing zeroes given integer n  return number trailing zeroes n!  easy math 
my explanation of the log(n) solution factorial trailing zeroes given integer n  return number trailing zeroes n!  easy math 
o(log_5(n)) solution  java factorial trailing zeroes given integer n  return number trailing zeroes n!  easy math 
4-lines 4ms c++ solution with explanations factorial trailing zeroes given integer n  return number trailing zeroes n!  easy math 
my solutions in 3 languages with stack binary search tree iterator implement iterator binary search tree (bst)  iterator initialized root node bst  calling next() return next smallest number bst  note: next() hasnext() run average o(1) time uses o(h) memory  h height tree  credits:special thanks @ts adding problem creating test cases  medium stack tree design 
ideal solution using stack (java) binary search tree iterator implement iterator binary search tree (bst)  iterator initialized root node bst  calling next() return next smallest number bst  note: next() hasnext() run average o(1) time uses o(h) memory  h height tree  credits:special thanks @ts adding problem creating test cases  medium stack tree design 
my java accepted solution binary search tree iterator implement iterator binary search tree (bst)  iterator initialized root node bst  calling next() return next smallest number bst  note: next() hasnext() run average o(1) time uses o(h) memory  h height tree  credits:special thanks @ts adding problem creating test cases  medium stack tree design 
my solution in c++  in average o(1) time and uses o(h) memory binary search tree iterator implement iterator binary search tree (bst)  iterator initialized root node bst  calling next() return next smallest number bst  note: next() hasnext() run average o(1) time uses o(h) memory  h height tree  credits:special thanks @ts adding problem creating test cases  medium stack tree design 
two python solutions  stack and generator binary search tree iterator implement iterator binary search tree (bst)  iterator initialized root node bst  calling next() return next smallest number bst  note: next() hasnext() run average o(1) time uses o(h) memory  h height tree  credits:special thanks @ts adding problem creating test cases  medium stack tree design 
c++ dp solution dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } demons captured princess (p) imprisoned bottom-right corner dungeon  dungeon consists x n rooms laid 2d grid  valiant knight (k) initially positioned top-left room must fight way dungeon rescue princess  knight initial health point represented positive integer  point health point drops 0 below  dies immediately  rooms guarded demons  knight loses health (negative integers) upon entering rooms; rooms either empty (0's) contain magic orbs increase knight's health (positive integers)  order reach princess quickly possible  knight decides move rightward downward step  write function determine knight's minimum initial health able rescue princess  hard binary search dynamic programming 
my ac java version  suggestions are welcome dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } demons captured princess (p) imprisoned bottom-right corner dungeon  dungeon consists x n rooms laid 2d grid  valiant knight (k) initially positioned top-left room must fight way dungeon rescue princess  knight initial health point represented positive integer  point health point drops 0 below  dies immediately  rooms guarded demons  knight loses health (negative integers) upon entering rooms; rooms either empty (0's) contain magic orbs increase knight's health (positive integers)  order reach princess quickly possible  knight decides move rightward downward step  write function determine knight's minimum initial health able rescue princess  hard binary search dynamic programming 
best solution i have found with explanations dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } demons captured princess (p) imprisoned bottom-right corner dungeon  dungeon consists x n rooms laid 2d grid  valiant knight (k) initially positioned top-left room must fight way dungeon rescue princess  knight initial health point represented positive integer  point health point drops 0 below  dies immediately  rooms guarded demons  knight loses health (negative integers) upon entering rooms; rooms either empty (0's) contain magic orbs increase knight's health (positive integers)  order reach princess quickly possible  knight decides move rightward downward step  write function determine knight's minimum initial health able rescue princess  hard binary search dynamic programming 
my java solution with explanation in detail dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } demons captured princess (p) imprisoned bottom-right corner dungeon  dungeon consists x n rooms laid 2d grid  valiant knight (k) initially positioned top-left room must fight way dungeon rescue princess  knight initial health point represented positive integer  point health point drops 0 below  dies immediately  rooms guarded demons  knight loses health (negative integers) upon entering rooms; rooms either empty (0's) contain magic orbs increase knight's health (positive integers)  order reach princess quickly possible  knight decides move rightward downward step  write function determine knight's minimum initial health able rescue princess  hard binary search dynamic programming 
sharing my solution with o(n) space  o(mn) runtime dungeon game table dungeon   dungeon th   dungeon td { border:3px solid black; }  dungeon th   dungeon td { text-align: center; height: 70px; width: 70px; } demons captured princess (p) imprisoned bottom-right corner dungeon  dungeon consists x n rooms laid 2d grid  valiant knight (k) initially positioned top-left room must fight way dungeon rescue princess  knight initial health point represented positive integer  point health point drops 0 below  dies immediately  rooms guarded demons  knight loses health (negative integers) upon entering rooms; rooms either empty (0's) contain magic orbs increase knight's health (positive integers)  order reach princess quickly possible  knight decides move rightward downward step  write function determine knight's minimum initial health able rescue princess  hard binary search dynamic programming 
its a simple question of left join  my solution attached combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid primary key column table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid primary key column table  write sql query report provides following information person person table  regardless address people: firstname  lastname  city  state easy 
comparative solution between left join  left join using and natural left join combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid primary key column table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid primary key column table  write sql query report provides following information person person table  regardless address people: firstname  lastname  city  state easy 
why cannot using where combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid primary key column table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid primary key column table  write sql query report provides following information person person table  regardless address people: firstname  lastname  city  state easy 
my solution and question with union combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid primary key column table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid primary key column table  write sql query report provides following information person person table  regardless address people: firstname  lastname  city  state easy 
so watch your capitalization carefully uff01 combine two tables sql schematable: person +-------------+---------+ | column name | type | +-------------+---------+ | personid | int | | firstname | varchar | | lastname | varchar | +-------------+---------+ personid primary key column table  table: address +-------------+---------+ | column name | type | +-------------+---------+ | addressid | int | | personid | int | | city | varchar | | state | varchar | +-------------+---------+ addressid primary key column table  write sql query report provides following information person person table  regardless address people: firstname  lastname  city  state easy 
simple query which handles the null situation second highest salary sql schemawrite sql query get second highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ easy 
a simple answer second highest salary sql schemawrite sql query get second highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ easy 
accepted solution second highest salary sql schemawrite sql query get second highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ easy 
my tidy soution second highest salary sql schemawrite sql query get second highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ easy 
simple solution second highest salary sql schemawrite sql query get second highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ easy 
accpted solution for the nth highest salary nth highest salary write sql query get nth highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ medium 
my accepted simply solution any advising? nth highest salary write sql query get nth highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ medium 
no variable  no limit x 1  just one query  808ms nth highest salary write sql query get nth highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ medium 
why using limit n-1 1 will cause error? nth highest salary write sql query get nth highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ medium 
accepted solution of nth highest salary nth highest salary write sql query get nth highest salary employee table  +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ medium 
simple  short  fast rank scores sql schemawrite sql query rank scores  tie two scores  ranking  note tie  next ranking number next consecutive integer value  words  "holes" ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ medium 
accepted solution using innerjoin and groupby rank scores sql schemawrite sql query rank scores  tie two scores  ranking  note tie  next ranking number next consecutive integer value  words  "holes" ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ medium 
maybe the simpest solution rank scores sql schemawrite sql query rank scores  tie two scores  ranking  note tie  next ranking number next consecutive integer value  words  "holes" ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ medium 
accepted solution with subqueries and group by rank scores sql schemawrite sql query rank scores  tie two scores  ranking  note tie  next ranking number next consecutive integer value  words  "holes" ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ medium 
accepted solution with subquery for rank rank scores sql schemawrite sql query rank scores  tie two scores  ranking  note tie  next ranking number next consecutive integer value  words  "holes" ranks  +----+-------+ | id | score | +----+-------+ | 1 | 3 50 | | 2 | 3 65 | | 3 | 4 00 | | 4 | 3 85 | | 5 | 4 00 | | 6 | 3 65 | +----+-------+ medium 
my java solution to share largest number given list non negative integers  arrange form largest number  medium sort 
a simple c++ solution largest number given list non negative integers  arrange form largest number  medium sort 
my 3-lines code in java and python largest number given list non negative integers  arrange form largest number  medium sort 
share a short code in c++ largest number given list non negative integers  arrange form largest number  medium sort 
python simple solution in 4 lines largest number given list non negative integers  arrange form largest number  medium sort 
simple solution consecutive numbers sql schemawrite sql query find numbers appear least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ medium 
solution with user defined variables consecutive numbers sql schemawrite sql query find numbers appear least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ medium 
an ugly solution consecutive numbers sql schemawrite sql query find numbers appear least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ medium 
accepted solution without joins (works in n-consecutive cases with slight modification) consecutive numbers sql schemawrite sql query find numbers appear least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ medium 
simple sql with join  1484 ms consecutive numbers sql schemawrite sql query find numbers appear least three times consecutively  +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ medium 
a straightforward method employees earning more than their managers sql schemathe employee table holds employees including managers  every employee id  also column manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given employee table  write sql query finds employees earn managers  table  joe employee earns manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
sharing my solution~   simple and easy to understand employees earning more than their managers sql schemathe employee table holds employees including managers  every employee id  also column manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given employee table  write sql query finds employees earn managers  table  joe employee earns manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
sharing my solution employees earning more than their managers sql schemathe employee table holds employees including managers  every employee id  also column manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given employee table  write sql query finds employees earn managers  table  joe employee earns manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
an easy solution to this question  employees earning more than their managers sql schemathe employee table holds employees including managers  every employee id  also column manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given employee table  write sql query finds employees earn managers  table  joe employee earns manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
two straightforward way  using 'where' and 'join' employees earning more than their managers sql schemathe employee table holds employees including managers  every employee id  also column manager id  +----+-------+--------+-----------+ | id | name | salary | managerid | +----+-------+--------+-----------+ | 1 | joe | 70000 | 3 | | 2 | henry | 80000 | 4 | | 3 | sam | 60000 | null | | 4 | max | 90000 | null | +----+-------+--------+-----------+ given employee table  write sql query finds employees earn managers  table  joe employee earns manager  +----------+ | employee | +----------+ | joe | +----------+ easy 
i have this simple approach  anybody has some other way duplicate emails sql schemawrite sql query find duplicate emails table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ easy 
my simple accepted solution duplicate emails sql schemawrite sql query find duplicate emails table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ easy 
a solution using a group by and another one using a self join duplicate emails sql schemawrite sql query find duplicate emails table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ easy 
share my solution duplicate emails sql schemawrite sql query find duplicate emails table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ easy 
simple solution use group by duplicate emails sql schemawrite sql query find duplicate emails table named person  +----+---------+ | id | email | +----+---------+ | 1 | a@b com | | 2 | c@d com | | 3 | a@b com | +----+---------+ easy 
three accepted solutions customers who never order sql schemasuppose website contains two tables  customers table orders table  write sql query find customers never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using tables easy 
a solution using not in and another one using left join customers who never order sql schemasuppose website contains two tables  customers table orders table  write sql query find customers never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using tables easy 
here are 3 solutions customers who never order sql schemasuppose website contains two tables  customers table orders table  write sql query find customers never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using tables easy 
share my first db answer customers who never order sql schemasuppose website contains two tables  customers table orders table  write sql query find customers never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using tables easy 
mysql solution using not in customers who never order sql schemasuppose website contains two tables  customers table orders table  write sql query find customers never order anything  table: customers  +----+-------+ | id | name | +----+-------+ | 1 | joe | | 2 | henry | | 3 | sam | | 4 | max | +----+-------+ table: orders  +----+------------+ | id | customerid | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ using tables easy 
three accpeted solutions department highest salary sql schemathe employee table holds employees  every employee id  salary  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees highest salary departments  tables  max highest salary department henry highest salary sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
simple solution  easy to understand department highest salary sql schemathe employee table holds employees  every employee id  salary  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees highest salary departments  tables  max highest salary department henry highest salary sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
sharing my simple solution department highest salary sql schemathe employee table holds employees  every employee id  salary  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees highest salary departments  tables  max highest salary department henry highest salary sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
group by having not working for multiple highest salary  why? department highest salary sql schemathe employee table holds employees  every employee id  salary  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees highest salary departments  tables  max highest salary department henry highest salary sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
why cannot we just use max() with group by? department highest salary sql schemathe employee table holds employees  every employee id  salary  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees highest salary departments  tables  max highest salary department henry highest salary sales department  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | sales | henry | 80000 | +------------+----------+--------+ medium 
accepted solution without group by or order by department top three salaries sql schemathe employee table holds employees  every employee id  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees earn top three salaries department  tables  sql query return following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | | randy | 85000 | | | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
my tidy solution department top three salaries sql schemathe employee table holds employees  every employee id  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees earn top three salaries department  tables  sql query return following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | | randy | 85000 | | | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
simple solution  easy to understand department top three salaries sql schemathe employee table holds employees  every employee id  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees earn top three salaries department  tables  sql query return following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | | randy | 85000 | | | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
best solution  clean  easy  no subquery department top three salaries sql schemathe employee table holds employees  every employee id  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees earn top three salaries department  tables  sql query return following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | | randy | 85000 | | | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
simple solution for 1112 ms department top three salaries sql schemathe employee table holds employees  every employee id  also column department id  +----+-------+--------+--------------+ | id | name | salary | departmentid | +----+-------+--------+--------------+ | 1 | joe | 70000 | 1 | | 2 | henry | 80000 | 2 | | 3 | sam | 60000 | 2 | | 4 | max | 90000 | 1 | | 5 | janet | 69000 | 1 | | 6 | randy | 85000 | 1 | +----+-------+--------+--------------+ department table holds departments company  +----+----------+ | id | name | +----+----------+ | 1 | | | 2 | sales | +----+----------+ write sql query find employees earn top three salaries department  tables  sql query return following rows  +------------+----------+--------+ | department | employee | salary | +------------+----------+--------+ | | max | 90000 | | | randy | 85000 | | | joe | 70000 | | sales | henry | 80000 | | sales | sam | 60000 | +------------+----------+--------+ hard 
7 lines simple java  o(n) repeated dna sequences dna composed series nucleotides abbreviated a  c  g  t  medium hash table bit manipulation 
clean java solution (hashmap + bits manipulation) repeated dna sequences dna composed series nucleotides abbreviated a  c  g  t  medium hash table bit manipulation 
i did it in 10 lines of c++ repeated dna sequences dna composed series nucleotides abbreviated a  c  g  t  medium hash table bit manipulation 
short java "rolling-hash" solution repeated dna sequences dna composed series nucleotides abbreviated a  c  g  t  medium hash table bit manipulation 
20 ms solution (c++) with explanation repeated dna sequences dna composed series nucleotides abbreviated a  c  g  t  medium hash table bit manipulation 
a concise dp solution in java best time to buy and sell stock iv say array ith element price given stock day i  design algorithm find maximum profit  may complete k transactions  note: may engage multiple transactions time (ie  must sell stock buy again)  hard dynamic programming 
clean java dp solution with comment best time to buy and sell stock iv say array ith element price given stock day i  design algorithm find maximum profit  may complete k transactions  note: may engage multiple transactions time (ie  must sell stock buy again)  hard dynamic programming 
c++ solution with o(n + klgn) time using max heap and stack best time to buy and sell stock iv say array ith element price given stock day i  design algorithm find maximum profit  may complete k transactions  note: may engage multiple transactions time (ie  must sell stock buy again)  hard dynamic programming 
share my c++ dp solution with o(kn) time o(k) space  10ms best time to buy and sell stock iv say array ith element price given stock day i  design algorithm find maximum profit  may complete k transactions  note: may engage multiple transactions time (ie  must sell stock buy again)  hard dynamic programming 
easy understanding and can be easily modified to different situations java solution best time to buy and sell stock iv say array ith element price given stock day i  design algorithm find maximum profit  may complete k transactions  note: may engage multiple transactions time (ie  must sell stock buy again)  hard dynamic programming 
easy to read java solution rotate array given array  rotate array right k steps  k non-negative  easy array 
summary of c++ solutions rotate array given array  rotate array right k steps  k non-negative  easy array 
java o(1) space solution of rotate array  rotate array given array  rotate array right k steps  k non-negative  easy array 
3-line using reverse rotate array given array  rotate array right k steps  k non-negative  easy array 
my solution by using python rotate array given array  rotate array right k steps  k non-negative  easy array 
o(1) bit operation c++ solution (8ms) reverse bits reverse bits given 32 bits unsigned integer  easy bit manipulation 
java solution and optimization reverse bits reverse bits given 32 bits unsigned integer  easy bit manipulation 
sharing my 2ms java solution with explanation reverse bits reverse bits given 32 bits unsigned integer  easy bit manipulation 
my 3ms pure c solution reverse bits reverse bits given 32 bits unsigned integer  easy bit manipulation 
the concise c++ solution(9ms) reverse bits reverse bits given 32 bits unsigned integer  easy bit manipulation 
simple java solution  bit shifting number of 1 bits write function takes unsigned integer returns number '1' bits (also known hamming weight)  easy bit manipulation 
short code of c++  o(m) by time  m is the count of 1's   and another several method of o(1) time number of 1 bits write function takes unsigned integer returns number '1' bits (also known hamming weight)  easy bit manipulation 
c++ solution: n & (n - 1) number of 1 bits write function takes unsigned integer returns number '1' bits (also known hamming weight)  easy bit manipulation 
readable simple java solution o(1) number of 1 bits write function takes unsigned integer returns number '1' bits (also known hamming weight)  easy bit manipulation 
use n=n&(n-1) trick to clear the least bit number of 1 bits write function takes unsigned integer returns number '1' bits (also known hamming weight)  easy bit manipulation 
my simple solution (one line with pipe) word frequency write bash script calculate frequency word text file words txt  simplicity sake  may assume: words txt contains lowercase characters space ' ' characters  word must consist lowercase characters only  words separated one whitespace characters  medium 
solution using awk and pipes with explaination word frequency write bash script calculate frequency word text file words txt  simplicity sake  may assume: words txt contains lowercase characters space ' ' characters  word must consist lowercase characters only  words separated one whitespace characters  medium 
my accepted answer using tr  sort  uniq and awk word frequency write bash script calculate frequency word text file words txt  simplicity sake  may assume: words txt contains lowercase characters space ' ' characters  word must consist lowercase characters only  words separated one whitespace characters  medium 
share my accepted solution  using awk and sort! word frequency write bash script calculate frequency word text file words txt  simplicity sake  may assume: words txt contains lowercase characters space ' ' characters  word must consist lowercase characters only  words separated one whitespace characters  medium 
my 16ms unix-pipe cat+tr+awk+sort+(hash) solution word frequency write bash script calculate frequency word text file words txt  simplicity sake  may assume: words txt contains lowercase characters space ' ' characters  word must consist lowercase characters only  words separated one whitespace characters  medium 
three different solutions using grep  sed  and awk valid phone numbers given text file file txt contains list phone numbers (one per line)  write one liner bash script print valid phone numbers  may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx  (x means digit) may also assume line text file must contain leading trailing white spaces  easy 
grep -e solution with detailed explanation  good for those new to regex valid phone numbers given text file file txt contains list phone numbers (one per line)  write one liner bash script print valid phone numbers  may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx  (x means digit) may also assume line text file must contain leading trailing white spaces  easy 
simple solution using awk valid phone numbers given text file file txt contains list phone numbers (one per line)  write one liner bash script print valid phone numbers  may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx  (x means digit) may also assume line text file must contain leading trailing white spaces  easy 
my "grep -e" solution valid phone numbers given text file file txt contains list phone numbers (one per line)  write one liner bash script print valid phone numbers  may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx  (x means digit) may also assume line text file must contain leading trailing white spaces  easy 
my easy understand grep -e solution valid phone numbers given text file file txt contains list phone numbers (one per line)  write one liner bash script print valid phone numbers  may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx  (x means digit) may also assume line text file must contain leading trailing white spaces  easy 
ac solution using awk and statement just like c  transpose file given text file file txt  transpose content  may assume row number columns field separated ' ' character  medium 
simple bash solution that oj hates transpose file given text file file txt  transpose content  may assume row number columns field separated ' ' character  medium 
solution using awk with explanations transpose file given text file file txt  transpose content  may assume row number columns field separated ' ' character  medium 
my 28ms awk solution transpose file given text file file txt  transpose content  may assume row number columns field separated ' ' character  medium 
memory limit exceeded transpose file given text file file txt  transpose content  may assume row number columns field separated ' ' character  medium 
share four different solutions tenth line given text file file txt  print 10th line file  easy 
super simple solution tenth line given text file file txt  print 10th line file  easy 
my three simple solutions tenth line given text file file txt  print 10th line file  easy 
a generalized approach with head tail tenth line given text file file txt  print 10th line file  easy 
simple solution using awk tenth line given text file file txt  print 10th line file  easy 
simple solution delete duplicate emails write sql query delete duplicate email entries table named person  keeping unique emails based smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
a skillful mysql solution  avoid " select and update conflict" delete duplicate emails write sql query delete duplicate email entries table named person  keeping unique emails based smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
solution in a single query without any conflicts delete duplicate emails write sql query delete duplicate email entries table named person  keeping unique emails based smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
i can't believe i get it wrong! what's wrong with my code? delete duplicate emails write sql query delete duplicate email entries table named person  keeping unique emails based smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
a simple ac solution  delete duplicate emails write sql query delete duplicate email entries table named person  keeping unique emails based smallest id  +----+------------------+ | id | email | +----+------------------+ | 1 | john@ easy 
simple solution rising temperature sql schemagiven weather table  write sql query find dates' ids higher temperature compared previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ easy 
my simple solution using inner join rising temperature sql schemagiven weather table  write sql query find dates' ids higher temperature compared previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ easy 
two solutions           rising temperature sql schemagiven weather table  write sql query find dates' ids higher temperature compared previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ easy 
my simple solution rising temperature sql schemagiven weather table  write sql query find dates' ids higher temperature compared previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ easy 
why is subtracting 1 directly from date not working  but subdate(a date 1) works? rising temperature sql schemagiven weather table  write sql query find dates' ids higher temperature compared previous (yesterday's) dates  +---------+------------------+------------------+ | id(int) | recorddate(date) | temperature(int) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ easy 
from good to great  how to approach most of dp problems  house robber professional robber planning rob houses along street  house certain amount money stashed  constraint stopping robbing adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  easy dynamic programming 
c 1ms  o(1)space   very simple solution house robber professional robber planning rob houses along street  house certain amount money stashed  constraint stopping robbing adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  easy dynamic programming 
java o(n) solution  space o(1) house robber professional robber planning rob houses along street  house certain amount money stashed  constraint stopping robbing adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  easy dynamic programming 
python solution  3 lines  house robber professional robber planning rob houses along street  house certain amount money stashed  constraint stopping robbing adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  easy dynamic programming 
java dp solution  o(n) runtime and o(1) space  with inline comment house robber professional robber planning rob houses along street  house certain amount money stashed  constraint stopping robbing adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  easy dynamic programming 
my simple accepted solution(java) binary tree right side view given binary tree  imagine standing right side it  return values nodes see ordered top bottom  medium tree depth-first search breadth-first search 
my c++ solution  modified preorder traversal binary tree right side view given binary tree  imagine standing right side it  return values nodes see ordered top bottom  medium tree depth-first search breadth-first search 
reverse level order traversal  java binary tree right side view given binary tree  imagine standing right side it  return values nodes see ordered top bottom  medium tree depth-first search breadth-first search 
5-9 lines python  48+ ms binary tree right side view given binary tree  imagine standing right side it  return values nodes see ordered top bottom  medium tree depth-first search breadth-first search 
simple c++ solution (btw: i like clean codes) binary tree right side view given binary tree  imagine standing right side it  return values nodes see ordered top bottom  medium tree depth-first search breadth-first search 
very concise java ac solution number of islands given 2d grid map '1's (land) '0's (water)  count number islands  island surrounded water formed connecting adjacent lands horizontally vertically  may assume four edges grid surrounded water  medium depth-first search breadth-first search union find 
7 lines python  ~14 lines java number of islands given 2d grid map '1's (land) '0's (water)  count number islands  island surrounded water formed connecting adjacent lands horizontally vertically  may assume four edges grid surrounded water  medium depth-first search breadth-first search union find 
1d union find java solution  easily generalized to other problems number of islands given 2d grid map '1's (land) '0's (water)  count number islands  island surrounded water formed connecting adjacent lands horizontally vertically  may assume four edges grid surrounded water  medium depth-first search breadth-first search union find 
python simple dfs solution number of islands given 2d grid map '1's (land) '0's (water)  count number islands  island surrounded water formed connecting adjacent lands horizontally vertically  may assume four edges grid surrounded water  medium depth-first search breadth-first search union find 
simple java solution number of islands given 2d grid map '1's (land) '0's (water)  count number islands  island surrounded water formed connecting adjacent lands horizontally vertically  may assume four edges grid surrounded water  medium depth-first search breadth-first search union find 
bit operation solution(java) bitwise and of numbers range given range [m  n] 0 <= <= n <= 2147483647  return bitwise numbers range  inclusive  medium bit manipulation 
one line c++ solution bitwise and of numbers range given range [m  n] 0 <= <= n <= 2147483647  return bitwise numbers range  inclusive  medium bit manipulation 
2 line solution with detailed explanation bitwise and of numbers range given range [m  n] 0 <= <= n <= 2147483647  return bitwise numbers range  inclusive  medium bit manipulation 
java python easy solution with explanation bitwise and of numbers range given range [m  n] 0 <= <= n <= 2147483647  return bitwise numbers range  inclusive  medium bit manipulation 
my simple java solution(3 lines) bitwise and of numbers range given range [m  n] 0 <= <= n <= 2147483647  return bitwise numbers range  inclusive  medium bit manipulation 
3 line recursive solution remove linked list elements remove elements linked list integers value val  easy linked list 
ac java solution remove linked list elements remove elements linked list integers value val  easy linked list 
iterative short java solution remove linked list elements remove elements linked list integers value val  easy linked list 
accepted 7 line clean java solution remove linked list elements remove elements linked list integers value val  easy linked list 
simple and elegant solution in c++ remove linked list elements remove elements linked list integers value val  easy linked list 
my simple java solution count primes count number prime numbers less non-negative number  n  easy hash table math 
fast python solution count primes count number prime numbers less non-negative number  n  easy hash table math 
my easy one round c++ code count primes count number prime numbers less non-negative number  n  easy hash table math 
12 ms java solution modified from the hint method  beats 99 95% count primes count number prime numbers less non-negative number  n  easy hash table math 
short c++ sieve of eratosthenes solution count primes count number prime numbers less non-negative number  n  easy hash table math 
my 6 lines solution isomorphic strings given two strings t  determine isomorphic  two strings isomorphic characters replaced get t  occurrences character must replaced another character preserving order characters  two characters may map character character may map itself  easy hash table 
python different solutions (dictionary  etc)  isomorphic strings given two strings t  determine isomorphic  two strings isomorphic characters replaced get t  occurrences character must replaced another character preserving order characters  two characters may map character character may map itself  easy hash table 
short java solution without maps isomorphic strings given two strings t  determine isomorphic  two strings isomorphic characters replaced get t  occurrences character must replaced another character preserving order characters  two characters may map character character may map itself  easy hash table 
java solution using hashmap isomorphic strings given two strings t  determine isomorphic  two strings isomorphic characters replaced get t  occurrences character must replaced another character preserving order characters  two characters may map character character may map itself  easy hash table 
java solution with 1 line core code isomorphic strings given two strings t  determine isomorphic  two strings isomorphic characters replaced get t  occurrences character must replaced another character preserving order characters  two characters may map character character may map itself  easy hash table 
in-place iterative and recursive java solution reverse linked list reverse singly linked list  easy linked list 
c++ iterative and recursive reverse linked list reverse singly linked list  easy linked list 
python iterative and recursive solution reverse linked list reverse singly linked list  easy linked list 
my java recursive solution reverse linked list reverse singly linked list  easy linked list 
accepted c solutions both iteratively and recursively reverse linked list reverse singly linked list  easy linked list 
18-22 lines c++ bfs dfs solutions course schedule total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
easy bfs topological sort  java course schedule total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
java dfs and bfs solution course schedule total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
python 20 lines dfs solution sharing with explanation course schedule total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
java---------easy version to understand!!!!!!!!!!!!!!!!! course schedule total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
ac java solution simple using single array implement trie (prefix tree) implement trie insert  search  startswith methods  medium design trie 
maybe the code is not too much by using "next[26]"  c++ implement trie (prefix tree) implement trie insert  search  startswith methods  medium design trie 
ac python solution implement trie (prefix tree) implement trie insert  search  startswith methods  medium design trie 
my python solution implement trie (prefix tree) implement trie insert  search  startswith methods  medium design trie 
c++  my solution   easy to understand:) implement trie (prefix tree) implement trie insert  search  startswith methods  medium design trie 
accepted clean java o(n) solution (two pointers) minimum size subarray sum given array n positive integers positive integer s  find minimal length contiguous subarray sum ≥ s  one  return 0 instead  medium array two pointers binary search 
two ac solutions in java with time complexity of n and nlogn with explanation minimum size subarray sum given array n positive integers positive integer s  find minimal length contiguous subarray sum ≥ s  one  return 0 instead  medium array two pointers binary search 
4ms o(n)   8ms o(nlogn) c++ minimum size subarray sum given array n positive integers positive integer s  find minimal length contiguous subarray sum ≥ s  one  return 0 instead  medium array two pointers binary search 
o(n) o(nlogn) solutions  both o(1) space minimum size subarray sum given array n positive integers positive integer s  find minimal length contiguous subarray sum ≥ s  one  return 0 instead  medium array two pointers binary search 
o(n)  template for minimum size subarray sum & minimum window substring & longest substring without repeating characters minimum size subarray sum given array n positive integers positive integer s  find minimal length contiguous subarray sum ≥ s  one  return 0 instead  medium array two pointers binary search 
two ac solution in java using bfs and dfs with explanation course schedule ii total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
20+ lines c++ bfs dfs solutions course schedule ii total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
concise java solution based on bfs with comments course schedule ii total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
python dfs  bfs solutions with comments  course schedule ii total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
java dfs double cache visiting each vertex once 433ms course schedule ii total n courses take  labeled 0 n-1  courses may prerequisites  medium depth-first search breadth-first search graph topological sort 
my simple and clean java code add and search word - data structure design design data structure supports following two operations: void addword(word) bool search(word) search(word) search literal word regular expression string containing letters a-z      means represent one letter  medium backtracking design trie 
80ms clear c++ code with detailed explanations add and search word - data structure design design data structure supports following two operations: void addword(word) bool search(word) search(word) search literal word regular expression string containing letters a-z      means represent one letter  medium backtracking design trie 
python 168ms-beat-100% solution add and search word - data structure design design data structure supports following two operations: void addword(word) bool search(word) search(word) search literal word regular expression string containing letters a-z      means represent one letter  medium backtracking design trie 
tree solutions  18-20 lines add and search word - data structure design design data structure supports following two operations: void addword(word) bool search(word) search(word) search literal word regular expression string containing letters a-z      means represent one letter  medium backtracking design trie 
my java trie based solution add and search word - data structure design design data structure supports following two operations: void addword(word) bool search(word) search(word) search literal word regular expression string containing letters a-z      means represent one letter  medium backtracking design trie 
java 15ms easiest solution (100 00%) word search ii given 2d board list words dictionary  find words board  word must constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used word  hard backtracking trie 
my simple and clean java code using dfs and trie word search ii given 2d board list words dictionary  find words board  word must constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used word  hard backtracking trie 
test case [a]  [a  a] doesn't make sense? word search ii given 2d board list words dictionary  find words board  word must constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used word  hard backtracking trie 
python code use trie and dfs 380ms word search ii given 2d board list words dictionary  find words board  word must constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used word  hard backtracking trie 
27 lines  uses complex numbers word search ii given 2d board list words dictionary  find words board  word must constructed letters sequentially adjacent cell  "adjacent" cells horizontally vertically neighboring  letter cell may used word  hard backtracking trie 
simple ac solution in java in o(n) with explanation house robber ii professional robber planning rob houses along street  house certain amount money stashed  houses place arranged circle  means first house neighbor last one  meanwhile  adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  medium dynamic programming 
9-lines 0ms o(1)-space c++ solution house robber ii professional robber planning rob houses along street  house certain amount money stashed  houses place arranged circle  means first house neighbor last one  meanwhile  adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  medium dynamic programming 
twice pass solution  c++ house robber ii professional robber planning rob houses along street  house certain amount money stashed  houses place arranged circle  means first house neighbor last one  meanwhile  adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  medium dynamic programming 
[c++] super simple 0ms solution with explanation house robber ii professional robber planning rob houses along street  house certain amount money stashed  houses place arranged circle  means first house neighbor last one  meanwhile  adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  medium dynamic programming 
good performance dp solution using java house robber ii professional robber planning rob houses along street  house certain amount money stashed  houses place arranged circle  means first house neighbor last one  meanwhile  adjacent houses security system connected automatically contact police two adjacent houses broken night  given list non-negative integers representing amount money house  determine maximum amount money rob tonight without alerting police  medium dynamic programming 
clean kmp solution with super detailed explanation shortest palindrome given string s  allowed convert palindrome adding characters front it  find return shortest palindrome find performing transformation  hard string 
my 7-lines recursive java solution shortest palindrome given string s  allowed convert palindrome adding characters front it  find return shortest palindrome find performing transformation  hard string 
c++ 8 ms kmp-based o(n) time & o(n) memory solution shortest palindrome given string s  allowed convert palindrome adding characters front it  find return shortest palindrome find performing transformation  hard string 
ac in 288 ms  simple brute force shortest palindrome given string s  allowed convert palindrome adding characters front it  find return shortest palindrome find performing transformation  hard string 
my 9-lines three pointers java solution with explanation shortest palindrome given string s  allowed convert palindrome adding characters front it  find return shortest palindrome find performing transformation  hard string 
solution explained kth largest element in an array find kth largest element unsorted array  note kth largest element sorted order  kth distinct element  medium divide and conquer heap 
c++ partition max-heap priority_queue multiset kth largest element in an array find kth largest element unsorted array  note kth largest element sorted order  kth distinct element  medium divide and conquer heap 
ac clean quickselect java solution avg  o(n) time kth largest element in an array find kth largest element unsorted array  note kth largest element sorted order  kth distinct element  medium divide and conquer heap 
python different solutions with comments (bubble sort  selection sort  heap sort and quick sort)  kth largest element in an array find kth largest element unsorted array  note kth largest element sorted order  kth distinct element  medium divide and conquer heap 
concise java solution based on quick select kth largest element in an array find kth largest element unsorted array  note kth largest element sorted order  kth distinct element  medium divide and conquer heap 
simple and clean java code  backtracking  combination sum iii find possible combinations k numbers add number n  given numbers 1 9 used combination unique set numbers  note: numbers positive integers  solution set must contain duplicate combinations  medium array backtracking 
my c++ solution  backtracking  combination sum iii find possible combinations k numbers add number n  given numbers 1 9 used combination unique set numbers  note: numbers positive integers  solution set must contain duplicate combinations  medium array backtracking 
fast  easy java code  with explanation! combination sum iii find possible combinations k numbers add number n  given numbers 1 9 used combination unique set numbers  note: numbers positive integers  solution set must contain duplicate combinations  medium array backtracking 
use backtrack c++ solution  easy to understand  combination sum iii find possible combinations k numbers add number n  given numbers 1 9 used combination unique set numbers  note: numbers positive integers  solution set must contain duplicate combinations  medium array backtracking 
clean 1 6 7-liners (ac) combination sum iii find possible combinations k numbers add number n  given numbers 1 9 used combination unique set numbers  note: numbers positive integers  solution set must contain duplicate combinations  medium array backtracking 
possible solutions  contains duplicate given array integers  find array contains duplicates  function return true value appears least twice array  return false every element distinct  easy array hash table 
single line c++ solution 60ms contains duplicate given array integers  find array contains duplicates  function return true value appears least twice array  return false every element distinct  easy array hash table 
one line solution in python contains duplicate given array integers  find array contains duplicates  function return true value appears least twice array  return false every element distinct  easy array hash table 
5 lines in java contains duplicate given array integers  find array contains duplicates  function return true value appears least twice array  return false every element distinct  easy array hash table 
c++ solution  simply one line  contains duplicate given array integers  find array contains duplicates  function return true value appears least twice array  return false every element distinct  easy array hash table 
(guaranteed) really detailed and good (perfect) explanation of the skyline problem the skyline problem city's skyline outer contour silhouette formed buildings city viewed distance  suppose given locations height buildings shown cityscape photo (figure a)  write program output skyline formed buildings collectively (figure b)  geometric information building represented triplet integers [li  ri  hi]  li ri x coordinates left right edge ith building  respectively  hi height  guaranteed 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  ri - li > 0  may assume buildings perfect rectangles grounded absolutely flat surface height 0  instance  dimensions buildings figure recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   output list "key points" (red dots figure b) format [ [x1 y1]  [x2  y2]  [x3  y3]      ] uniquely defines skyline  key point left endpoint horizontal line segment  note last key point  rightmost building ends  merely used mark termination skyline  always zero height  also  ground two adjacent buildings considered part skyline contour  instance  skyline figure b represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: number buildings input list guaranteed range [0  10000]  input list already sorted ascending order left x position li  output list must sorted x position  must consecutive horizontal lines equal height output skyline  instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] acceptable; three lines height 5 merged one final output such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
short java solution the skyline problem city's skyline outer contour silhouette formed buildings city viewed distance  suppose given locations height buildings shown cityscape photo (figure a)  write program output skyline formed buildings collectively (figure b)  geometric information building represented triplet integers [li  ri  hi]  li ri x coordinates left right edge ith building  respectively  hi height  guaranteed 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  ri - li > 0  may assume buildings perfect rectangles grounded absolutely flat surface height 0  instance  dimensions buildings figure recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   output list "key points" (red dots figure b) format [ [x1 y1]  [x2  y2]  [x3  y3]      ] uniquely defines skyline  key point left endpoint horizontal line segment  note last key point  rightmost building ends  merely used mark termination skyline  always zero height  also  ground two adjacent buildings considered part skyline contour  instance  skyline figure b represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: number buildings input list guaranteed range [0  10000]  input list already sorted ascending order left x position li  output list must sorted x position  must consecutive horizontal lines equal height output skyline  instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] acceptable; three lines height 5 merged one final output such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
once for all  explanation with clean java code(o(n^2)time  o(n) space) the skyline problem city's skyline outer contour silhouette formed buildings city viewed distance  suppose given locations height buildings shown cityscape photo (figure a)  write program output skyline formed buildings collectively (figure b)  geometric information building represented triplet integers [li  ri  hi]  li ri x coordinates left right edge ith building  respectively  hi height  guaranteed 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  ri - li > 0  may assume buildings perfect rectangles grounded absolutely flat surface height 0  instance  dimensions buildings figure recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   output list "key points" (red dots figure b) format [ [x1 y1]  [x2  y2]  [x3  y3]      ] uniquely defines skyline  key point left endpoint horizontal line segment  note last key point  rightmost building ends  merely used mark termination skyline  always zero height  also  ground two adjacent buildings considered part skyline contour  instance  skyline figure b represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: number buildings input list guaranteed range [0  10000]  input list already sorted ascending order left x position li  output list must sorted x position  must consecutive horizontal lines equal height output skyline  instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] acceptable; three lines height 5 merged one final output such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
my c++ code using one priority queue (812 ms) the skyline problem city's skyline outer contour silhouette formed buildings city viewed distance  suppose given locations height buildings shown cityscape photo (figure a)  write program output skyline formed buildings collectively (figure b)  geometric information building represented triplet integers [li  ri  hi]  li ri x coordinates left right edge ith building  respectively  hi height  guaranteed 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  ri - li > 0  may assume buildings perfect rectangles grounded absolutely flat surface height 0  instance  dimensions buildings figure recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   output list "key points" (red dots figure b) format [ [x1 y1]  [x2  y2]  [x3  y3]      ] uniquely defines skyline  key point left endpoint horizontal line segment  note last key point  rightmost building ends  merely used mark termination skyline  always zero height  also  ground two adjacent buildings considered part skyline contour  instance  skyline figure b represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: number buildings input list guaranteed range [0  10000]  input list already sorted ascending order left x position li  output list must sorted x position  must consecutive horizontal lines equal height output skyline  instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] acceptable; three lines height 5 merged one final output such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
share my divide and conquer java solution  464 ms the skyline problem city's skyline outer contour silhouette formed buildings city viewed distance  suppose given locations height buildings shown cityscape photo (figure a)  write program output skyline formed buildings collectively (figure b)  geometric information building represented triplet integers [li  ri  hi]  li ri x coordinates left right edge ith building  respectively  hi height  guaranteed 0 ≤ li  ri ≤ int_max  0 < hi ≤ int_max  ri - li > 0  may assume buildings perfect rectangles grounded absolutely flat surface height 0  instance  dimensions buildings figure recorded as: [ [2 9 10]  [3 7 15]  [5 12 12]  [15 20 10]  [19 24 8] ]   output list "key points" (red dots figure b) format [ [x1 y1]  [x2  y2]  [x3  y3]      ] uniquely defines skyline  key point left endpoint horizontal line segment  note last key point  rightmost building ends  merely used mark termination skyline  always zero height  also  ground two adjacent buildings considered part skyline contour  instance  skyline figure b represented as:[ [2 10]  [3 15]  [7 12]  [12 0]  [15 10]  [20 8]  [24  0] ]  notes: number buildings input list guaranteed range [0  10000]  input list already sorted ascending order left x position li  output list must sorted x position  must consecutive horizontal lines equal height output skyline  instance  [   [2 3]  [4 5]  [7 5]  [11 5]  [12 7]   ] acceptable; three lines height 5 merged one final output such: [   [2 3]  [4 5]  [12 7]     ] hard divide and conquer heap binary indexed tree segment tree 
simple java solution contains duplicate ii given array integers integer k  find whether two distinct indices j array nums[i] = nums[j] absolute difference j k  easy array hash table 
c++ solution with unordered_set contains duplicate ii given array integers integer k  find whether two distinct indices j array nums[i] = nums[j] absolute difference j k  easy array hash table 
short ac java solution contains duplicate ii given array integers integer k  find whether two distinct indices j array nums[i] = nums[j] absolute difference j k  easy array hash table 
python concise solution with dictionary  contains duplicate ii given array integers integer k  find whether two distinct indices j array nums[i] = nums[j] absolute difference j k  easy array hash table 
c++ 6 line solution  simple code and easy understanding contains duplicate ii given array integers integer k  find whether two distinct indices j array nums[i] = nums[j] absolute difference j k  easy array hash table 
ac o(n) solution in java using buckets with explanation contains duplicate iii given array integers  find whether two distinct indices j array absolute difference nums[i] nums[j] absolute difference j k  medium binary search tree 
java o(n lg k) solution contains duplicate iii given array integers  find whether two distinct indices j array absolute difference nums[i] nums[j] absolute difference j k  medium binary search tree 
java python one pass solution  o(n) time o(n) space using buckets contains duplicate iii given array integers  find whether two distinct indices j array absolute difference nums[i] nums[j] absolute difference j k  medium binary search tree 
c++ using set (less 10 lines)  with simple explanation  contains duplicate iii given array integers  find whether two distinct indices j array absolute difference nums[i] nums[j] absolute difference j k  medium binary search tree 
o(n) python using buckets with explanation  10 lines  contains duplicate iii given array integers  find whether two distinct indices j array absolute difference nums[i] nums[j] absolute difference j k  medium binary search tree 
c++ dynamic programming maximal square given 2d binary matrix filled 0's 1's  find largest square containing 1's return area  medium dynamic programming 
extremely simple java solution :) maximal square given 2d binary matrix filled 0's 1's  find largest square containing 1's return area  medium dynamic programming 
accepted clean java dp solution maximal square given 2d binary matrix filled 0's 1's  find largest square containing 1's return area  medium dynamic programming 
6 lines  visual explanation  o(mn) maximal square given 2d binary matrix filled 0's 1's  find largest square containing 1's return area  medium dynamic programming 
clear c++ solution  no extra space  12 ms  maximal square given 2d binary matrix filled 0's 1's  find largest square containing 1's return area  medium dynamic programming 
concise java solutions o(log(n)^2) count complete tree nodes given complete binary tree  count number nodes  note: definition complete binary tree wikipedia: complete binary tree every level  except possibly last  completely filled  nodes last level far left possible  1 2h nodes inclusive last level h  medium binary search tree 
easy short c++ recursive solution count complete tree nodes given complete binary tree  count number nodes  note: definition complete binary tree wikipedia: complete binary tree every level  except possibly last  completely filled  nodes last level far left possible  1 2h nodes inclusive last level h  medium binary search tree 
accepted easy understand java solution count complete tree nodes given complete binary tree  count number nodes  note: definition complete binary tree wikipedia: complete binary tree every level  except possibly last  completely filled  nodes last level far left possible  1 2h nodes inclusive last level h  medium binary search tree 
my java solution with explanation which beats 99% count complete tree nodes given complete binary tree  count number nodes  note: definition complete binary tree wikipedia: complete binary tree every level  except possibly last  completely filled  nodes last level far left possible  1 2h nodes inclusive last level h  medium binary search tree 
a very clear recursive solution  isn't it? count complete tree nodes given complete binary tree  count number nodes  note: definition complete binary tree wikipedia: complete binary tree every level  except possibly last  completely filled  nodes last level far left possible  1 2h nodes inclusive last level h  medium binary search tree 
if you want to laugh  look at my solution rectangle area find total area covered two rectilinear rectangles 2d plane  rectangle defined bottom left corner top right corner shown figure  medium math 
just another short way rectangle area find total area covered two rectilinear rectangles 2d plane  rectangle defined bottom left corner top right corner shown figure  medium math 
my java solution [sum of areas - overlapped area] rectangle area find total area covered two rectilinear rectangles 2d plane  rectangle defined bottom left corner top right corner shown figure  medium math 
python concise solution  rectangle area find total area covered two rectilinear rectangles 2d plane  rectangle defined bottom left corner top right corner shown figure  medium math 
an explanation in plain language rectangle area find total area covered two rectilinear rectangles 2d plane  rectangle defined bottom left corner top right corner shown figure  medium math 
iterative java solution with stack basic calculator implement basic calculator evaluate simple expression string  expression string may contain open ( closing parentheses )  plus + minus sign -  non-negative integers empty spaces   hard math stack 
java-----------easy version to understand!!!!! basic calculator implement basic calculator evaluate simple expression string  expression string may contain open ( closing parentheses )  plus + minus sign -  non-negative integers empty spaces   hard math stack 
16 ms solution in c++ with stacks basic calculator implement basic calculator evaluate simple expression string  expression string may contain open ( closing parentheses )  plus + minus sign -  non-negative integers empty spaces   hard math stack 
easy 18 lines c++  16 lines python basic calculator implement basic calculator evaluate simple expression string  expression string may contain open ( closing parentheses )  plus + minus sign -  non-negative integers empty spaces   hard math stack 
java solution stack basic calculator implement basic calculator evaluate simple expression string  expression string may contain open ( closing parentheses )  plus + minus sign -  non-negative integers empty spaces   hard math stack 
a simple c++ solution implement stack using queues implement following operations stack using queues  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  empty() -- return whether stack empty  easy stack design 
only push is o(n)  others are o(1)  using one queue  combination of two shared solutions implement stack using queues implement following operations stack using queues  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  empty() -- return whether stack empty  easy stack design 
java solutions about three ways one of which utilizes one queue  and the others utilize two queues implement stack using queues implement following operations stack using queues  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  empty() -- return whether stack empty  easy stack design 
concise 1 queue - java  c++  python implement stack using queues implement following operations stack using queues  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  empty() -- return whether stack empty  easy stack design 
o(1) purely with queues implement stack using queues implement following operations stack using queues  push(x) -- push element x onto stack  pop() -- removes element top stack  top() -- get top element  empty() -- return whether stack empty  easy stack design 
straightforward dfs recursive  iterative  bfs solutions invert binary tree invert binary tree  easy tree 
3-4 lines python invert binary tree invert binary tree  easy tree 
recursive and non-recursive c++ both 4ms invert binary tree invert binary tree  easy tree 
python solutions (recursively  dfs  bfs)  invert binary tree invert binary tree  easy tree 
my simple recursion java solution invert binary tree invert binary tree  easy tree 
share my  java solution basic calculator ii implement basic calculator evaluate simple expression string  expression string contains non-negative integers  +  -       operators empty spaces   integer division truncate toward zero  medium string 
17 lines c++  easy  20 ms basic calculator ii implement basic calculator evaluate simple expression string  expression string contains non-negative integers  +  -       operators empty spaces   integer division truncate toward zero  medium string 
java straight forward iteration solution with comments  no stack  o(n) & o(1) basic calculator ii implement basic calculator evaluate simple expression string  expression string contains non-negative integers  +  -       operators empty spaces   integer division truncate toward zero  medium string 
my 16 ms no stack one pass short c++ solution basic calculator ii implement basic calculator evaluate simple expression string  expression string contains non-negative integers  +  -       operators empty spaces   integer division truncate toward zero  medium string 
python short solution with stack  basic calculator ii implement basic calculator evaluate simple expression string  expression string contains non-negative integers  +  -       operators empty spaces   integer division truncate toward zero  medium string 
accepted java solution--easy to understand summary ranges given sorted integer array without duplicates  return summary ranges  medium array 
6 lines in python summary ranges given sorted integer array without duplicates  return summary ranges  medium array 
10 line c++ easy understand summary ranges given sorted integer array without duplicates  return summary ranges  medium array 
my concise java solution summary ranges given sorted integer array without duplicates  return summary ranges  medium array 
idea + 1-liner: group by number-index summary ranges given sorted integer array without duplicates  return summary ranges  medium array 
boyer-moore majority vote algorithm and my elaboration majority element ii given integer array size n  find elements appear ⌊ n 3 ⌋ times  note: algorithm run linear time o(1) space  medium array 
java-------------------easy version to understand!!!!!!!!!!!! majority element ii given integer array size n  find elements appear ⌊ n 3 ⌋ times  note: algorithm run linear time o(1) space  medium array 
6 lines  general case o(n) time and o(k) space majority element ii given integer array size n  find elements appear ⌊ n 3 ⌋ times  note: algorithm run linear time o(1) space  medium array 
boyer-moore majority vote algorithm generalization majority element ii given integer array size n  find elements appear ⌊ n 3 ⌋ times  note: algorithm run linear time o(1) space  medium array 
my c++ solution majority element ii given integer array size n  find elements appear ⌊ n 3 ⌋ times  note: algorithm run linear time o(1) space  medium array 
3 ways implemented in java (python): binary search  in-order iterative & recursive kth smallest element in a bst given binary search tree  write function kthsmallest find kth smallest element it  note: may assume k always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
what if you could modify the bst node's structure? kth smallest element in a bst given binary search tree  write function kthsmallest find kth smallest element it  note: may assume k always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
two easiest in order traverse (java) kth smallest element in a bst given binary search tree  write function kthsmallest find kth smallest element it  note: may assume k always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
4 lines in c++  kth smallest element in a bst given binary search tree  write function kthsmallest find kth smallest element it  note: may assume k always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
python easy iterative and recursive solution kth smallest element in a bst given binary search tree  write function kthsmallest find kth smallest element it  note: may assume k always valid  1 ≤ k ≤ bst's total elements  medium binary search tree 
using n&(n-1) trick power of two given integer  write function determine power two  easy math bit manipulation 
4 different ways to solve -- iterative   recursive   bit operation   math power of two given integer  write function determine power two  easy math bit manipulation 
one line java solution using bitcount power of two given integer  write function determine power two  easy math bit manipulation 
one line of c++ power of two given integer  write function determine power two  easy math bit manipulation 
python one line solution power of two given integer  write function determine power two  easy math bit manipulation 
short o(1) amortized  c++   java   ruby implement queue using stacks implement following operations queue using stacks  push(x) -- push element x back queue  pop() -- removes element front queue  peek() -- get front element  empty() -- return whether queue empty  easy stack design 
easy java solution  just edit push() method implement queue using stacks implement following operations queue using stacks  push(x) -- push element x back queue  pop() -- removes element front queue  peek() -- get front element  empty() -- return whether queue empty  easy stack design 
0 ms c++ solution using one stack w  explanation  implement queue using stacks implement following operations queue using stacks  push(x) -- push element x back queue  pop() -- removes element front queue  peek() -- get front element  empty() -- return whether queue empty  easy stack design 
share my python solution (32ms) implement queue using stacks implement following operations queue using stacks  push(x) -- push element x back queue  pop() -- removes element front queue  peek() -- get front element  empty() -- return whether queue empty  easy stack design 
do you know when we should use two stacks to implement a queue? implement queue using stacks implement following operations queue using stacks  push(x) -- push element x back queue  pop() -- removes element front queue  peek() -- get front element  empty() -- return whether queue empty  easy stack design 
4+ lines  o(log n)  c++ java python number of digit one given integer n  count total number digit 1 appearing non-negative integers less equal n  hard math 
ac short java solution number of digit one given integer n  count total number digit 1 appearing non-negative integers less equal n  hard math 
java python one pass solution easy to understand number of digit one given integer n  count total number digit 1 appearing non-negative integers less equal n  hard math 
0ms o(lgn) accepted c++ solution using counting principle with explanation number of digit one given integer n  count total number digit 1 appearing non-negative integers less equal n  hard math 
0 ms recursive solution number of digit one given integer n  count total number digit 1 appearing non-negative integers less equal n  hard math 
reversing a list is not considered "o(1) space" palindrome linked list given singly linked list  determine palindrome  easy linked list two pointers 
java  easy to understand palindrome linked list given singly linked list  determine palindrome  easy linked list two pointers 
11 lines  12 with restore  o(n) time  o(1) space palindrome linked list given singly linked list  determine palindrome  easy linked list two pointers 
share my c++ solution  o(n) time and o(1) memory palindrome linked list given singly linked list  determine palindrome  easy linked list two pointers 
my easy understand c++ solution palindrome linked list given singly linked list  determine palindrome  easy linked list two pointers 
3 lines with o(1) space  1-liners  alternatives lowest common ancestor of a binary search tree given binary search tree (bst)  find lowest common ancestor (lca) two given nodes bst  according definition lca wikipedia: “the lowest common ancestor defined two nodes p q lowest node p q descendants (where allow node descendant itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
my java solution lowest common ancestor of a binary search tree given binary search tree (bst)  find lowest common ancestor (lca) two given nodes bst  according definition lca wikipedia: “the lowest common ancestor defined two nodes p q lowest node p q descendants (where allow node descendant itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
c++ recursive and iterative lowest common ancestor of a binary search tree given binary search tree (bst)  find lowest common ancestor (lca) two given nodes bst  according definition lca wikipedia: “the lowest common ancestor defined two nodes p q lowest node p q descendants (where allow node descendant itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
python iterative solution lowest common ancestor of a binary search tree given binary search tree (bst)  find lowest common ancestor (lca) two given nodes bst  according definition lca wikipedia: “the lowest common ancestor defined two nodes p q lowest node p q descendants (where allow node descendant itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
11ms java solution  3 lines lowest common ancestor of a binary search tree given binary search tree (bst)  find lowest common ancestor (lca) two given nodes bst  according definition lca wikipedia: “the lowest common ancestor defined two nodes p q lowest node p q descendants (where allow node descendant itself) ” given binary search tree: root = [6 2 8 0 4 7 9 null null 3 5] _______6______     ___2__ ___8__         0 _4 7 9     3 5 easy tree 
why leetcode accepted such stupid question? delete node in a linked list write function delete node (except tail) singly linked list  given access node  given linked list -- head = [4 5 1 9]  looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
1-3 lines  c++ java python c c# javascript ruby delete node in a linked list write function delete node (except tail) singly linked list  given access node  given linked list -- head = [4 5 1 9]  looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
easy solution in java delete node in a linked list write function delete node (except tail) singly linked list  given access node  given linked list -- head = [4 5 1 9]  looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
this question is wrong you cannot delete the node delete node in a linked list write function delete node (except tail) singly linked list  given access node  given linked list -- head = [4 5 1 9]  looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
easy question  easy solution(java) delete node in a linked list write function delete node (except tail) singly linked list  given access node  given linked list -- head = [4 5 1 9]  looks like following: 4 -> 5 -> 1 -> 9 easy linked list 
simple java solution in o(n) without extra space product of array except self given array nums n integers n > 1  return array output output[i] equal product elements nums except nums[i]  medium array 
python solution (accepted)  o(n) time  o(1) space product of array except self given array nums n integers n > 1  return array output output[i] equal product elements nums except nums[i]  medium array 
my simple java solution product of array except self given array nums n integers n > 1  return array output output[i] equal product elements nums except nums[i]  medium array 
o(n) time and o(1) space c++ solution with explanation product of array except self given array nums n integers n > 1  return array output output[i] equal product elements nums except nums[i]  medium array 
my solution beats 100% java solutions product of array except self given array nums n integers n > 1  return array output output[i] equal product elements nums except nums[i]  medium array 
java o(n) solution using deque with explanation sliding window maximum given array nums  sliding window size k moving left array right  see k numbers window  time sliding window moves right one position  return max sliding window  hard heap 
o(n) solution in java with two simple pass in the array sliding window maximum given array nums  sliding window size k moving left array right  see k numbers window  time sliding window moves right one position  return max sliding window  hard heap 
this is a typical monotonic queue problem sliding window maximum given array nums  sliding window size k moving left array right  see k numbers window  time sliding window moves right one position  return max sliding window  hard heap 
clean c++ o(n) solution using a deque sliding window maximum given array nums  sliding window size k moving left array right  see k numbers window  time sliding window moves right one position  return max sliding window  hard heap 
my c++ o(n) deque based solution with explanation sliding window maximum given array nums  sliding window size k moving left array right  see k numbers window  time sliding window moves right one position  return max sliding window  hard heap 
my concise o(m+n) java solution search a 2d matrix ii write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted ascending left right  integers column sorted ascending top bottom  medium binary search divide and conquer 
c++ with o(m+n) complexity search a 2d matrix ii write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted ascending left right  integers column sorted ascending top bottom  medium binary search divide and conquer 
 java  an easy-to-understand divide and conquer method search a 2d matrix ii write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted ascending left right  integers column sorted ascending top bottom  medium binary search divide and conquer 
6-9 lines c++ python solutions with explanations search a 2d matrix ii write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted ascending left right  integers column sorted ascending top bottom  medium binary search divide and conquer 
java short code  o(m+n) search a 2d matrix ii write efficient algorithm searches value x n matrix  matrix following properties: integers row sorted ascending left right  integers column sorted ascending top bottom  medium binary search divide and conquer 
a recursive java solution (284 ms) different ways to add parentheses given string numbers operators  return possible results computing different possible ways group numbers operators  valid operators +  -    medium divide and conquer 
c++ 4ms recursive & dp solution with brief explanation different ways to add parentheses given string numbers operators  return possible results computing different possible ways group numbers operators  valid operators +  -    medium divide and conquer 
1-11 lines python  9 lines c++ different ways to add parentheses given string numbers operators  return possible results computing different possible ways group numbers operators  valid operators +  -    medium divide and conquer 
python easy to understand solution (divide and conquer)  different ways to add parentheses given string numbers operators  return possible results computing different possible ways group numbers operators  valid operators +  -    medium divide and conquer 
share a clean and short java solution different ways to add parentheses given string numbers operators  return possible results computing different possible ways group numbers operators  valid operators +  -    medium divide and conquer 
accepted java o(n) solution in 5 lines valid anagram given two strings   write function determine anagram s  easy hash table sort 
2 c++ solutions with explanations valid anagram given two strings   write function determine anagram s  easy hash table sort 
python solutions (sort and dictionary)  valid anagram given two strings   write function determine anagram s  easy hash table sort 
share my java solution valid anagram given two strings   write function determine anagram s  easy hash table sort 
simple fast java solution (beats 97%) valid anagram given two strings   write function determine anagram s  easy hash table sort 
accepted java simple solution in 8 lines binary tree paths given binary tree  return root-to-leaf paths  note: leaf node children  easy tree depth-first search 
python solutions (dfs+stack  bfs+queue  dfs recursively)  binary tree paths given binary tree  return root-to-leaf paths  note: leaf node children  easy tree depth-first search 
clean java solution (accepted) without any helper recursive function binary tree paths given binary tree  return root-to-leaf paths  note: leaf node children  easy tree depth-first search 
c++ simple 4ms recursive solution binary tree paths given binary tree  return root-to-leaf paths  note: leaf node children  easy tree depth-first search 
my java solution in dfs  bfs  recursion binary tree paths given binary tree  return root-to-leaf paths  note: leaf node children  easy tree depth-first search 
accepted c++ o(1)-time o(1)-space 1-line solution with detail explanations add digits given non-negative integer num  repeatedly add digits result one digit  easy math 
3 methods for python with explains add digits given non-negative integer num  repeatedly add digits result one digit  easy math 
two lines c code  with explanation add digits given non-negative integer num  repeatedly add digits result one digit  easy math 
simple java solution no recursion  loop add digits given non-negative integer num  repeatedly add digits result one digit  easy math 
1 line java solution add digits given non-negative integer num  repeatedly add digits result one digit  easy math 
accepted c++ java o(n)-time o(1)-space easy solution with detail explanations single number iii given array numbers nums  exactly two elements appear elements appear exactly twice  find two elements appear once  medium bit manipulation 
sharing explanation of the solution single number iii given array numbers nums  exactly two elements appear elements appear exactly twice  find two elements appear once  medium bit manipulation 
c++ solution o(n) time and o(1) space  easy-understaning with simple explanation single number iii given array numbers nums  exactly two elements appear elements appear exactly twice  find two elements appear once  medium bit manipulation 
bit manipulation beats 99 62% single number iii given array numbers nums  exactly two elements appear elements appear exactly twice  find two elements appear once  medium bit manipulation 
share my c++ solution  single number iii given array numbers nums  exactly two elements appear elements appear exactly twice  find two elements appear once  medium bit manipulation 
solution without join trips and users sql schemathe trips table holds taxi trips  trip unique id  client_id driver_id foreign keys users_id users table  status enum type (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ users table holds users  user unique users_id  role enum type (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | | client | | 2 | yes | client | | 3 | | client | | 4 | | client | | 10 | | driver | | 11 | | driver | | 12 | | driver | | 13 | | driver | +----------+--------+--------+ write sql query find cancellation rate requests made unbanned users oct 1  2013 oct 3  2013  tables  sql query return following rows cancellation rate rounded two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks @cak1erlizhou contributing question  writing problem description adding part test cases  hard 
sharing my solution  trips and users sql schemathe trips table holds taxi trips  trip unique id  client_id driver_id foreign keys users_id users table  status enum type (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ users table holds users  user unique users_id  role enum type (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | | client | | 2 | yes | client | | 3 | | client | | 4 | | client | | 10 | | driver | | 11 | | driver | | 12 | | driver | | 13 | | driver | +----------+--------+--------+ write sql query find cancellation rate requests made unbanned users oct 1  2013 oct 3  2013  tables  sql query return following rows cancellation rate rounded two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks @cak1erlizhou contributing question  writing problem description adding part test cases  hard 
question towards problem description trips and users sql schemathe trips table holds taxi trips  trip unique id  client_id driver_id foreign keys users_id users table  status enum type (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ users table holds users  user unique users_id  role enum type (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | | client | | 2 | yes | client | | 3 | | client | | 4 | | client | | 10 | | driver | | 11 | | driver | | 12 | | driver | | 13 | | driver | +----------+--------+--------+ write sql query find cancellation rate requests made unbanned users oct 1  2013 oct 3  2013  tables  sql query return following rows cancellation rate rounded two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks @cak1erlizhou contributing question  writing problem description adding part test cases  hard 
sharing my solution trips and users sql schemathe trips table holds taxi trips  trip unique id  client_id driver_id foreign keys users_id users table  status enum type (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ users table holds users  user unique users_id  role enum type (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | | client | | 2 | yes | client | | 3 | | client | | 4 | | client | | 10 | | driver | | 11 | | driver | | 12 | | driver | | 13 | | driver | +----------+--------+--------+ write sql query find cancellation rate requests made unbanned users oct 1  2013 oct 3  2013  tables  sql query return following rows cancellation rate rounded two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks @cak1erlizhou contributing question  writing problem description adding part test cases  hard 
my solution share trips and users sql schemathe trips table holds taxi trips  trip unique id  client_id driver_id foreign keys users_id users table  status enum type (‘completed’  ‘cancelled_by_driver’  ‘cancelled_by_client’)  +----+-----------+-----------+---------+--------------------+----------+ | id | client_id | driver_id | city_id | status |request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ users table holds users  user unique users_id  role enum type (‘client’  ‘driver’  ‘partner’)  +----------+--------+--------+ | users_id | banned | role | +----------+--------+--------+ | 1 | | client | | 2 | yes | client | | 3 | | client | | 4 | | client | | 10 | | driver | | 11 | | driver | | 12 | | driver | | 13 | | driver | +----------+--------+--------+ write sql query find cancellation rate requests made unbanned users oct 1  2013 oct 3  2013  tables  sql query return following rows cancellation rate rounded two decimal places  +------------+-------------------+ | day | cancellation rate | +------------+-------------------+ | 2013-10-01 | 0 33 | | 2013-10-02 | 0 00 | | 2013-10-03 | 0 50 | +------------+-------------------+ credits: special thanks @cak1erlizhou contributing question  writing problem description adding part test cases  hard 
2-4 lines  every language ugly number write program check whether given number ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  easy math 
my 2ms java solution ugly number write program check whether given number ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  easy math 
simple java solution with explanation ugly number write program check whether given number ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  easy math 
my python solution ugly number write program check whether given number ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  easy math 
java solution  greatest divide by 2  3  5 ugly number write program check whether given number ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  easy math 
my 16ms c++ dp solution with short explanation ugly number ii write program find n-th ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  medium math dynamic programming heap 
o(n) java solution ugly number ii write program find n-th ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  medium math dynamic programming heap 
elegant c++ solution o(n) space time with detailed explanation  ugly number ii write program find n-th ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  medium math dynamic programming heap 
my expressive python solution ugly number ii write program find n-th ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  medium math dynamic programming heap 
java solution -- using priorityqueue ugly number ii write program find n-th ugly number  ugly numbers positive numbers whose prime factors include 2  3  5  medium math dynamic programming heap 
4 line simple java bit manipulate solution with explaination missing number given array containing n distinct numbers taken 0  1  2       n  find one missing array  easy array math bit manipulation 
3 different ideas: xor  sum  binary search  java code missing number given array containing n distinct numbers taken 0  1  2       n  find one missing array  easy array math bit manipulation 
c++ solution using bit manipulation missing number given array containing n distinct numbers taken 0  1  2       n  find one missing array  easy array math bit manipulation 
1+ lines ruby  python  java  c++ missing number given array containing n distinct numbers taken 0  1  2       n  find one missing array  easy array math bit manipulation 
java solution o(1) space and o(n) in time missing number given array containing n distinct numbers taken 0  1  2       n  find one missing array  easy array math bit manipulation 
my clean java solution  very easy to understand integer to english words convert non-negative integer english words representation  given input guaranteed less 231 - 1  hard math string 
short clean java solution integer to english words convert non-negative integer english words representation  given input guaranteed less 231 - 1  hard math string 
fairly clear 4ms c++ solution integer to english words convert non-negative integer english words representation  given input guaranteed less 231 - 1  hard math string 
recursive python integer to english words convert non-negative integer english words representation  given input guaranteed less 231 - 1  hard math string 
python clean solution integer to english words convert non-negative integer english words representation  given input guaranteed less 231 - 1  hard math string 
my o(n) time solution use java h-index given array citations (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium hash table sort 
java bucket sort o(n) solution with detail explanation h-index given array citations (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium hash table sort 
a clean o(n) solution in java h-index given array citations (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium hash table sort 
java  o(n) time  with easy explanation  h-index given array citations (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium hash table sort 
my easy solution h-index given array citations (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium hash table sort 
standard binary search h-index ii given array citations sorted ascending order (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium binary search 
java binary search  simple and clean h-index ii given array citations sorted ascending order (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium binary search 
o(logn)-time o(1)-space easy solution with detailed explanations (c++ java python) h-index ii given array citations sorted ascending order (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium binary search 
very standard binary search using (start + 1 < end) h-index ii given array citations sorted ascending order (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium binary search 
share my c o(logn) solution with explanation  h-index ii given array citations sorted ascending order (each citation non-negative integer) researcher  write function compute researcher's h-index  according definition h-index wikipedia: "a scientist index h h his her n papers least h citations each  n − h papers h citations each " medium binary search 
o(lgn) simple java solution first bad version product manager currently leading team develop new product  unfortunately  latest version product fails quality check  since version developed based previous version  versions bad version also bad  suppose n versions [1  2       n] want find first bad one  causes following ones bad  given api bool isbadversion(version) return whether version bad  implement function find first bad version  minimize number calls api  easy binary search 
a good warning to me to use  start+(end-start) 2 to avoid overflow first bad version product manager currently leading team develop new product  unfortunately  latest version product fails quality check  since version developed based previous version  versions bad version also bad  suppose n versions [1  2       n] want find first bad one  causes following ones bad  given api bool isbadversion(version) return whether version bad  implement function find first bad version  minimize number calls api  easy binary search 
time limit exceed first bad version product manager currently leading team develop new product  unfortunately  latest version product fails quality check  since version developed based previous version  versions bad version also bad  suppose n versions [1  2       n] want find first bad one  causes following ones bad  given api bool isbadversion(version) return whether version bad  implement function find first bad version  minimize number calls api  easy binary search 
short c++ answer and minimize api calls first bad version product manager currently leading team develop new product  unfortunately  latest version product fails quality check  since version developed based previous version  versions bad version also bad  suppose n versions [1  2       n] want find first bad one  causes following ones bad  given api bool isbadversion(version) return whether version bad  implement function find first bad version  minimize number calls api  easy binary search 
1-liner in ruby   python first bad version product manager currently leading team develop new product  unfortunately  latest version product fails quality check  since version developed based previous version  versions bad version also bad  suppose n versions [1  2       n] want find first bad one  causes following ones bad  given api bool isbadversion(version) return whether version bad  implement function find first bad version  minimize number calls api  easy binary search 
summary of 4 different solutions (bfs  dp  static dp and mathematics) perfect squares given positive integer n  find least number perfect square numbers (for medium math dynamic programming breadth-first search 
an easy understanding dp solution in java perfect squares given positive integer n  find least number perfect square numbers (for medium math dynamic programming breadth-first search 
short python solution using bfs perfect squares given positive integer n  find least number perfect square numbers (for medium math dynamic programming breadth-first search 
static dp  c++ 12 ms  python 172 ms  ruby 384 ms perfect squares given positive integer n  find least number perfect square numbers (for medium math dynamic programming breadth-first search 
o(sqrt(n)) in ruby  c++  c perfect squares given positive integer n  find least number perfect square numbers (for medium math dynamic programming breadth-first search 
java standard backtrace ac solutoin  short and clear expression add operators given string contains digits 0-9 target value  return possibilities add binary operators (not unary) +  -    digits evaluate target value  hard divide and conquer 
17 lines solution  dfs (c++) expression add operators given string contains digits 0-9 target value  return possibilities add binary operators (not unary) +  -    digits evaluate target value  hard divide and conquer 
java ac solution  19ms  beat 100 00%  expression add operators given string contains digits 0-9 target value  return possibilities add binary operators (not unary) +  -    digits evaluate target value  hard divide and conquer 
clean python dfs with comments expression add operators given string contains digits 0-9 target value  return possibilities add binary operators (not unary) +  -    digits evaluate target value  hard divide and conquer 
accepted c++ solution expression add operators given string contains digits 0-9 target value  return possibilities add binary operators (not unary) +  -    digits evaluate target value  hard divide and conquer 
simple o(n) java solution using insert index move zeroes given array nums  write function move 0's end maintaining relative order non-zero elements  easy array two pointers 
my simple c++ solution move zeroes given array nums  write function move 0's end maintaining relative order non-zero elements  easy array two pointers 
1ms java solution move zeroes given array nums  write function move 0's end maintaining relative order non-zero elements  easy array two pointers 
python short in-place solution with comments  move zeroes given array nums  write function move 0's end maintaining relative order non-zero elements  easy array two pointers 
c++ accepted code move zeroes given array nums  write function move 0's end maintaining relative order non-zero elements  easy array two pointers 
concise java solution peeking iterator given iterator class interface methods: next() hasnext()  design implement peekingiterator support peek() operation -- essentially peek() element returned next call next()  medium design 
simple c++ solution (1 line per method) without extra member variables peeking iterator given iterator class interface methods: next() hasnext()  design implement peekingiterator support peek() operation -- essentially peek() element returned next call next()  medium design 
simple python solution peeking iterator given iterator class interface methods: next() hasnext()  design implement peekingiterator support peek() operation -- essentially peek() element returned next call next()  medium design 
another c++ solution with one line in peek() and hasnext()  ac peeking iterator given iterator class interface methods: next() hasnext()  design implement peekingiterator support peek() operation -- essentially peek() element returned next call next()  medium design 
simple java solution by caching next element peeking iterator given iterator class interface methods: next() hasnext()  design implement peekingiterator support peek() operation -- essentially peek() element returned next call next()  medium design 
my easy understood solution with o(n) time and o(1) space without modifying the array  with clear explanation  find the duplicate number given array nums containing n + 1 integers integer 1 n (inclusive)  prove least one duplicate number must exist  assume one duplicate number  find duplicate one  medium array two pointers binary search 
two solutions (with explanation): o(nlog(n)) and o(n) time   o(1) space  without changing the input array find the duplicate number given array nums containing n + 1 integers integer 1 n (inclusive)  prove least one duplicate number must exist  assume one duplicate number  find duplicate one  medium array two pointers binary search 
java o(n) time and o(1) space solution  similar to find loop in linkedlist  find the duplicate number given array nums containing n + 1 integers integer 1 n (inclusive)  prove least one duplicate number must exist  assume one duplicate number  find duplicate one  medium array two pointers binary search 
simple c++ code with o(1) space and o(nlogn) time complexity find the duplicate number given array nums containing n + 1 integers integer 1 n (inclusive)  prove least one duplicate number must exist  assume one duplicate number  find duplicate one  medium array two pointers binary search 
java o(1)space using binary-search find the duplicate number given array nums containing n + 1 integers integer 1 n (inclusive)  prove least one duplicate number must exist  assume one duplicate number  find duplicate one  medium array two pointers binary search 
easiest java solution with explanation game of life according wikipedia's article: "the game life  also known simply life  cellular automaton devised british mathematician john horton conway 1970 " given board n cells  cell initial state live (1) dead (0)  cell interacts eight neighbors (horizontal  vertical  diagonal) using following four rules (taken wikipedia article): live cell fewer two live neighbors dies  caused under-population  live cell two three live neighbors lives next generation  live cell three live neighbors dies  over-population   dead cell exactly three live neighbors becomes live cell  reproduction  write function compute next state (after one update) board given current state  next state created applying rules simultaneously every cell current state  births deaths occur simultaneously  medium array 
c++ o(1) space  o(mn) time game of life according wikipedia's article: "the game life  also known simply life  cellular automaton devised british mathematician john horton conway 1970 " given board n cells  cell initial state live (1) dead (0)  cell interacts eight neighbors (horizontal  vertical  diagonal) using following four rules (taken wikipedia article): live cell fewer two live neighbors dies  caused under-population  live cell two three live neighbors lives next generation  live cell three live neighbors dies  over-population   dead cell exactly three live neighbors becomes live cell  reproduction  write function compute next state (after one update) board given current state  next state created applying rules simultaneously every cell current state  births deaths occur simultaneously  medium array 
infinite board solution game of life according wikipedia's article: "the game life  also known simply life  cellular automaton devised british mathematician john horton conway 1970 " given board n cells  cell initial state live (1) dead (0)  cell interacts eight neighbors (horizontal  vertical  diagonal) using following four rules (taken wikipedia article): live cell fewer two live neighbors dies  caused under-population  live cell two three live neighbors lives next generation  live cell three live neighbors dies  over-population   dead cell exactly three live neighbors becomes live cell  reproduction  write function compute next state (after one update) board given current state  next state created applying rules simultaneously every cell current state  births deaths occur simultaneously  medium array 
c++ ac code  o(1) space  o(mn) time game of life according wikipedia's article: "the game life  also known simply life  cellular automaton devised british mathematician john horton conway 1970 " given board n cells  cell initial state live (1) dead (0)  cell interacts eight neighbors (horizontal  vertical  diagonal) using following four rules (taken wikipedia article): live cell fewer two live neighbors dies  caused under-population  live cell two three live neighbors lives next generation  live cell three live neighbors dies  over-population   dead cell exactly three live neighbors becomes live cell  reproduction  write function compute next state (after one update) board given current state  next state created applying rules simultaneously every cell current state  births deaths occur simultaneously  medium array 
clean o(1) space o(mn) time java solution game of life according wikipedia's article: "the game life  also known simply life  cellular automaton devised british mathematician john horton conway 1970 " given board n cells  cell initial state live (1) dead (0)  cell interacts eight neighbors (horizontal  vertical  diagonal) using following four rules (taken wikipedia article): live cell fewer two live neighbors dies  caused under-population  live cell two three live neighbors lives next generation  live cell three live neighbors dies  over-population   dead cell exactly three live neighbors becomes live cell  reproduction  write function compute next state (after one update) board given current state  next state created applying rules simultaneously every cell current state  births deaths occur simultaneously  medium array 
8 lines simple java word pattern given pattern string str  find str follows pattern  follow means full match  bijection letter pattern non-empty word str  easy hash table 
short c++  read words on the fly word pattern given pattern string str  find str follows pattern  follow means full match  bijection letter pattern non-empty word str  easy hash table 
very fast (3ms) java solution using hashmap word pattern given pattern string str  find str follows pattern  follow means full match  bijection letter pattern non-empty word str  easy hash table 
short in python word pattern given pattern string str  find str follows pattern  follow means full match  bijection letter pattern non-empty word str  easy hash table 
0ms c++ solution using istringstream and double maps word pattern given pattern string str  find str follows pattern  follow means full match  bijection letter pattern non-empty word str  easy hash table 
theorem: all 4s shall be false nim game playing following nim game friend: heap stones table  time one take turns remove 1 3 stones  one removes last stone winner  take first turn remove stones  clever optimal strategies game  write function determine whether win game given number stones heap  easy brainteaser 
one line o(1) solution and explanation nim game playing following nim game friend: heap stones table  time one take turns remove 1 3 stones  one removes last stone winner  take first turn remove stones  clever optimal strategies game  write function determine whether win game given number stones heap  easy brainteaser 
o(1) efficient single-line java using bit checking nim game playing following nim game friend: heap stones table  time one take turns remove 1 3 stones  one removes last stone winner  take first turn remove stones  clever optimal strategies game  write function determine whether win game given number stones heap  easy brainteaser 
two java solution  nim game playing following nim game friend: heap stones table  time one take turns remove 1 3 stones  one removes last stone winner  take first turn remove stones  clever optimal strategies game  write function determine whether win game given number stones heap  easy brainteaser 
1 line 0 ms c++ solution with explanation nim game playing following nim game friend: heap stones table  time one take turns remove 1 3 stones  one removes last stone winner  take first turn remove stones  clever optimal strategies game  write function determine whether win game given number stones heap  easy brainteaser 
short simple java c++ python  o(log n) + o(1) find median from data stream median middle value ordered integer list  size list even  middle value  median mean two middle value  hard heap design 
share my java solution logn to insert  o(1) to query find median from data stream median middle value ordered integer list  size list even  middle value  median mean two middle value  hard heap design 
java python two heap solution  o(log n) add  o(1) find find median from data stream median middle value ordered integer list  size list even  middle value  median mean two middle value  hard heap design 
easy to understand double-heap solution in java find median from data stream median middle value ordered integer list  size list even  middle value  median mean two middle value  hard heap design 
very short  o(log n) + o(1) find median from data stream median middle value ordered integer list  size list even  middle value  median mean two middle value  hard heap design 
easy to understand java solution serialize and deserialize binary tree serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary tree  restriction serialization deserialization algorithm work  need ensure binary tree serialized string string deserialized original tree structure  hard tree design 
recursive preorder  python and c++  o(n) serialize and deserialize binary tree serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary tree  restriction serialization deserialization algorithm work  need ensure binary tree serialized string string deserialized original tree structure  hard tree design 
short and straight forward bfs java code with a queue serialize and deserialize binary tree serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary tree  restriction serialization deserialization algorithm work  need ensure binary tree serialized string string deserialized original tree structure  hard tree design 
clean c++ solution serialize and deserialize binary tree serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary tree  restriction serialization deserialization algorithm work  need ensure binary tree serialized string string deserialized original tree structure  hard tree design 
recursive dfs  iterative dfs and bfs serialize and deserialize binary tree serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary tree  restriction serialization deserialization algorithm work  need ensure binary tree serialized string string deserialized original tree structure  hard tree design 
one pass java solution bulls and cows playing following bulls cows game friend: write number ask friend guess number is  time friend makes guess  provide hint indicates many digits said guess match secret number exactly digit position (called "bulls") many digits match secret number locate wrong position (called "cows")  friend use successive guesses hints eventually derive secret number  write function return hint according secret number friend's guess  use indicate bulls b indicate cows  please note secret number friend's guess may contain duplicate digits  medium hash table 
[c++] 4ms straight forward solution two pass o(n) time bulls and cows playing following bulls cows game friend: write number ask friend guess number is  time friend makes guess  provide hint indicates many digits said guess match secret number exactly digit position (called "bulls") many digits match secret number locate wrong position (called "cows")  friend use successive guesses hints eventually derive secret number  write function return hint according secret number friend's guess  use indicate bulls b indicate cows  please note secret number friend's guess may contain duplicate digits  medium hash table 
my 3ms java solution may help u bulls and cows playing following bulls cows game friend: write number ask friend guess number is  time friend makes guess  provide hint indicates many digits said guess match secret number exactly digit position (called "bulls") many digits match secret number locate wrong position (called "cows")  friend use successive guesses hints eventually derive secret number  write function return hint according secret number friend's guess  use indicate bulls b indicate cows  please note secret number friend's guess may contain duplicate digits  medium hash table 
python 3 lines solution bulls and cows playing following bulls cows game friend: write number ask friend guess number is  time friend makes guess  provide hint indicates many digits said guess match secret number exactly digit position (called "bulls") many digits match secret number locate wrong position (called "cows")  friend use successive guesses hints eventually derive secret number  write function return hint according secret number friend's guess  use indicate bulls b indicate cows  please note secret number friend's guess may contain duplicate digits  medium hash table 
3 lines in python bulls and cows playing following bulls cows game friend: write number ask friend guess number is  time friend makes guess  provide hint indicates many digits said guess match secret number exactly digit position (called "bulls") many digits match secret number locate wrong position (called "cows")  friend use successive guesses hints eventually derive secret number  write function return hint according secret number friend's guess  use indicate bulls b indicate cows  please note secret number friend's guess may contain duplicate digits  medium hash table 
java python binary search o(nlogn) time with explanation longest increasing subsequence given unsorted array integers  find length longest increasing subsequence  medium binary search dynamic programming 
short java solution using dp o(n log n) longest increasing subsequence given unsorted array integers  find length longest increasing subsequence  medium binary search dynamic programming 
9 lines c++ code with o(nlogn) complexity longest increasing subsequence given unsorted array integers  find length longest increasing subsequence  medium binary search dynamic programming 
my easy to understand o(n^2) solution using dp with video explanation longest increasing subsequence given unsorted array integers  find length longest increasing subsequence  medium binary search dynamic programming 
[c++] typical dp n^2 solution and nlogn solution from geekforgeek longest increasing subsequence given unsorted array integers  find length longest increasing subsequence  medium binary search dynamic programming 
easy  short  concise and fast java dfs 3 ms solution remove invalid parentheses remove minimum number invalid parentheses order make input string valid  return possible results  note: input string may contain letters parentheses ( )  hard depth-first search breadth-first search 
share my java bfs solution remove invalid parentheses remove minimum number invalid parentheses order make input string valid  return possible results  note: input string may contain letters parentheses ( )  hard depth-first search breadth-first search 
easiest 9ms java solution remove invalid parentheses remove minimum number invalid parentheses order make input string valid  return possible results  note: input string may contain letters parentheses ( )  hard depth-first search breadth-first search 
short python bfs remove invalid parentheses remove minimum number invalid parentheses order make input string valid  return possible results  note: input string may contain letters parentheses ( )  hard depth-first search breadth-first search 
my c++ dfs solution - 16ms remove invalid parentheses remove minimum number invalid parentheses order make input string valid  return possible results  note: input string may contain letters parentheses ( )  hard depth-first search breadth-first search 
java simple o(n) init and o(1) query solution range sum query - immutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  easy dynamic programming 
5-lines c++  4-lines python range sum query - immutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  easy dynamic programming 
c++ o(1) queries - just 2 extra lines of code range sum query - immutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  easy dynamic programming 
a very short python solution range sum query - immutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  easy dynamic programming 
my java 3ms solution range sum query - immutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  easy dynamic programming 
clean c++ solution and explaination - o(mn) space with o(1) time range sum query 2d - immutable given 2d matrix matrix  find sum elements inside rectangle defined upper left corner (row1  col1) lower right corner (row2  col2)  rectangle (with red border) defined (row1  col1) = (2  1) (row2  col2) = (4  3)  contains sum = 8  medium dynamic programming 
clean and easy to understand java solution range sum query 2d - immutable given 2d matrix matrix  find sum elements inside rectangle defined upper left corner (row1  col1) lower right corner (row2  col2)  rectangle (with red border) defined (row1  col1) = (2  1) (row2  col2) = (4  3)  contains sum = 8  medium dynamic programming 
sharing my python solution range sum query 2d - immutable given 2d matrix matrix  find sum elements inside rectangle defined upper left corner (row1  col1) lower right corner (row2  col2)  rectangle (with red border) defined (row1  col1) = (2  1) (row2  col2) = (4  3)  contains sum = 8  medium dynamic programming 
c++ with helper range sum query 2d - immutable given 2d matrix matrix  find sum elements inside rectangle defined upper left corner (row1  col1) lower right corner (row2  col2)  rectangle (with red border) defined (row1  col1) = (2  1) (row2  col2) = (4  3)  contains sum = 8  medium dynamic programming 
very clean and fast java solution range sum query 2d - immutable given 2d matrix matrix  find sum elements inside rectangle defined upper left corner (row1  col1) lower right corner (row2  col2)  rectangle (with red border) defined (row1  col1) = (2  1) (row2  col2) = (4  3)  contains sum = 8  medium dynamic programming 
java recursive and iterative solutions additive number additive number string whose digits form additive sequence  valid additive sequence contain least three numbers  except first two numbers  subsequent number sequence must sum preceding two  given string containing digits '0'-'9'  write function determine additive number  note: numbers additive sequence cannot leading zeros  sequence 1  2  03 1  02  3 invalid  medium backtracking 
0ms concise c++ solution (perfectly handles the follow-up and leading 0s) additive number additive number string whose digits form additive sequence  valid additive sequence contain least three numbers  except first two numbers  subsequent number sequence must sum preceding two  given string containing digits '0'-'9'  write function determine additive number  note: numbers additive sequence cannot leading zeros  sequence 1  2  03 1  02  3 invalid  medium backtracking 
 java  very straightforward solution with detailed explanation additive number additive number string whose digits form additive sequence  valid additive sequence contain least three numbers  except first two numbers  subsequent number sequence must sum preceding two  given string containing digits '0'-'9'  write function determine additive number  note: numbers additive sequence cannot leading zeros  sequence 1  2  03 1  02  3 invalid  medium backtracking 
python solution additive number additive number string whose digits form additive sequence  valid additive sequence contain least three numbers  except first two numbers  subsequent number sequence must sum preceding two  given string containing digits '0'-'9'  write function determine additive number  note: numbers additive sequence cannot leading zeros  sequence 1  2  03 1  02  3 invalid  medium backtracking 
java easy understand dfs additive number additive number string whose digits form additive sequence  valid additive sequence contain least three numbers  except first two numbers  subsequent number sequence must sum preceding two  given string containing digits '0'-'9'  write function determine additive number  note: numbers additive sequence cannot leading zeros  sequence 1  2  03 1  02  3 invalid  medium backtracking 
17 ms java solution with segment tree range sum query - mutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  update(i  val) function modifies nums updating element index val  medium binary indexed tree segment tree 
java using binary indexed tree with clear explanation range sum query - mutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  update(i  val) function modifies nums updating element index val  medium binary indexed tree segment tree 
"0 lines" python range sum query - mutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  update(i  val) function modifies nums updating element index val  medium binary indexed tree segment tree 
c++ solution using "buckets"  o(1) for updating and o(n^0 5) for query in the worst case (not the fast)  range sum query - mutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  update(i  val) function modifies nums updating element index val  medium binary indexed tree segment tree 
python: well commented solution using segment trees range sum query - mutable given integer array nums  find sum elements indices j (i ≤ j)  inclusive  update(i  val) function modifies nums updating element index val  medium binary indexed tree segment tree 
share my thinking process best time to buy and sell stock with cooldown say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (ie  buy one sell one share stock multiple times) following restrictions: may engage multiple transactions time (ie  must sell stock buy again)  sell stock  cannot buy stock next day  (ie  cooldown 1 day) medium dynamic programming 
share my dp solution (by state machine thinking) best time to buy and sell stock with cooldown say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (ie  buy one sell one share stock multiple times) following restrictions: may engage multiple transactions time (ie  must sell stock buy again)  sell stock  cannot buy stock next day  (ie  cooldown 1 day) medium dynamic programming 
easiest java solution with explanations best time to buy and sell stock with cooldown say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (ie  buy one sell one share stock multiple times) following restrictions: may engage multiple transactions time (ie  must sell stock buy again)  sell stock  cannot buy stock next day  (ie  cooldown 1 day) medium dynamic programming 
7-line java: only consider sell and cooldown best time to buy and sell stock with cooldown say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (ie  buy one sell one share stock multiple times) following restrictions: may engage multiple transactions time (ie  must sell stock buy again)  sell stock  cannot buy stock next day  (ie  cooldown 1 day) medium dynamic programming 
very easy to understand one pass o(n) solution with no extra space best time to buy and sell stock with cooldown say array ith element price given stock day i  design algorithm find maximum profit  may complete many transactions like (ie  buy one sell one share stock multiple times) following restrictions: may engage multiple transactions time (ie  must sell stock buy again)  sell stock  cannot buy stock next day  (ie  cooldown 1 day) medium dynamic programming 
share some thoughts minimum height trees undirected graph tree characteristics  choose node root  result graph rooted tree  among possible rooted trees  minimum height called minimum height trees (mhts)  given graph  write function find mhts return list root labels  format graph contains n nodes labeled 0 n - 1  given number n list undirected edges (each edge pair labels)  assume duplicate edges appear edges  since edges undirected  [0  1] [1  0] thus appear together edges  medium breadth-first search graph 
two o(n) solutions minimum height trees undirected graph tree characteristics  choose node root  result graph rooted tree  among possible rooted trees  minimum height called minimum height trees (mhts)  given graph  write function find mhts return list root labels  format graph contains n nodes labeled 0 n - 1  given number n list undirected edges (each edge pair labels)  assume duplicate edges appear edges  since edges undirected  [0  1] [1  0] thus appear together edges  medium breadth-first search graph 
c++ solution  o(n)-time  o(n)-space minimum height trees undirected graph tree characteristics  choose node root  result graph rooted tree  among possible rooted trees  minimum height called minimum height trees (mhts)  given graph  write function find mhts return list root labels  format graph contains n nodes labeled 0 n - 1  given number n list undirected edges (each edge pair labels)  assume duplicate edges appear edges  since edges undirected  [0  1] [1  0] thus appear together edges  medium breadth-first search graph 
c++ bfs short clean solution with explanation minimum height trees undirected graph tree characteristics  choose node root  result graph rooted tree  among possible rooted trees  minimum height called minimum height trees (mhts)  given graph  write function find mhts return list root labels  format graph contains n nodes labeled 0 n - 1  given number n list undirected edges (each edge pair labels)  assume duplicate edges appear edges  since edges undirected  [0  1] [1  0] thus appear together edges  medium breadth-first search graph 
share my bfs java code using degree with explanation  which beats more than 95% minimum height trees undirected graph tree characteristics  choose node root  result graph rooted tree  among possible rooted trees  minimum height called minimum height trees (mhts)  given graph  write function find mhts return list root labels  format graph contains n nodes labeled 0 n - 1  given number n list undirected edges (each edge pair labels)  assume duplicate edges appear edges  since edges undirected  [0  1] [1  0] thus appear together edges  medium breadth-first search graph 
share some analysis and explanations burst balloons given n balloons  indexed 0 n-1  balloon painted number represented array nums  asked burst balloons  burst balloon get nums[left]   nums[i]   nums[right] coins  left right adjacent indices i  burst  left right becomes adjacent  find maximum coins collect bursting balloons wisely  note: may imagine nums[-1] = nums[n] = 1  real therefore burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
c++ dynamic programming  o(n^3)  32 ms  with comments burst balloons given n balloons  indexed 0 n-1  balloon painted number represented array nums  asked burst balloons  burst balloon get nums[left]   nums[i]   nums[right] coins  left right adjacent indices i  burst  left right becomes adjacent  find maximum coins collect bursting balloons wisely  note: may imagine nums[-1] = nums[n] = 1  real therefore burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
for anyone that is still confused after reading all kinds of explanations    burst balloons given n balloons  indexed 0 n-1  balloon painted number represented array nums  asked burst balloons  burst balloon get nums[left]   nums[i]   nums[right] coins  left right adjacent indices i  burst  left right becomes adjacent  find maximum coins collect bursting balloons wisely  note: may imagine nums[-1] = nums[n] = 1  real therefore burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
java dp solution with detailed explanation  o(n^3) burst balloons given n balloons  indexed 0 n-1  balloon painted number represented array nums  asked burst balloons  burst balloon get nums[left]   nums[i]   nums[right] coins  left right adjacent indices i  burst  left right becomes adjacent  find maximum coins collect bursting balloons wisely  note: may imagine nums[-1] = nums[n] = 1  real therefore burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
easiest java solution burst balloons given n balloons  indexed 0 n-1  balloon painted number represented array nums  asked burst balloons  burst balloon get nums[left]   nums[i]   nums[right] coins  left right adjacent indices i  burst  left right becomes adjacent  find maximum coins collect bursting balloons wisely  note: may imagine nums[-1] = nums[n] = 1  real therefore burst them  0 ≤ n ≤ 500  0 ≤ nums[i] ≤ 100 hard divide and conquer dynamic programming 
java three methods  23ms  36 ms  58ms(with heap)  performance explained super ugly number write program find nth super ugly number  super ugly numbers positive numbers whose prime factors given prime list primes size k  medium math heap 
7 line consice o(kn) c++ solution super ugly number write program find nth super ugly number  super ugly numbers positive numbers whose prime factors given prime list primes size k  medium math heap 
108ms easy to understand java solution super ugly number write program find nth super ugly number  super ugly numbers positive numbers whose prime factors given prime list primes size k  medium math heap 
python  generators on a heap super ugly number write program find nth super ugly number  super ugly numbers positive numbers whose prime factors given prime list primes size k  medium math heap 
java solution uff0c21ms uff0c u8be6 u7ec6 u7684 u4e2d u6587 u89e3 u91ca super ugly number write program find nth super ugly number  super ugly numbers positive numbers whose prime factors given prime list primes size k  medium math heap 
9ms  short java bst solution get answer when building bst count of smaller numbers after self given integer array nums return new counts array  counts array property counts[i] number smaller elements right nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
mergesort solution count of smaller numbers after self given integer array nums return new counts array  counts array property counts[i] number smaller elements right nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
11ms java solution using merge sort with explanation count of smaller numbers after self given integer array nums return new counts array  counts array property counts[i] number smaller elements right nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
my simple ac java binary search code count of smaller numbers after self given integer array nums return new counts array  counts array property counts[i] number smaller elements right nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
c++ o(nlogn)-time o(n)-space mergesort solution with detail explanation count of smaller numbers after self given integer array nums return new counts array  counts array property counts[i] number smaller elements right nums[i]  hard divide and conquer binary indexed tree segment tree binary search tree 
a short o(n) recursive greedy solution remove duplicate letters given string contains lowercase letters  remove duplicate letters every letter appear once  must make sure result smallest lexicographical order among possible results  hard stack greedy 
java solution using stack with comments remove duplicate letters given string contains lowercase letters  remove duplicate letters every letter appear once  must make sure result smallest lexicographical order among possible results  hard stack greedy 
easy to understand iterative java solution remove duplicate letters given string contains lowercase letters  remove duplicate letters every letter appear once  must make sure result smallest lexicographical order among possible results  hard stack greedy 
c++ simple solution easy understanding remove duplicate letters given string contains lowercase letters  remove duplicate letters every letter appear once  must make sure result smallest lexicographical order among possible results  hard stack greedy 
java o(n) solution using stack with detail explanation remove duplicate letters given string contains lowercase letters  remove duplicate letters every letter appear once  must make sure result smallest lexicographical order among possible results  hard stack greedy 
java----------easy version to understand!!!!!!!!!!!!!!!!! maximum product of word lengths given string array words  find maximum value length(word[i])   length(word[j]) two words share common letters  may assume word contain lower case letters  two words exist  return 0  medium bit manipulation 
32ms java ac solution maximum product of word lengths given string array words  find maximum value length(word[i])   length(word[j]) two words share common letters  may assume word contain lower case letters  two words exist  return 0  medium bit manipulation 
bit shorter c++ maximum product of word lengths given string array words  find maximum value length(word[i])   length(word[j]) two words share common letters  may assume word contain lower case letters  two words exist  return 0  medium bit manipulation 
python solution  beats 99 67% maximum product of word lengths given string array words  find maximum value length(word[i])   length(word[j]) two words share common letters  may assume word contain lower case letters  two words exist  return 0  medium bit manipulation 
java solution with comments maximum product of word lengths given string array words  find maximum value length(word[i])   length(word[j]) two words share common letters  may assume word contain lower case letters  two words exist  return 0  medium bit manipulation 
math solution   bulb switcher n bulbs initially off  first turn bulbs  then  turn every second bulb  third round  toggle every third bulb (turning turning on)  i-th round  toggle every bulb  n-th round  toggle last bulb  find many bulbs n rounds  medium math brainteaser 
share my o(1) solution with explanation bulb switcher n bulbs initially off  first turn bulbs  then  turn every second bulb  third round  toggle every third bulb (turning turning on)  i-th round  toggle every bulb  n-th round  toggle last bulb  find many bulbs n rounds  medium math brainteaser 
my 0 ms c++ solution with explanation bulb switcher n bulbs initially off  first turn bulbs  then  turn every second bulb  third round  toggle every third bulb (turning turning on)  i-th round  toggle every bulb  n-th round  toggle last bulb  find many bulbs n rounds  medium math brainteaser 
the simplest and most efficient solution well-explained bulb switcher n bulbs initially off  first turn bulbs  then  turn every second bulb  third round  toggle every third bulb (turning turning on)  i-th round  toggle every bulb  n-th round  toggle last bulb  find many bulbs n rounds  medium math brainteaser 
one line java with explanation bulb switcher n bulbs initially off  first turn bulbs  then  turn every second bulb  third round  toggle every third bulb (turning turning on)  i-th round  toggle every bulb  n-th round  toggle last bulb  find many bulbs n rounds  medium math brainteaser 
share my greedy solution create maximum number given two arrays length n digits 0-9 representing two numbers  create maximum number length k <= + n digits two  relative order digits array must preserved  return array k digits  note: try optimize time space complexity  hard dynamic programming greedy 
c++ 16ms  fastest  beats 97%  create maximum number given two arrays length n digits 0-9 representing two numbers  create maximum number length k <= + n digits two  relative order digits array must preserved  return array k digits  note: try optimize time space complexity  hard dynamic programming greedy 
short python   ruby   c++ create maximum number given two arrays length n digits 0-9 representing two numbers  create maximum number length k <= + n digits two  relative order digits array must preserved  return array k digits  note: try optimize time space complexity  hard dynamic programming greedy 
share my 21ms java solution with comments create maximum number given two arrays length n digits 0-9 representing two numbers  create maximum number length k <= + n digits two  relative order digits array must preserved  return array k digits  note: try optimize time space complexity  hard dynamic programming greedy 
share my python solution with explanation create maximum number given two arrays length n digits 0-9 representing two numbers  create maximum number length k <= + n digits two  relative order digits array must preserved  return array k digits  note: try optimize time space complexity  hard dynamic programming greedy 
[c++] o(n amount) time o(amount) space dp solution coin change given coins different denominations total amount money amount  write function compute fewest number coins need make amount  amount money cannot made combination coins  return -1  medium dynamic programming 
 java  both iterative and recursive solutions with explanations coin change given coins different denominations total amount money amount  write function compute fewest number coins need make amount  amount money cannot made combination coins  return -1  medium dynamic programming 
easy-to-understand recursive dp solution using java (with explanations) coin change given coins different denominations total amount money amount  write function compute fewest number coins need make amount  amount money cannot made combination coins  return -1  medium dynamic programming 
clean dp python code coin change given coins different denominations total amount money amount  write function compute fewest number coins need make amount  amount money cannot made combination coins  return -1  medium dynamic programming 
fast python bfs solution coin change given coins different denominations total amount money amount  write function compute fewest number coins need make amount  amount money cannot made combination coins  return -1  medium dynamic programming 
o(n)+o(1) after median --- virtual indexing wiggle sort ii given unsorted array nums  reorder nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
step by step explanation of index mapping in java wiggle sort ii given unsorted array nums  reorder nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
3 lines python  with explanation   proof wiggle sort ii given unsorted array nums  reorder nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
summary of the various solutions to wiggle sort for your reference wiggle sort ii given unsorted array nums  reorder nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
o(n)-time o(1)-space solution with detail explanations wiggle sort ii given unsorted array nums  reorder nums[0] < nums[1] > nums[2] < nums[3]     medium sort 
1 line java solution without loop   recursion power of three given integer  write function determine power three  easy math 
   a summary of `all` solutions (new method included at 15:30pm jan-8th) power of three given integer  write function determine power three  easy math 
without log and o(1)  power of three given integer  write function determine power three  easy math 
1 line c++ no recursion loop power of three given integer  write function determine power three  easy math 
one line (cheating) power of three given integer  write function determine power three  easy math 
share my solution count of range sum given integer array nums  return number range sums lie [lower  upper] inclusive  range sum s(i  j) defined sum elements nums indices j (i ≤ j)  inclusive  note: naive algorithm o(n2) trivial  must better that  hard divide and conquer binary search tree 
summary of the divide and conquer based and binary indexed tree based solutions count of range sum given integer array nums  return number range sums lie [lower  upper] inclusive  range sum s(i  j) defined sum elements nums indices j (i ≤ j)  inclusive  note: naive algorithm o(n2) trivial  must better that  hard divide and conquer binary search tree 
short & simple o(n log n) count of range sum given integer array nums  return number range sums lie [lower  upper] inclusive  range sum s(i  j) defined sum elements nums indices j (i ≤ j)  inclusive  note: naive algorithm o(n2) trivial  must better that  hard divide and conquer binary search tree 
java segmenttree solution  36ms count of range sum given integer array nums  return number range sums lie [lower  upper] inclusive  range sum s(i  j) defined sum elements nums indices j (i ≤ j)  inclusive  note: naive algorithm o(n2) trivial  must better that  hard divide and conquer binary search tree 
c++ merge sort solution  very short count of range sum given integer array nums  return number range sums lie [lower  upper] inclusive  range sum s(i  j) defined sum elements nums indices j (i ≤ j)  inclusive  note: naive algorithm o(n2) trivial  must better that  hard divide and conquer binary search tree 
simple o(n) time  o(1)  space java solution  odd even linked list given singly linked list  group odd nodes together followed even nodes  please note talking node number value nodes  try place  program run o(1) space complexity o(nodes) time complexity  medium linked list 
straigntforward java solution  o(1) space  o(n) time odd even linked list given singly linked list  group odd nodes together followed even nodes  please note talking node number value nodes  try place  program run o(1) space complexity o(nodes) time complexity  medium linked list 
simple c++ solution  o(n) time  o(1) space odd even linked list given singly linked list  group odd nodes together followed even nodes  please note talking node number value nodes  try place  program run o(1) space complexity o(nodes) time complexity  medium linked list 
clear python solution odd even linked list given singly linked list  group odd nodes together followed even nodes  please note talking node number value nodes  try place  program run o(1) space complexity o(nodes) time complexity  medium linked list 
1ms java solution odd even linked list given singly linked list  group odd nodes together followed even nodes  please note talking node number value nodes  try place  program run o(1) space complexity o(nodes) time complexity  medium linked list 
15ms concise java solution longest increasing path in a matrix given integer matrix  find length longest increasing path  cell  either move four directions: left  right  down  may move diagonally move outside boundary (i e  wrap-around allowed)  hard depth-first search topological sort memoization 
python solution  memoization dp  288ms longest increasing path in a matrix given integer matrix  find length longest increasing path  cell  either move four directions: left  right  down  may move diagonally move outside boundary (i e  wrap-around allowed)  hard depth-first search topological sort memoization 
graph theory  java solution  o(v^2)  no dfs longest increasing path in a matrix given integer matrix  find length longest increasing path  cell  either move four directions: left  right  down  may move diagonally move outside boundary (i e  wrap-around allowed)  hard depth-first search topological sort memoization 
java 14ms relative short & easy to code solution with explanation  o(mn) time o(mn) space  dfs + dp longest increasing path in a matrix given integer matrix  find length longest increasing path  cell  either move four directions: left  right  down  may move diagonally move outside boundary (i e  wrap-around allowed)  hard depth-first search topological sort memoization 
c++ dp   dfs solution sharing longest increasing path in a matrix given integer matrix  find length longest increasing path  cell  either move four directions: left  right  down  may move diagonally move outside boundary (i e  wrap-around allowed)  hard depth-first search topological sort memoization 
solution + explanation patching array given sorted positive integer array nums integer n  add patch elements array number range [1  n] inclusive formed sum elements array  return minimum number patches required  hard greedy 
share my thinking process patching array given sorted positive integer array nums integer n  add patch elements array number range [1  n] inclusive formed sum elements array  return minimum number patches required  hard greedy 
c++  8ms  greedy solution with explanation patching array given sorted positive integer array nums integer n  add patch elements array number range [1  n] inclusive formed sum elements array  return minimum number patches required  hard greedy 
share my greedy solution by java with simple explanation (time: 1 ms) patching array given sorted positive integer array nums integer n  add patch elements array number range [1  n] inclusive formed sum elements array  return minimum number patches required  hard greedy 
my simple accepted c++ solution patching array given sorted positive integer array nums integer n  add patch elements array number range [1  n] inclusive formed sum elements array  return minimum number patches required  hard greedy 
7 lines easy java solution verify preorder serialization of a binary tree one way serialize binary tree use pre-order traversal  encounter non-null node  record node's value  null node  record using sentinel value #  _9_     3 2         4 1 # 6             # # # # # # medium stack 
java intuitive 22ms solution with stack verify preorder serialization of a binary tree one way serialize binary tree use pre-order traversal  encounter non-null node  record node's value  null node  record using sentinel value #  _9_     3 2         4 1 # 6             # # # # # # medium stack 
the simplest python solution with explanation (no stack  no recursion) verify preorder serialization of a binary tree one way serialize binary tree use pre-order traversal  encounter non-null node  record node's value  null node  record using sentinel value #  _9_     3 2         4 1 # 6             # # # # # # medium stack 
java  counting indegree and outdegree  simple & clear! verify preorder serialization of a binary tree one way serialize binary tree use pre-order traversal  encounter non-null node  record node's value  null node  record using sentinel value #  _9_     3 2         4 1 # 6             # # # # # # medium stack 
simple python solution using stack  with explanation  verify preorder serialization of a binary tree one way serialize binary tree use pre-order traversal  encounter non-null node  record node's value  null node  record using sentinel value #  _9_     3 2         4 1 # 6             # # # # # # medium stack 
short ruby   python   java   c++ reconstruct itinerary given list airline tickets represented pairs departure arrival airports [from  to]  reconstruct itinerary order  tickets belong man departs jfk  thus  itinerary must begin jfk  note: multiple valid itineraries  return itinerary smallest lexical order read single string  medium depth-first search graph 
share my solution reconstruct itinerary given list airline tickets represented pairs departure arrival airports [from  to]  reconstruct itinerary order  tickets belong man departs jfk  thus  itinerary must begin jfk  note: multiple valid itineraries  return itinerary smallest lexical order read single string  medium depth-first search graph 
short c++ dfs iterative 44ms solution with explanation   no recursive calls  no backtracking  reconstruct itinerary given list airline tickets represented pairs departure arrival airports [from  to]  reconstruct itinerary order  tickets belong man departs jfk  thus  itinerary must begin jfk  note: multiple valid itineraries  return itinerary smallest lexical order read single string  medium depth-first search graph 
[share solution] java  greedy  stack  15ms with explanation reconstruct itinerary given list airline tickets represented pairs departure arrival airports [from  to]  reconstruct itinerary order  tickets belong man departs jfk  thus  itinerary must begin jfk  note: multiple valid itineraries  return itinerary smallest lexical order read single string  medium depth-first search graph 
very straightforward dfs solution with detailed explanations reconstruct itinerary given list airline tickets represented pairs departure arrival airports [from  to]  reconstruct itinerary order  tickets belong man departs jfk  thus  itinerary must begin jfk  note: multiple valid itineraries  return itinerary smallest lexical order read single string  medium depth-first search graph 
concise java solution with comments  increasing triplet subsequence given unsorted array return whether increasing subsequence length 3 exists array  formally function should: return true exists i  j  k arr[i] < arr[j] < arr[k] given 0 ≤ < j < k ≤ n-1 else return false  note: algorithm run o(n) time complexity o(1) space complexity  medium 
clean and short  with comments  c++ increasing triplet subsequence given unsorted array return whether increasing subsequence length 3 exists array  formally function should: return true exists i  j  k arr[i] < arr[j] < arr[k] given 0 ≤ < j < k ≤ n-1 else return false  note: algorithm run o(n) time complexity o(1) space complexity  medium 
python easy o(n) solution increasing triplet subsequence given unsorted array return whether increasing subsequence length 3 exists array  formally function should: return true exists i  j  k arr[i] < arr[j] < arr[k] given 0 ≤ < j < k ≤ n-1 else return false  note: algorithm run o(n) time complexity o(1) space complexity  medium 
my accepted java solution for this question  only 7-lines  clear and concise  increasing triplet subsequence given unsorted array return whether increasing subsequence length 3 exists array  formally function should: return true exists i  j  k arr[i] < arr[j] < arr[k] given 0 ≤ < j < k ≤ n-1 else return false  note: algorithm run o(n) time complexity o(1) space complexity  medium 
simple java solution   easy to understand!!!! increasing triplet subsequence given unsorted array return whether increasing subsequence length 3 exists array  formally function should: return true exists i  j  k arr[i] < arr[j] < arr[k] given 0 ≤ < j < k ≤ n-1 else return false  note: algorithm run o(n) time complexity o(1) space complexity  medium 
java oms with explanation self crossing given array x n positive numbers  start point (0 0) moves x[0] metres north  x[1] metres west  x[2] metres south  x[3] metres east on  words  move direction changes counter-clockwise  write one-pass algorithm o(1) extra space determine  path crosses itself  not  hard math 
another python    self crossing given array x n positive numbers  start point (0 0) moves x[0] metres north  x[1] metres west  x[2] metres south  x[3] metres east on  words  move direction changes counter-clockwise  write one-pass algorithm o(1) extra space determine  path crosses itself  not  hard math 
simple java solution self crossing given array x n positive numbers  start point (0 0) moves x[0] metres north  x[1] metres west  x[2] metres south  x[3] metres east on  words  move direction changes counter-clockwise  write one-pass algorithm o(1) extra space determine  path crosses itself  not  hard math 
the best submission in c searching for the crossing patterns is the key self crossing given array x n positive numbers  start point (0 0) moves x[0] metres north  x[1] metres west  x[2] metres south  x[3] metres east on  words  move direction changes counter-clockwise  write one-pass algorithm o(1) extra space determine  path crosses itself  not  hard math 
c++ simple solution self crossing given array x n positive numbers  start point (0 0) moves x[0] metres north  x[1] metres west  x[2] metres south  x[3] metres east on  words  move direction changes counter-clockwise  write one-pass algorithm o(1) extra space determine  path crosses itself  not  hard math 
o(n   k^2) java solution with trie structure palindrome pairs given list unique words  find pairs distinct indices (i  j) given list  concatenation two words  i e  words[i] + words[j] palindrome  hard hash table string trie 
150 ms 45 lines java solution palindrome pairs given list unique words  find pairs distinct indices (i  j) given list  concatenation two words  i e  words[i] + words[j] palindrome  hard hash table string trie 
the easy-to-unserstand java solution palindrome pairs given list unique words  find pairs distinct indices (i  j) given list  concatenation two words  i e  words[i] + words[j] palindrome  hard hash table string trie 
accepted python solution with explanation palindrome pairs given list unique words  find pairs distinct indices (i  j) given list  concatenation two words  i e  words[i] + words[j] palindrome  hard hash table string trie 
easy to understand ac c++ solution o(n k^2) using map palindrome pairs given list unique words  find pairs distinct indices (i  j) given list  concatenation two words  i e  words[i] + words[j] palindrome  hard hash table string trie 
step by step tackling of the problem house robber iii thief found new place thievery again  one entrance area  called "root " besides root  house one one parent house  tour  smart thief realized "all houses place forms binary tree"  automatically contact police two directly-linked houses broken night  determine maximum amount money thief rob tonight without alerting police  medium tree depth-first search 
easy understanding solution with dfs house robber iii thief found new place thievery again  one entrance area  called "root " besides root  house one one parent house  tour  smart thief realized "all houses place forms binary tree"  automatically contact police two directly-linked houses broken night  determine maximum amount money thief rob tonight without alerting police  medium tree depth-first search 
simple c++ solution house robber iii thief found new place thievery again  one entrance area  called "root " besides root  house one one parent house  tour  smart thief realized "all houses place forms binary tree"  automatically contact police two directly-linked houses broken night  determine maximum amount money thief rob tonight without alerting police  medium tree depth-first search 
easy to understand(java) house robber iii thief found new place thievery again  one entrance area  called "root " besides root  house one one parent house  tour  smart thief realized "all houses place forms binary tree"  automatically contact police two directly-linked houses broken night  determine maximum amount money thief rob tonight without alerting police  medium tree depth-first search 
c++  java  python &  explanation house robber iii thief found new place thievery again  one entrance area  called "root " besides root  house one one parent house  tour  smart thief realized "all houses place forms binary tree"  automatically contact police two directly-linked houses broken night  determine maximum amount money thief rob tonight without alerting police  medium tree depth-first search 
three-line java solution counting bits given non negative integer number num  every numbers range 0 ≤ ≤ num calculate number 1's binary representation return array  medium dynamic programming bit manipulation 
four lines  c++  time o(n)  space o(n) counting bits given non negative integer number num  every numbers range 0 ≤ ≤ num calculate number 1's binary representation return array  medium dynamic programming bit manipulation 
how we handle this question on interview [thinking process + dp solution] counting bits given non negative integer number num  every numbers range 0 ≤ ≤ num calculate number 1's binary representation return array  medium dynamic programming bit manipulation 
simple java o(n) solution using two pointers counting bits given non negative integer number num  every numbers range 0 ≤ ≤ num calculate number 1's binary representation return array  medium dynamic programming bit manipulation 
simple java dynamic programming without any bitwise operation counting bits given non negative integer number num  every numbers range 0 ≤ ≤ num calculate number 1's binary representation return array  medium dynamic programming bit manipulation 
simple java solution using a stack with explanation flatten nested list iterator given nested list integers  implement iterator flatten it  element either integer  list -- whose elements may also integers lists  medium stack design 
real iterator in python  java  c++ flatten nested list iterator given nested list integers  implement iterator flatten it  element either integer  list -- whose elements may also integers lists  medium stack design 
share my java neat solution  8ms flatten nested list iterator given nested list integers  implement iterator flatten it  element either integer  list -- whose elements may also integers lists  medium stack design 
8-line python solution flatten nested list iterator given nested list integers  implement iterator flatten it  element either integer  list -- whose elements may also integers lists  medium stack design 
concise c++ without storing all values at initialization flatten nested list iterator given nested list integers  implement iterator flatten it  element either integer  list -- whose elements may also integers lists  medium stack design 
java 1-line (cheating for the purpose of not using loops) power of four given integer (signed 32 bits)  write function check whether power 4  easy bit manipulation 
1 line c++ solution without confusing bit manipulations power of four given integer (signed 32 bits)  write function check whether power 4  easy bit manipulation 
o(1) one-line solution without loops power of four given integer (signed 32 bits)  write function check whether power 4  easy bit manipulation 
python one line solution with explanations power of four given integer (signed 32 bits)  write function check whether power 4  easy bit manipulation 
simple c++ o(1) solution without 0x55555555 power of four given integer (signed 32 bits)  write function check whether power 4  easy bit manipulation 
why factor 2 or 3? the math behind this problem  integer break given positive integer n  break sum least two positive integers maximize product integers  return maximum product get  medium math dynamic programming 
a simple explanation of the math part and a o(n) solution integer break given positive integer n  break sum least two positive integers maximize product integers  return maximum product get  medium math dynamic programming 
java dp solution integer break given positive integer n  break sum least two positive integers maximize product integers  return maximum product get  medium math dynamic programming 
o(log(n)) time solution with explanation integer break given positive integer n  break sum least two positive integers maximize product integers  return maximum product get  medium math dynamic programming 
easy to understand c++ with explanation integer break given positive integer n  break sum least two positive integers maximize product integers  return maximum product get  medium math dynamic programming 
[java] simple and clean with explanations [6 solutions] reverse string write function takes string input returns string reversed  easy two pointers string 
python2 7 (3 solutions: recursive  classic  pythonic) reverse string write function takes string input returns string reversed  easy two pointers string 
simple c++ solution reverse string write function takes string input returns string reversed  easy two pointers string 
python solution reverse string write function takes string input returns string reversed  easy two pointers string 
c solution sharing reverse string write function takes string input returns string reversed  easy two pointers string 
java standard two pointer solution reverse vowels of a string write function takes string input reverse vowels string  easy two pointers string 
super clean c++ solution using find_first_of and find_last_of reverse vowels of a string write function takes string input reverse vowels string  easy two pointers string 
1-2 lines python ruby reverse vowels of a string write function takes string input reverse vowels string  easy two pointers string 
python 2 pointers solution reverse vowels of a string write function takes string input reverse vowels string  easy two pointers string 
one pass java solution 13ms reverse vowels of a string write function takes string input reverse vowels string  easy two pointers string 
java o(n) solution - bucket sort top k frequent elements given non-empty array integers  return k frequent elements  medium hash table heap 
3 java solution using array  maxheap  treemap top k frequent elements given non-empty array integers  return k frequent elements  medium hash table heap 
c++ o(n log(n-k)) unordered_map and priority_queue(maxheap) solution top k frequent elements given non-empty array integers  return k frequent elements  medium hash table heap 
3 ways to solve this problem top k frequent elements given non-empty array integers  return k frequent elements  medium hash table heap 
simple c++ solution using hash table and bucket sort top k frequent elements given non-empty array integers  return k frequent elements  medium hash table heap 
three java solutions intersection of two arrays given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
8ms concise c++ using unordered_set intersection of two arrays given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
small c++ solution intersection of two arrays given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
5ms java using 1 hashset and time complexity of o(m+n) intersection of two arrays given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
python code  3 lines using set intersection of two arrays given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
solution to 3rd follow-up question intersection of two arrays ii given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
ac solution using java hashmap intersection of two arrays ii given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
c++ hash table solution and sort + two pointers solution with time and space complexity intersection of two arrays ii given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
short python   c++ intersection of two arrays ii given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
2 lines in python intersection of two arrays ii given two arrays  write function compute intersection  easy hash table two pointers binary search sort 
java solution using treemap  real o(logn) per adding  data stream as disjoint intervals given data stream input non-negative integers a1  a2       an       summarize numbers seen far list disjoint intervals  hard binary search tree 
very concise c++ solution  data stream as disjoint intervals given data stream input non-negative integers a1  a2       an       summarize numbers seen far list disjoint intervals  hard binary search tree 
share my python solution using heap data stream as disjoint intervals given data stream input non-negative integers a1  a2       an       summarize numbers seen far list disjoint intervals  hard binary search tree 
java fast log (n) solution (186ms) without using the treemap but a customized bst data stream as disjoint intervals given data stream input non-negative integers a1  a2       an       summarize numbers seen far list disjoint intervals  hard binary search tree 
i can not understand the question description  can any one explain it? data stream as disjoint intervals given data stream input non-negative integers a1  a2       an       summarize numbers seen far list disjoint intervals  hard binary search tree 
java nlogn solution with explanation russian doll envelopes number envelopes widths heights given pair integers (w  h)  one envelope fit another width height one envelope greater width height envelope  maximum number envelopes russian doll? (put one inside other) note: rotation allowed  hard binary search dynamic programming 
simple dp solution russian doll envelopes number envelopes widths heights given pair integers (w  h)  one envelope fit another width height one envelope greater width height envelope  maximum number envelopes russian doll? (put one inside other) note: rotation allowed  hard binary search dynamic programming 
[[1 3] [3 5] [6 7] [6 8] [8 4] [9 5]] should be 4 not 3 russian doll envelopes number envelopes widths heights given pair integers (w  h)  one envelope fit another width height one envelope greater width height envelope  maximum number envelopes russian doll? (put one inside other) note: rotation allowed  hard binary search dynamic programming 
c++ 9-line short and clean o(nlogn) solution (plus classic o(n^2) dp solution)  russian doll envelopes number envelopes widths heights given pair integers (w  h)  one envelope fit another width height one envelope greater width height envelope  maximum number envelopes russian doll? (put one inside other) note: rotation allowed  hard binary search dynamic programming 
a trick to solve this problem  russian doll envelopes number envelopes widths heights given pair integers (w  h)  one envelope fit another width height one envelope greater width height envelope  maximum number envelopes russian doll? (put one inside other) note: rotation allowed  hard binary search dynamic programming 
java oo design with most efficient function getnewsfeed design twitter design simplified version twitter users post tweets  follow unfollow another user able see 10 recent tweets user's news feed  design support following methods: posttweet(userid  tweetid): compose new tweet  getnewsfeed(userid): retrieve 10 recent tweet ids user's news feed  item news feed must posted users user followed user herself  tweets must ordered recent least recent  follow(followerid  followeeid): follower follows followee  unfollow(followerid  followeeid): follower unfollows followee  medium hash table heap design 
python solution design twitter design simplified version twitter users post tweets  follow unfollow another user able see 10 recent tweets user's news feed  design support following methods: posttweet(userid  tweetid): compose new tweet  getnewsfeed(userid): retrieve 10 recent tweet ids user's news feed  item news feed must posted users user followed user herself  tweets must ordered recent least recent  follow(followerid  followeeid): follower follows followee  unfollow(followerid  followeeid): follower unfollows followee  medium hash table heap design 
java solutions with two maps and priorityqueue design twitter design simplified version twitter users post tweets  follow unfollow another user able see 10 recent tweets user's news feed  design support following methods: posttweet(userid  tweetid): compose new tweet  getnewsfeed(userid): retrieve 10 recent tweet ids user's news feed  item news feed must posted users user followed user herself  tweets must ordered recent least recent  follow(followerid  followeeid): follower follows followee  unfollow(followerid  followeeid): follower unfollows followee  medium hash table heap design 
72ms c++ solution design twitter design simplified version twitter users post tweets  follow unfollow another user able see 10 recent tweets user's news feed  design support following methods: posttweet(userid  tweetid): compose new tweet  getnewsfeed(userid): retrieve 10 recent tweet ids user's news feed  item news feed must posted users user followed user herself  tweets must ordered recent least recent  follow(followerid  followeeid): follower follows followee  unfollow(followerid  followeeid): follower unfollows followee  medium hash table heap design 
java ood solution with detailed explanation design twitter design simplified version twitter users post tweets  follow unfollow another user able see 10 recent tweets user's news feed  design support following methods: posttweet(userid  tweetid): compose new tweet  getnewsfeed(userid): retrieve 10 recent tweet ids user's news feed  item news feed must posted users user followed user herself  tweets must ordered recent least recent  follow(followerid  followeeid): follower follows followee  unfollow(followerid  followeeid): follower unfollows followee  medium hash table heap design 
java dp o(1) solution  count numbers with unique digits given non-negative integer n  count numbers unique digits  x  0 ≤ x < 10n  medium math dynamic programming backtracking 
java  o(1)  with explanation count numbers with unique digits given non-negative integer n  count numbers unique digits  x  0 ≤ x < 10n  medium math dynamic programming backtracking 
share my 0ms c++ solution with proof and explanation count numbers with unique digits given non-negative integer n  count numbers unique digits  x  0 ≤ x < 10n  medium math dynamic programming backtracking 
backtracking solution count numbers with unique digits given non-negative integer n  count numbers unique digits  x  0 ≤ x < 10n  medium math dynamic programming backtracking 
simple python solution  90% count numbers with unique digits given non-negative integer n  count numbers unique digits  x  0 ≤ x < 10n  medium math dynamic programming backtracking 
accepted c++ codes with explanation and references max sum of rectangle no larger than k given non-empty 2d matrix matrix integer k  find max sum rectangle matrix sum larger k  hard binary search dynamic programming queue 
java binary search solution time complexity min(m n)^2 max(m n) log(max(m n)) max sum of rectangle no larger than k given non-empty 2d matrix matrix integer k  find max sum rectangle matrix sum larger k  hard binary search dynamic programming queue 
2 accepted java solution max sum of rectangle no larger than k given non-empty 2d matrix matrix integer k  find max sum rectangle matrix sum larger k  hard binary search dynamic programming queue 
java 117ms  beat 99 81%  merge sort max sum of rectangle no larger than k given non-empty 2d matrix matrix integer k  find max sum rectangle matrix sum larger k  hard binary search dynamic programming queue 
any accepted python solution? max sum of rectangle no larger than k given non-empty 2d matrix matrix integer k  find max sum rectangle matrix sum larger k  hard binary search dynamic programming queue 
math solution - java solution water and jug problem given two jugs capacities x litres  infinite amount water supply available  need determine whether possible measure exactly z litres using two jugs  z liters water measurable  must z liters water contained within one buckets end  operations allowed: fill jugs completely water  empty jugs  pour water one jug another till jug completely full first jug empty  medium math 
this problem should be classified as hard water and jug problem given two jugs capacities x litres  infinite amount water supply available  need determine whether possible measure exactly z litres using two jugs  z liters water measurable  must z liters water contained within one buckets end  operations allowed: fill jugs completely water  empty jugs  pour water one jug another till jug completely full first jug empty  medium math 
a little explanation on gcd method  c++ java python water and jug problem given two jugs capacities x litres  infinite amount water supply available  need determine whether possible measure exactly z litres using two jugs  z liters water measurable  must z liters water contained within one buckets end  operations allowed: fill jugs completely water  empty jugs  pour water one jug another till jug completely full first jug empty  medium math 
breadth-first search with explanation  water and jug problem given two jugs capacities x litres  infinite amount water supply available  need determine whether possible measure exactly z litres using two jugs  z liters water measurable  must z liters water contained within one buckets end  operations allowed: fill jugs completely water  empty jugs  pour water one jug another till jug completely full first jug empty  medium math 
clear explanation of why using gcd water and jug problem given two jugs capacities x litres  infinite amount water supply available  need determine whether possible measure exactly z litres using two jugs  z liters water measurable  must z liters water contained within one buckets end  operations allowed: fill jugs completely water  empty jugs  pour water one jug another till jug completely full first jug empty  medium math 
a square number is 1+3+5+7+     java code valid perfect square given positive integer num  write function returns true num perfect square else false  note: use built-in library function sqrt  easy math binary search 
3-4 short lines  integer newton  most languages valid perfect square given positive integer num  write function returns true num perfect square else false  note: use built-in library function sqrt  easy math binary search 
java three solutions 1 3 5    sequence binary search newton valid perfect square given positive integer num  write function returns true num perfect square else false  note: use built-in library function sqrt  easy math binary search 
o(1) time c++ solution inspired by q_rsqrt valid perfect square given positive integer num  write function returns true num perfect square else false  note: use built-in library function sqrt  easy math binary search 
o(logn) bisection method valid perfect square given positive integer num  write function returns true num perfect square else false  note: use built-in library function sqrt  easy math binary search 
classic dp solution similar to lis  o(n^2) largest divisible subset given set distinct positive integers  find largest subset every pair (si  sj) elements subset satisfies: si % sj = 0 sj % si = 0  multiple solutions  return subset fine  medium math dynamic programming 
c++ solution with explanations largest divisible subset given set distinct positive integers  find largest subset every pair (si  sj) elements subset satisfies: si % sj = 0 sj % si = 0  multiple solutions  return subset fine  medium math dynamic programming 
4 lines in python largest divisible subset given set distinct positive integers  find largest subset every pair (si  sj) elements subset satisfies: si % sj = 0 sj % si = 0  multiple solutions  return subset fine  medium math dynamic programming 
easy understood java dp solution in 28ms with o(n^2) time largest divisible subset given set distinct positive integers  find largest subset every pair (si  sj) elements subset satisfies: si % sj = 0 sj % si = 0  multiple solutions  return subset fine  medium math dynamic programming 
java solution in 32ms o(n^2) time  o(n) space largest divisible subset given set distinct positive integers  find largest subset every pair (si  sj) elements subset satisfies: si % sj = 0 sj % si = 0  multiple solutions  return subset fine  medium math dynamic programming 
a summary: how to use bit manipulation to solve problems easily and efficiently sum of two integers calculate sum two integers b  allowed use operator + -  easy bit manipulation 
java simple easy understand solution with explanation sum of two integers calculate sum two integers b  allowed use operator + -  easy bit manipulation 
python solution with no "+-  %"  completely bit manipulation guaranteed sum of two integers calculate sum two integers b  allowed use operator + -  easy bit manipulation 
share my c++ solutions easy to understand sum of two integers calculate sum two integers b  allowed use operator + -  easy bit manipulation 
simple explanation on how to arrive at the solution  sum of two integers calculate sum two integers b  allowed use operator + -  easy bit manipulation 
c++ clean and short solution super pow task calculate ab mod 1337 positive integer b extremely large positive integer given form array  medium math 
math solusion based on euler's theorem  power called only once  c++ java 1-line-python super pow task calculate ab mod 1337 positive integer b extremely large positive integer given form array  medium math 
what's the point of this kind of question? super pow task calculate ab mod 1337 positive integer b extremely large positive integer given form array  medium math 
java 4ms solution using the remainder repeat pattern super pow task calculate ab mod 1337 positive integer b extremely large positive integer given form array  medium math 
fermat and chinese remainder super pow task calculate ab mod 1337 positive integer b extremely large positive integer given form array  medium math 
simple java o(klogk) solution with explanation find k pairs with smallest sums given two integer arrays nums1 nums2 sorted ascending order integer k  define pair (u v) consists one element first array one element second array  find k pairs (u1 v1) (u2 v2)    (uk vk) smallest sums  medium heap 
slow 1-liner to fast solutions find k pairs with smallest sums given two integer arrays nums1 nums2 sorted ascending order integer k  define pair (u v) consists one element first array one element second array  find k pairs (u1 v1) (u2 v2)    (uk vk) smallest sums  medium heap 
share my solution which beat 96 42% find k pairs with smallest sums given two integer arrays nums1 nums2 sorted ascending order integer k  define pair (u v) consists one element first array one element second array  find k pairs (u1 v1) (u2 v2)    (uk vk) smallest sums  medium heap 
java 9ms heap queue solution  k log(k) find k pairs with smallest sums given two integer arrays nums1 nums2 sorted ascending order integer k  define pair (u v) consists one element first array one element second array  find k pairs (u1 v1) (u2 v2)    (uk vk) smallest sums  medium heap 
clean 16ms c++ o(n) space o(klogn) time solution using priority queue find k pairs with smallest sums given two integer arrays nums1 nums2 sorted ascending order integer k  define pair (u v) consists one element first array one element second array  find k pairs (u1 v1) (u2 v2)    (uk vk) smallest sums  medium heap 
the key point is to read the problem carefully  guess number higher or lower playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number higher lower  call pre-defined api guess(int num) returns 3 possible results (-1  1  0): -1 : number lower 1 : number higher 0 : congrats! got it! easy binary search 
2 lines as usual guess number higher or lower playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number higher lower  call pre-defined api guess(int num) returns 3 possible results (-1  1  0): -1 : number lower 1 : number higher 0 : congrats! got it! easy binary search 
0ms c++ binary search guess number higher or lower playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number higher lower  call pre-defined api guess(int num) returns 3 possible results (-1  1  0): -1 : number lower 1 : number higher 0 : congrats! got it! easy binary search 
short java code using binary search guess number higher or lower playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number higher lower  call pre-defined api guess(int num) returns 3 possible results (-1  1  0): -1 : number lower 1 : number higher 0 : congrats! got it! easy binary search 
i hope developers of leetcode can make the question definition more clear  guess number higher or lower playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number higher lower  call pre-defined api guess(int num) returns 3 possible results (-1  1  0): -1 : number lower 1 : number higher 0 : congrats! got it! easy binary search 
simple dp solution with explanation~~ guess number higher or lower ii playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number picked higher lower  however  guess particular number x  guess wrong  pay $x  win game guess number picked  medium dynamic programming minimax 
improve the question and example guess number higher or lower ii playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number picked higher lower  however  guess particular number x  guess wrong  pay $x  win game guess number picked  medium dynamic programming minimax 
clarification on the problem description  [problem description need to be updated !!! ] guess number higher or lower ii playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number picked higher lower  however  guess particular number x  guess wrong  pay $x  win game guess number picked  medium dynamic programming minimax 
java dp solution guess number higher or lower ii playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number picked higher lower  however  guess particular number x  guess wrong  pay $x  win game guess number picked  medium dynamic programming minimax 
java commented dp solution guess number higher or lower ii playing guess game  game follows: pick number 1 n  guess number picked  every time guess wrong  i'll tell whether number picked higher lower  however  guess particular number x  guess wrong  pay $x  win game guess number picked  medium dynamic programming minimax 
easy understanding dp solution with o(n)  java version wiggle subsequence sequence numbers called wiggle sequence differences successive numbers strictly alternate positive negative  first difference (if one exists) may either positive negative  sequence fewer two elements trivially wiggle sequence  medium dynamic programming greedy 
very simple java solution with detail explanation wiggle subsequence sequence numbers called wiggle sequence differences successive numbers strictly alternate positive negative  first difference (if one exists) may either positive negative  sequence fewer two elements trivially wiggle sequence  medium dynamic programming greedy 
c++ 0ms o(n) dynamic programming solution wiggle subsequence sequence numbers called wiggle sequence differences successive numbers strictly alternate positive negative  first difference (if one exists) may either positive negative  sequence fewer two elements trivially wiggle sequence  medium dynamic programming greedy 
two solutions  one is dp  the other is greedy (8 lines)  wiggle subsequence sequence numbers called wiggle sequence differences successive numbers strictly alternate positive negative  first difference (if one exists) may either positive negative  sequence fewer two elements trivially wiggle sequence  medium dynamic programming greedy 
3 lines o(n) python with explanation proof wiggle subsequence sequence numbers called wiggle sequence differences successive numbers strictly alternate positive negative  first difference (if one exists) may either positive negative  sequence fewer two elements trivially wiggle sequence  medium dynamic programming greedy 
1ms java dp solution with detailed explanation combination sum iv given integer array positive numbers duplicates  find number possible combinations add positive integer target  medium dynamic programming 
my 3ms java dp solution combination sum iv given integer array positive numbers duplicates  find number possible combinations add positive integer target  medium dynamic programming 
are you kidding me? it is combination?? combination sum iv given integer array positive numbers duplicates  find number possible combinations add positive integer target  medium dynamic programming 
c++ template for all combination problem set combination sum iv given integer array positive numbers duplicates  find number possible combinations add positive integer target  medium dynamic programming 
java recursion solution using hashmap as memory  combination sum iv given integer array positive numbers duplicates  find number possible combinations add positive integer target  medium dynamic programming 
share my thoughts and clean java code kth smallest element in a sorted matrix given n x n matrix rows columns sorted ascending order  find kth smallest element matrix  note kth smallest element sorted order  kth distinct element  medium binary search heap 
java 1ms nlog(max -min) solution kth smallest element in a sorted matrix given n x n matrix rows columns sorted ascending order  find kth smallest element matrix  note kth smallest element sorted order  kth distinct element  medium binary search heap 
o(n) from paper  yes  o(#rows)  kth smallest element in a sorted matrix given n x n matrix rows columns sorted ascending order  find kth smallest element matrix  note kth smallest element sorted order  kth distinct element  medium binary search heap 
my solution using binary search in c++ kth smallest element in a sorted matrix given n x n matrix rows columns sorted ascending order  find kth smallest element matrix  note kth smallest element sorted order  kth distinct element  medium binary search heap 
binary search  heap and sorting comparison  with concise code and 1-liners  python 72 ms kth smallest element in a sorted matrix given n x n matrix rows columns sorted ascending order  find kth smallest element matrix  note kth smallest element sorted order  kth distinct element  medium binary search heap 
java solution using a hashmap and an arraylist along with a follow-up  (131 ms) insert delete getrandom o(1) design data structure supports following operations average o(1) time  insert(val): inserts item val set already present  remove(val): removes item val set present  getrandom: returns random element current set elements  element must probability returned  medium array hash table design 
simple solution in python insert delete getrandom o(1) design data structure supports following operations average o(1) time  insert(val): inserts item val set already present  remove(val): removes item val set present  getrandom: returns random element current set elements  element must probability returned  medium array hash table design 
ac c++ solution  unordered_map + vector insert delete getrandom o(1) design data structure supports following operations average o(1) time  insert(val): inserts item val set already present  remove(val): removes item val set present  getrandom: returns random element current set elements  element must probability returned  medium array hash table design 
java solution  concise code with hashmap and arraylist  easy to understand insert delete getrandom o(1) design data structure supports following operations average o(1) time  insert(val): inserts item val set already present  remove(val): removes item val set present  getrandom: returns random element current set elements  element must probability returned  medium array hash table design 
java solution with two hashmaps: easy to understand insert delete getrandom o(1) design data structure supports following operations average o(1) time  insert(val): inserts item val set already present  remove(val): removes item val set present  getrandom: returns random element current set elements  element must probability returned  medium array hash table design 
c++ 128m solution  real o(1) solution insert delete getrandom o(1) - duplicates allowed design data structure supports following operations average o(1) time  note: duplicate elements allowed  insert(val): inserts item val collection  remove(val): removes item val collection present  getrandom: returns random element current collection elements  probability element returned linearly related number value collection contains  hard array hash table design 
java haspmap  linkedhashset  arraylist (155 ms) insert delete getrandom o(1) - duplicates allowed design data structure supports following operations average o(1) time  note: duplicate elements allowed  insert(val): inserts item val collection  remove(val): removes item val collection present  getrandom: returns random element current collection elements  probability element returned linearly related number value collection contains  hard array hash table design 
frugal python code insert delete getrandom o(1) - duplicates allowed design data structure supports following operations average o(1) time  note: duplicate elements allowed  insert(val): inserts item val collection  remove(val): removes item val collection present  getrandom: returns random element current collection elements  probability element returned linearly related number value collection contains  hard array hash table design 
clean o(1) java solution with hashmap and set insert delete getrandom o(1) - duplicates allowed design data structure supports following operations average o(1) time  note: duplicate elements allowed  insert(val): inserts item val collection  remove(val): removes item val collection present  getrandom: returns random element current collection elements  probability element returned linearly related number value collection contains  hard array hash table design 
easy understanding java solution using hashset insert delete getrandom o(1) - duplicates allowed design data structure supports following operations average o(1) time  note: duplicate elements allowed  insert(val): inserts item val collection  remove(val): removes item val collection present  getrandom: returns random element current collection elements  probability element returned linearly related number value collection contains  hard array hash table design 
brief explanation for reservoir sampling linked list random node given singly linked list  return random node's value linked list  node must probability chosen  follow up: linked list extremely large length unknown you? could solve efficiently without using extra space? medium reservoir sampling 
java solution with cases explain linked list random node given singly linked list  return random node's value linked list  node must probability chosen  follow up: linked list extremely large length unknown you? could solve efficiently without using extra space? medium reservoir sampling 
using "reservoir sampling" o(1) space  o(n) time complexity uff0cc++ linked list random node given singly linked list  return random node's value linked list  node must probability chosen  follow up: linked list extremely large length unknown you? could solve efficiently without using extra space? medium reservoir sampling 
o(n) time & o(1) space java solution linked list random node given singly linked list  return random node's value linked list  node must probability chosen  follow up: linked list extremely large length unknown you? could solve efficiently without using extra space? medium reservoir sampling 
"buffered" reservoir sampling linked list random node given singly linked list  return random node's value linked list  node must probability chosen  follow up: linked list extremely large length unknown you? could solve efficiently without using extra space? medium reservoir sampling 
java o(n) solution---easy to understand ransom note given arbitrary ransom note string another string containing letters magazines  write function return true ransom note constructed magazines ; otherwise  return false  letter magazine string used ransom note  note: may assume strings contain lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
o(m+n) one-liner python ransom note given arbitrary ransom note string another string containing letters magazines  write function return true ransom note constructed magazines ; otherwise  return false  letter magazine string used ransom note  note: may assume strings contain lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
java map solution ransom note given arbitrary ransom note string another string containing letters magazines  write function return true ransom note constructed magazines ; otherwise  return false  letter magazine string used ransom note  note: may assume strings contain lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
share my easy to understand 5 lines of java code  13ms beats 96% ransom note given arbitrary ransom note string another string containing letters magazines  write function return true ransom note constructed magazines ; otherwise  return false  letter magazine string used ransom note  note: may assume strings contain lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
two ac c++ solutions (unordered_map vector) ransom note given arbitrary ransom note string another string containing letters magazines  write function return true ransom note constructed magazines ; otherwise  return false  letter magazine string used ransom note  note: may assume strings contain lowercase letters  canconstruct("a"  "b") -> false canconstruct("aa"  "ab") -> false canconstruct("aa"  "aab") -> true easy string 
first accepted solution - java shuffle an array shuffle set numbers without duplicates  medium 
python hack shuffle an array shuffle set numbers without duplicates  medium 
simple java solution shuffle an array shuffle set numbers without duplicates  medium 
straight-forward c++ solution shuffle an array shuffle set numbers without duplicates  medium 
easy python solution based on generating random index and swapping shuffle an array shuffle set numbers without duplicates  medium 
an java iterative solution mini parser given nested list integers represented string  implement parser deserialize it  element either integer  list -- whose elements may also integers lists  note: may assume string well-formed: string non-empty  string contain white spaces  string contains digits 0-9  [  -    ]  medium string stack 
clarification mini parser given nested list integers represented string  implement parser deserialize it  element either integer  list -- whose elements may also integers lists  note: may assume string well-formed: string non-empty  string contain white spaces  string contains digits 0-9  [  -    ]  medium string stack 
python & c++ solutions mini parser given nested list integers represented string  implement parser deserialize it  element either integer  list -- whose elements may also integers lists  note: may assume string well-formed: string non-empty  string contain white spaces  string contains digits 0-9  [  -    ]  medium string stack 
c++ non-recursive one-pass solution (using stack) || a possible implementation of nestedinteger mini parser given nested list integers represented string  implement parser deserialize it  element either integer  list -- whose elements may also integers lists  note: may assume string well-formed: string non-empty  string contain white spaces  string contains digits 0-9  [  -    ]  medium string stack 
short java recursive solution mini parser given nested list integers represented string  implement parser deserialize it  element either integer  list -- whose elements may also integers lists  note: may assume string well-formed: string non-empty  string contain white spaces  string contains digits 0-9  [  -    ]  medium string stack 
java o(n) time  o(1) space iterative solution 130ms lexicographical numbers given integer n  return 1 - n lexicographical order  medium 
simple java dfs solution lexicographical numbers given integer n  return 1 - n lexicographical order  medium 
ac 200ms c++ solution  beats 98% lexicographical numbers given integer n  return 1 - n lexicographical order  medium 
the most elegant python solution so far  10 liner  iterative  o(n) time  o(1) space  lexicographical numbers given integer n  return 1 - n lexicographical order  medium 
python with sorting lexicographical numbers given integer n  return 1 - n lexicographical order  medium 
java 7 lines solution 29ms first unique character in a string given string  find first non-repeating character return index  exist  return -1  easy hash table string 
python 3 lines beats 100% (~ 60ms) ! first unique character in a string given string  find first non-repeating character return index  exist  return -1  easy hash table string 
java one pass solution with linkedhashmap first unique character in a string given string  find first non-repeating character return index  exist  return -1  easy hash table string 
javascript solution first unique character in a string given string  find first non-repeating character return index  exist  return -1  easy hash table string 
c++ 2 solutions first unique character in a string given string  find first non-repeating character return index  exist  return -1  easy hash table string 
9 lines 4ms java solution longest absolute file path suppose abstract file system string following manner: string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext directory dir contains empty sub-directory subdir1 sub-directory subdir2 containing file file ext  string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext directory dir contains two sub-directories subdir1 subdir2  subdir1 contains file file1 ext empty second-level sub-directory subsubdir1  subdir2 contains second-level sub-directory subsubdir2 containing file file2 ext  interested finding longest (number characters) absolute path file within file system  medium 
simple python solution longest absolute file path suppose abstract file system string following manner: string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext directory dir contains empty sub-directory subdir1 sub-directory subdir2 containing file file ext  string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext directory dir contains two sub-directories subdir1 subdir2  subdir1 contains file file1 ext empty second-level sub-directory subsubdir1  subdir2 contains second-level sub-directory subsubdir2 containing file file2 ext  interested finding longest (number characters) absolute path file within file system  medium 
this problem is not well-defined  it should state that 4-space is considered as a tab under certain situation  longest absolute file path suppose abstract file system string following manner: string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext directory dir contains empty sub-directory subdir1 sub-directory subdir2 containing file file ext  string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext directory dir contains two sub-directories subdir1 subdir2  subdir1 contains file file1 ext empty second-level sub-directory subsubdir1  subdir2 contains second-level sub-directory subsubdir2 containing file file2 ext  interested finding longest (number characters) absolute path file within file system  medium 
simple c++ o(n) solution 0ms longest absolute file path suppose abstract file system string following manner: string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext directory dir contains empty sub-directory subdir1 sub-directory subdir2 containing file file ext  string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext directory dir contains two sub-directories subdir1 subdir2  subdir1 contains file file1 ext empty second-level sub-directory subsubdir1  subdir2 contains second-level sub-directory subsubdir2 containing file file2 ext  interested finding longest (number characters) absolute path file within file system  medium 
java o(n) solution using stack longest absolute file path suppose abstract file system string following manner: string "dir n tsubdir1 n tsubdir2 n t tfile ext" represents: dir subdir1 subdir2 file ext directory dir contains empty sub-directory subdir1 sub-directory subdir2 containing file file ext  string "dir n tsubdir1 n t tfile1 ext n t tsubsubdir1 n tsubdir2 n t tsubsubdir2 n t t tfile2 ext" represents: dir subdir1 file1 ext subsubdir1 subdir2 subsubdir2 file2 ext directory dir contains two sub-directories subdir1 subdir2  subdir1 contains file file1 ext empty second-level sub-directory subsubdir1  subdir2 contains second-level sub-directory subsubdir2 containing file file2 ext  interested finding longest (number characters) absolute path file within file system  medium 
java solution using bit manipulation find the difference given two strings consist lowercase letters  string generated random shuffling string add one letter random position  find letter added t  easy hash table bit manipulation 
simple java 8ms solution  4 lines find the difference given two strings consist lowercase letters  string generated random shuffling string add one letter random position  find letter added t  easy hash table bit manipulation 
concise c++ solution using xor find the difference given two strings consist lowercase letters  string generated random shuffling string add one letter random position  find letter added t  easy hash table bit manipulation 
3 different python solutions (dictionary  difference  xor) find the difference given two strings consist lowercase letters  string generated random shuffling string add one letter random position  find letter added t  easy hash table bit manipulation 
1-liners and 2-liner in python find the difference given two strings consist lowercase letters  string generated random shuffling string add one letter random position  find letter added t  easy hash table bit manipulation 
java: easiest solution o(logn) with explanation elimination game list sorted integers 1 n  starting left right  remove first number every number afterward reach end list  repeat previous step again  time right left  remove right number every number remaining numbers  keep repeating steps again  alternating left right right left  single number remains  find last number remains starting list length n  medium 
c 1 line solution with explanation elimination game list sorted integers 1 n  starting left right  remove first number every number afterward reach end list  repeat previous step again  time right left  remove right number every number remaining numbers  keep repeating steps again  alternating left right right left  single number remains  find last number remains starting list length n  medium 
o(logn) solution  clear break down elimination game list sorted integers 1 n  starting left right  remove first number every number afterward reach end list  repeat previous step again  time right left  remove right number every number remaining numbers  keep repeating steps again  alternating left right right left  single number remains  find last number remains starting list length n  medium 
one line java solution based on josephus problem elimination game list sorted integers 1 n  starting left right  remove first number every number afterward reach end list  repeat previous step again  time right left  remove right number every number remaining numbers  keep repeating steps again  alternating left right right left  single number remains  find last number remains starting list length n  medium 
c++ 29ms with complexity of log4(n) and explanation elimination game list sorted integers 1 n  starting left right  remove first number every number afterward reach end list  repeat previous step again  time right left  remove right number every number remaining numbers  keep repeating steps again  alternating left right right left  single number remains  find last number remains starting list length n  medium 
really easy understanding solution(o(n)  java) perfect rectangle given n axis-aligned rectangles n > 0  determine together form exact cover rectangular region  rectangle represented bottom-left point top-right point  hard 
o(n) solution by counting corners with detailed explaination perfect rectangle given n axis-aligned rectangles n > 0  determine together form exact cover rectangular region  rectangle represented bottom-left point top-right point  hard 
o(n log n) sweep line solution perfect rectangle given n axis-aligned rectangles n > 0  determine together form exact cover rectangular region  rectangle represented bottom-left point top-right point  hard 
short java solution with explanation (updated) perfect rectangle given n axis-aligned rectangles n > 0  determine together form exact cover rectangular region  rectangle represented bottom-left point top-right point  hard 
easy understanding o(n) python solution perfect rectangle given n axis-aligned rectangles n > 0  determine together form exact cover rectangular region  rectangle represented bottom-left point top-right point  hard 
binary search solution for follow-up with detailed comments is subsequence given string string t  check subsequence t  may assume lower case english letters t  potentially long (length ~= 500 000) string  short string (<=100)  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  medium binary search dynamic programming greedy 
straight forward java simple solution is subsequence given string string t  check subsequence t  may assume lower case english letters t  potentially long (length ~= 500 000) string  short string (<=100)  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  medium binary search dynamic programming greedy 
3 lines c is subsequence given string string t  check subsequence t  may assume lower case english letters t  potentially long (length ~= 500 000) string  short string (<=100)  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  medium binary search dynamic programming greedy 
2 lines python is subsequence given string string t  check subsequence t  may assume lower case english letters t  potentially long (length ~= 500 000) string  short string (<=100)  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  medium binary search dynamic programming greedy 
java code for the follow-up question is subsequence given string string t  check subsequence t  may assume lower case english letters t  potentially long (length ~= 500 000) string  short string (<=100)  subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters  (ie  "ace" subsequence "abcde" "aec" not)  medium binary search dynamic programming greedy 
concise c++ implementation utf-8 validation character utf8 1 4 bytes long  subjected following rules: 1-byte character  first bit 0  followed unicode code  n-bytes character  first n-bits one's  n+1 bit 0  followed n-1 bytes significant 2 bits 10  utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given array integers representing data  return whether valid utf-8 encoding  note: input array integers  least significant 8 bits integer used store data  means integer represents 1 byte data  medium bit manipulation 
feeling like an english reading comprehension problem utf-8 validation character utf8 1 4 bytes long  subjected following rules: 1-byte character  first bit 0  followed unicode code  n-bytes character  first n-bits one's  n+1 bit 0  followed n-1 bytes significant 2 bits 10  utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given array integers representing data  return whether valid utf-8 encoding  note: input array integers  least significant 8 bits integer used store data  means integer represents 1 byte data  medium bit manipulation 
bit manipulation  java  6ms utf-8 validation character utf8 1 4 bytes long  subjected following rules: 1-byte character  first bit 0  followed unicode code  n-bytes character  first n-bits one's  n+1 bit 0  followed n-1 bytes significant 2 bits 10  utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given array integers representing data  return whether valid utf-8 encoding  note: input array integers  least significant 8 bits integer used store data  means integer represents 1 byte data  medium bit manipulation 
one pass simple solution utf-8 validation character utf8 1 4 bytes long  subjected following rules: 1-byte character  first bit 0  followed unicode code  n-bytes character  first n-bits one's  n+1 bit 0  followed n-1 bytes significant 2 bits 10  utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given array integers representing data  return whether valid utf-8 encoding  note: input array integers  least significant 8 bits integer used store data  means integer represents 1 byte data  medium bit manipulation 
short'n'clean 12-lines python solution utf-8 validation character utf8 1 4 bytes long  subjected following rules: 1-byte character  first bit 0  followed unicode code  n-bytes character  first n-bits one's  n+1 bit 0  followed n-1 bytes significant 2 bits 10  utf-8 encoding would work: char  number range | utf-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007f | 0xxxxxxx 0000 0080-0000 07ff | 110xxxxx 10xxxxxx 0000 0800-0000 ffff | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx given array integers representing data  return whether valid utf-8 encoding  note: input array integers  least significant 8 bits integer used store data  means integer represents 1 byte data  medium bit manipulation 
0ms simple c++ solution decode string given encoded string  return decoded string  encoding rule is: k[encoded_string]  encoded_string inside square brackets repeated exactly k times  note k guaranteed positive integer  may assume input string always valid; extra white spaces  square brackets well-formed  etc  furthermore  may assume original data contain digits digits repeat numbers  k  medium stack depth-first search 
simple java solution using stack decode string given encoded string  return decoded string  encoding rule is: k[encoded_string]  encoded_string inside square brackets repeated exactly k times  note k guaranteed positive integer  may assume input string always valid; extra white spaces  square brackets well-formed  etc  furthermore  may assume original data contain digits digits repeat numbers  k  medium stack depth-first search 
share my python stack simple solution (easy to understand) decode string given encoded string  return decoded string  encoding rule is: k[encoded_string]  encoded_string inside square brackets repeated exactly k times  note k guaranteed positive integer  may assume input string always valid; extra white spaces  square brackets well-formed  etc  furthermore  may assume original data contain digits digits repeat numbers  k  medium stack depth-first search 
java short and easy-understanding solution using stack decode string given encoded string  return decoded string  encoding rule is: k[encoded_string]  encoded_string inside square brackets repeated exactly k times  note k guaranteed positive integer  may assume input string always valid; extra white spaces  square brackets well-formed  etc  furthermore  may assume original data contain digits digits repeat numbers  k  medium stack depth-first search 
python solution using stack decode string given encoded string  return decoded string  encoding rule is: k[encoded_string]  encoded_string inside square brackets repeated exactly k times  note k guaranteed positive integer  may assume input string always valid; extra white spaces  square brackets well-formed  etc  furthermore  may assume original data contain digits digits repeat numbers  k  medium stack depth-first search 
java strict o(n) two-pointer solution longest substring with at least k repeating characters find length longest substring given string (consists lowercase letters only) every character appears less k times  medium 
4 lines python longest substring with at least k repeating characters find length longest substring given string (consists lowercase letters only) every character appears less k times  medium 
java divide and conquer(recursion) solution longest substring with at least k repeating characters find length longest substring given string (consists lowercase letters only) every character appears less k times  medium 
c++ recursive solution longest substring with at least k repeating characters find length longest substring given string (consists lowercase letters only) every character appears less k times  medium 
java 20 lines very easy solution 7ms with explanation longest substring with at least k repeating characters find length longest substring given string (consists lowercase letters only) every character appears less k times  medium 
java o(n) solution with explanation rotate function given array integers let n length  assume bk array obtained rotating array k positions clock-wise  define "rotation function" f follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate maximum value f(0)  f(1)       f(n-1)  note: n guaranteed less 105  medium math 
java solution o(n) with non mathametical explaination rotate function given array integers let n length  assume bk array obtained rotating array k positions clock-wise  define "rotation function" f follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate maximum value f(0)  f(1)       f(n-1)  note: n guaranteed less 105  medium math 
java solution rotate function given array integers let n length  assume bk array obtained rotating array k positions clock-wise  define "rotation function" f follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate maximum value f(0)  f(1)       f(n-1)  note: n guaranteed less 105  medium math 
c++ solution rotate function given array integers let n length  assume bk array obtained rotating array k positions clock-wise  define "rotation function" f follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate maximum value f(0)  f(1)       f(n-1)  note: n guaranteed less 105  medium math 
my o(n) simple c++ solution rotate function given array integers let n length  assume bk array obtained rotating array k positions clock-wise  define "rotation function" f follow: f(k) = 0   bk[0] + 1   bk[1] +     + (n-1)   bk[n-1]  calculate maximum value f(0)  f(1)       f(n-1)  note: n guaranteed less 105  medium math 
a couple of java solutions with explanations integer replacement given positive integer n operations follow: n even  replace n n 2  n odd  replace n either n + 1 n - 1  minimum number replacements needed n become 1? medium math bit manipulation 
java 12 line 4(5)ms iterative solution with explanations  no other data structures  integer replacement given positive integer n operations follow: n even  replace n n 2  n odd  replace n either n + 1 n - 1  minimum number replacements needed n become 1? medium math bit manipulation 
python o(log n) time  o(1) space with explanation and proof integer replacement given positive integer n operations follow: n even  replace n n 2  n odd  replace n either n + 1 n - 1  minimum number replacements needed n become 1? medium math bit manipulation 
c++ 0ms 11 lines "dp" solution integer replacement given positive integer n operations follow: n even  replace n n 2  n odd  replace n either n + 1 n - 1  minimum number replacements needed n become 1? medium math bit manipulation 
0 ms c++ recursion solution with explanation integer replacement given positive integer n operations follow: n even  replace n n 2  n odd  replace n either n + 1 n - 1  minimum number replacements needed n become 1? medium math bit manipulation 
simple reservoir sampling solution random pick index given array integers possible duplicates  randomly output index given target number  assume given target number must exist array  note: array size large  solution uses much extra space pass judge  medium reservoir sampling 
what on earth is meant by too much memory? random pick index given array integers possible duplicates  randomly output index given target number  assume given target number must exist array  note: array size large  solution uses much extra space pass judge  medium reservoir sampling 
c++_time: o(n)  space: o(n)_116ms_96 41%_with clear explanation by probability random pick index given array integers possible duplicates  randomly output index given target number  assume given target number must exist array  note: array size large  solution uses much extra space pass judge  medium reservoir sampling 
clean  understandable  o(1) momery  o(n) time  java solution random pick index given array integers possible duplicates  randomly output index given target number  assume given target number must exist array  note: array size large  solution uses much extra space pass judge  medium reservoir sampling 
simple python solution random pick index given array integers possible duplicates  randomly output index given target number  assume given target number must exist array  note: array size large  solution uses much extra space pass judge  medium reservoir sampling 
java ac solution using graph evaluate division equations given format   b = k  b variables represented strings  k real number (floating point number)  given queries  return answers  answer exist  return -1 0  medium graph 
9 lines "floyd u2013warshall" in python evaluate division equations given format   b = k  b variables represented strings  k real number (floating point number)  given queries  return answers  answer exist  return -1 0  medium graph 
0ms c++ union-find solution [easy to understand] evaluate division equations given format   b = k  b variables represented strings  k real number (floating point number)  given queries  return answers  answer exist  return -1 0  medium graph 
python fast bfs solution with detailed explantion evaluate division equations given format   b = k  b variables represented strings  k real number (floating point number)  given queries  return answers  answer exist  return -1 0  medium graph 
esay understand java solution  3ms evaluate division equations given format   b = k  b variables represented strings  k real number (floating point number)  given queries  return answers  answer exist  return -1 0  medium graph 
java solution nth digit find nth digit infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n positive fit within range 32-bit signed integer (n < 231)  easy math 
0ms c++ solution with detail-explanation nth digit find nth digit infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n positive fit within range 32-bit signed integer (n < 231)  easy math 
short python+java nth digit find nth digit infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n positive fit within range 32-bit signed integer (n < 231)  easy math 
4-liner in python  and complexity analysis nth digit find nth digit infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n positive fit within range 32-bit signed integer (n < 231)  easy math 
sharing my thinking process nth digit find nth digit infinite integer sequence 1  2  3  4  5  6  7  8  9  10  11      note: n positive fit within range 32-bit signed integer (n < 231)  easy math 
simple python+java binary watch binary watch 4 leds top represent hours (0-11)  6 leds bottom represent minutes (0-59)  led represents zero one  least significant bit right  easy backtracking bit manipulation 
straight-forward 6-line c++ solution  no need to explain binary watch binary watch 4 leds top represent hours (0-11)  6 leds bottom represent minutes (0-59)  led represents zero one  least significant bit right  easy backtracking bit manipulation 
3ms java solution using backtracking and idea of "permutation and combination" binary watch binary watch 4 leds top represent hours (0-11)  6 leds bottom represent minutes (0-59)  led represents zero one  least significant bit right  easy backtracking bit manipulation 
just for fun!!!!!!!   java 1ms  beats 100% binary watch binary watch 4 leds top represent hours (0-11)  6 leds bottom represent minutes (0-59)  led represents zero one  least significant bit right  easy backtracking bit manipulation 
straightforward java answer binary watch binary watch 4 leds top represent hours (0-11)  6 leds bottom represent minutes (0-59)  led represents zero one  least significant bit right  easy backtracking bit manipulation 
straightforward java solution using stack remove k digits given non-negative integer num represented string  remove k digits number new number smallest possible  note: length num less 10002 ≥ k  given num contain leading zero  medium stack greedy 
a greedy method using stack  o(n) time and o(n) space remove k digits given non-negative integer num represented string  remove k digits number new number smallest possible  note: length num less 10002 ≥ k  given num contain leading zero  medium stack greedy 
two algorithms with detailed explaination remove k digits given non-negative integer num represented string  remove k digits number new number smallest possible  note: length num less 10002 ≥ k  given num contain leading zero  medium stack greedy 
short python  one o(n) and one regex remove k digits given non-negative integer num represented string  remove k digits number new number smallest possible  note: length num less 10002 ≥ k  given num contain leading zero  medium stack greedy 
my easy understandable c++ solution remove k digits given non-negative integer num represented string  remove k digits number new number smallest possible  note: length num less 10002 ≥ k  given num contain leading zero  medium stack greedy 
java iterative and recursive solutions sum of left leaves find sum left leaves given binary tree  easy tree 
java solution using bfs sum of left leaves find sum left leaves given binary tree  easy tree 
3-line c++ solution sum of left leaves find sum left leaves given binary tree  easy tree 
3 line recursive c++ solution  no need to explain sum of left leaves find sum left leaves given binary tree  easy tree 
4 lines python recursive ac solution sum of left leaves find sum left leaves given binary tree  easy tree 
simple java solution with comment convert a number to hexadecimal given integer  write algorithm convert hexadecimal  negative integer  two’s complement method used  note: letters hexadecimal (a-f) must lowercase  hexadecimal string must contain extra leading 0s  number zero  represented single zero character '0'; otherwise  first character hexadecimal string zero character  given number guaranteed fit within range 32-bit signed integer  must use method provided library converts formats number hex directly  easy bit manipulation 
concise c++ solution convert a number to hexadecimal given integer  write algorithm convert hexadecimal  negative integer  two’s complement method used  note: letters hexadecimal (a-f) must lowercase  hexadecimal string must contain extra leading 0s  number zero  represented single zero character '0'; otherwise  first character hexadecimal string zero character  given number guaranteed fit within range 32-bit signed integer  must use method provided library converts formats number hex directly  easy bit manipulation 
easy 10-line python solution with inline explanation convert a number to hexadecimal given integer  write algorithm convert hexadecimal  negative integer  two’s complement method used  note: letters hexadecimal (a-f) must lowercase  hexadecimal string must contain extra leading 0s  number zero  represented single zero character '0'; otherwise  first character hexadecimal string zero character  given number guaranteed fit within range 32-bit signed integer  must use method provided library converts formats number hex directly  easy bit manipulation 
1-liner in python convert a number to hexadecimal given integer  write algorithm convert hexadecimal  negative integer  two’s complement method used  note: letters hexadecimal (a-f) must lowercase  hexadecimal string must contain extra leading 0s  number zero  represented single zero character '0'; otherwise  first character hexadecimal string zero character  given number guaranteed fit within range 32-bit signed integer  must use method provided library converts formats number hex directly  easy bit manipulation 
python solution convert a number to hexadecimal given integer  write algorithm convert hexadecimal  negative integer  two’s complement method used  note: letters hexadecimal (a-f) must lowercase  hexadecimal string must contain extra leading 0s  number zero  represented single zero character '0'; otherwise  first character hexadecimal string zero character  given number guaranteed fit within range 32-bit signed integer  must use method provided library converts formats number hex directly  easy bit manipulation 
easy concept with python c++ java solution queue reconstruction by height suppose random list people standing queue  person described pair integers (h  k)  h height person k number people front person height greater equal h  write algorithm reconstruct queue  note: number people less 1 100  medium greedy 
explanation of the neat sort+insert solution queue reconstruction by height suppose random list people standing queue  person described pair integers (h  k)  h height person k number people front person height greater equal h  write algorithm reconstruct queue  note: number people less 1 100  medium greedy 
6 lines  concise c++ queue reconstruction by height suppose random list people standing queue  person described pair integers (h  k)  h height person k number people front person height greater equal h  write algorithm reconstruct queue  note: number people less 1 100  medium greedy 
i don't understand the question  reconstruct the queue to what? queue reconstruction by height suppose random list people standing queue  person described pair integers (h  k)  h height person k number people front person height greater equal h  write algorithm reconstruct queue  note: number people less 1 100  medium greedy 
java solution using arrays sort() and "insert sorting" idea queue reconstruction by height suppose random list people standing queue  person described pair integers (h  k)  h height person k number people front person height greater equal h  write algorithm reconstruct queue  note: number people less 1 100  medium greedy 
java solution using priorityqueue trapping rain water ii given x n matrix positive integers representing height unit cell 2d elevation map  compute volume water able trap raining  note: n less 110  height unit cell greater 0 less 20 000  hard heap breadth-first search 
visualization - no code trapping rain water ii given x n matrix positive integers representing height unit cell 2d elevation map  compute volume water able trap raining  note: n less 110  height unit cell greater 0 less 20 000  hard heap breadth-first search 
python solution with heap trapping rain water ii given x n matrix positive integers representing height unit cell 2d elevation map  compute volume water able trap raining  note: n less 110  height unit cell greater 0 less 20 000  hard heap breadth-first search 
how to get the solution to 2-d "trapping rain water" problem from 1-d case trapping rain water ii given x n matrix positive integers representing height unit cell 2d elevation map  compute volume water able trap raining  note: n less 110  height unit cell greater 0 less 20 000  hard heap breadth-first search 
alternative approach using dijkstra in o(rc max(log r  log c)) time trapping rain water ii given x n matrix positive integers representing height unit cell 2d elevation map  compute volume water able trap raining  note: n less 110  height unit cell greater 0 less 20 000  hard heap breadth-first search 
simple hashset solution java longest palindrome given string consists lowercase uppercase letters  find length longest palindromes built letters  case sensitive  easy hash table 
what are the odds? (python & c++) longest palindrome given string consists lowercase uppercase letters  find length longest palindromes built letters  case sensitive  easy hash table 
java solution  simple and clear  using int[26] longest palindrome given string consists lowercase uppercase letters  find length longest palindromes built letters  case sensitive  easy hash table 
simple java solution in one pass longest palindrome given string consists lowercase uppercase letters  find length longest palindromes built letters  case sensitive  easy hash table 
easy to understand accepted solution with explanation longest palindrome given string consists lowercase uppercase letters  find length longest palindromes built letters  case sensitive  easy hash table 
clear explanation: 8ms binary search java split array largest sum given array consists non-negative integers integer m  split array non-empty continuous subarrays  write algorithm minimize largest sum among subarrays  note: n length array  assume following constraints satisfied: 1 ≤ n ≤ 1000 1 ≤ ≤ min(50  n) hard binary search dynamic programming 
[c++   fast   very clear explanation   clean code] solution with greedy algorithm and binary search split array largest sum given array consists non-negative integers integer m  split array non-empty continuous subarrays  write algorithm minimize largest sum among subarrays  note: n length array  assume following constraints satisfied: 1 ≤ n ≤ 1000 1 ≤ ≤ min(50  n) hard binary search dynamic programming 
dp java split array largest sum given array consists non-negative integers integer m  split array non-empty continuous subarrays  write algorithm minimize largest sum among subarrays  note: n length array  assume following constraints satisfied: 1 ≤ n ≤ 1000 1 ≤ ≤ min(50  n) hard binary search dynamic programming 
java easy binary search solution 8ms split array largest sum given array consists non-negative integers integer m  split array non-empty continuous subarrays  write algorithm minimize largest sum among subarrays  note: n length array  assume following constraints satisfied: 1 ≤ n ≤ 1000 1 ≤ ≤ min(50  n) hard binary search dynamic programming 
python solution dp and binary search split array largest sum given array consists non-negative integers integer m  split array non-empty continuous subarrays  write algorithm minimize largest sum among subarrays  note: n length array  assume following constraints satisfied: 1 ≤ n ≤ 1000 1 ≤ ≤ min(50  n) hard binary search dynamic programming 
java 4ms solution   not using "%" operation fizz buzz write program outputs string representation numbers 1 n  multiples three output “fizz” instead number multiples five output “buzz”  numbers multiples three five output “fizzbuzz”  easy 
python golf fizz buzz write program outputs string representation numbers 1 n  multiples three output “fizz” instead number multiples five output “buzz”  numbers multiples three five output “fizzbuzz”  easy 
java easy iterative solution fizz buzz write program outputs string representation numbers 1 n  multiples three output “fizz” instead number multiples five output “buzz”  numbers multiples three five output “fizzbuzz”  easy 
java  fuzz buzz--follow up(no if else  and extendable) fizz buzz write program outputs string representation numbers 1 n  multiples three output “fizz” instead number multiples five output “buzz”  numbers multiples three five output “fizzbuzz”  easy 
one-line c# solution fizz buzz write program outputs string representation numbers 1 n  multiples three output “fizz” instead number multiples five output “buzz”  numbers multiples three five output “fizzbuzz”  easy 
simple java solution 9 lines  2ms arithmetic slices sequence number called arithmetic consists least three elements difference two consecutive elements same  medium math dynamic programming 
3ms c++ standard dp solution with very detailed explanation arithmetic slices sequence number called arithmetic consists least three elements difference two consecutive elements same  medium math dynamic programming 
2ms java o(n) time  o(1) space solution arithmetic slices sequence number called arithmetic consists least three elements difference two consecutive elements same  medium math dynamic programming 
python dp solution arithmetic slices sequence number called arithmetic consists least three elements difference two consecutive elements same  medium math dynamic programming 
java 2ms o(n) solution using dp with detail explanation arithmetic slices sequence number called arithmetic consists least three elements difference two consecutive elements same  medium math dynamic programming 
java neat and easy understand solution  o(n) time  o(1) space third maximum number given non-empty array integers  return third maximum number array  exist  return maximum number  time complexity must o(n)  easy array 
short easy c++ using set third maximum number given non-empty array integers  return third maximum number array  exist  return maximum number  time complexity must o(n)  easy array 
intuitive and short python solution third maximum number given non-empty array integers  return third maximum number array  exist  return maximum number  time complexity must o(n)  easy array 
a python amusing solution  which actually beats 98%    third maximum number given non-empty array integers  return third maximum number array  exist  return maximum number  time complexity must o(n)  easy array 
java priorityqueue o(n) + o(1) third maximum number given non-empty array integers  return third maximum number array  exist  return maximum number  time complexity must o(n)  easy array 
0 1 knapsack detailed explanation partition equal subset sum given non-empty array containing positive integers  find array partitioned two subsets sum elements subsets equal  note: array element exceed 100  array size exceed 200  medium dynamic programming 
java solution similar to backpack problem - easy to understand partition equal subset sum given non-empty array containing positive integers  find array partitioned two subsets sum elements subsets equal  note: array element exceed 100  array size exceed 200  medium dynamic programming 
simple c++ 4-line solution using a bitset partition equal subset sum given non-empty array containing positive integers  find array partitioned two subsets sum elements subsets equal  note: array element exceed 100  array size exceed 200  medium dynamic programming 
concise c++ solution summary with dfs  dp  bit partition equal subset sum given non-empty array containing positive integers  find array partitioned two subsets sum elements subsets equal  note: array element exceed 100  array size exceed 200  medium dynamic programming 
java solution similar to 'subset sum problem' partition equal subset sum given non-empty array containing positive integers  find array partitioned two subsets sum elements subsets equal  note: array element exceed 100  array size exceed 200  medium dynamic programming 
java bfs & dfs from ocean pacific atlantic water flow given x n matrix non-negative integers representing height unit cell continent  "pacific ocean" touches left top edges matrix "atlantic ocean" touches right bottom edges  water flow four directions (up  down  left  right) cell another one height equal lower  find list grid coordinates water flow pacific atlantic ocean  note: order returned grid coordinates matter  n less 150  medium depth-first search breadth-first search 
python dfs bests 85%  tips for all dfs in matrix question  pacific atlantic water flow given x n matrix non-negative integers representing height unit cell continent  "pacific ocean" touches left top edges matrix "atlantic ocean" touches right bottom edges  water flow four directions (up  down  left  right) cell another one height equal lower  find list grid coordinates water flow pacific atlantic ocean  note: order returned grid coordinates matter  n less 150  medium depth-first search breadth-first search 
not understanding the problem  could someone please explain? pacific atlantic water flow given x n matrix non-negative integers representing height unit cell continent  "pacific ocean" touches left top edges matrix "atlantic ocean" touches right bottom edges  water flow four directions (up  down  left  right) cell another one height equal lower  find list grid coordinates water flow pacific atlantic ocean  note: order returned grid coordinates matter  n less 150  medium depth-first search breadth-first search 
very concise c++ solution using dfs and bit mask pacific atlantic water flow given x n matrix non-negative integers representing height unit cell continent  "pacific ocean" touches left top edges matrix "atlantic ocean" touches right bottom edges  water flow four directions (up  down  left  right) cell another one height equal lower  find list grid coordinates water flow pacific atlantic ocean  note: order returned grid coordinates matter  n less 150  medium depth-first search breadth-first search 
simple commented java solution with thinking progress o(n) pacific atlantic water flow given x n matrix non-negative integers representing height unit cell continent  "pacific ocean" touches left top edges matrix "atlantic ocean" touches right bottom edges  water flow four directions (up  down  left  right) cell another one height equal lower  find list grid coordinates water flow pacific atlantic ocean  note: order returned grid coordinates matter  n less 150  medium depth-first search breadth-first search 
simple java solution battleships in a board given 2d board  count many battleships it  battleships represented 'x's  empty slots represented ' 's  may assume following rules: receive valid board  made battleships empty slots  battleships placed horizontally vertically  words  made shape 1xn (1 row  n columns) nx1 (n rows  1 column)  n size  least one horizontal vertical cell separates two battleships - adjacent battleships  medium 
share my 7-line code  1-line core code  3ms  super easy battleships in a board given 2d board  count many battleships it  battleships represented 'x's  empty slots represented ' 's  may assume following rules: receive valid board  made battleships empty slots  battleships placed horizontally vertically  words  made shape 1xn (1 row  n columns) nx1 (n rows  1 column)  n size  least one horizontal vertical cell separates two battleships - adjacent battleships  medium 
python solution battleships in a board given 2d board  count many battleships it  battleships represented 'x's  empty slots represented ' 's  may assume following rules: receive valid board  made battleships empty slots  battleships placed horizontally vertically  words  made shape 1xn (1 row  n columns) nx1 (n rows  1 column)  n size  least one horizontal vertical cell separates two battleships - adjacent battleships  medium 
4ms java optimized code battleships in a board given 2d board  count many battleships it  battleships represented 'x's  empty slots represented ' 's  may assume following rules: receive valid board  made battleships empty slots  battleships placed horizontally vertically  words  made shape 1xn (1 row  n columns) nx1 (n rows  1 column)  n size  least one horizontal vertical cell separates two battleships - adjacent battleships  medium 
confused with test cases battleships in a board given 2d board  count many battleships it  battleships represented 'x's  empty slots represented ' 's  may assume following rules: receive valid board  made battleships empty slots  battleships placed horizontally vertically  words  made shape 1xn (1 row  n columns) nx1 (n rows  1 column)  n size  least one horizontal vertical cell separates two battleships - adjacent battleships  medium 
c++ 0ms o(n) 35 lines solution with detailed explanation strong password checker password considered strong conditions met: least 6 characters 20 characters  must contain least one lowercase letter  least one uppercase letter  least one digit  must contain three repeating characters row ("   aaa   " weak  "   aa   a   " strong  assuming conditions met)  write function strongpasswordchecker(s)  takes string input  return minimum change required make strong password  already strong  return 0  insertion  deletion replace one character considered one change  hard 
o(n) java solution by analyzing changes allowed to fix each problem strong password checker password considered strong conditions met: least 6 characters 20 characters  must contain least one lowercase letter  least one uppercase letter  least one digit  must contain three repeating characters row ("   aaa   " weak  "   aa   a   " strong  assuming conditions met)  write function strongpasswordchecker(s)  takes string input  return minimum change required make strong password  already strong  return 0  insertion  deletion replace one character considered one change  hard 
simple python solution strong password checker password considered strong conditions met: least 6 characters 20 characters  must contain least one lowercase letter  least one uppercase letter  least one digit  must contain three repeating characters row ("   aaa   " weak  "   aa   a   " strong  assuming conditions met)  write function strongpasswordchecker(s)  takes string input  return minimum change required make strong password  already strong  return 0  insertion  deletion replace one character considered one change  hard 
java easy solution with explanation strong password checker password considered strong conditions met: least 6 characters 20 characters  must contain least one lowercase letter  least one uppercase letter  least one digit  must contain three repeating characters row ("   aaa   " weak  "   aa   a   " strong  assuming conditions met)  write function strongpasswordchecker(s)  takes string input  return minimum change required make strong password  already strong  return 0  insertion  deletion replace one character considered one change  hard 
java o(n) greedy solution with super clear explanation strong password checker password considered strong conditions met: least 6 characters 20 characters  must contain least one lowercase letter  least one uppercase letter  least one digit  must contain three repeating characters row ("   aaa   " weak  "   aa   a   " strong  assuming conditions met)  write function strongpasswordchecker(s)  takes string input  return minimum change required make strong password  already strong  return 0  insertion  deletion replace one character considered one change  hard 
java o(n) solution using bit manipulation and hashmap maximum xor of two numbers in an array given non-empty array numbers  a0  a1  a2  …   an-1  0 ≤ ai < 231  find maximum result ai xor aj  0 ≤ i  j < n  could o(n) runtime? medium bit manipulation trie 
java o(n) solution using trie maximum xor of two numbers in an array given non-empty array numbers  a0  a1  a2  …   an-1  0 ≤ ai < 231  find maximum result ai xor aj  0 ≤ i  j < n  could o(n) runtime? medium bit manipulation trie 
python 6 lines  bit by bit maximum xor of two numbers in an array given non-empty array numbers  a0  a1  a2  …   an-1  0 ≤ ai < 231  find maximum result ai xor aj  0 ≤ i  j < n  could o(n) runtime? medium bit manipulation trie 
使用前缀树(二叉树表示) 打败 92% maximum xor of two numbers in an array given non-empty array numbers  a0  a1  a2  …   an-1  0 ≤ ai < 231  find maximum result ai xor aj  0 ≤ i  j < n  could o(n) runtime? medium bit manipulation trie 
c++  o(n) solution  explanation added maximum xor of two numbers in an array given non-empty array numbers  a0  a1  a2  …   an-1  0 ≤ ai < 231  find maximum result ai xor aj  0 ≤ i  j < n  could o(n) runtime? medium bit manipulation trie 
one pass o(n) java solution  simple and clear reconstruct original digits from english given non-empty string containing out-of-order english representation digits 0-9  output digits ascending order  note: input contains lowercase english letters  input guaranteed valid transformed original digits  means invalid inputs "abc" "zerone" permitted  input length less 50 000  medium math 
fun fact reconstruct original digits from english given non-empty string containing out-of-order english representation digits 0-9  output digits ascending order  note: input contains lowercase english letters  input guaranteed valid transformed original digits  means invalid inputs "abc" "zerone" permitted  input length less 50 000  medium math 
share my simple and easy o(n) solution reconstruct original digits from english given non-empty string containing out-of-order english representation digits 0-9  output digits ascending order  note: input contains lowercase english letters  input guaranteed valid transformed original digits  means invalid inputs "abc" "zerone" permitted  input length less 50 000  medium math 
straightforward c++ accepted solution reconstruct original digits from english given non-empty string containing out-of-order english representation digits 0-9  output digits ascending order  note: input contains lowercase english letters  input guaranteed valid transformed original digits  means invalid inputs "abc" "zerone" permitted  input length less 50 000  medium math 
short matrix solution reconstruct original digits from english given non-empty string containing out-of-order english representation digits 0-9  output digits ascending order  note: input contains lowercase english letters  input guaranteed valid transformed original digits  means invalid inputs "abc" "zerone" permitted  input length less 50 000  medium math 
java 12 lines o(n) sliding window solution with explanation longest repeating character replacement given string consists uppercase english letters  replace letter string another letter k times  find length longest substring containing repeating letters get performing operations  note: string's length k exceed 104  medium 
sliding window  similar to finding longest substring with k distinct characters longest repeating character replacement given string consists uppercase english letters  replace letter string another letter k times  find length longest substring containing repeating letters get performing operations  note: string's length k exceed 104  medium 
7 lines c++ longest repeating character replacement given string consists uppercase english letters  replace letter string another letter k times  find length longest substring containing repeating letters get performing operations  note: string's length k exceed 104  medium 
consise python sliding window longest repeating character replacement given string consists uppercase english letters  replace letter string another letter k times  find length longest substring containing repeating letters get performing operations  note: string's length k exceed 104  medium 
java sliding window easy to understand longest repeating character replacement given string consists uppercase english letters  replace letter string another letter k times  find length longest substring containing repeating letters get performing operations  note: string's length k exceed 104  medium 
please correct your example illustration !!! construct quad tree want use quad trees store n x n boolean grid  cell grid true false  root node represents whole grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  task use quad tree represent given grid  following easy 
recursive java solution construct quad tree want use quad trees store n x n boolean grid  cell grid true false  root node represents whole grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  task use quad tree represent given grid  following easy 
python short & readable dfs solution construct quad tree want use quad trees store n x n boolean grid  cell grid true false  root node represents whole grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  task use quad tree represent given grid  following easy 
java recursive solution construct quad tree want use quad trees store n x n boolean grid  cell grid true false  root node represents whole grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  task use quad tree represent given grid  following easy 
non-leaf nodes seems have to be true value construct quad tree want use quad trees store n x n boolean grid  cell grid true false  root node represents whole grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  task use quad tree represent given grid  following easy 
python 5 lines bfs solution  n-ary tree level order traversal given n-ary tree  return level order traversal nodes' values  (ie  left right  level level)  easy tree breadth-first search 
basic c++ solution using queue  super easy for beginners  n-ary tree level order traversal given n-ary tree  return level order traversal nodes' values  (ie  left right  level level)  easy tree breadth-first search 
java solution n-ary tree level order traversal given n-ary tree  return level order traversal nodes' values  (ie  left right  level level)  easy tree breadth-first search 
python iterative solution beat 96% n-ary tree level order traversal given n-ary tree  return level order traversal nodes' values  (ie  left right  level level)  easy tree breadth-first search 
beat 100% of java -  dfs (recursive) n-ary tree level order traversal given n-ary tree  return level order traversal nodes' values  (ie  left right  level level)  easy tree breadth-first search 
easy understanding java beat 95 7% with explanation flatten a multilevel doubly linked list given doubly linked list addition next previous pointers  could child pointer  may may point separate doubly linked list  child lists may one children own  on  produce multilevel data structure  shown medium linked list depth-first search 
java recursive solution flatten a multilevel doubly linked list given doubly linked list addition next previous pointers  could child pointer  may may point separate doubly linked list  child lists may one children own  on  produce multilevel data structure  shown medium linked list depth-first search 
python easy solution using stack  flatten a multilevel doubly linked list given doubly linked list addition next previous pointers  could child pointer  may may point separate doubly linked list  child lists may one children own  on  produce multilevel data structure  shown medium linked list depth-first search 
c++  about 10 lines solution flatten a multilevel doubly linked list given doubly linked list addition next previous pointers  could child pointer  may may point separate doubly linked list  child lists may one children own  on  produce multilevel data structure  shown medium linked list depth-first search 
python solution with explanation flatten a multilevel doubly linked list given doubly linked list addition next previous pointers  could child pointer  may may point separate doubly linked list  child lists may one children own  on  produce multilevel data structure  shown medium linked list depth-first search 
java ac all strict o(1) not average o(1)  easy to read all o`one data structure implement data structure supporting following operations: inc(key) - inserts new key value 1  increments existing key 1  key guaranteed non-empty string  dec(key) - key's value 1  remove data structure  otherwise decrements existing key 1  key exist  function nothing  key guaranteed non-empty string  getmaxkey() - returns one keys maximal value  element exists  return empty string ""  getminkey() - returns one keys minimal value  element exists  return empty string ""  challenge: perform o(1) time complexity  hard design 
all in o(1)  with detailed explantation all o`one data structure implement data structure supporting following operations: inc(key) - inserts new key value 1  increments existing key 1  key guaranteed non-empty string  dec(key) - key's value 1  remove data structure  otherwise decrements existing key 1  key exist  function nothing  key guaranteed non-empty string  getmaxkey() - returns one keys maximal value  element exists  return empty string ""  getminkey() - returns one keys minimal value  element exists  return empty string ""  challenge: perform o(1) time complexity  hard design 
c++ solution with comments all o`one data structure implement data structure supporting following operations: inc(key) - inserts new key value 1  increments existing key 1  key guaranteed non-empty string  dec(key) - key's value 1  remove data structure  otherwise decrements existing key 1  key exist  function nothing  key guaranteed non-empty string  getmaxkey() - returns one keys maximal value  element exists  return empty string ""  getminkey() - returns one keys minimal value  element exists  return empty string ""  challenge: perform o(1) time complexity  hard design 
an accepted java solution  detailed explanation (hashmap + double linked list) all o`one data structure implement data structure supporting following operations: inc(key) - inserts new key value 1  increments existing key 1  key guaranteed non-empty string  dec(key) - key's value 1  remove data structure  otherwise decrements existing key 1  key exist  function nothing  key guaranteed non-empty string  getmaxkey() - returns one keys maximal value  element exists  return empty string ""  getminkey() - returns one keys minimal value  element exists  return empty string ""  challenge: perform o(1) time complexity  hard design 
python solution with detailed comments all o`one data structure implement data structure supporting following operations: inc(key) - inserts new key value 1  increments existing key 1  key guaranteed non-empty string  dec(key) - key's value 1  remove data structure  otherwise decrements existing key 1  key exist  function nothing  key guaranteed non-empty string  getmaxkey() - returns one keys maximal value  element exists  return empty string ""  getminkey() - returns one keys minimal value  element exists  return empty string ""  challenge: perform o(1) time complexity  hard design 
java solution using bfs minimum genetic mutation gene string represented 8-character long string  choices "a"  "c"  "g"  "t"  suppose need investigate mutation (mutation "start" "end")  one mutation defined one single character changed gene string  medium 
c++ two end bfs solution  exactly same as 127 word ladder minimum genetic mutation gene string represented 8-character long string  choices "a"  "c"  "g"  "t"  suppose need investigate mutation (mutation "start" "end")  one mutation defined one single character changed gene string  medium 
python solution using bfs minimum genetic mutation gene string represented 8-character long string  choices "a"  "c"  "g"  "t"  suppose need investigate mutation (mutation "start" "end")  one mutation defined one single character changed gene string  medium 
clear java solution based on bfs (similar to word ladder) minimum genetic mutation gene string represented 8-character long string  choices "a"  "c"  "g"  "t"  suppose need investigate mutation (mutation "start" "end")  one mutation defined one single character changed gene string  medium 
c++ bfs (0ms) minimum genetic mutation gene string represented 8-character long string  choices "a"  "c"  "g"  "t"  suppose need investigate mutation (mutation "start" "end")  one mutation defined one single character changed gene string  medium 
clean java solution o(n) number of segments in a string count number segments string  segment defined contiguous sequence non-space characters  please note string contain non-printable characters  easy string 
one-liners number of segments in a string count number segments string  segment defined contiguous sequence non-space characters  please note string contain non-printable characters  easy string 
o(n) sentinel value concise solution  c++ number of segments in a string count number segments string  segment defined contiguous sequence non-space characters  please note string contain non-printable characters  easy string 
2-line c++ solution simply using stringstream >> operator number of segments in a string count number segments string  segment defined contiguous sequence non-space characters  please note string contain non-printable characters  easy string 
ac solution java with trim() and split() number of segments in a string count number segments string  segment defined contiguous sequence non-space characters  please note string contain non-printable characters  easy string 
java: least is most non-overlapping intervals given collection intervals  find minimum number intervals need remove make rest intervals non-overlapping  note: may assume interval's end point always bigger start point  intervals like [1 2] [2 3] borders "touching" overlap other  medium greedy 
short ruby and python non-overlapping intervals given collection intervals  find minimum number intervals need remove make rest intervals non-overlapping  note: may assume interval's end point always bigger start point  intervals like [1 2] [2 3] borders "touching" overlap other  medium greedy 
concise c++ solution non-overlapping intervals given collection intervals  find minimum number intervals need remove make rest intervals non-overlapping  note: may assume interval's end point always bigger start point  intervals like [1 2] [2 3] borders "touching" overlap other  medium greedy 
java solution with clear explain non-overlapping intervals given collection intervals  find minimum number intervals need remove make rest intervals non-overlapping  note: may assume interval's end point always bigger start point  intervals like [1 2] [2 3] borders "touching" overlap other  medium greedy 
python greedy solution with explanation non-overlapping intervals given collection intervals  find minimum number intervals need remove make rest intervals non-overlapping  note: may assume interval's end point always bigger start point  intervals like [1 2] [2 3] borders "touching" overlap other  medium greedy 
java clear o(n logn) solution based on treemap find right interval given set intervals  interval i  check exists interval j whose start point bigger equal end point interval i  called j "right" i  interval i  need store minimum interval j's index  means interval j minimum start point build "right" relationship interval i  interval j exist  store -1 interval i  finally  need output stored value interval array  note: may assume interval's end point always bigger start point  may assume none intervals start point  medium binary search 
c++ map solution find right interval given set intervals  interval i  check exists interval j whose start point bigger equal end point interval i  called j "right" i  interval i  need store minimum interval j's index  means interval j minimum start point build "right" relationship interval i  interval j exist  store -1 interval i  finally  need output stored value interval array  note: may assume interval's end point always bigger start point  may assume none intervals start point  medium binary search 
python o(nlogn) short solution with explanation find right interval given set intervals  interval i  check exists interval j whose start point bigger equal end point interval i  called j "right" i  interval i  need store minimum interval j's index  means interval j minimum start point build "right" relationship interval i  interval j exist  store -1 interval i  finally  need output stored value interval array  note: may assume interval's end point always bigger start point  may assume none intervals start point  medium binary search 
java concise binary search find right interval given set intervals  interval i  check exists interval j whose start point bigger equal end point interval i  called j "right" i  interval i  need store minimum interval j's index  means interval j minimum start point build "right" relationship interval i  interval j exist  store -1 interval i  finally  need output stored value interval array  note: may assume interval's end point always bigger start point  may assume none intervals start point  medium binary search 
2 lines python   ruby find right interval given set intervals  interval i  check exists interval j whose start point bigger equal end point interval i  called j "right" i  interval i  need store minimum interval j's index  means interval j minimum start point build "right" relationship interval i  interval j exist  store -1 interval i  finally  need output stored value interval array  note: may assume interval's end point always bigger start point  may assume none intervals start point  medium binary search 
17 ms o(n) java prefix sum method path sum iii given binary tree node contains integer value  find number paths sum given value  path need start end root leaf  must go downwards (traveling parent nodes child nodes)  tree 1 000 nodes values range -1 000 000 1 000 000  easy tree 
simple java dfs path sum iii given binary tree node contains integer value  find number paths sum given value  path need start end root leaf  must go downwards (traveling parent nodes child nodes)  tree 1 000 nodes values range -1 000 000 1 000 000  easy tree 
simple ac java solution dfs path sum iii given binary tree node contains integer value  find number paths sum given value  path need start end root leaf  must go downwards (traveling parent nodes child nodes)  tree 1 000 nodes values range -1 000 000 1 000 000  easy tree 
python solution with detailed explanation path sum iii given binary tree node contains integer value  find number paths sum given value  path need start end root leaf  must go downwards (traveling parent nodes child nodes)  tree 1 000 nodes values range -1 000 000 1 000 000  easy tree 
python step-by-step walk through  easy to understand  two solutions comparison  : ) path sum iii given binary tree node contains integer value  find number paths sum given value  path need start end root leaf  must go downwards (traveling parent nodes child nodes)  tree 1 000 nodes values range -1 000 000 1 000 000  easy tree 
sliding window algorithm template to solve all the leetcode substring search problem  find all anagrams in a string given string non-empty string p  find start indices p's anagrams s  strings consists lowercase english letters length strings p larger 20 100  order output matter  easy hash table 
shortest concise java o(n) sliding window solution find all anagrams in a string given string non-empty string p  find start indices p's anagrams s  strings consists lowercase english letters length strings p larger 20 100  order output matter  easy hash table 
o(n) sliding window java solution  extremely detailed explanation find all anagrams in a string given string non-empty string p  find start indices p's anagrams s  strings consists lowercase english letters length strings p larger 20 100  order output matter  easy hash table 
python sliding window solution using counter find all anagrams in a string given string non-empty string p  find start indices p's anagrams s  strings consists lowercase english letters length strings p larger 20 100  order output matter  easy hash table 
c++ o(n) sliding window concise solution with explanation find all anagrams in a string given string non-empty string p  find start indices p's anagrams s  strings consists lowercase english letters length strings p larger 20 100  order output matter  easy hash table 
concise easy-to-understand java 5ms solution with explaination k-th smallest in lexicographical order given integers n k  find lexicographically k-th smallest integer range 1 n  note: 1 ≤ k ≤ n ≤ 109  hard 
c++ python 0ms o((log n)^2)-time o(1)-space super easy solution with detailed explanations k-th smallest in lexicographical order given integers n k  find lexicographically k-th smallest integer range 1 n  note: 1 ≤ k ≤ n ≤ 109  hard 
java 7ms denary(trie?) tree solution with detailed explanation k-th smallest in lexicographical order given integers n k  find lexicographically k-th smallest integer range 1 n  note: 1 ≤ k ≤ n ≤ 109  hard 
it's a denary tree k-th smallest in lexicographical order given integers n k  find lexicographically k-th smallest integer range 1 n  note: 1 ≤ k ≤ n ≤ 109  hard 
what's wrong with my answer??? i am definitely right k-th smallest in lexicographical order given integers n k  find lexicographically k-th smallest integer range 1 n  note: 1 ≤ k ≤ n ≤ 109  hard 
[java] clean code with explanations and running time [2 solutions] arranging coins total n coins want form staircase shape  every k-th row must exactly k coins  given n  find total number full staircase rows formed  n non-negative integer fits within range 32-bit signed integer  easy math binary search 
java o(1) solution - math problem arranging coins total n coins want form staircase shape  every k-th row must exactly k coins  given n  find total number full staircase rows formed  n non-negative integer fits within range 32-bit signed integer  easy math binary search 
c++ 1 line code arranging coins total n coins want form staircase shape  every k-th row must exactly k coins  given n  find total number full staircase rows formed  n non-negative integer fits within range 32-bit signed integer  easy math binary search 
[java] cleaner and easier to understand solution  arranging coins total n coins want form staircase shape  every k-th row must exactly k coins  given n  find total number full staircase rows formed  n non-negative integer fits within range 32-bit signed integer  easy math binary search 
o(logn) binary search java solution arranging coins total n coins want form staircase shape  every k-th row must exactly k coins  given n  find total number full staircase rows formed  n non-negative integer fits within range 32-bit signed integer  easy math binary search 
java simple solution find all duplicates in an array given array integers  1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements appear twice array  could without extra space o(n) runtime? medium array 
python o(n) time o(1) space find all duplicates in an array given array integers  1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements appear twice array  could without extra space o(n) runtime? medium array 
very simple c++ solution find all duplicates in an array given array integers  1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements appear twice array  could without extra space o(n) runtime? medium array 
c++ beats 98% find all duplicates in an array given array integers  1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements appear twice array  could without extra space o(n) runtime? medium array 
java solution without destroying the input array  o(n) time  o(1) space  find all duplicates in an array given array integers  1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements appear twice array  could without extra space o(n) runtime? medium array 
simple easy to understand java solution string compression given array characters  compress in-place  length compression must always smaller equal original array  every element array character (not int) length 1  done modifying input array in-place  return new length array  follow up: could solve using o(1) extra space? easy string 
python two pointers - o(n) time o(1) space string compression given array characters  compress in-place  length compression must always smaller equal original array  every element array character (not int) length 1  done modifying input array in-place  return new length array  follow up: could solve using o(1) extra space? easy string 
java o(n)  two pointers and a counter string compression given array characters  compress in-place  length compression must always smaller equal original array  every element array character (not int) length 1  done modifying input array in-place  return new length array  follow up: could solve using o(1) extra space? easy string 
python 5-liner  o(n) time  no pointers! string compression given array characters  compress in-place  length compression must always smaller equal original array  every element array character (not int) length 1  done modifying input array in-place  return new length array  follow up: could solve using o(1) extra space? easy string 
python solution with detailed explanation string compression given array characters  compress in-place  length compression must always smaller equal original array  every element array character (not int) length 1  done modifying input array in-place  return new length array  follow up: could solve using o(1) extra space? easy string 
easy o(n) java solution using stack add two numbers ii given two non-empty linked lists representing two non-negative integers  significant digit comes first nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  follow up: cannot modify input lists? words  reversing lists allowed  medium linked list 
c++ o(1) extra space except for output  reverse output instead  is this cheating? add two numbers ii given two non-empty linked lists representing two non-negative integers  significant digit comes first nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  follow up: cannot modify input lists? words  reversing lists allowed  medium linked list 
java o(n) recursive solution by counting the difference of length add two numbers ii given two non-empty linked lists representing two non-negative integers  significant digit comes first nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  follow up: cannot modify input lists? words  reversing lists allowed  medium linked list 
there is no maximum of int in python  so      add two numbers ii given two non-empty linked lists representing two non-negative integers  significant digit comes first nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  follow up: cannot modify input lists? words  reversing lists allowed  medium linked list 
concise c++ solution without reverse add two numbers ii given two non-empty linked lists representing two non-negative integers  significant digit comes first nodes contain single digit  add two numbers return linked list  may assume two numbers contain leading zero  except number 0 itself  follow up: cannot modify input lists? words  reversing lists allowed  medium linked list 
detailed explanation for java o(n^2) solution arithmetic slices ii - subsequence sequence numbers called arithmetic consists least three elements difference two consecutive elements same  hard dynamic programming 
java 15 lines solution arithmetic slices ii - subsequence sequence numbers called arithmetic consists least three elements difference two consecutive elements same  hard dynamic programming 
11 line python o(n^2) solution arithmetic slices ii - subsequence sequence numbers called arithmetic consists least three elements difference two consecutive elements same  hard dynamic programming 
c++_dp_accepted arithmetic slices ii - subsequence sequence numbers called arithmetic consists least three elements difference two consecutive elements same  hard dynamic programming 
o(n^2) mle tle in c++? try this one  concise and fast  arithmetic slices ii - subsequence sequence numbers called arithmetic consists least three elements difference two consecutive elements same  hard dynamic programming 
clean java solution: o(n^2) 166ms number of boomerangs given n points plane pairwise distinct  "boomerang" tuple points (i  j  k) distance j equals distance k (the order tuple matters)  find number boomerangs  may assume n 500 coordinates points range [-10000  10000] (inclusive)  easy hash table 
short python o(n^2) hashmap solution number of boomerangs given n points plane pairwise distinct  "boomerang" tuple points (i  j  k) distance j equals distance k (the order tuple matters)  find number boomerangs  may assume n 500 coordinates points range [-10000  10000] (inclusive)  easy hash table 
7 lines ~1050 ms c++ number of boomerangs given n points plane pairwise distinct  "boomerang" tuple points (i  j  k) distance j equals distance k (the order tuple matters)  find number boomerangs  may assume n 500 coordinates points range [-10000  10000] (inclusive)  easy hash table 
c++ clean solution o(n^2)  fully commented and explained  number of boomerangs given n points plane pairwise distinct  "boomerang" tuple points (i  j  k) distance j equals distance k (the order tuple matters)  find number boomerangs  may assume n 500 coordinates points range [-10000  10000] (inclusive)  easy hash table 
share my straightforward solution with hashmap  o(n^2) number of boomerangs given n points plane pairwise distinct  "boomerang" tuple points (i  j  k) distance j equals distance k (the order tuple matters)  find number boomerangs  may assume n 500 coordinates points range [-10000  10000] (inclusive)  easy hash table 
java accepted simple solution find all numbers disappeared in an array given array integers 1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements [1  n] inclusive appear array  could without extra space o(n) runtime? may assume returned list count extra space  easy array 
python 4 lines with short explanation find all numbers disappeared in an array given array integers 1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements [1  n] inclusive appear array  could without extra space o(n) runtime? may assume returned list count extra space  easy array 
5-line java easy-understanding find all numbers disappeared in an array given array integers 1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements [1  n] inclusive appear array  could without extra space o(n) runtime? may assume returned list count extra space  easy array 
c++ solution o(1) space find all numbers disappeared in an array given array integers 1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements [1  n] inclusive appear array  could without extra space o(n) runtime? may assume returned list count extra space  easy array 
simple java in-place sort solution find all numbers disappeared in an array given array integers 1 ≤ a[i] ≤ n (n = size array)  elements appear twice others appear once  find elements [1  n] inclusive appear array  could without extra space o(n) runtime? may assume returned list count extra space  easy array 
java preorder + queue solution serialize and deserialize bst serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary search tree  restriction serialization deserialization algorithm work  need ensure binary search tree serialized string string deserialized original tree structure  encoded string compact possible  note: use class member global static variables store states  serialize deserialize algorithms stateless  medium tree 
concise c++ 19ms solution beating 99 4% serialize and deserialize bst serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary search tree  restriction serialization deserialization algorithm work  need ensure binary search tree serialized string string deserialized original tree structure  encoded string compact possible  note: use class member global static variables store states  serialize deserialize algorithms stateless  medium tree 
deserialize from preorder and computed inorder  reusing old solution serialize and deserialize bst serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary search tree  restriction serialization deserialization algorithm work  need ensure binary search tree serialized string string deserialized original tree structure  encoded string compact possible  note: use class member global static variables store states  serialize deserialize algorithms stateless  medium tree 
what's the difference between this and #297 ? serialize and deserialize bst serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary search tree  restriction serialization deserialization algorithm work  need ensure binary search tree serialized string string deserialized original tree structure  encoded string compact possible  note: use class member global static variables store states  serialize deserialize algorithms stateless  medium tree 
using lower bound and upper bound to deserialize bst serialize and deserialize bst serialization process converting data structure object sequence bits stored file memory buffer  transmitted across network connection link reconstructed later another computer environment  design algorithm serialize deserialize binary search tree  restriction serialization deserialization algorithm work  need ensure binary search tree serialized string string deserialized original tree structure  encoded string compact possible  note: use class member global static variables store states  serialize deserialize algorithms stateless  medium tree 
recursive easy to understand java solution delete node in a bst given root node reference bst key  delete node given key bst  return root node reference (possibly updated) bst  basically  deletion divided two stages: search node remove  node found  delete node  note: time complexity o(height tree)  medium tree 
iterative solution in java  o(h) time and o(1) space delete node in a bst given root node reference bst key  delete node given key bst  return root node reference (possibly updated) bst  basically  deletion divided two stages: search node remove  node found  delete node  note: time complexity o(height tree)  medium tree 
very concise c++ solution for general binary tree not only bst delete node in a bst given root node reference bst key  delete node given key bst  return root node reference (possibly updated) bst  basically  deletion divided two stages: search node remove  node found  delete node  note: time complexity o(height tree)  medium tree 
simple python solution with explanation delete node in a bst given root node reference bst key  delete node given key bst  return root node reference (possibly updated) bst  basically  deletion divided two stages: search node remove  node found  delete node  note: time complexity o(height tree)  medium tree 
java easy to understand solution delete node in a bst given root node reference bst key  delete node given key bst  return root node reference (possibly updated) bst  basically  deletion divided two stages: search node remove  node found  delete node  note: time complexity o(height tree)  medium tree 
java o(n) bucket sort solution   o(nlogm) priorityqueue solution  easy to understand sort characters by frequency given string  sort decreasing order based frequency characters  medium hash table heap 
c++ o(n) solution without sort() sort characters by frequency given string  sort decreasing order based frequency characters  medium hash table heap 
o(n) easy to understand java solution sort characters by frequency given string  sort decreasing order based frequency characters  medium hash table heap 
concise c++ solution using stl sort sort characters by frequency given string  sort decreasing order based frequency characters  medium hash table heap 
1 line python code  sort characters by frequency given string  sort decreasing order based frequency characters  medium hash table heap 
share my explained greedy solution minimum number of arrows to burst balloons number spherical balloons spread two-dimensional space  balloon  provided input start end coordinates horizontal diameter  since horizontal  y-coordinates matter hence x-coordinates start end diameter suffice  start always smaller end  104 balloons  arrow shot exactly vertically different points along x-axis  balloon xstart xend bursts arrow shot x xstart ≤ x ≤ xend  limit number arrows shot  arrow shot keeps travelling infinitely  problem find minimum number arrows must shot burst balloons  medium greedy 
greedy  python (132 ms) minimum number of arrows to burst balloons number spherical balloons spread two-dimensional space  balloon  provided input start end coordinates horizontal diameter  since horizontal  y-coordinates matter hence x-coordinates start end diameter suffice  start always smaller end  104 balloons  arrow shot exactly vertically different points along x-axis  balloon xstart xend bursts arrow shot x xstart ≤ x ≤ xend  limit number arrows shot  arrow shot keeps travelling infinitely  problem find minimum number arrows must shot burst balloons  medium greedy 
java greedy soution minimum number of arrows to burst balloons number spherical balloons spread two-dimensional space  balloon  provided input start end coordinates horizontal diameter  since horizontal  y-coordinates matter hence x-coordinates start end diameter suffice  start always smaller end  104 balloons  arrow shot exactly vertically different points along x-axis  balloon xstart xend bursts arrow shot x xstart ≤ x ≤ xend  limit number arrows shot  arrow shot keeps travelling infinitely  problem find minimum number arrows must shot burst balloons  medium greedy 
c++ easy understood solution (sort) minimum number of arrows to burst balloons number spherical balloons spread two-dimensional space  balloon  provided input start end coordinates horizontal diameter  since horizontal  y-coordinates matter hence x-coordinates start end diameter suffice  start always smaller end  104 balloons  arrow shot exactly vertically different points along x-axis  balloon xstart xend bursts arrow shot x xstart ≤ x ≤ xend  limit number arrows shot  arrow shot keeps travelling infinitely  problem find minimum number arrows must shot burst balloons  medium greedy 
a concise template for "overlapping interval problem" minimum number of arrows to burst balloons number spherical balloons spread two-dimensional space  balloon  provided input start end coordinates horizontal diameter  since horizontal  y-coordinates matter hence x-coordinates start end diameter suffice  start always smaller end  104 balloons  arrow shot exactly vertically different points along x-axis  balloon xstart xend bursts arrow shot x xstart ≤ x ≤ xend  limit number arrows shot  arrow shot keeps travelling infinitely  problem find minimum number arrows must shot burst balloons  medium greedy 
it is a math question minimum moves to equal array elements given non-empty integer array size n  find minimum number moves required make array elements equal  move incrementing n - 1 elements 1  easy math 
java o(n) solution  short  minimum moves to equal array elements given non-empty integer array size n  find minimum number moves required make array elements equal  move incrementing n - 1 elements 1  easy math 
simple one-liners minimum moves to equal array elements given non-empty integer array size n  find minimum number moves required make array elements equal  move incrementing n - 1 elements 1  easy math 
what if we are not smart enough to come up with decrease 1  here is how we do it  minimum moves to equal array elements given non-empty integer array size n  find minimum number moves required make array elements equal  move incrementing n - 1 elements 1  easy math 
four python solutions with detailed explanation minimum moves to equal array elements given non-empty integer array size n  find minimum number moves required make array elements equal  move incrementing n - 1 elements 1  easy math 
clean java solution o(n^2) 4sum ii given four lists a  b  c  integer values  compute many tuples (i  j  k  l) a[i] + b[j] + c[k] + d[l] zero  make problem bit easier  a  b  c  length n 0 ≤ n ≤ 500  integers range -228 228 - 1 result guaranteed 231 - 1  medium hash table binary search 
easy 2 lines o(n^2) python 4sum ii given four lists a  b  c  integer values  compute many tuples (i  j  k  l) a[i] + b[j] + c[k] + d[l] zero  make problem bit easier  a  b  c  length n 0 ≤ n ≤ 500  integers range -228 228 - 1 result guaranteed 231 - 1  medium hash table binary search 
simple java solution with explanation 4sum ii given four lists a  b  c  integer values  compute many tuples (i  j  k  l) a[i] + b[j] + c[k] + d[l] zero  make problem bit easier  a  b  c  length n 0 ≤ n ≤ 500  integers range -228 228 - 1 result guaranteed 231 - 1  medium hash table binary search 
concise c++ 11 code beat 99 5% 4sum ii given four lists a  b  c  integer values  compute many tuples (i  j  k  l) a[i] + b[j] + c[k] + d[l] zero  make problem bit easier  a  b  c  length n 0 ≤ n ≤ 500  integers range -228 228 - 1 result guaranteed 231 - 1  medium hash table binary search 
python o(n^2) solution with hashtable 4sum ii given four lists a  b  c  integer values  compute many tuples (i  j  k  l) a[i] + b[j] + c[k] + d[l] zero  make problem bit easier  a  b  c  length n 0 ≤ n ≤ 500  integers range -228 228 - 1 result guaranteed 231 - 1  medium hash table binary search 
simple greedy java solution assign cookies assume awesome parent want give children cookies  but  give child one cookie  child greed factor gi  minimum size cookie child content with; cookie j size sj  sj >= gi  assign cookie j child i  child content  goal maximize number content children output maximum number  note: may assume greed factor always positive  cannot assign one cookie one child  easy greedy 
array sort + two pointer greedy solution o(nlogn) assign cookies assume awesome parent want give children cookies  but  give child one cookie  child greed factor gi  minimum size cookie child content with; cookie j size sj  sj >= gi  assign cookie j child i  child content  goal maximize number content children output maximum number  note: may assume greed factor always positive  cannot assign one cookie one child  easy greedy 
simple python o(nlogn) assign cookies assume awesome parent want give children cookies  but  give child one cookie  child greed factor gi  minimum size cookie child content with; cookie j size sj  sj >= gi  assign cookie j child i  child content  goal maximize number content children output maximum number  note: may assume greed factor always positive  cannot assign one cookie one child  easy greedy 
easy understanding c++ solution o(nlogn) assign cookies assume awesome parent want give children cookies  but  give child one cookie  child greed factor gi  minimum size cookie child content with; cookie j size sj  sj >= gi  assign cookie j child i  child content  goal maximize number content children output maximum number  note: may assume greed factor always positive  cannot assign one cookie one child  easy greedy 
simple python solution assign cookies assume awesome parent want give children cookies  but  give child one cookie  child greed factor gi  minimum size cookie child content with; cookie j size sj  sj >= gi  assign cookie j child i  child content  goal maximize number content children output maximum number  note: may assume greed factor always positive  cannot assign one cookie one child  easy greedy 
single pass c++ o(n) space and time solution (8 lines) with detailed explanation  132 pattern given sequence n integers a1  a2       an  132 pattern subsequence ai  aj  ak < j < k ai < ak < aj  design algorithm takes list n numbers input checks whether 132 pattern list  note: n less 15 000  medium stack 
java solutions from o(n^3) to o(n) for "132" pattern (updated with one-pass slution) 132 pattern given sequence n integers a1  a2       an  132 pattern subsequence ai  aj  ak < j < k ai < ak < aj  design algorithm takes list n numbers input checks whether 132 pattern list  note: n less 15 000  medium stack 
java o(n) solution using stack in detail explanation 132 pattern given sequence n integers a1  a2       an  132 pattern subsequence ai  aj  ak < j < k ai < ak < aj  design algorithm takes list n numbers input checks whether 132 pattern list  note: n less 15 000  medium stack 
10-line python solution 132 pattern given sequence n integers a1  a2       an  132 pattern subsequence ai  aj  ak < j < k ai < ak < aj  design algorithm takes list n numbers input checks whether 132 pattern list  note: n less 15 000  medium stack 
share my easy and simple solution 132 pattern given sequence n integers a1  a2       an  132 pattern subsequence ai  aj  ak < j < k ai < ak < aj  design algorithm takes list n numbers input checks whether 132 pattern list  note: n less 15 000  medium stack 
i cannot understand why test case [-2  1  -1  -2  -2] gives false? circular array loop given array positive negative integers  number n index positive  move forward n steps  conversely  negative (-n)  move backward n steps  assume first element array forward next last element  last element backward next first element  determine loop array  loop starts ends particular index 1 element along loop  loop must "forward" "backward'  medium 
java slow fast pointer solution circular array loop given array positive negative integers  number n index positive  move forward n steps  conversely  negative (-n)  move backward n steps  assume first element array forward next last element  last element backward next first element  determine loop array  loop starts ends particular index 1 element along loop  loop must "forward" "backward'  medium 
why {3  1  2} is a loop and {-1  -2  -3  -4  -5} is not? circular array loop given array positive negative integers  number n index positive  move forward n steps  conversely  negative (-n)  move backward n steps  assume first element array forward next last element  last element backward next first element  determine loop array  loop starts ends particular index 1 element along loop  loop must "forward" "backward'  medium 
python 1 pointer o(n) time o(1) space circular array loop given array positive negative integers  number n index positive  move forward n steps  conversely  negative (-n)  move backward n steps  assume first element array forward next last element  last element backward next first element  determine loop array  loop starts ends particular index 1 element along loop  loop must "forward" "backward'  medium 
two pass o(n) solution by marking failed loop by zero circular array loop given array positive negative integers  number n index positive  move forward n steps  conversely  negative (-n)  move backward n steps  assume first element array forward next last element  last element backward next first element  determine loop array  loop starts ends particular index 1 element along loop  loop must "forward" "backward'  medium 
another explanation and solution poor pigs 1000 buckets  one one contains poison  rest filled water  look same  pig drinks poison die within 15 minutes  minimum amount pigs need figure bucket contains poison within one hour  answer question  write algorithm follow-up general case  follow-up: n buckets pig drinking poison die within minutes  many pigs (x) need figure "poison" bucket within p minutes? exact one bucket poison  easy 
solution with detailed explanation poor pigs 1000 buckets  one one contains poison  rest filled water  look same  pig drinks poison die within 15 minutes  minimum amount pigs need figure bucket contains poison within one hour  answer question  write algorithm follow-up general case  follow-up: n buckets pig drinking poison die within minutes  many pigs (x) need figure "poison" bucket within p minutes? exact one bucket poison  easy 
why is the difficulty of this problem easy? poor pigs 1000 buckets  one one contains poison  rest filled water  look same  pig drinks poison die within 15 minutes  minimum amount pigs need figure bucket contains poison within one hour  answer question  write algorithm follow-up general case  follow-up: n buckets pig drinking poison die within minutes  many pigs (x) need figure "poison" bucket within p minutes? exact one bucket poison  easy 
why should pig die? poor pigs 1000 buckets  one one contains poison  rest filled water  look same  pig drinks poison die within 15 minutes  minimum amount pigs need figure bucket contains poison within one hour  answer question  write algorithm follow-up general case  follow-up: n buckets pig drinking poison die within minutes  many pigs (x) need figure "poison" bucket within p minutes? exact one bucket poison  easy 
major flaw in current algorithm [fixed] poor pigs 1000 buckets  one one contains poison  rest filled water  look same  pig drinks poison die within 15 minutes  minimum amount pigs need figure bucket contains poison within one hour  answer question  write algorithm follow-up general case  follow-up: n buckets pig drinking poison die within minutes  many pigs (x) need figure "poison" bucket within p minutes? exact one bucket poison  easy 
easy python solution with explaination repeated substring pattern given non-empty string check constructed taking substring appending multiple copies substring together  may assume given string consists lowercase english letters length exceed 10000  easy string 
java simple solution with explanation repeated substring pattern given non-empty string check constructed taking substring appending multiple copies substring together  may assume given string consists lowercase english letters length exceed 10000  easy string 
simple java solution  2 lines repeated substring pattern given non-empty string check constructed taking substring appending multiple copies substring together  may assume given string consists lowercase english letters length exceed 10000  easy string 
c++ o(n) using kmp  32ms  8 lines of code with brief explanation  repeated substring pattern given non-empty string check constructed taking substring appending multiple copies substring together  may assume given string consists lowercase english letters length exceed 10000  easy string 
java & o(n) repeated substring pattern given non-empty string check constructed taking substring appending multiple copies substring together  may assume given string consists lowercase english letters length exceed 10000  easy string 
java o(1) very easy solution using 3 hashmaps and linkedhashset lfu cache design implement data structure least frequently used (lfu) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reaches capacity  invalidate least frequently used item inserting new item  purpose problem  tie (i e   two keys frequency)  least recently used key would evicted  follow up: could operations o(1) time complexity? hard design 
java o(1) accept solution using hashmap  doublelinkedlist and linkedhashset lfu cache design implement data structure least frequently used (lfu) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reaches capacity  invalidate least frequently used item inserting new item  purpose problem  tie (i e   two keys frequency)  least recently used key would evicted  follow up: could operations o(1) time complexity? hard design 
concise c++ o(1) solution using 3 hash maps with explanation lfu cache design implement data structure least frequently used (lfu) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reaches capacity  invalidate least frequently used item inserting new item  purpose problem  tie (i e   two keys frequency)  least recently used key would evicted  follow up: could operations o(1) time complexity? hard design 
java o(1) solution using two hashmap and one doublelinkedlist lfu cache design implement data structure least frequently used (lfu) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reaches capacity  invalidate least frequently used item inserting new item  purpose problem  tie (i e   two keys frequency)  least recently used key would evicted  follow up: could operations o(1) time complexity? hard design 
java solutions of three different ways  priorityqueue : o(capacity)  treemap : o(log(capacity)) doublelinkedlist  : o(1) lfu cache design implement data structure least frequently used (lfu) cache  support following operations: get put  get(key) - get value (will always positive) key key exists cache  otherwise return -1  put(key  value) - set insert value key already present  cache reaches capacity  invalidate least frequently used item inserting new item  purpose problem  tie (i e   two keys frequency)  least recently used key would evicted  follow up: could operations o(1) time complexity? hard design 
java 1 line solution :d hamming distance hamming distance two integers number positions corresponding bits different  given two integers x y  calculate hamming distance  note: 0 ≤ x  < 231  easy bit manipulation 
my c++ solution using bit manipulation hamming distance hamming distance two integers number positions corresponding bits different  given two integers x y  calculate hamming distance  note: 0 ≤ x  < 231  easy bit manipulation 
python 1 line 49ms hamming distance hamming distance two integers number positions corresponding bits different  given two integers x y  calculate hamming distance  note: 0 ≤ x  < 231  easy bit manipulation 
java 3-line solution hamming distance hamming distance two integers number positions corresponding bits different  given two integers x y  calculate hamming distance  note: 0 ≤ x  < 231  easy bit manipulation 
javascript one line solution hamming distance hamming distance two integers number positions corresponding bits different  given two integers x y  calculate hamming distance  note: 0 ≤ x  < 231  easy bit manipulation 
java(just like meeting point problem) minimum moves to equal array elements ii given non-empty integer array  find minimum number moves required make array elements equal  move incrementing selected element 1 decrementing selected element 1  may assume array's length 10 000  medium math 
2 lines python  2 ways minimum moves to equal array elements ii given non-empty integer array  find minimum number moves required make array elements equal  move incrementing selected element 1 decrementing selected element 1  may assume array's length 10 000  medium math 
java o(n) time using quickselect minimum moves to equal array elements ii given non-empty integer array  find minimum number moves required make array elements equal  move incrementing selected element 1 decrementing selected element 1  may assume array's length 10 000  medium math 
o(n) solution with detailed explanation  minimum moves to equal array elements ii given non-empty integer array  find minimum number moves required make array elements equal  move incrementing selected element 1 decrementing selected element 1  may assume array's length 10 000  medium math 
why median is better than average? minimum moves to equal array elements ii given non-empty integer array  find minimum number moves required make array elements equal  move incrementing selected element 1 decrementing selected element 1  may assume array's length 10 000  medium math 
clear and easy java solution island perimeter given map form two-dimensional integer grid 1 represents land 0 represents water  grid cells connected horizontally vertically (not diagonally)  grid completely surrounded water  exactly one island (i e   one connected land cells)  island "lakes" (water inside connected water around island)  one cell square side length 1  grid rectangular  width height exceed 100  determine perimeter island  easy hash table 
short python island perimeter given map form two-dimensional integer grid 1 represents land 0 represents water  grid cells connected horizontally vertically (not diagonally)  grid completely surrounded water  exactly one island (i e   one connected land cells)  island "lakes" (water inside connected water around island)  one cell square side length 1  grid rectangular  width height exceed 100  determine perimeter island  easy hash table 
java 9 line solution  add 4 for each land and remove 2 for each internal edge island perimeter given map form two-dimensional integer grid 1 represents land 0 represents water  grid cells connected horizontally vertically (not diagonally)  grid completely surrounded water  exactly one island (i e   one connected land cells)  island "lakes" (water inside connected water around island)  one cell square side length 1  grid rectangular  width height exceed 100  determine perimeter island  easy hash table 
c++ solution with explanation island perimeter given map form two-dimensional integer grid 1 represents land 0 represents water  grid cells connected horizontally vertically (not diagonally)  grid completely surrounded water  exactly one island (i e   one connected land cells)  island "lakes" (water inside connected water around island)  one cell square side length 1  grid rectangular  width height exceed 100  determine perimeter island  easy hash table 
easy to read python solution island perimeter given map form two-dimensional integer grid 1 represents land 0 represents water  grid cells connected horizontally vertically (not diagonally)  grid completely surrounded water  exactly one island (i e   one connected land cells)  island "lakes" (water inside connected water around island)  one cell square side length 1  grid rectangular  width height exceed 100  determine perimeter island  easy hash table 
java solution using hashmap with detailed explanation can i win "100 game " two players take turns adding  running total  integer 1  10  player first causes running total reach exceed 100 wins  change game players cannot re-use integers? medium dynamic programming minimax 
python solution  easy to understand can i win "100 game " two players take turns adding  running total  integer 1  10  player first causes running total reach exceed 100 wins  change game players cannot re-use integers? medium dynamic programming minimax 
7-liner c++ beat 98 4%  dfs with early termination check (detailed explanation) can i win "100 game " two players take turns adding  running total  integer 1  10  player first causes running total reach exceed 100 wins  change game players cannot re-use integers? medium dynamic programming minimax 
brute force and memoization can i win "100 game " two players take turns adding  running total  integer 1  10  player first causes running total reach exceed 100 wins  change game players cannot re-use integers? medium dynamic programming minimax 
java easy strightforward solution with explanation can i win "100 game " two players take turns adding  running total  integer 1  10  player first causes running total reach exceed 100 wins  change game players cannot re-use integers? medium dynamic programming minimax 
ugly java brute force solution  but accepted  1088ms  count the repetitions define = [s n] string consists n connected strings s  hard dynamic programming 
c++ solution inspired by @70664914 with organized explanation count the repetitions define = [s n] string consists n connected strings s  hard dynamic programming 
c++ 0ms o(str1 length str2 length) count the repetitions define = [s n] string consists n connected strings s  hard dynamic programming 
easy-understanding java solution with detailed explanation  21ms! count the repetitions define = [s n] string consists n connected strings s  hard dynamic programming 
very clean and short 7ms java solution based on @70664914 's idea count the repetitions define = [s n] string consists n connected strings s  hard dynamic programming 
concise java solution using dp unique substrings in wraparound string consider string infinite wraparound string "abcdefghijklmnopqrstuvwxyz"  look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  another string p  job find many unique non-empty substrings p present s  particular  input string p need output number different non-empty substrings p string s  note: p consists lowercase english letters size p might 10000  medium dynamic programming 
c++ concise solution unique substrings in wraparound string consider string infinite wraparound string "abcdefghijklmnopqrstuvwxyz"  look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  another string p  job find many unique non-empty substrings p present s  particular  input string p need output number different non-empty substrings p string s  note: p consists lowercase english letters size p might 10000  medium dynamic programming 
python concise solution unique substrings in wraparound string consider string infinite wraparound string "abcdefghijklmnopqrstuvwxyz"  look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  another string p  job find many unique non-empty substrings p present s  particular  input string p need output number different non-empty substrings p string s  note: p consists lowercase english letters size p might 10000  medium dynamic programming 
evolve from brute force to optimal unique substrings in wraparound string consider string infinite wraparound string "abcdefghijklmnopqrstuvwxyz"  look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  another string p  job find many unique non-empty substrings p present s  particular  input string p need output number different non-empty substrings p string s  note: p consists lowercase english letters size p might 10000  medium dynamic programming 
concise o(n) 6-liner in python unique substrings in wraparound string consider string infinite wraparound string "abcdefghijklmnopqrstuvwxyz"  look like this: "   zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd    "  another string p  job find many unique non-empty substrings p present s  particular  input string p need output number different non-empty substrings p string s  note: p consists lowercase english letters size p might 10000  medium dynamic programming 
java simple solution validate ip address write function check whether input string valid ipv4 address ipv6 address neither  ipv4 addresses canonically represented dot-decimal notation  consists four decimal numbers  ranging 0 255  separated dots (" ")  e g  172 16 254 1; besides  leading zeros ipv4 invalid  medium string 
python easy understand solution validate ip address write function check whether input string valid ipv4 address ipv6 address neither  ipv4 addresses canonically represented dot-decimal notation  consists four decimal numbers  ranging 0 255  separated dots (" ")  e g  172 16 254 1; besides  leading zeros ipv4 invalid  medium string 
c++ solution straightforward string processing validate ip address write function check whether input string valid ipv4 address ipv6 address neither  ipv4 addresses canonically represented dot-decimal notation  consists four decimal numbers  ranging 0 255  separated dots (" ")  e g  172 16 254 1; besides  leading zeros ipv4 invalid  medium string 
java simple solution with regexp validate ip address write function check whether input string valid ipv4 address ipv6 address neither  ipv4 addresses canonically represented dot-decimal notation  consists four decimal numbers  ranging 0 255  separated dots (" ")  e g  172 16 254 1; besides  leading zeros ipv4 invalid  medium string 
short regexp solution validate ip address write function check whether input string valid ipv4 address ipv6 address neither  ipv4 addresses canonically represented dot-decimal notation  consists four decimal numbers  ranging 0 255  separated dots (" ")  e g  172 16 254 1; besides  leading zeros ipv4 invalid  medium string 
java dp solution concatenated words given list words (without duplicates)  please write program returns concatenated words given list words  concatenated word defined string comprised entirely least two shorter words given array  hard dynamic programming depth-first search trie 
102ms java trie + dfs solution  with explanation  easy to understand  concatenated words given list words (without duplicates)  please write program returns concatenated words given list words  concatenated word defined string comprised entirely least two shorter words given array  hard dynamic programming depth-first search trie 
simple java trie + dfs solution 144ms concatenated words given list words (without duplicates)  please write program returns concatenated words given list words  concatenated word defined string comprised entirely least two shorter words given array  hard dynamic programming depth-first search trie 
c++ 772 ms dp solution concatenated words given list words (without duplicates)  please write program returns concatenated words given list words  concatenated word defined string comprised entirely least two shorter words given array  hard dynamic programming depth-first search trie 
20 line c++ 169 ms beats 100% & why i think this problem is not properly judged  concatenated words given list words (without duplicates)  please write program returns concatenated words given list words  concatenated word defined string comprised entirely least two shorter words given array  hard dynamic programming depth-first search trie 
java dfs solution with explanation matchsticks to square remember story little match girl? now  know exactly matchsticks little match girl has  please find way make one square using matchsticks  break stick  link up  matchstick must used exactly one time  input several matchsticks girl has  represented stick length  output either true false  represent whether could make one square using matchsticks little match girl has  medium depth-first search 
cpp 6ms solution with dfs matchsticks to square remember story little match girl? now  know exactly matchsticks little match girl has  please find way make one square using matchsticks  break stick  link up  matchstick must used exactly one time  input several matchsticks girl has  represented stick length  output either true false  represent whether could make one square using matchsticks little match girl has  medium depth-first search 
java dfs solution with various optimizations (sorting  sequential-partition  dp) matchsticks to square remember story little match girl? now  know exactly matchsticks little match girl has  please find way make one square using matchsticks  break stick  link up  matchstick must used exactly one time  input several matchsticks girl has  represented stick length  output either true false  represent whether could make one square using matchsticks little match girl has  medium depth-first search 
c++ bit masking + dp solution with detailed comments matchsticks to square remember story little match girl? now  know exactly matchsticks little match girl has  please find way make one square using matchsticks  break stick  link up  matchstick must used exactly one time  input several matchsticks girl has  represented stick length  output either true false  represent whether could make one square using matchsticks little match girl has  medium depth-first search 
python dfs solution matchsticks to square remember story little match girl? now  know exactly matchsticks little match girl has  please find way make one square using matchsticks  break stick  link up  matchstick must used exactly one time  input several matchsticks girl has  represented stick length  output either true false  represent whether could make one square using matchsticks little match girl has  medium depth-first search 
c++ dp solution with comments ones and zeroes computer world  use restricted resource generate maximum benefit always want pursue  now  suppose dominator 0s n 1s respectively  hand  array strings consisting 0s 1s  task find maximum number strings form given 0s n 1s  0 1 used once  note: given numbers 0s 1s exceed 100 size given string array exceed 600  medium dynamic programming 
0-1 knapsack detailed explanation  ones and zeroes computer world  use restricted resource generate maximum benefit always want pursue  now  suppose dominator 0s n 1s respectively  hand  array strings consisting 0s 1s  task find maximum number strings form given 0s n 1s  0 1 used once  note: given numbers 0s 1s exceed 100 size given string array exceed 600  medium dynamic programming 
have you graduated from primary school? ones and zeroes computer world  use restricted resource generate maximum benefit always want pursue  now  suppose dominator 0s n 1s respectively  hand  array strings consisting 0s 1s  task find maximum number strings form given 0s n 1s  0 1 used once  note: given numbers 0s 1s exceed 100 size given string array exceed 600  medium dynamic programming 
java iterative dp solution - o(mn) space ones and zeroes computer world  use restricted resource generate maximum benefit always want pursue  now  suppose dominator 0s n 1s respectively  hand  array strings consisting 0s 1s  task find maximum number strings form given 0s n 1s  0 1 used once  note: given numbers 0s 1s exceed 100 size given string array exceed 600  medium dynamic programming 
0-1 knapsack in python ones and zeroes computer world  use restricted resource generate maximum benefit always want pursue  now  suppose dominator 0s n 1s respectively  hand  array strings consisting 0s 1s  task find maximum number strings form given 0s n 1s  0 1 used once  note: given numbers 0s 1s exceed 100 size given string array exceed 600  medium dynamic programming 
short and clean java binary search solution heaters winter coming! first job contest design standard heater fixed warm radius warm houses  now  given positions houses heaters horizontal line  find minimum radius heaters houses could covered heaters  so  input positions houses heaters seperately  expected output minimum radius standard heaters  note: numbers houses heaters given non-negative exceed 25000  positions houses heaters given non-negative exceed 10^9  long house heaters' warm radius range  warmed  heaters follow radius standard warm radius same  easy binary search 
simple java solution with 2 pointers heaters winter coming! first job contest design standard heater fixed warm radius warm houses  now  given positions houses heaters horizontal line  find minimum radius heaters houses could covered heaters  so  input positions houses heaters seperately  expected output minimum radius standard heaters  note: numbers houses heaters given non-negative exceed 25000  positions houses heaters given non-negative exceed 10^9  long house heaters' warm radius range  warmed  heaters follow radius standard warm radius same  easy binary search 
short python heaters winter coming! first job contest design standard heater fixed warm radius warm houses  now  given positions houses heaters horizontal line  find minimum radius heaters houses could covered heaters  so  input positions houses heaters seperately  expected output minimum radius standard heaters  note: numbers houses heaters given non-negative exceed 25000  positions houses heaters given non-negative exceed 10^9  long house heaters' warm radius range  warmed  heaters follow radius standard warm radius same  easy binary search 
c++ clean solution with explanation heaters winter coming! first job contest design standard heater fixed warm radius warm houses  now  given positions houses heaters horizontal line  find minimum radius heaters houses could covered heaters  so  input positions houses heaters seperately  expected output minimum radius standard heaters  note: numbers houses heaters given non-negative exceed 25000  positions houses heaters given non-negative exceed 10^9  long house heaters' warm radius range  warmed  heaters follow radius standard warm radius same  easy binary search 
10 lines python with easy understanding heaters winter coming! first job contest design standard heater fixed warm radius warm houses  now  given positions houses heaters horizontal line  find minimum radius heaters houses could covered heaters  so  input positions houses heaters seperately  expected output minimum radius standard heaters  note: numbers houses heaters given non-negative exceed 25000  positions houses heaters given non-negative exceed 10^9  long house heaters' warm radius range  warmed  heaters follow radius standard warm radius same  easy binary search 
3 line c++ number complement given positive integer  output complement number  complement strategy flip bits binary representation  note: given integer guaranteed fit within range 32-bit signed integer  could assume leading zero bit integer’s binary representation  easy bit manipulation 
java 1 line bit manipulation solution number complement given positive integer  output complement number  complement strategy flip bits binary representation  note: given integer guaranteed fit within range 32-bit signed integer  could assume leading zero bit integer’s binary representation  easy bit manipulation 
java  very simple code and self-evident  explanation number complement given positive integer  output complement number  complement strategy flip bits binary representation  note: given integer guaranteed fit within range 32-bit signed integer  could assume leading zero bit integer’s binary representation  easy bit manipulation 
simple python number complement given positive integer  output complement number  complement strategy flip bits binary representation  note: given integer guaranteed fit within range 32-bit signed integer  could assume leading zero bit integer’s binary representation  easy bit manipulation 
maybe fewest operations number complement given positive integer  output complement number  complement strategy flip bits binary representation  note: given integer guaranteed fit within range 32-bit signed integer  could assume leading zero bit integer’s binary representation  easy bit manipulation 
java o(n) time o(1) space total hamming distance hamming distance two integers number positions corresponding bits different  job find total hamming distance pairs given numbers  medium bit manipulation 
share my o(n) c++ bitwise solution with thinking process and explanation total hamming distance hamming distance two integers number positions corresponding bits different  job find total hamming distance pairs given numbers  medium bit manipulation 
python via strings total hamming distance hamming distance two integers number positions corresponding bits different  job find total hamming distance pairs given numbers  medium bit manipulation 
java solution with explanation total hamming distance hamming distance two integers number positions corresponding bits different  job find total hamming distance pairs given numbers  medium bit manipulation 
python explanation total hamming distance hamming distance two integers number positions corresponding bits different  job find total hamming distance pairs given numbers  medium bit manipulation 
polar coordinates 10 lines generate random point in a circle given radius x-y positions center circle  write function randpoint generates uniform random point circle  note: input output values floating-point  radius x-y position center circle passed class constructor  point circumference circle considered circle  randpoint returns size 2 array containing x-position y-position random point  order  medium math random rejection sampling 
how is the solution verified? generate random point in a circle given radius x-y positions center circle  write function randpoint generates uniform random point circle  note: input output values floating-point  radius x-y position center circle passed class constructor  point circumference circle considered circle  randpoint returns size 2 array containing x-position y-position random point  order  medium math random rejection sampling 
explanation with graphs why using math sqrt() generate random point in a circle given radius x-y positions center circle  write function randpoint generates uniform random point circle  note: input output values floating-point  radius x-y position center circle passed class constructor  point circumference circle considered circle  randpoint returns size 2 array containing x-position y-position random point  order  medium math random rejection sampling 
very simple python solution generate random point in a circle given radius x-y positions center circle  write function randpoint generates uniform random point circle  note: input output values floating-point  radius x-y position center circle passed class constructor  point circumference circle considered circle  randpoint returns size 2 array containing x-position y-position random point  order  medium math random rejection sampling 
python solution without using rejection sampling generate random point in a circle given radius x-y positions center circle  write function randpoint generates uniform random point circle  note: input output values floating-point  radius x-y position center circle passed class constructor  point circumference circle considered circle  randpoint returns size 2 array containing x-position y-position random point  order  medium math random rejection sampling 
i don't feel like this is a easy question largest palindrome product find largest palindrome made product two n-digit numbers  since result could large  return largest palindrome mod 1337  easy 
java solution using assumed max palindrom largest palindrome product find largest palindrome made product two n-digit numbers  since result could large  return largest palindrome mod 1337  easy 
java solutions with two different approaches largest palindrome product find largest palindrome made product two n-digit numbers  since result could large  return largest palindrome mod 1337  easy 
trickiness depending on language you use largest palindrome product find largest palindrome made product two n-digit numbers  since result could large  return largest palindrome mod 1337  easy 
java solution with explanation largest palindrome product find largest palindrome made product two n-digit numbers  since result could large  return largest palindrome mod 1337  easy 
o(n log k) c++ using multiset and updating middle-iterator sliding window median median middle value ordered integer list  size list even  middle value  median mean two middle value  hard 
java solution using two priorityqueues sliding window median median middle value ordered integer list  size list even  middle value  median mean two middle value  hard 
easy to understand o(nlogk) java solution using treemap sliding window median median middle value ordered integer list  size list even  middle value  median mean two middle value  hard 
java using two tree sets - o(n logk) sliding window median median middle value ordered integer list  size list even  middle value  median mean two middle value  hard 
easy python o(nk) sliding window median median middle value ordered integer list  size list even  middle value  median mean two middle value  hard 
simple java solution using one array and two pointers magical string magical string consists '1' '2' obeys following rules: string magical concatenating number contiguous occurrences characters '1' '2' generates string itself  first elements string following: = "1221121221221121122……" group consecutive '1's '2's s  be: 1 22 11 2 1 22 1 22 11 2 11 22        occurrences '1's '2's group are: 1 2 2 1 1 2 1 2 2 1 2 2        see occurrence sequence itself  given integer n input  return number '1's first n number magical string s  note: n exceed 100 000  medium 
short c++ magical string magical string consists '1' '2' obeys following rules: string magical concatenating number contiguous occurrences characters '1' '2' generates string itself  first elements string following: = "1221121221221121122……" group consecutive '1's '2's s  be: 1 22 11 2 1 22 1 22 11 2 11 22        occurrences '1's '2's group are: 1 2 2 1 1 2 1 2 2 1 2 2        see occurrence sequence itself  given integer n input  return number '1's first n number magical string s  note: n exceed 100 000  medium 
is the magical string unique? magical string magical string consists '1' '2' obeys following rules: string magical concatenating number contiguous occurrences characters '1' '2' generates string itself  first elements string following: = "1221121221221121122……" group consecutive '1's '2's s  be: 1 22 11 2 1 22 1 22 11 2 11 22        occurrences '1's '2's group are: 1 2 2 1 1 2 1 2 2 1 2 2        see occurrence sequence itself  given integer n input  return number '1's first n number magical string s  note: n exceed 100 000  medium 
o(log n) space using recursive generators magical string magical string consists '1' '2' obeys following rules: string magical concatenating number contiguous occurrences characters '1' '2' generates string itself  first elements string following: = "1221121221221121122……" group consecutive '1's '2's s  be: 1 22 11 2 1 22 1 22 11 2 11 22        occurrences '1's '2's group are: 1 2 2 1 1 2 1 2 2 1 2 2        see occurrence sequence itself  given integer n input  return number '1's first n number magical string s  note: n exceed 100 000  medium 
very straightforward and simple java solution o(n) magical string magical string consists '1' '2' obeys following rules: string magical concatenating number contiguous occurrences characters '1' '2' generates string itself  first elements string following: = "1221121221221121122……" group consecutive '1's '2's s  be: 1 22 11 2 1 22 1 22 11 2 11 22        occurrences '1's '2's group are: 1 2 2 1 1 2 1 2 2 1 2 2        see occurrence sequence itself  given integer n input  return number '1's first n number magical string s  note: n exceed 100 000  medium 
java 5 lines clean solution license key formatting given license key represented string consists alphanumeric character dashes  string separated n+1 groups n dashes  given number k  would want reformat strings group contains exactly k characters  except first group could shorter k  still must contain least one character  furthermore  must dash inserted two groups lowercase letters converted uppercase  given non-empty string number k  format string according rules described above  easy 
python solution license key formatting given license key represented string consists alphanumeric character dashes  string separated n+1 groups n dashes  given number k  would want reformat strings group contains exactly k characters  except first group could shorter k  still must contain least one character  furthermore  must dash inserted two groups lowercase letters converted uppercase  given non-empty string number k  format string according rules described above  easy 
easy to understand using stringbuilder license key formatting given license key represented string consists alphanumeric character dashes  string separated n+1 groups n dashes  given number k  would want reformat strings group contains exactly k characters  except first group could shorter k  still must contain least one character  furthermore  must dash inserted two groups lowercase letters converted uppercase  given non-empty string number k  format string according rules described above  easy 
4-line c++ concise solution to scan string backward license key formatting given license key represented string consists alphanumeric character dashes  string separated n+1 groups n dashes  given number k  would want reformat strings group contains exactly k characters  except first group could shorter k  still must contain least one character  furthermore  must dash inserted two groups lowercase letters converted uppercase  given non-empty string number k  format string according rules described above  easy 
beats 100% python3 submission license key formatting given license key represented string consists alphanumeric character dashes  string separated n+1 groups n dashes  given number k  would want reformat strings group contains exactly k characters  except first group could shorter k  still must contain least one character  furthermore  must dash inserted two groups lowercase letters converted uppercase  given non-empty string number k  format string according rules described above  easy 
python solution with detailed mathematical explanation and derivation smallest good base integer n  call k>=2 good base n  digits n base k 1  given string representing n  return smallest good base n string format  hard math binary search 
3ms  ac  c++  long long int + binary search smallest good base integer n  call k>=2 good base n  digits n base k 1  given string representing n  return smallest good base n string format  hard math binary search 
java solution with hand-writing explain smallest good base integer n  call k>=2 good base n  digits n base k 1  given string representing n  return smallest good base n string format  hard math binary search 
java o((logn)^2) binary search solution smallest good base integer n  call k>=2 good base n  digits n base k 1  given string representing n  return smallest good base n string format  hard math binary search 
short python o(log(n)) smallest good base integer n  call k>=2 good base n  digits n base k 1  given string representing n  return smallest good base n string format  hard math binary search 
java 4 lines concise solution with explanation max consecutive ones given binary array  find maximum number consecutive 1s array  easy array 
easy java solution max consecutive ones given binary array  find maximum number consecutive 1s array  easy array 
simple c solution with easy explanation max consecutive ones given binary array  find maximum number consecutive 1s array  easy array 
simple python max consecutive ones given binary array  find maximum number consecutive 1s array  easy array 
simple c++ code max consecutive ones given binary array  find maximum number consecutive 1s array  easy array 
java 9 lines dp solution  easy to understand with improvement to o(n) space complexity  predict the winner given array scores non-negative integers  player 1 picks one numbers either end array followed player 2 player 1 on  time player picks number  number available next player  continues scores chosen  player maximum score wins  given array scores  predict whether player 1 winner  assume player plays maximize score  medium dynamic programming minimax 
java '1 line' recursive solution o(n^2) time and o(n) space predict the winner given array scores non-negative integers  player 1 picks one numbers either end array followed player 2 player 1 on  time player picks number  number available next player  continues scores chosen  player maximum score wins  given array scores  predict whether player 1 winner  assume player plays maximize score  medium dynamic programming minimax 
dp o(n^2)  + mit ocw solution explanation predict the winner given array scores non-negative integers  player 1 picks one numbers either end array followed player 2 player 1 on  time player picks number  number available next player  continues scores chosen  player maximum score wins  given array scores  predict whether player 1 winner  assume player plays maximize score  medium dynamic programming minimax 
c++ dp solution with explanation predict the winner given array scores non-negative integers  player 1 picks one numbers either end array followed player 2 player 1 on  time player picks number  number available next player  continues scores chosen  player maximum score wins  given array scores  predict whether player 1 winner  assume player plays maximize score  medium dynamic programming minimax 
java dp solution with explanation predict the winner given array scores non-negative integers  player 1 picks one numbers either end array followed player 2 player 1 on  time player picks number  number available next player  continues scores chosen  player maximum score wins  given array scores  predict whether player 1 winner  assume player plays maximize score  medium dynamic programming minimax 
standard test program is wrong? zuma game think zuma game  row balls table  colored red(r)  yellow(y)  blue(b)  green(g)  white(w)  also several balls hand  time  may choose ball hand  insert row (including leftmost place rightmost place)  then  group 3 balls color touching  remove balls  keep balls removed  find minimal balls insert remove balls table  cannot remove balls  output -1  hard depth-first search 
"short" java solution  beats 98% zuma game think zuma game  row balls table  colored red(r)  yellow(y)  blue(b)  green(g)  white(w)  also several balls hand  time  may choose ball hand  insert row (including leftmost place rightmost place)  then  group 3 balls color touching  remove balls  keep balls removed  find minimal balls insert remove balls table  cannot remove balls  output -1  hard depth-first search 
straightforward recursive java solution beat 97% zuma game think zuma game  row balls table  colored red(r)  yellow(y)  blue(b)  green(g)  white(w)  also several balls hand  time  may choose ball hand  insert row (including leftmost place rightmost place)  then  group 3 balls color touching  remove balls  keep balls removed  find minimal balls insert remove balls table  cannot remove balls  output -1  hard depth-first search 
concise 3ms c++ solution zuma game think zuma game  row balls table  colored red(r)  yellow(y)  blue(b)  green(g)  white(w)  also several balls hand  time  may choose ball hand  insert row (including leftmost place rightmost place)  then  group 3 balls color touching  remove balls  keep balls removed  find minimal balls insert remove balls table  cannot remove balls  output -1  hard depth-first search 
recursive java solution zuma game think zuma game  row balls table  colored red(r)  yellow(y)  blue(b)  green(g)  white(w)  also several balls hand  time  may choose ball hand  insert row (including leftmost place rightmost place)  then  group 3 balls color touching  remove balls  keep balls removed  find minimal balls insert remove balls table  cannot remove balls  output -1  hard depth-first search 
java solution beats 100% increasing subsequences given integer array  task find different possible increasing subsequences given array  length increasing subsequence least 2   medium depth-first search 
java 20 lines backtracking solution using set  beats 100%  increasing subsequences given integer array  task find different possible increasing subsequences given array  length increasing subsequence least 2   medium depth-first search 
simple python increasing subsequences given integer array  task find different possible increasing subsequences given array  length increasing subsequence least 2   medium depth-first search 
c++ dfs solution using unordered_set increasing subsequences given integer array  task find different possible increasing subsequences given array  length increasing subsequence least 2   medium depth-first search 
clean 20ms solution increasing subsequences given integer array  task find different possible increasing subsequences given array  length increasing subsequence least 2   medium depth-first search 
3 line clean and easy understand solution construct the rectangle web developer  important know design web page's size  so  given specific rectangular web page’s area  job design rectangular web page  whose length l width w satisfy following requirements:1  area rectangular web page designed must equal given target area  2  width w larger length l  means l >= w  3  difference length l width w small possible  need output length l width w web page designed sequence  easy 
simple java solution  beats 100% construct the rectangle web developer  important know design web page's size  so  given specific rectangular web page’s area  job design rectangular web page  whose length l width w satisfy following requirements:1  area rectangular web page designed must equal given target area  2  width w larger length l  means l >= w  3  difference length l width w small possible  need output length l width w web page designed sequence  easy 
simple python construct the rectangle web developer  important know design web page's size  so  given specific rectangular web page’s area  job design rectangular web page  whose length l width w satisfy following requirements:1  area rectangular web page designed must equal given target area  2  width w larger length l  means l >= w  3  difference length l width w small possible  need output length l width w web page designed sequence  easy 
3 line c++ clean solution with explanation construct the rectangle web developer  important know design web page's size  so  given specific rectangular web page’s area  job design rectangular web page  whose length l width w satisfy following requirements:1  area rectangular web page designed must equal given target area  2  width w larger length l  means l >= w  3  difference length l width w small possible  need output length l width w web page designed sequence  easy 
python solution (linear time  constant space) with explanation construct the rectangle web developer  important know design web page's size  so  given specific rectangular web page’s area  job design rectangular web page  whose length l width w satisfy following requirements:1  area rectangular web page designed must equal given target area  2  width w larger length l  means l >= w  3  difference length l width w small possible  need output length l width w web page designed sequence  easy 
general principles behind problems similar to "reverse pairs" reverse pairs given array nums  call (i  j) important reverse pair < j nums[i] > 2 nums[j]  need return number important reverse pairs given array  hard divide and conquer binary indexed tree segment tree binary search tree 
very short and clear mergesort & bst java solutions reverse pairs given array nums  call (i  j) important reverse pair < j nums[i] > 2 nums[j]  need return number important reverse pairs given array  hard divide and conquer binary indexed tree segment tree binary search tree 
c++ with iterators reverse pairs given array nums  call (i  j) important reverse pair < j nums[i] > 2 nums[j]  need return number important reverse pairs given array  hard divide and conquer binary indexed tree segment tree binary search tree 
clean java solution using enhanced binary search tree reverse pairs given array nums  call (i  j) important reverse pair < j nums[i] > 2 nums[j]  need return number important reverse pairs given array  hard divide and conquer binary indexed tree segment tree binary search tree 
java merge sort solution  o(nlog(n)) reverse pairs given array nums  call (i  j) important reverse pair < j nums[i] > 2 nums[j]  need return number important reverse pairs given array  hard divide and conquer binary indexed tree segment tree binary search tree 
java (15 ms) c++ (3 ms) o(ns) iterative dp solution using subset sum with explanation target sum given list non-negative integers  a1  a2       an  target  s  2 symbols + -  integer  choose one + - new symbol  find many ways assign symbols make sum integers equal target s  medium dynamic programming depth-first search 
short java dp solution with explanation target sum given list non-negative integers  a1  a2       an  target  s  2 symbols + -  integer  choose one + - new symbol  find many ways assign symbols make sum integers equal target s  medium dynamic programming depth-first search 
java simple dfs with memorization target sum given list non-negative integers  a1  a2       an  target  s  2 symbols + -  integer  choose one + - new symbol  find many ways assign symbols make sum integers equal target s  medium dynamic programming depth-first search 
python dp target sum given list non-negative integers  a1  a2       an  target  s  2 symbols + -  integer  choose one + - new symbol  find many ways assign symbols make sum integers equal target s  medium dynamic programming depth-first search 
java short dfs solution target sum given list non-negative integers  a1  a2       an  target  s  2 symbols + -  integer  choose one + - new symbol  find many ways assign symbols make sum integers equal target s  medium dynamic programming depth-first search 
java 10 lines linear time complexity o(n) with explanation next greater element i given two arrays (without duplicates) nums1 nums2 nums1’s elements subset nums2  find next greater numbers nums1's elements corresponding places nums2  next greater number number x nums1 first greater number right nums2  exist  output -1 number  easy stack 
c++ stack + unordered_map next greater element i given two arrays (without duplicates) nums1 nums2 nums1’s elements subset nums2  find next greater numbers nums1's elements corresponding places nums2  next greater number number x nums1 first greater number right nums2  exist  output -1 number  easy stack 
python solution with o(n) next greater element i given two arrays (without duplicates) nums1 nums2 nums1’s elements subset nums2  find next greater numbers nums1's elements corresponding places nums2  next greater number number x nums1 first greater number right nums2  exist  output -1 number  easy stack 
meh  1000 is small next greater element i given two arrays (without duplicates) nums1 nums2 nums1’s elements subset nums2  find next greater numbers nums1's elements corresponding places nums2  next greater number number x nums1 first greater number right nums2  exist  output -1 number  easy stack 
whys is it -1 for findnums[2] = 2 instead of 4  next greater element i given two arrays (without duplicates) nums1 nums2 nums1’s elements subset nums2  find next greater numbers nums1's elements corresponding places nums2  next greater number number x nums1 first greater number right nums2  exist  output -1 number  easy stack 
java randomly pick a rectangle then pick a point inside random point in non-overlapping rectangles given list non-overlapping axis-aligned rectangles rects  write function pick randomly uniformily picks integer point space covered rectangles  note: integer point point integer coordinates  point perimeter rectangle included space covered rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  [x1  y1] integer coordinates bottom-left corner  [x2  y2] integer coordinates top-right corner  length width rectangle exceed 2000  1 <= rects length <= 100 pick return point array integer coordinates [p_x  p_y] pick called 10000 times  medium binary search random 
python weighted probability solution random point in non-overlapping rectangles given list non-overlapping axis-aligned rectangles rects  write function pick randomly uniformily picks integer point space covered rectangles  note: integer point point integer coordinates  point perimeter rectangle included space covered rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  [x1  y1] integer coordinates bottom-left corner  [x2  y2] integer coordinates top-right corner  length width rectangle exceed 2000  1 <= rects length <= 100 pick return point array integer coordinates [p_x  p_y] pick called 10000 times  medium binary search random 
java treemap solution only one random per pick random point in non-overlapping rectangles given list non-overlapping axis-aligned rectangles rects  write function pick randomly uniformily picks integer point space covered rectangles  note: integer point point integer coordinates  point perimeter rectangle included space covered rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  [x1  y1] integer coordinates bottom-left corner  [x2  y2] integer coordinates top-right corner  length width rectangle exceed 2000  1 <= rects length <= 100 pick return point array integer coordinates [p_x  p_y] pick called 10000 times  medium binary search random 
c++ solution using reservoir sampling with explanation - concise and easy to understand random point in non-overlapping rectangles given list non-overlapping axis-aligned rectangles rects  write function pick randomly uniformily picks integer point space covered rectangles  note: integer point point integer coordinates  point perimeter rectangle included space covered rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  [x1  y1] integer coordinates bottom-left corner  [x2  y2] integer coordinates top-right corner  length width rectangle exceed 2000  1 <= rects length <= 100 pick return point array integer coordinates [p_x  p_y] pick called 10000 times  medium binary search random 
is [1 0 3 0] a valid rectangle? random point in non-overlapping rectangles given list non-overlapping axis-aligned rectangles rects  write function pick randomly uniformily picks integer point space covered rectangles  note: integer point point integer coordinates  point perimeter rectangle included space covered rectangles  ith rectangle = rects[i] = [x1 y1 x2 y2]  [x1  y1] integer coordinates bottom-left corner  [x2  y2] integer coordinates top-right corner  length width rectangle exceed 2000  1 <= rects length <= 100 pick return point array integer coordinates [p_x  p_y] pick called 10000 times  medium binary search random 
java 15 lines without using boolean diagonal traverse given matrix x n elements (m rows  n columns)  return elements matrix diagonal order shown image  medium 
concise java solution diagonal traverse given matrix x n elements (m rows  n columns)  return elements matrix diagonal order shown image  medium 
simply python solution diagonal traverse given matrix x n elements (m rows  n columns)  return elements matrix diagonal order shown image  medium 
c++ without paying too much attention on direction switch diagonal traverse given matrix x n elements (m rows  n columns)  return elements matrix diagonal order shown image  medium 
sorting and normal python diagonal traverse given matrix x n elements (m rows  n columns)  return elements matrix diagonal order shown image  medium 
java 1-line solution via regex and stream keyboard row given list words  return words typed using letters alphabet one row's american keyboard like image below  easy hash table 
easy understand solution in 7 lines for everyone keyboard row given list words  return words typed using letters alphabet one row's american keyboard like image below  easy hash table 
short easy java with explanation keyboard row given list words  return words typed using letters alphabet one row's american keyboard like image below  easy hash table 
one-liner ruby + python keyboard row given list words  return words typed using letters alphabet one row's american keyboard like image below  easy hash table 
solution in python using set keyboard row given list words  return words typed using letters alphabet one row's american keyboard like image below  easy hash table 
proper o(1) space find mode in binary search tree given binary search tree (bst) duplicates  find mode(s) (the frequently occurred element) given bst  assume bst defined follows: left subtree node contains nodes keys less equal node's key  right subtree node contains nodes keys greater equal node's key  left right subtrees must also binary search trees  easy tree 
java 4ms beats 100% extra o(1) solution - no map find mode in binary search tree given binary search tree (bst) duplicates  find mode(s) (the frequently occurred element) given bst  assume bst defined follows: left subtree node contains nodes keys less equal node's key  right subtree node contains nodes keys greater equal node's key  left right subtrees must also binary search trees  easy tree 
11-liner c++ o(n) time o(1) extra space in-order traversal (detailed explanation) find mode in binary search tree given binary search tree (bst) duplicates  find mode(s) (the frequently occurred element) given bst  assume bst defined follows: left subtree node contains nodes keys less equal node's key  right subtree node contains nodes keys greater equal node's key  left right subtrees must also binary search trees  easy tree 
what does "mode" mean? find mode in binary search tree given binary search tree (bst) duplicates  find mode(s) (the frequently occurred element) given bst  assume bst defined follows: left subtree node contains nodes keys less equal node's key  right subtree node contains nodes keys greater equal node's key  left right subtrees must also binary search trees  easy tree 
java ac solution find mode in binary search tree given binary search tree (bst) duplicates  find mode(s) (the frequently occurred element) given bst  assume bst defined follows: left subtree node contains nodes keys less equal node's key  right subtree node contains nodes keys greater equal node's key  left right subtrees must also binary search trees  easy tree 
very simple (greedy) java solution using two priorityqueues ipo suppose leetcode start ipo soon  order sell good price shares venture capital  leetcode would like work projects increase capital ipo  since limited resources  finish k distinct projects ipo  help leetcode design best way maximize total capital finishing k distinct projects  given several projects  project i  pure profit pi minimum capital ci needed start corresponding project  initially  w capital  finish project  obtain pure profit profit added total capital  sum up  pick list k distinct projects given projects maximize final capital  output final maximized capital  hard heap greedy 
python solution by priority queue with explanation ipo suppose leetcode start ipo soon  order sell good price shares venture capital  leetcode would like work projects increase capital ipo  since limited resources  finish k distinct projects ipo  help leetcode design best way maximize total capital finishing k distinct projects  given several projects  project i  pure profit pi minimum capital ci needed start corresponding project  initially  w capital  finish project  obtain pure profit profit added total capital  sum up  pick list k distinct projects given projects maximize final capital  output final maximized capital  hard heap greedy 
8-liner c++ 42ms beat 98% greedy algorithm (detailed explanation) ipo suppose leetcode start ipo soon  order sell good price shares venture capital  leetcode would like work projects increase capital ipo  since limited resources  finish k distinct projects ipo  help leetcode design best way maximize total capital finishing k distinct projects  given several projects  project i  pure profit pi minimum capital ci needed start corresponding project  initially  w capital  finish project  obtain pure profit profit added total capital  sum up  pick list k distinct projects given projects maximize final capital  output final maximized capital  hard heap greedy 
python solution ipo suppose leetcode start ipo soon  order sell good price shares venture capital  leetcode would like work projects increase capital ipo  since limited resources  finish k distinct projects ipo  help leetcode design best way maximize total capital finishing k distinct projects  given several projects  project i  pure profit pi minimum capital ci needed start corresponding project  initially  w capital  finish project  obtain pure profit profit added total capital  sum up  pick list k distinct projects given projects maximize final capital  output final maximized capital  hard heap greedy 
why does greedy solution work for this; why not dynamic programming ? ipo suppose leetcode start ipo soon  order sell good price shares venture capital  leetcode would like work projects increase capital ipo  since limited resources  finish k distinct projects ipo  help leetcode design best way maximize total capital finishing k distinct projects  given several projects  project i  pure profit pi minimum capital ci needed start corresponding project  initially  w capital  finish project  obtain pure profit profit added total capital  sum up  pick list k distinct projects given projects maximize final capital  output final maximized capital  hard heap greedy 
java 10 lines and c++ 12 lines linear time complexity o(n) with explanation next greater element ii given circular array (the next element last element first element array)  print next greater number every element  next greater number number x first greater number traversing-order next array  means could search circularly find next greater number  exist  output -1 number  medium stack 
typical ways to solve circular array problems  java solution  next greater element ii given circular array (the next element last element first element array)  print next greater number every element  next greater number number x first greater number traversing-order next array  means could search circularly find next greater number  exist  output -1 number  medium stack 
python 6 lines solution using stack next greater element ii given circular array (the next element last element first element array)  print next greater number every element  next greater number number x first greater number traversing-order next array  means could search circularly find next greater number  exist  output -1 number  medium stack 
no stack: o(n) time complexity and o(1) space complexity using dp next greater element ii given circular array (the next element last element first element array)  print next greater number every element  next greater number number x first greater number traversing-order next array  means could search circularly find next greater number  exist  output -1 number  medium stack 
python solution with detailed explanation next greater element ii given circular array (the next element last element first element array)  print next greater number every element  next greater number number x first greater number traversing-order next array  means could search circularly find next greater number  exist  output -1 number  medium stack 
simple java  oneliner ruby base 7 given integer  return base 7 string representation  easy 
python easy understand solution base 7 given integer  return base 7 string representation  easy 
3-liner c++ to build string backward + 1-liner recursive solutions base 7 given integer  return base 7 string representation  easy 
verbose java solution base 7 given integer  return base 7 string representation  easy 
3ms c++ 3 lines solution base 7 given integer  return base 7 string representation  easy 
easy java solution  sorting  relative ranks given scores n athletes  find relative ranks people top three highest scores  awarded medals: "gold medal"  "silver medal" "bronze medal"  easy 
python solution relative ranks given scores n athletes  find relative ranks people top three highest scores  awarded medals: "gold medal"  "silver medal" "bronze medal"  easy 
simple sorting o(n log n) solution relative ranks given scores n athletes  find relative ranks people top three highest scores  awarded medals: "gold medal"  "silver medal" "bronze medal"  easy 
c++ easy to understand relative ranks given scores n athletes  find relative ranks people top three highest scores  awarded medals: "gold medal"  "silver medal" "bronze medal"  easy 
java 6ms solution o(n) without sorting relative ranks given scores n athletes  find relative ranks people top three highest scores  awarded medals: "gold medal"  "silver medal" "bronze medal"  easy 
verbose java solution  postorder traverse  hashmap (18ms) most frequent subtree sum given root tree  asked find frequent subtree sum  subtree sum node defined sum node values formed subtree rooted node (including node itself)  frequent subtree sum value? tie  return values highest frequency order  medium hash table tree 
python easy understand solution most frequent subtree sum given root tree  asked find frequent subtree sum  subtree sum node defined sum node values formed subtree rooted node (including node itself)  frequent subtree sum value? tie  return values highest frequency order  medium hash table tree 
short clean c++ o(n)  solution most frequent subtree sum given root tree  asked find frequent subtree sum  subtree sum node defined sum node values formed subtree rooted node (including node itself)  frequent subtree sum value? tie  return values highest frequency order  medium hash table tree 
java divide and conquer most frequent subtree sum given root tree  asked find frequent subtree sum  subtree sum node defined sum node values formed subtree rooted node (including node itself)  frequent subtree sum value? tie  return values highest frequency order  medium hash table tree 
short easy java most frequent subtree sum given root tree  asked find frequent subtree sum  subtree sum node defined sum node values formed subtree rooted node (including node itself)  frequent subtree sum value? tie  return values highest frequency order  medium hash table tree 
right-to-left bfs (python + java) find bottom left tree value given binary tree  find leftmost value last row tree  medium tree depth-first search breadth-first search 
simple java solution  beats 100 0%! find bottom left tree value given binary tree  find leftmost value last row tree  medium tree depth-first search breadth-first search 
verbose java solution  binary tree level order traversal find bottom left tree value given binary tree  find leftmost value last row tree  medium tree depth-first search breadth-first search 
c++ recursive solution (beats 100%) with basic explanation find bottom left tree value given binary tree  find leftmost value last row tree  medium tree depth-first search breadth-first search 
my bfs solution for python find bottom left tree value given binary tree  find leftmost value last row tree  medium tree depth-first search breadth-first search 
concise java dp solution freedom trail video game fallout 4  quest "road freedom" requires players reach metal dial called "freedom trail ring"  use dial spell specific keyword order open door  given string ring  represents code engraved outer ring another string key  represents keyword needs spelled  need find minimum number steps order spell characters keyword  initially  first character ring aligned 12:00 direction  need spell characters string key one one rotating ring clockwise anticlockwise make character string key aligned 12:00 direction pressing center button  stage rotating ring spell key character key[i]: rotate ring clockwise anticlockwise one place  counts 1 step  final purpose rotation align one string ring's characters 12:00 direction  character must equal character key[i]  character key[i] aligned 12:00 direction  need press center button spell  also counts 1 step  pressing  could begin spell next character key (next stage)  otherwise  finished spelling  hard divide and conquer dynamic programming depth-first search 
evolve from brute force to dp freedom trail video game fallout 4  quest "road freedom" requires players reach metal dial called "freedom trail ring"  use dial spell specific keyword order open door  given string ring  represents code engraved outer ring another string key  represents keyword needs spelled  need find minimum number steps order spell characters keyword  initially  first character ring aligned 12:00 direction  need spell characters string key one one rotating ring clockwise anticlockwise make character string key aligned 12:00 direction pressing center button  stage rotating ring spell key character key[i]: rotate ring clockwise anticlockwise one place  counts 1 step  final purpose rotation align one string ring's characters 12:00 direction  character must equal character key[i]  character key[i] aligned 12:00 direction  need press center button spell  also counts 1 step  pressing  could begin spell next character key (next stage)  otherwise  finished spelling  hard divide and conquer dynamic programming depth-first search 
shared my c++ dp solution  19ms freedom trail video game fallout 4  quest "road freedom" requires players reach metal dial called "freedom trail ring"  use dial spell specific keyword order open door  given string ring  represents code engraved outer ring another string key  represents keyword needs spelled  need find minimum number steps order spell characters keyword  initially  first character ring aligned 12:00 direction  need spell characters string key one one rotating ring clockwise anticlockwise make character string key aligned 12:00 direction pressing center button  stage rotating ring spell key character key[i]: rotate ring clockwise anticlockwise one place  counts 1 step  final purpose rotation align one string ring's characters 12:00 direction  character must equal character key[i]  character key[i] aligned 12:00 direction  need press center button spell  also counts 1 step  pressing  could begin spell next character key (next stage)  otherwise  finished spelling  hard divide and conquer dynamic programming depth-first search 
java clear solution  dfs+memoization freedom trail video game fallout 4  quest "road freedom" requires players reach metal dial called "freedom trail ring"  use dial spell specific keyword order open door  given string ring  represents code engraved outer ring another string key  represents keyword needs spelled  need find minimum number steps order spell characters keyword  initially  first character ring aligned 12:00 direction  need spell characters string key one one rotating ring clockwise anticlockwise make character string key aligned 12:00 direction pressing center button  stage rotating ring spell key character key[i]: rotate ring clockwise anticlockwise one place  counts 1 step  final purpose rotation align one string ring's characters 12:00 direction  character must equal character key[i]  character key[i] aligned 12:00 direction  need press center button spell  also counts 1 step  pressing  could begin spell next character key (next stage)  otherwise  finished spelling  hard divide and conquer dynamic programming depth-first search 
super clear dfs + memorization solution freedom trail video game fallout 4  quest "road freedom" requires players reach metal dial called "freedom trail ring"  use dial spell specific keyword order open door  given string ring  represents code engraved outer ring another string key  represents keyword needs spelled  need find minimum number steps order spell characters keyword  initially  first character ring aligned 12:00 direction  need spell characters string key one one rotating ring clockwise anticlockwise make character string key aligned 12:00 direction pressing center button  stage rotating ring spell key character key[i]: rotate ring clockwise anticlockwise one place  counts 1 step  final purpose rotation align one string ring's characters 12:00 direction  character must equal character key[i]  character key[i] aligned 12:00 direction  need press center button spell  also counts 1 step  pressing  could begin spell next character key (next stage)  otherwise  finished spelling  hard divide and conquer dynamic programming depth-first search 
9ms java dfs solution find largest value in each tree row need find largest value row binary tree  medium tree depth-first search breadth-first search 
python bfs find largest value in each tree row need find largest value row binary tree  medium tree depth-first search breadth-first search 
java bfs find largest value in each tree row need find largest value row binary tree  medium tree depth-first search breadth-first search 
1-liner python  divide and conquer find largest value in each tree row need find largest value row binary tree  medium tree depth-first search breadth-first search 
c++ a different approach (12ms beats 100%) find largest value in each tree row need find largest value row binary tree  medium tree depth-first search breadth-first search 
straight forward java dp solution longest palindromic subsequence given string s  find longest palindromic subsequence's length s  may assume maximum length 1000  medium dynamic programming 
evolve from brute force to dp longest palindromic subsequence given string s  find longest palindromic subsequence's length s  may assume maximum length 1000  medium dynamic programming 
what is the meaning of example 1? longest palindromic subsequence given string s  find longest palindromic subsequence's length s  may assume maximum length 1000  medium dynamic programming 
python dp o(n) space o(n^2) time longest palindromic subsequence given string s  find longest palindromic subsequence's length s  may assume maximum length 1000  medium dynamic programming 
fast and concise python solution that actually gets ac longest palindromic subsequence given string s  find longest palindromic subsequence's length s  may assume maximum length 1000  medium dynamic programming 
super short & easy java o(n) solution super washing machines n super washing machines line  initially  washing machine dresses empty  move  could choose (1 ≤ ≤ n) washing machines  pass one dress washing machine one adjacent washing machines time   given integer array representing number dresses washing machine left right line  find minimum number moves make washing machines number dresses  possible it  return -1  hard math dynamic programming 
c++ 16ms o(n) solution (with trivial proof) super washing machines n super washing machines line  initially  washing machine dresses empty  move  could choose (1 ≤ ≤ n) washing machines  pass one dress washing machine one adjacent washing machines time   given integer array representing number dresses washing machine left right line  find minimum number moves make washing machines number dresses  possible it  return -1  hard math dynamic programming 
very intuitive o(n) solution super washing machines n super washing machines line  initially  washing machine dresses empty  move  could choose (1 ≤ ≤ n) washing machines  pass one dress washing machine one adjacent washing machines time   given integer array representing number dresses washing machine left right line  find minimum number moves make washing machines number dresses  possible it  return -1  hard math dynamic programming 
java o(n) dp solution super washing machines n super washing machines line  initially  washing machine dresses empty  move  could choose (1 ≤ ≤ n) washing machines  pass one dress washing machine one adjacent washing machines time   given integer array representing number dresses washing machine left right line  find minimum number moves make washing machines number dresses  possible it  return -1  hard math dynamic programming 
easy understand solution o(n) time and o(1) space super washing machines n super washing machines line  initially  washing machine dresses empty  move  could choose (1 ≤ ≤ n) washing machines  pass one dress washing machine one adjacent washing machines time   given integer array representing number dresses washing machine left right line  find minimum number moves make washing machines number dresses  possible it  return -1  hard math dynamic programming 
knapsack problem - java solution with thinking process o(nm) time and o(m) space coin change 2 given coins different denominations total amount money  write function compute number combinations make amount  may assume infinite number kind coin  note: assume 0 <= amount <= 5000 1 <= coin <= 5000 number coins less 500 answer guaranteed fit signed 32-bit integer medium 
video explaining how dynamic programming works with the coin change problem coin change 2 given coins different denominations total amount money  write function compute number combinations make amount  may assume infinite number kind coin  note: assume 0 <= amount <= 5000 1 <= coin <= 5000 number coins less 500 answer guaranteed fit signed 32-bit integer medium 
logical thinking with clear java code coin change 2 given coins different denominations total amount money  write function compute number combinations make amount  may assume infinite number kind coin  note: assume 0 <= amount <= 5000 1 <= coin <= 5000 number coins less 500 answer guaranteed fit signed 32-bit integer medium 
python o(n) space dp solution coin change 2 given coins different denominations total amount money  write function compute number combinations make amount  may assume infinite number kind coin  note: assume 0 <= amount <= 5000 1 <= coin <= 5000 number coins less 500 answer guaranteed fit signed 32-bit integer medium 
c# - dfs with memorization - of course dp is better coin change 2 given coins different denominations total amount money  write function compute number combinations make amount  may assume infinite number kind coin  note: assume 0 <= amount <= 5000 1 <= coin <= 5000 number coins less 500 answer guaranteed fit signed 32-bit integer medium 
java ac solution  call least times of random nextint() function random flip matrix given number rows n_rows number columns n_cols 2d binary matrix values initially 0  write function flip chooses 0 value uniformly random  changes 1  returns position [row id  col id] value  also  write function reset sets values back 0  try minimize number calls system's math random() optimize time space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows 0 <= col id < n_cols flip called matrix 0 values left  total number calls flip reset exceed 1000  medium random 
step by step algorithm explanation random flip matrix given number rows n_rows number columns n_cols 2d binary matrix values initially 0  write function flip chooses 0 value uniformly random  changes 1  returns position [row id  col id] value  also  write function reset sets values back 0  try minimize number calls system's math random() optimize time space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows 0 <= col id < n_cols flip called matrix 0 values left  total number calls flip reset exceed 1000  medium random 
python solution based on random shuffle with explanation random flip matrix given number rows n_rows number columns n_cols 2d binary matrix values initially 0  write function flip chooses 0 value uniformly random  changes 1  returns position [row id  col id] value  also  write function reset sets values back 0  try minimize number calls system's math random() optimize time space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows 0 <= col id < n_cols flip called matrix 0 values left  total number calls flip reset exceed 1000  medium random 
shuffle random flip matrix given number rows n_rows number columns n_cols 2d binary matrix values initially 0  write function flip chooses 0 value uniformly random  changes 1  returns position [row id  col id] value  also  write function reset sets values back 0  try minimize number calls system's math random() optimize time space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows 0 <= col id < n_cols flip called matrix 0 values left  total number calls flip reset exceed 1000  medium random 
c++ solution random flip matrix given number rows n_rows number columns n_cols 2d binary matrix values initially 0  write function flip chooses 0 value uniformly random  changes 1  returns position [row id  col id] value  also  write function reset sets values back 0  try minimize number calls system's math random() optimize time space complexity  note: 1 <= n_rows  n_cols <= 10000 0 <= row id < n_rows 0 <= col id < n_cols flip called matrix 0 values left  total number calls flip reset exceed 1000  medium random 
3 lines detect capital given word  need judge whether usage capitals right not  define usage capitals word right one following cases holds: letters word capitals  like "usa"  letters word capitals  like "leetcode"  first letter word capital one letter  like "google"  otherwise  define word use capitals right way  easy string 
python has useful methods    detect capital given word  need judge whether usage capitals right not  define usage capitals word right one following cases holds: letters word capitals  like "usa"  letters word capitals  like "leetcode"  first letter word capital one letter  like "google"  otherwise  define word use capitals right way  easy string 
java 1-liner detect capital given word  need judge whether usage capitals right not  define usage capitals word right one following cases holds: letters word capitals  like "usa"  letters word capitals  like "leetcode"  first letter word capital one letter  like "google"  otherwise  define word use capitals right way  easy string 
simple java solution o(n) time o(1) space detect capital given word  need judge whether usage capitals right not  define usage capitals word right one following cases holds: letters word capitals  like "usa"  letters word capitals  like "leetcode"  first letter word capital one letter  like "google"  otherwise  define word use capitals right way  easy string 
java short solution using built-in string methods detect capital given word  need judge whether usage capitals right not  define usage capitals word right one following cases holds: letters word capitals  like "usa"  letters word capitals  like "leetcode"  first letter word capital one letter  like "google"  otherwise  define word use capitals right way  easy string 
i feel this problem is just perfect for april fools' day longest uncommon subsequence i  given group two strings  need find longest uncommon subsequence group two strings  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input two strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  easy string 
java 1-liner longest uncommon subsequence i  given group two strings  need find longest uncommon subsequence group two strings  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input two strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  easy string 
python  simple explanation longest uncommon subsequence i  given group two strings  need find longest uncommon subsequence group two strings  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input two strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  easy string 
this is a silly question longest uncommon subsequence i  given group two strings  need find longest uncommon subsequence group two strings  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input two strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  easy string 
this is a boring word game longest uncommon subsequence i  given group two strings  need find longest uncommon subsequence group two strings  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input two strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  easy string 
python  simple explanation longest uncommon subsequence ii given list strings  need find longest uncommon subsequence among them  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input list strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  medium string 
java(15ms) - sort + check subsequence longest uncommon subsequence ii given list strings  need find longest uncommon subsequence among them  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input list strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  medium string 
java hashing solution longest uncommon subsequence ii given list strings  need find longest uncommon subsequence among them  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input list strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  medium string 
hashmap + sort solution  c++ longest uncommon subsequence ii given list strings  need find longest uncommon subsequence among them  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input list strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  medium string 
java 13 lines 5ms beats 100% with explaination longest uncommon subsequence ii given list strings  need find longest uncommon subsequence among them  longest uncommon subsequence defined longest subsequence one strings subsequence subsequence strings  subsequence sequence derived one sequence deleting characters without changing order remaining elements  trivially  string subsequence empty string subsequence string  input list strings  output needs length longest uncommon subsequence  longest uncommon subsequence exist  return -1  medium string 
java o(n) time o(k) space continuous subarray sum given list non-negative numbers target integer k  write function check array continuous subarray size least 2 sums multiple k  is  sums n k n also integer  medium math dynamic programming 
need to pay attention to a lot of corner cases    continuous subarray sum given list non-negative numbers target integer k  write function check array continuous subarray size least 2 sums multiple k  is  sums n k n also integer  medium math dynamic programming 
concise c++ solution  use set instead of map continuous subarray sum given list non-negative numbers target integer k  write function check array continuous subarray size least 2 sums multiple k  is  sums n k n also integer  medium math dynamic programming 
share my o(n) c++ accumulation-modulo solution with thinking process and explanation continuous subarray sum given list non-negative numbers target integer k  write function check array continuous subarray size least 2 sums multiple k  is  sums n k n also integer  medium math dynamic programming 
math behind the solutions continuous subarray sum given list non-negative numbers target integer k  write function check array continuous subarray size least 2 sums multiple k  is  sums n k n also integer  medium math dynamic programming 
short java solutions - sorting dictionary and without sorting longest word in dictionary through deleting given string string dictionary  find longest string dictionary formed deleting characters given string  one possible results  return longest word smallest lexicographical order  possible result  return empty string  medium two pointers sort 
short python solutions longest word in dictionary through deleting given string string dictionary  find longest string dictionary formed deleting characters given string  one possible results  return longest word smallest lexicographical order  possible result  return empty string  medium two pointers sort 
python simple (two pointer) longest word in dictionary through deleting given string string dictionary  find longest string dictionary formed deleting characters given string  one possible results  return longest word smallest lexicographical order  possible result  return empty string  medium two pointers sort 
10 lines solutions for c++ longest word in dictionary through deleting given string string dictionary  find longest string dictionary formed deleting characters given string  one possible results  return longest word smallest lexicographical order  possible result  return empty string  medium two pointers sort 
easy java solution  issubsequence longest word in dictionary through deleting given string string dictionary  find longest string dictionary formed deleting characters given string  one possible results  return longest word smallest lexicographical order  possible result  return empty string  medium two pointers sort 
easy java o(n) solution  presum + hashmap contiguous array given binary array  find maximum length contiguous subarray equal number 0 1  medium hash table 
python o(n) solution with visual explanation contiguous array given binary array  find maximum length contiguous subarray equal number 0 1  medium hash table 
one pass use a hashmap to record 0-1 count difference contiguous array given binary array  find maximum length contiguous subarray equal number 0 1  medium hash table 
python and java with little tricks (incl  a oneliner :-) contiguous array given binary array  find maximum length contiguous subarray equal number 0 1  medium hash table 
share my dp&map solution  one pass contiguous array given binary array  find maximum length contiguous subarray equal number 0 1  medium hash table 
java solution  backtracking beautiful arrangement suppose n integers 1 n  define beautiful arrangement array constructed n numbers successfully one following true ith position (1 <= <= n) array: number ith position divisible i  divisible number ith position  given n  many beautiful arrangements construct? medium backtracking 
java 6ms beats 98% back tracking (swap) starting from the back beautiful arrangement suppose n integers 1 n  define beautiful arrangement array constructed n numbers successfully one following true ith position (1 <= <= n) array: number ith position divisible i  divisible number ith position  given n  many beautiful arrangements construct? medium backtracking 
my c++ elegant solution with back-tracking beautiful arrangement suppose n integers 1 n  define beautiful arrangement array constructed n numbers successfully one following true ith position (1 <= <= n) array: number ith position divisible i  divisible number ith position  given n  many beautiful arrangements construct? medium backtracking 
python recursion + dp 66ms beautiful arrangement suppose n integers 1 n  define beautiful arrangement array constructed n numbers successfully one following true ith position (1 <= <= n) array: number ith position divisible i  divisible number ith position  given n  many beautiful arrangements construct? medium backtracking 
easy python  ~230ms beautiful arrangement suppose n integers 1 n  define beautiful arrangement array constructed n numbers successfully one following true ith position (1 <= <= n) array: number ith position divisible i  divisible number ith position  given n  many beautiful arrangements construct? medium backtracking 
please someone explain this question? random pick with weight given array w positive integers  w[i] describes weight index i  write function pickindex randomly picks index proportion weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex called 10000 times  medium binary search random 
java accumulated freq sum & binary search random pick with weight given array w positive integers  w[i] describes weight index i  write function pickindex randomly picks index proportion weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex called 10000 times  medium binary search random 
java 8 lines treemap random pick with weight given array w positive integers  w[i] describes weight index i  write function pickindex randomly picks index proportion weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex called 10000 times  medium binary search random 
very easy solution based on uniform sampling with explanation random pick with weight given array w positive integers  w[i] describes weight index i  write function pickindex randomly picks index proportion weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex called 10000 times  medium binary search random 
c++ concise binary search solution random pick with weight given array w positive integers  w[i] describes weight index i  write function pickindex randomly picks index proportion weight  note: 1 <= w length <= 10000 1 <= w[i] <= 10^5 pickindex called 10000 times  medium binary search random 
java solution  dfs + bfs minesweeper let's play minesweeper game (wikipedia  online game)! given 2d char matrix representing game board  'm' represents unrevealed mine  'e' represents unrevealed empty square  'b' represents revealed blank square adjacent (above  below  left  right  4 diagonals) mines  digit ('1' '8') represents many mines adjacent revealed square  finally 'x' represents revealed mine  given next click position (row column indices) among unrevealed squares ('m' 'e')  return board revealing position according following rules: mine ('m') revealed  game - change 'x'  empty square ('e') adjacent mines revealed  change revealed blank ('b') adjacent unrevealed squares revealed recursively  empty square ('e') least one adjacent mine revealed  change digit ('1' '8') representing number adjacent mines  return board squares revealed  medium depth-first search breadth-first search 
straight forward java solution minesweeper let's play minesweeper game (wikipedia  online game)! given 2d char matrix representing game board  'm' represents unrevealed mine  'e' represents unrevealed empty square  'b' represents revealed blank square adjacent (above  below  left  right  4 diagonals) mines  digit ('1' '8') represents many mines adjacent revealed square  finally 'x' represents revealed mine  given next click position (row column indices) among unrevealed squares ('m' 'e')  return board revealing position according following rules: mine ('m') revealed  game - change 'x'  empty square ('e') adjacent mines revealed  change revealed blank ('b') adjacent unrevealed squares revealed recursively  empty square ('e') least one adjacent mine revealed  change digit ('1' '8') representing number adjacent mines  return board squares revealed  medium depth-first search breadth-first search 
10 line python solution minesweeper let's play minesweeper game (wikipedia  online game)! given 2d char matrix representing game board  'm' represents unrevealed mine  'e' represents unrevealed empty square  'b' represents revealed blank square adjacent (above  below  left  right  4 diagonals) mines  digit ('1' '8') represents many mines adjacent revealed square  finally 'x' represents revealed mine  given next click position (row column indices) among unrevealed squares ('m' 'e')  return board revealing position according following rules: mine ('m') revealed  game - change 'x'  empty square ('e') adjacent mines revealed  change revealed blank ('b') adjacent unrevealed squares revealed recursively  empty square ('e') least one adjacent mine revealed  change digit ('1' '8') representing number adjacent mines  return board squares revealed  medium depth-first search breadth-first search 
c++ dfs solution  easy to understand minesweeper let's play minesweeper game (wikipedia  online game)! given 2d char matrix representing game board  'm' represents unrevealed mine  'e' represents unrevealed empty square  'b' represents revealed blank square adjacent (above  below  left  right  4 diagonals) mines  digit ('1' '8') represents many mines adjacent revealed square  finally 'x' represents revealed mine  given next click position (row column indices) among unrevealed squares ('m' 'e')  return board revealing position according following rules: mine ('m') revealed  game - change 'x'  empty square ('e') adjacent mines revealed  change revealed blank ('b') adjacent unrevealed squares revealed recursively  empty square ('e') least one adjacent mine revealed  change digit ('1' '8') representing number adjacent mines  return board squares revealed  medium depth-first search breadth-first search 
simple python (dfs) minesweeper let's play minesweeper game (wikipedia  online game)! given 2d char matrix representing game board  'm' represents unrevealed mine  'e' represents unrevealed empty square  'b' represents revealed blank square adjacent (above  below  left  right  4 diagonals) mines  digit ('1' '8') represents many mines adjacent revealed square  finally 'x' represents revealed mine  given next click position (row column indices) among unrevealed squares ('m' 'e')  return board revealing position according following rules: mine ('m') revealed  game - change 'x'  empty square ('e') adjacent mines revealed  change revealed blank ('b') adjacent unrevealed squares revealed recursively  empty square ('e') least one adjacent mine revealed  change digit ('1' '8') representing number adjacent mines  return board squares revealed  medium depth-first search breadth-first search 
java o(n) solution - one hashmap  easy to understand k-diff pairs in an array given array integers integer k  need find number unique k-diff pairs array  k-diff pair defined integer pair (i  j)  j numbers array absolute difference k  easy array two pointers 
1-liner in python  o(n) time k-diff pairs in an array given array integers integer k  need find number unique k-diff pairs array  k-diff pair defined integer pair (i  j)  j numbers array absolute difference k  easy array two pointers 
two-pointer approach k-diff pairs in an array given array integers integer k  need find number unique k-diff pairs array  k-diff pair defined integer pair (i  j)  j numbers array absolute difference k  easy array two pointers 
easy understood python solution k-diff pairs in an array given array integers integer k  need find number unique k-diff pairs array  k-diff pair defined integer pair (i  j)  j numbers array absolute difference k  easy array two pointers 
[c++] [java] clean code with explanation [set] [map] k-diff pairs in an array given array integers integer k  need find number unique k-diff pairs array  k-diff pair defined integer pair (i  j)  j numbers array absolute difference k  easy array two pointers 
c++ using stringstream complex number multiplication given two strings representing two complex numbers  need return string representing multiplication  note i2 = -1 according definition  medium math string 
java 3-liner complex number multiplication given two strings representing two complex numbers  need return string representing multiplication  note i2 = -1 according definition  medium math string 
java - (a1+b1) (a2+b2) = (a1a2 + b1b2 + (a1b2+b1a2)) complex number multiplication given two strings representing two complex numbers  need return string representing multiplication  note i2 = -1 according definition  medium math string 
python simple 3 lines solution complex number multiplication given two strings representing two complex numbers  need return string representing multiplication  note i2 = -1 according definition  medium math string 
2 lines python complex number multiplication given two strings representing two complex numbers  need return string representing multiplication  note i2 = -1 according definition  medium math string 
java recursive o(n) time convert bst to greater tree given binary search tree (bst)  convert greater tree every key original bst changed original key plus sum keys greater original key bst  easy tree 
c++ solution beats 100% convert bst to greater tree given binary search tree (bst)  convert greater tree every key original bst changed original key plus sum keys greater original key bst  easy tree 
java solution  7 liner  reversed traversal convert bst to greater tree given binary search tree (bst)  convert greater tree every key original bst changed original key plus sum keys greater original key bst  easy tree 
java three o(n) methods: recursive  iterative  and morris traversal convert bst to greater tree given binary search tree (bst)  convert greater tree every key original bst changed original key plus sum keys greater original key bst  easy tree 
python  simple with explanation convert bst to greater tree given binary search tree (bst)  convert greater tree every key original bst changed original key plus sum keys greater original key bst  easy tree 
verbose java solution  bucket minimum time difference given list 24-hour clock time points "hour:minutes" format  find minimum minutes difference two time points list  medium string 
java 10 liner solution  simplest so far minimum time difference given list 24-hour clock time points "hour:minutes" format  find minimum minutes difference two time points list  medium string 
python  straightforward with explanation minimum time difference given list 24-hour clock time points "hour:minutes" format  find minimum minutes difference two time points list  medium string 
[c++] clean code minimum time difference given list 24-hour clock time points "hour:minutes" format  find minimum minutes difference two time points list  medium string 
java sorting with a sentinel node minimum time difference given list 24-hour clock time points "hour:minutes" format  find minimum minutes difference two time points list  medium string 
java binary search  short (7l)  o(log(n)) w  explanations single element in a sorted array given sorted array consisting integers every element appears twice except one element appears once  find single element appears once  medium 
java binary search o(log(n)) shorter than others single element in a sorted array given sorted array consisting integers every element appears twice except one element appears once  find single element appears once  medium 
short  compare nums[i] with nums[i^1] single element in a sorted array given sorted array consisting integers every element appears twice except one element appears once  find single element appears once  medium 
java code by using binary search o(log(n)) single element in a sorted array given sorted array consisting integers every element appears twice except one element appears once  find single element appears once  medium 
c++ binary search single element in a sorted array given sorted array consisting integers every element appears twice except one element appears once  find single element appears once  medium 
java concise solution reverse string ii given string integer k  need reverse first k characters every 2k characters counting start string  less k characters left  reverse them  less 2k greater equal k characters  reverse first k characters left original  easy string 
python  straightforward with explanation reverse string ii given string integer k  need reverse first k characters every 2k characters counting start string  less k characters left  reverse them  less 2k greater equal k characters  reverse first k characters left original  easy string 
[c++][java] clean code reverse string ii given string integer k  need reverse first k characters every 2k characters counting start string  less k characters left  reverse them  less 2k greater equal k characters  reverse first k characters left original  easy string 
1 line simple recursive python reverse string ii given string integer k  need reverse first k characters every 2k characters counting start string  less k characters left  reverse them  less 2k greater equal k characters  reverse first k characters left original  easy string 
one line c++ reverse string ii given string integer k  need reverse first k characters every 2k characters counting start string  less k characters left  reverse them  less 2k greater equal k characters  reverse first k characters left original  easy string 
java solution  bfs 01 matrix given matrix consists 0 1  find distance nearest 0 cell  distance two adjacent cells 1  medium depth-first search breadth-first search 
short solution - each path needs at most one turn 01 matrix given matrix consists 0 1  find distance nearest 0 cell  distance two adjacent cells 1  medium depth-first search breadth-first search 
java 33ms solution with two sweeps in o(n) 01 matrix given matrix consists 0 1  find distance nearest 0 cell  distance two adjacent cells 1  medium depth-first search breadth-first search 
simple java solution beat 99% (use dp) 01 matrix given matrix consists 0 1  find distance nearest 0 cell  distance two adjacent cells 1  medium depth-first search breadth-first search 
python  simple with explanation 01 matrix given matrix consists 0 1  find distance nearest 0 cell  distance two adjacent cells 1  medium depth-first search breadth-first search 
java solution  maxdepth diameter of binary tree given binary tree  need compute length diameter tree  diameter binary tree length longest path two nodes tree  path may may pass root  easy tree 
simple python diameter of binary tree given binary tree  need compute length diameter tree  diameter binary tree length longest path two nodes tree  path may may pass root  easy tree 
python  simple with explanation diameter of binary tree given binary tree  need compute length diameter tree  diameter binary tree length longest path two nodes tree  path may may pass root  easy tree 
[543  diameter of binary tree] c++_recursive_with brief explanation diameter of binary tree given binary tree  need compute length diameter tree  diameter binary tree length longest path two nodes tree  path may may pass root  easy tree 
java easy to understand solution diameter of binary tree given binary tree  need compute length diameter tree  diameter binary tree length longest path two nodes tree  path may may pass root  easy tree 
java top-down and bottom-up dp solutions remove boxes given several boxes different colors represented different positive numbers  may experience several rounds remove boxes box left  time choose continuous boxes color (composed k boxes  k >= 1)  remove get k k points  find maximum points get  hard dynamic programming depth-first search 
memoization dfs c++ remove boxes given several boxes different colors represented different positive numbers  may experience several rounds remove boxes box left  time choose continuous boxes color (composed k boxes  k >= 1)  remove get k k points  find maximum points get  hard dynamic programming depth-first search 
java dp + memorization 60ms remove boxes given several boxes different colors represented different positive numbers  may experience several rounds remove boxes box left  time choose continuous boxes color (composed k boxes  k >= 1)  remove get k k points  find maximum points get  hard dynamic programming depth-first search 
python  fast dp with explanation remove boxes given several boxes different colors represented different positive numbers  may experience several rounds remove boxes box left  time choose continuous boxes color (composed k boxes  k >= 1)  remove get k k points  find maximum points get  hard dynamic programming depth-first search 
c++ 29ms dp solution! remove boxes given several boxes different colors represented different positive numbers  may experience several rounds remove boxes box left  time choose continuous boxes color (composed k boxes  k >= 1)  remove get k k points  find maximum points get  hard dynamic programming depth-first search 
neat dfs java solution friend circles n students class  friends  not  friendship transitive nature  medium depth-first search union find 
java solution  union find friend circles n students class  friends  not  friendship transitive nature  medium depth-first search union find 
python  simple explanation friend circles n students class  friends  not  friendship transitive nature  medium depth-first search union find 
oneliners :-p friend circles n students class  friends  not  friendship transitive nature  medium depth-first search union find 
[c++] clean code - dfs|unionfind friend circles n students class  friends  not  friendship transitive nature  medium depth-first search union find 
java 1-liner student attendance record i given string representing attendance record student  record contains following three characters: 'a' : absent  'l' : late  'p' : present  student could rewarded attendance record contain one 'a' (absent) two continuous 'l' (late)  need return whether student could rewarded according attendance record  easy string 
c++ very simple solution student attendance record i given string representing attendance record student  record contains following three characters: 'a' : absent  'l' : late  'p' : present  student could rewarded attendance record contain one 'a' (absent) two continuous 'l' (late)  need return whether student could rewarded according attendance record  easy string 
java simple without regex 3 lines student attendance record i given string representing attendance record student  record contains following three characters: 'a' : absent  'l' : late  'p' : present  student could rewarded attendance record contain one 'a' (absent) two continuous 'l' (late)  need return whether student could rewarded according attendance record  easy string 
java o(n) solution - accepted student attendance record i given string representing attendance record student  record contains following three characters: 'a' : absent  'l' : late  'p' : present  student could rewarded attendance record contain one 'a' (absent) two continuous 'l' (late)  need return whether student could rewarded according attendance record  easy string 
python 1 liner without regex student attendance record i given string representing attendance record student  record contains following three characters: 'a' : absent  'l' : late  'p' : present  student could rewarded attendance record contain one 'a' (absent) two continuous 'l' (late)  need return whether student could rewarded according attendance record  easy string 
share my o(n) c++ dp solution with thinking process and explanation student attendance record ii given positive integer n  return number possible attendance records length n  regarded rewardable  answer may large  return mod 109 + 7  student attendance record string contains following three characters: 'a' : absent  'l' : late  'p' : present  record regarded rewardable contain one 'a' (absent) two continuous 'l' (late)  hard dynamic programming 
improving the runtime from o(n) to o(log n) student attendance record ii given positive integer n  return number possible attendance records length n  regarded rewardable  answer may large  return mod 109 + 7  student attendance record string contains following three characters: 'a' : absent  'l' : late  'p' : present  record regarded rewardable contain one 'a' (absent) two continuous 'l' (late)  hard dynamic programming 
simple java o(n) solution student attendance record ii given positive integer n  return number possible attendance records length n  regarded rewardable  answer may large  return mod 109 + 7  student attendance record string contains following three characters: 'a' : absent  'l' : late  'p' : present  record regarded rewardable contain one 'a' (absent) two continuous 'l' (late)  hard dynamic programming 
python dp with explanation student attendance record ii given positive integer n  return number possible attendance records length n  regarded rewardable  answer may large  return mod 109 + 7  student attendance record string contains following three characters: 'a' : absent  'l' : late  'p' : present  record regarded rewardable contain one 'a' (absent) two continuous 'l' (late)  hard dynamic programming 
o(n) time o(1) space solution student attendance record ii given positive integer n  return number possible attendance records length n  regarded rewardable  answer may large  return mod 109 + 7  student attendance record string contains following three characters: 'a' : absent  'l' : late  'p' : present  record regarded rewardable contain one 'a' (absent) two continuous 'l' (late)  hard dynamic programming 
easy to understand simple o(n) solution with explanation optimal division given list positive integers  adjacent integers perform float division  medium math string 
java solution  backtracking optimal division given list positive integers  adjacent integers perform float division  medium math string 
brute force with memory in case of your interviewer forbid tricky solution optimal division given list positive integers  adjacent integers perform float division  medium math string 
o(n) very easy java solution  optimal division given list positive integers  adjacent integers perform float division  medium math string 
python  straightforward with explanation (insightful approach) optimal division given list positive integers  adjacent integers perform float division  medium math string 
i don't think there is a better person than me to answer this question brick wall brick wall front you  wall rectangular several rows bricks  bricks height different width  want draw vertical line top bottom cross least bricks  brick wall represented list rows  row list integers representing width brick row left right  line go edge brick  brick considered crossed  need find draw line cross least bricks return number crossed bricks  cannot draw line along one two vertical edges wall  case line obviously cross bricks  medium hash table 
c++ 6 lines (hash map) brick wall brick wall front you  wall rectangular several rows bricks  bricks height different width  want draw vertical line top bottom cross least bricks  brick wall represented list rows  row list integers representing width brick row left right  line go edge brick  brick considered crossed  need find draw line cross least bricks return number crossed bricks  cannot draw line along one two vertical edges wall  case line obviously cross bricks  medium hash table 
clear python solution brick wall brick wall front you  wall rectangular several rows bricks  bricks height different width  want draw vertical line top bottom cross least bricks  brick wall represented list rows  row list integers representing width brick row left right  line go edge brick  brick considered crossed  need find draw line cross least bricks return number crossed bricks  cannot draw line along one two vertical edges wall  case line obviously cross bricks  medium hash table 
neat java solution o(n) using hashmap brick wall brick wall front you  wall rectangular several rows bricks  bricks height different width  want draw vertical line top bottom cross least bricks  brick wall represented list rows  row list integers representing width brick row left right  line go edge brick  brick considered crossed  need find draw line cross least bricks return number crossed bricks  cannot draw line along one two vertical edges wall  case line obviously cross bricks  medium hash table 
verbose java solution  priorityqueue brick wall brick wall front you  wall rectangular several rows bricks  bricks height different width  want draw vertical line top bottom cross least bricks  brick wall represented list rows  row list integers representing width brick row left right  line go edge brick  brick considered crossed  need find draw line cross least bricks return number crossed bricks  cannot draw line along one two vertical edges wall  case line obviously cross bricks  medium hash table 
simple java solution (4ms) with explanation  next greater element iii given positive 32-bit integer n  need find smallest 32-bit integer exactly digits existing integer n greater value n  positive 32-bit integer exists  need return -1  medium string 
c++ 4 lines (next_permutation) next greater element iii given positive 32-bit integer n  need find smallest 32-bit integer exactly digits existing integer n greater value n  positive 32-bit integer exists  need return -1  medium string 
[c++] solution with explanation next greater element iii given positive 32-bit integer n  need find smallest 32-bit integer exactly digits existing integer n greater value n  positive 32-bit integer exists  need return -1  medium string 
java solution like next permutation problem o(n) next greater element iii given positive 32-bit integer n  need find smallest 32-bit integer exactly digits existing integer n greater value n  positive 32-bit integer exists  need return -1  medium string 
easy python3 beats 100% next greater element iii given positive 32-bit integer n  need find smallest 32-bit integer exactly digits existing integer n greater value n  positive 32-bit integer exists  need return -1  medium string 
1 line ruby   python reverse words in a string iii given string  need reverse order characters word within sentence still preserving whitespace initial word order  easy string 
short java code without explanation reverse words in a string iii given string  need reverse order characters word within sentence still preserving whitespace initial word order  easy string 
[c++] [java] clean code reverse words in a string iii given string  need reverse order characters word within sentence still preserving whitespace initial word order  easy string 
easiest java solution (9ms) - similar to reverse words in a string ii reverse words in a string iii given string  need reverse order characters word within sentence still preserving whitespace initial word order  easy string 
c++ solution reverse words in a string iii given string  need reverse order characters word within sentence still preserving whitespace initial word order  easy string 
python simple & short & readable ac solution quad tree intersection quadtree tree data internal node exactly four children: topleft  topright  bottomleft bottomright  quad trees often used partition two-dimensional space recursively subdividing four quadrants regions  want store true false information quad tree  quad tree used represent n   n boolean grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  easy 
[fixed] incorrect test cases quad tree intersection quadtree tree data internal node exactly four children: topleft  topright  bottomleft bottomright  quad trees often used partition two-dimensional space recursively subdividing four quadrants regions  want store true false information quad tree  quad tree used represent n   n boolean grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  easy 
c++ 10 line beat 100% quad tree intersection quadtree tree data internal node exactly four children: topleft  topright  bottomleft bottomright  quad trees often used partition two-dimensional space recursively subdividing four quadrants regions  want store true false information quad tree  quad tree used represent n   n boolean grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  easy 
java concise code beat 100% quad tree intersection quadtree tree data internal node exactly four children: topleft  topright  bottomleft bottomright  quad trees often used partition two-dimensional space recursively subdividing four quadrants regions  want store true false information quad tree  quad tree used represent n   n boolean grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  easy 
python solution to a badly worded question quad tree intersection quadtree tree data internal node exactly four children: topleft  topright  bottomleft bottomright  quad trees often used partition two-dimensional space recursively subdividing four quadrants regions  want store true false information quad tree  quad tree used represent n   n boolean grid  node  subdivided four children nodes values region represents same  node another two boolean attributes : isleaf val  isleaf true node leaf node  val attribute leaf node contains value region represents  easy 
[solution] python  c++  simple  with explanation maximum depth of n-ary tree given n-ary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  easy tree depth-first search breadth-first search 
java top down dfs solutions maximum depth of n-ary tree given n-ary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  easy tree depth-first search breadth-first search 
java bfs iterative solution maximum depth of n-ary tree given n-ary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  easy tree depth-first search breadth-first search 
dfs & bfs solutions in c++  maximum depth of n-ary tree given n-ary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  easy tree depth-first search breadth-first search 
java solution with explain  same logic with maximum depth of binary tree maximum depth of n-ary tree given n-ary tree  find maximum depth  maximum depth number nodes along longest path root node farthest leaf node  easy tree depth-first search breadth-first search 
java solution  presum + hashmap subarray sum equals k given array integers integer k  need find total number continuous subarrays whose sum equals k  medium array hash table 
python  simple with explanation subarray sum equals k given array integers integer k  need find total number continuous subarrays whose sum equals k  medium array hash table 
c++ prefix sum + map subarray sum equals k given array integers integer k  need find total number continuous subarrays whose sum equals k  medium array hash table 
three approaches with explanation subarray sum equals k given array integers integer k  need find total number continuous subarrays whose sum equals k  medium array hash table 
super simple python subarray sum equals k given array integers integer k  need find total number continuous subarrays whose sum equals k  medium array hash table 
java solution  sorting  and rough proof of algorithm  array partition i given array 2n integers  task group integers n pairs integer  say (a1  b1)  (a2  b2)       (an  bn) makes sum min(ai  bi) 1 n large possible  easy array 
please explain: the question doesn't make sense  array partition i given array 2n integers  task group integers n pairs integer  say (a1  b1)  (a2  b2)       (an  bn) makes sum min(ai  bi) 1 n large possible  easy array 
java o(n) beats 100% array partition i given array 2n integers  task group integers n pairs integer  say (a1  b1)  (a2  b2)       (an  bn) makes sum min(ai  bi) 1 n large possible  easy array 
c++ code o(n) beats 100% array partition i given array 2n integers  task group integers n pairs integer  say (a1  b1)  (a2  b2)       (an  bn) makes sum min(ai  bi) 1 n large possible  easy array 
python 1 line (sorting is accepted) array partition i given array 2n integers  task group integers n pairs integer  say (a1  b1)  (a2  b2)       (an  bn) makes sum min(ai  bi) 1 n large possible  easy array 
java solution  post-order traversal binary tree tilt given binary tree  return tilt whole tree  tilt tree node defined absolute difference sum left subtree node values sum right subtree node values  null node tilt 0  tilt whole tree defined sum nodes' tilt  easy tree 
python  simple with explanation binary tree tilt given binary tree  return tilt whole tree  tilt tree node defined absolute difference sum left subtree node values sum right subtree node values  null node tilt 0  tilt whole tree defined sum nodes' tilt  easy tree 
simple java solution  -- without global variable binary tree tilt given binary tree  return tilt whole tree  tilt tree node defined absolute difference sum left subtree node values sum right subtree node values  null node tilt 0  tilt whole tree defined sum nodes' tilt  easy tree 
python straightforward solution binary tree tilt given binary tree  return tilt whole tree  tilt tree node defined absolute difference sum left subtree node values sum right subtree node values  null node tilt 0  tilt whole tree defined sum nodes' tilt  easy tree 
java solution  no globle varible  easy and clean binary tree tilt given binary tree  return tilt whole tree  tilt tree node defined absolute difference sum left subtree node values sum right subtree node values  null node tilt 0  tilt whole tree defined sum nodes' tilt  easy tree 
python  simple with explanation find the closest palindrome given integer n  find closest integer (not including itself)  palindrome  'closest' defined absolute difference minimized two integers  hard string 
java solution with full explaination find the closest palindrome given integer n  find closest integer (not including itself)  palindrome  'closest' defined absolute difference minimized two integers  hard string 
java solution with detailed proof find the closest palindrome given integer n  find closest integer (not including itself)  palindrome  'closest' defined absolute difference minimized two integers  hard string 
c++ short solution  only need to compare 5 numbers find the closest palindrome given integer n  find closest integer (not including itself)  palindrome  'closest' defined absolute difference minimized two integers  hard string 
concise java solution find the closest palindrome given integer n  find closest integer (not including itself)  palindrome  'closest' defined absolute difference minimized two integers  hard string 
[c++] [java] clean code - o(n) array nesting zero-indexed array length n contains integers 0 n-1  find return longest length set s  s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected rule below  suppose first element starts selection element a[i] index = i  next element a[a[i]]  a[a[a[i]]]… analogy  stop adding right duplicate element occurs s  medium array 
this is actually dfs array nesting zero-indexed array length n contains integers 0 n-1  find return longest length set s  s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected rule below  suppose first element starts selection element a[i] index = i  next element a[a[i]]  a[a[a[i]]]… analogy  stop adding right duplicate element occurs s  medium array 
python solution array nesting zero-indexed array length n contains integers 0 n-1  find return longest length set s  s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected rule below  suppose first element starts selection element a[i] index = i  next element a[a[i]]  a[a[a[i]]]… analogy  stop adding right duplicate element occurs s  medium array 
short python array nesting zero-indexed array length n contains integers 0 n-1  find return longest length set s  s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected rule below  suppose first element starts selection element a[i] index = i  next element a[a[i]]  a[a[a[i]]]… analogy  stop adding right duplicate element occurs s  medium array 
java o(n) time o(1) space array nesting zero-indexed array length n contains integers 0 n-1  find return longest length set s  s[i] = {a[i]  a[a[i]]  a[a[a[i]]]      } subjected rule below  suppose first element starts selection element a[i] index = i  next element a[a[i]]  a[a[a[i]]]… analogy  stop adding right duplicate element occurs s  medium array 
java concise o(nm) time reshape the matrix matlab  useful function called 'reshape'  reshape matrix new one different size keep original data  given matrix represented two-dimensional array  two positive integers r c representing row number column number wanted reshaped matrix  respectively  reshaped matrix need filled elements original matrix row-traversing order were  'reshape' operation given parameters possible legal  output new reshaped matrix; otherwise  output original matrix  easy array 
one loop reshape the matrix matlab  useful function called 'reshape'  reshape matrix new one different size keep original data  given matrix represented two-dimensional array  two positive integers r c representing row number column number wanted reshaped matrix  respectively  reshaped matrix need filled elements original matrix row-traversing order were  'reshape' operation given parameters possible legal  output new reshaped matrix; otherwise  output original matrix  easy array 
python solutions reshape the matrix matlab  useful function called 'reshape'  reshape matrix new one different size keep original data  given matrix represented two-dimensional array  two positive integers r c representing row number column number wanted reshaped matrix  respectively  reshaped matrix need filled elements original matrix row-traversing order were  'reshape' operation given parameters possible legal  output new reshaped matrix; otherwise  output original matrix  easy array 
easy java solution reshape the matrix matlab  useful function called 'reshape'  reshape matrix new one different size keep original data  given matrix represented two-dimensional array  two positive integers r c representing row number column number wanted reshaped matrix  respectively  reshaped matrix need filled elements original matrix row-traversing order were  'reshape' operation given parameters possible legal  output new reshaped matrix; otherwise  output original matrix  easy array 
c solution reshape the matrix matlab  useful function called 'reshape'  reshape matrix new one different size keep original data  given matrix represented two-dimensional array  two positive integers r c representing row number column number wanted reshaped matrix  respectively  reshaped matrix need filled elements original matrix row-traversing order were  'reshape' operation given parameters possible legal  output new reshaped matrix; otherwise  output original matrix  easy array 
java solution  sliding window permutation in string given two strings s1 s2  write function return true s2 contains permutation s1  words  one first string's permutations substring second string  medium two pointers 
8 lines slide window solution in java permutation in string given two strings s1 s2  write function return true s2 contains permutation s1  words  one first string's permutations substring second string  medium two pointers 
python  simple with explanation permutation in string given two strings s1 s2  write function return true s2 contains permutation s1  words  one first string's permutations substring second string  medium two pointers 
sliding window in java  very similar to find all anagrams in a string permutation in string given two strings s1 s2  write function return true s2 contains permutation s1  words  one first string's permutations substring second string  medium two pointers 
java solution two pointers permutation in string given two strings s1 s2  write function return true s2 contains permutation s1  words  one first string's permutations substring second string  medium two pointers 
java solution  tree traversal subtree of another tree given two non-empty binary trees t  check whether tree exactly structure node values subtree s  subtree tree consists node node's descendants  tree could also considered subtree itself  easy tree 
easy o(n) java solution using preorder traversal subtree of another tree given two non-empty binary trees t  check whether tree exactly structure node values subtree s  subtree tree consists node node's descendants  tree could also considered subtree itself  easy tree 
python  straightforward with explanation (o(st) and o(s+t) approaches) subtree of another tree given two non-empty binary trees t  check whether tree exactly structure node values subtree s  subtree tree consists node node's descendants  tree could also considered subtree itself  easy tree 
short python by converting into strings subtree of another tree given two non-empty binary trees t  check whether tree exactly structure node values subtree s  subtree tree consists node node's descendants  tree could also considered subtree itself  easy tree 
java concise o(n+m) time o(n+m) space subtree of another tree given two non-empty binary trees t  check whether tree exactly structure node values subtree s  subtree tree consists node node's descendants  tree could also considered subtree itself  easy tree 
python  straightforward with explanation distribute candies given integer array even length  different numbers array represent different kinds candies  number means one candy corresponding kind  need distribute candies equally number brother sister  return maximum number kinds candies sister could gain  easy hash table 
java solution  3 lines  hashset distribute candies given integer array even length  different numbers array represent different kinds candies  number means one candy corresponding kind  need distribute candies equally number brother sister  return maximum number kinds candies sister could gain  easy hash table 
c++  bitset  beats 99 60% distribute candies given integer array even length  different numbers array represent different kinds candies  number means one candy corresponding kind  need distribute candies equally number brother sister  return maximum number kinds candies sister could gain  easy hash table 
[c++] clean code - 2 solutions: set and sort distribute candies given integer array even length  different numbers array represent different kinds candies  number means one candy corresponding kind  need distribute candies equally number brother sister  return maximum number kinds candies sister could gain  easy hash table 
1-line javascript o(n) solution using set distribute candies given integer array even length  different numbers array represent different kinds candies  number means one candy corresponding kind  need distribute candies equally number brother sister  return maximum number kinds candies sister could gain  easy hash table 
java solution  dp with space compression out of boundary paths n grid ball  given start coordinate (i j) ball  move ball adjacent cell cross grid boundary four directions (up  down  left  right)  however  move n times  find number paths move ball grid boundary  answer may large  return mod 109 + 7  medium dynamic programming depth-first search 
c++ 6 lines dp o(n   m   n)  6 ms out of boundary paths n grid ball  given start coordinate (i j) ball  move ball adjacent cell cross grid boundary four directions (up  down  left  right)  however  move n times  find number paths move ball grid boundary  answer may large  return mod 109 + 7  medium dynamic programming depth-first search 
clean code - 8 solutions (6 c++ & 2 java) out of boundary paths n grid ball  given start coordinate (i j) ball  move ball adjacent cell cross grid boundary four directions (up  down  left  right)  however  move n times  find number paths move ball grid boundary  answer may large  return mod 109 + 7  medium dynamic programming depth-first search 
java dfs with memorization out of boundary paths n grid ball  given start coordinate (i j) ball  move ball adjacent cell cross grid boundary four directions (up  down  left  right)  however  move n times  find number paths move ball grid boundary  answer may large  return mod 109 + 7  medium dynamic programming depth-first search 
fast python solution using numpy out of boundary paths n grid ball  given start coordinate (i j) ball  move ball adjacent cell cross grid boundary four directions (up  down  left  right)  however  move n times  find number paths move ball grid boundary  answer may large  return mod 109 + 7  medium dynamic programming depth-first search 
java o(n) time o(1) space shortest unsorted continuous subarray given integer array  need find one continuous subarray sort subarray ascending order  whole array sorted ascending order  too  need find shortest subarray output length  easy array 
ideas behind the o(n) two-pass and one-pass solutions shortest unsorted continuous subarray given integer array  need find one continuous subarray sort subarray ascending order  whole array sorted ascending order  too  need find shortest subarray output length  easy array 
java solution  sort  shortest unsorted continuous subarray given integer array  need find one continuous subarray sort subarray ascending order  whole array sorted ascending order  too  need find shortest subarray output length  easy array 
python 2 lines sort solution shortest unsorted continuous subarray given integer array  need find one continuous subarray sort subarray ascending order  whole array sorted ascending order  too  need find shortest subarray output length  easy array 
c++ o(n) solution shortest unsorted continuous subarray given integer array  need find one continuous subarray sort subarray ascending order  whole array sorted ascending order  too  need find shortest subarray output length  easy array 
java dp solution (longest common subsequence) delete operation for two strings given two words word1 word2  find minimum number steps required make word1 word2 same  step delete one character either string  medium string 
java dp solution  same as edit distance delete operation for two strings given two words word1 word2  find minimum number steps required make word1 word2 same  step delete one character either string  medium string 
longest common subsequence dp java solution delete operation for two strings given two words word1 word2  find minimum number steps required make word1 word2 same  step delete one character either string  medium string 
python dp solution delete operation for two strings given two words word1 word2  find minimum number steps required make word1 word2 same  step delete one character either string  medium string 
python  straightforward with explanation delete operation for two strings given two words word1 word2  find minimum number steps required make word1 word2 same  step delete one character either string  medium string 
java solution  convex hull algorithm - gift wrapping aka jarvis march erect the fence trees  tree represented (x y) coordinate two-dimensional garden  job fence entire garden using minimum length rope expensive  garden well fenced trees enclosed  task help find coordinates trees exactly located fence perimeter  hard geometry 
java graham scan with adapted sorting to deal with collinear points erect the fence trees  tree represented (x y) coordinate two-dimensional garden  job fence entire garden using minimum length rope expensive  garden well fenced trees enclosed  task help find coordinates trees exactly located fence perimeter  hard geometry 
c++ and python easy wiki solution erect the fence trees  tree represented (x y) coordinate two-dimensional garden  job fence entire garden using minimum length rope expensive  garden well fenced trees enclosed  task help find coordinates trees exactly located fence perimeter  hard geometry 
python  am chain with explanation erect the fence trees  tree represented (x y) coordinate two-dimensional garden  job fence entire garden using minimum length rope expensive  garden well fenced trees enclosed  task help find coordinates trees exactly located fence perimeter  hard geometry 
c++ graham scan monotone chain dealing with collinear cases erect the fence trees  tree represented (x y) coordinate two-dimensional garden  job fence entire garden using minimum length rope expensive  garden well fenced trees enclosed  task help find coordinates trees exactly located fence perimeter  hard geometry 
java iterative and recursive solutions n-ary tree preorder traversal given n-ary tree  return preorder traversal nodes' values  easy tree 
python short iterative solution beats 100%    66 ms faster than fastest ! n-ary tree preorder traversal given n-ary tree  return preorder traversal nodes' values  easy tree 
c++ simple 10-line iterative solution  beat 100%! n-ary tree preorder traversal given n-ary tree  return preorder traversal nodes' values  easy tree 
c++ 44ms beats 100% both iterative and recursive n-ary tree preorder traversal given n-ary tree  return preorder traversal nodes' values  easy tree 
java time o(n) and space o(n) recursive   iterative solution using helper method n-ary tree preorder traversal given n-ary tree  return preorder traversal nodes' values  easy tree 
java solution: use startswith and indexof tag validator given string representing code snippet  need implement tag validator parse code return whether valid  code snippet valid following rules hold: code must wrapped valid closed tag  otherwise  code invalid  closed tag (not necessarily valid) exactly following format : <tag_name>tag_content< tag_name>  among them  <tag_name> start tag  < tag_name> end tag  tag_name start end tags same  closed tag valid tag_name tag_content valid  valid tag_name contain upper-case letters  length range [1 9]  otherwise  tag_name invalid  valid tag_content may contain valid closed tags  cdata characters (see note1) except unmatched <  unmatched start end tag  unmatched closed tags invalid tag_name  otherwise  tag_content invalid  start tag unmatched end tag exists tag_name  vice versa  however  also need consider issue unbalanced tags nested  < unmatched cannot find subsequent >  find < <   subsequent characters next > parsed tag_name (not necessarily valid)  cdata following format : <![cdata[cdata_content]]>  range cdata_content defined characters <![cdata[ first subsequent ]]>  cdata_content may contain characters  function cdata forbid validator parse cdata_content  even characters parsed tag (no matter valid invalid)  treat regular characters  valid code hard string stack 
short python  accepted but not sure if correct tag validator given string representing code snippet  need implement tag validator parse code return whether valid  code snippet valid following rules hold: code must wrapped valid closed tag  otherwise  code invalid  closed tag (not necessarily valid) exactly following format : <tag_name>tag_content< tag_name>  among them  <tag_name> start tag  < tag_name> end tag  tag_name start end tags same  closed tag valid tag_name tag_content valid  valid tag_name contain upper-case letters  length range [1 9]  otherwise  tag_name invalid  valid tag_content may contain valid closed tags  cdata characters (see note1) except unmatched <  unmatched start end tag  unmatched closed tags invalid tag_name  otherwise  tag_content invalid  start tag unmatched end tag exists tag_name  vice versa  however  also need consider issue unbalanced tags nested  < unmatched cannot find subsequent >  find < <   subsequent characters next > parsed tag_name (not necessarily valid)  cdata following format : <![cdata[cdata_content]]>  range cdata_content defined characters <![cdata[ first subsequent ]]>  cdata_content may contain characters  function cdata forbid validator parse cdata_content  even characters parsed tag (no matter valid invalid)  treat regular characters  valid code hard string stack 
java solution  7 lines  regular expression tag validator given string representing code snippet  need implement tag validator parse code return whether valid  code snippet valid following rules hold: code must wrapped valid closed tag  otherwise  code invalid  closed tag (not necessarily valid) exactly following format : <tag_name>tag_content< tag_name>  among them  <tag_name> start tag  < tag_name> end tag  tag_name start end tags same  closed tag valid tag_name tag_content valid  valid tag_name contain upper-case letters  length range [1 9]  otherwise  tag_name invalid  valid tag_content may contain valid closed tags  cdata characters (see note1) except unmatched <  unmatched start end tag  unmatched closed tags invalid tag_name  otherwise  tag_content invalid  start tag unmatched end tag exists tag_name  vice versa  however  also need consider issue unbalanced tags nested  < unmatched cannot find subsequent >  find < <   subsequent characters next > parsed tag_name (not necessarily valid)  cdata following format : <![cdata[cdata_content]]>  range cdata_content defined characters <![cdata[ first subsequent ]]>  cdata_content may contain characters  function cdata forbid validator parse cdata_content  even characters parsed tag (no matter valid invalid)  treat regular characters  valid code hard string stack 
[c++] clean code - recursive parser tag validator given string representing code snippet  need implement tag validator parse code return whether valid  code snippet valid following rules hold: code must wrapped valid closed tag  otherwise  code invalid  closed tag (not necessarily valid) exactly following format : <tag_name>tag_content< tag_name>  among them  <tag_name> start tag  < tag_name> end tag  tag_name start end tags same  closed tag valid tag_name tag_content valid  valid tag_name contain upper-case letters  length range [1 9]  otherwise  tag_name invalid  valid tag_content may contain valid closed tags  cdata characters (see note1) except unmatched <  unmatched start end tag  unmatched closed tags invalid tag_name  otherwise  tag_content invalid  start tag unmatched end tag exists tag_name  vice versa  however  also need consider issue unbalanced tags nested  < unmatched cannot find subsequent >  find < <   subsequent characters next > parsed tag_name (not necessarily valid)  cdata following format : <![cdata[cdata_content]]>  range cdata_content defined characters <![cdata[ first subsequent ]]>  cdata_content may contain characters  function cdata forbid validator parse cdata_content  even characters parsed tag (no matter valid invalid)  treat regular characters  valid code hard string stack 
clean c++ solution tag validator given string representing code snippet  need implement tag validator parse code return whether valid  code snippet valid following rules hold: code must wrapped valid closed tag  otherwise  code invalid  closed tag (not necessarily valid) exactly following format : <tag_name>tag_content< tag_name>  among them  <tag_name> start tag  < tag_name> end tag  tag_name start end tags same  closed tag valid tag_name tag_content valid  valid tag_name contain upper-case letters  length range [1 9]  otherwise  tag_name invalid  valid tag_content may contain valid closed tags  cdata characters (see note1) except unmatched <  unmatched start end tag  unmatched closed tags invalid tag_name  otherwise  tag_content invalid  start tag unmatched end tag exists tag_name  vice versa  however  also need consider issue unbalanced tags nested  < unmatched cannot find subsequent >  find < <   subsequent characters next > parsed tag_name (not necessarily valid)  cdata following format : <![cdata[cdata_content]]>  range cdata_content defined characters <![cdata[ first subsequent ]]>  cdata_content may contain characters  function cdata forbid validator parse cdata_content  even characters parsed tag (no matter valid invalid)  treat regular characters  valid code hard string stack 
small simple c++ java python fraction addition and subtraction given string representing expression fraction addition subtraction  need return calculation result string format  final result irreducible fraction  final result integer  say 2  need change format fraction denominator 1  case  2 converted 2 1  medium math 
concise java solution fraction addition and subtraction given string representing expression fraction addition subtraction  need return calculation result string format  final result irreducible fraction  final result integer  say 2  need change format fraction denominator 1  case  2 converted 2 1  medium math 
python easy understood 2-line solution fraction addition and subtraction given string representing expression fraction addition subtraction  need return calculation result string format  final result irreducible fraction  final result integer  say 2  need change format fraction denominator 1  case  2 converted 2 1  medium math 
java solution  fraction addition and gcd fraction addition and subtraction given string representing expression fraction addition subtraction  need return calculation result string format  final result irreducible fraction  final result integer  say 2  need change format fraction denominator 1  case  2 converted 2 1  medium math 
c++ clean code fraction addition and subtraction given string representing expression fraction addition subtraction  need return calculation result string format  final result irreducible fraction  final result integer  say 2  need change format fraction denominator 1  case  2 converted 2 1  medium math 
c++ 3 lines (unordered_set) valid square given coordinates four points 2d space  return whether four points could construct square  coordinate (x y) point represented integer array two integers  medium math 
simple java solution - square distances valid square given coordinates four points 2d space  return whether four points could construct square  coordinate (x y) point represented integer array two integers  medium math 
4 liner java valid square given coordinates four points 2d space  return whether four points could construct square  coordinate (x y) point represented integer array two integers  medium math 
a general solution to find combination of squares in n points in o(n^2) time valid square given coordinates four points 2d space  return whether four points could construct square  coordinate (x y) point represented integer array two integers  medium math 
share my simple python solution valid square given coordinates four points 2d space  return whether four points could construct square  coordinate (x y) point represented integer array two integers  medium math 
simple java hashmap solution longest harmonious subsequence define harmonious array array difference maximum value minimum value exactly 1  now  given integer array  need find length longest harmonious subsequence among possible subsequences  easy hash table 
python  straightforward with explanation longest harmonious subsequence define harmonious array array difference maximum value minimum value exactly 1  now  given integer array  need find length longest harmonious subsequence among possible subsequences  easy hash table 
three c++ solution run time with explanation longest harmonious subsequence define harmonious array array difference maximum value minimum value exactly 1  now  given integer array  need find length longest harmonious subsequence among possible subsequences  easy hash table 
short python using counter longest harmonious subsequence define harmonious array array difference maximum value minimum value exactly 1  now  given integer array  need find length longest harmonious subsequence among possible subsequences  easy hash table 
java solution  hashmap longest harmonious subsequence define harmonious array array difference maximum value minimum value exactly 1  now  given integer array  need find length longest harmonious subsequence among possible subsequences  easy hash table 
union and or and the explanation big countries sql schemathere table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ country big area bigger 3 million square km population 25 million  write sql solution output big countries' name  population area  easy 
easy ac big countries sql schemathere table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ country big area bigger 3 million square km population 25 million  write sql solution output big countries' name  population area  easy 
description and author's solution are inconsistent big countries sql schemathere table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ country big area bigger 3 million square km population 25 million  write sql solution output big countries' name  population area  easy 
obvious solution: runtime: 1724 ms  faster than 92 81% of mysql online submissions big countries sql schemathere table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ country big area bigger 3 million square km population 25 million  write sql solution output big countries' name  population area  easy 
for those wondering the units big countries sql schemathere table world +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | afghanistan | asia | 652230 | 25500100 | 20343000 | | albania | europe | 28748 | 2831741 | 12960000 | | algeria | africa | 2381741 | 37100000 | 188681000 | | andorra | europe | 468 | 78115 | 3712000 | | angola | africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ country big area bigger 3 million square km population 25 million  write sql solution output big countries' name  population area  easy 
all the same classes more than 5 students sql schema table courses columns: student class please list classes equal 5 students  easy 
my solution classes more than 5 students sql schema table courses columns: student class please list classes equal 5 students  easy 
my first mysql solution   classes more than 5 students sql schema table courses columns: student class please list classes equal 5 students  easy 
can not be more simpler classes more than 5 students sql schema table courses columns: student class please list classes equal 5 students  easy 
concise solution using distinct and having  classes more than 5 students sql schema table courses columns: student class please list classes equal 5 students  easy 
java solution  find min range addition ii given   n matrix initialized 0's several update operations  operations represented 2d array  operation represented array two positive integers b  means m[i][j] added one 0 <= < 0 <= j < b  need count return number maximum integers matrix performing operations  easy math 
python solution   beat 100% range addition ii given   n matrix initialized 0's several update operations  operations represented 2d array  operation represented array two positive integers b  means m[i][j] added one 0 <= < 0 <= j < b  need count return number maximum integers matrix performing operations  easy math 
python  straightforward with explanation range addition ii given   n matrix initialized 0's several update operations  operations represented 2d array  operation represented array two positive integers b  means m[i][j] added one 0 <= < 0 <= j < b  need count return number maximum integers matrix performing operations  easy math 
java simple solution range addition ii given   n matrix initialized 0's several update operations  operations represented 2d array  operation represented array two positive integers b  means m[i][j] added one 0 <= < 0 <= j < b  need count return number maximum integers matrix performing operations  easy math 
c++ short solution range addition ii given   n matrix initialized 0's several update operations  operations represented 2d array  operation represented array two positive integers b  means m[i][j] added one 0 <= < 0 <= j < b  need count return number maximum integers matrix performing operations  easy math 
java o(n+m) time o(n) space minimum index sum of two lists suppose andy doris want choose restaurant dinner  list favorite restaurants represented strings  need help find common interest least list index sum  choice tie answers  output order requirement  could assume always exists answer  easy hash table 
ucsd students? minimum index sum of two lists suppose andy doris want choose restaurant dinner  list favorite restaurants represented strings  need help find common interest least list index sum  choice tie answers  output order requirement  could assume always exists answer  easy hash table 
python  straightforward with explanation minimum index sum of two lists suppose andy doris want choose restaurant dinner  list favorite restaurants represented strings  need help find common interest least list index sum  choice tie answers  output order requirement  could assume always exists answer  easy hash table 
c++ 9 lines hash table easy to understand minimum index sum of two lists suppose andy doris want choose restaurant dinner  list favorite restaurants represented strings  need help find common interest least list index sum  choice tie answers  output order requirement  could assume always exists answer  easy hash table 
bug report minimum index sum of two lists suppose andy doris want choose restaurant dinner  list favorite restaurants represented strings  need help find common interest least list index sum  choice tie answers  output order requirement  could assume always exists answer  easy hash table 
java solution  dp non-negative integers without consecutive ones given positive integer n  find number non-negative integers less equal n  whose binary representations contain consecutive ones  hard dynamic programming 
c++  non-dp  o(32) fibonacci solution non-negative integers without consecutive ones given positive integer n  find number non-negative integers less equal n  whose binary representations contain consecutive ones  hard dynamic programming 
c++ 4 lines dp fibonacci 6 ms non-negative integers without consecutive ones given positive integer n  find number non-negative integers less equal n  whose binary representations contain consecutive ones  hard dynamic programming 
java o(1) time o(1) space dp solution non-negative integers without consecutive ones given positive integer n  find number non-negative integers less equal n  whose binary representations contain consecutive ones  hard dynamic programming 
python dp solution easily understood non-negative integers without consecutive ones given positive integer n  find number non-negative integers less equal n  whose binary representations contain consecutive ones  hard dynamic programming 
a simple solution human traffic of stadium sql schemax city built new stadium  day many people visit stats saved columns: id  date  people please write query display records 3 consecutive rows amount people 100(inclusive)  hard 
solution using join human traffic of stadium sql schemax city built new stadium  day many people visit stats saved columns: id  date  people please write query display records 3 consecutive rows amount people 100(inclusive)  hard 
i don't understand the problem human traffic of stadium sql schemax city built new stadium  day many people visit stats saved columns: id  date  people please write query display records 3 consecutive rows amount people 100(inclusive)  hard 
wrong testcase human traffic of stadium sql schemax city built new stadium  day many people visit stats saved columns: id  date  people please write query display records 3 consecutive rows amount people 100(inclusive)  hard 
a solution with union  join and where human traffic of stadium sql schemax city built new stadium  day many people visit stats saved columns: id  date  people please write query display records 3 consecutive rows amount people 100(inclusive)  hard 
java - greedy solution - o(flowerbed) - beats 100% can place flowers suppose long flowerbed plots planted not  however  flowers cannot planted adjacent plots - would compete water would die  given flowerbed (represented array containing 0 1  0 means empty 1 means empty)  number n  return n new flowers planted without violating no-adjacent-flowers rule  easy array 
[java] very easy solution can place flowers suppose long flowerbed plots planted not  however  flowers cannot planted adjacent plots - would compete water would die  given flowerbed (represented array containing 0 1  0 means empty 1 means empty)  number n  return n new flowers planted without violating no-adjacent-flowers rule  easy array 
python  straightforward with explanation can place flowers suppose long flowerbed plots planted not  however  flowers cannot planted adjacent plots - would compete water would die  given flowerbed (represented array containing 0 1  0 means empty 1 means empty)  number n  return n new flowers planted without violating no-adjacent-flowers rule  easy array 
simplest c++ code can place flowers suppose long flowerbed plots planted not  however  flowers cannot planted adjacent plots - would compete water would die  given flowerbed (represented array containing 0 1  0 means empty 1 means empty)  number n  return n new flowers planted without violating no-adjacent-flowers rule  easy array 
[c++][java] clean code can place flowers suppose long flowerbed plots planted not  however  flowers cannot planted adjacent plots - would compete water would die  given flowerbed (represented array containing 0 1  0 means empty 1 means empty)  number n  return n new flowers planted without violating no-adjacent-flowers rule  easy array 
java solution  tree traversal construct string from binary tree need construct string consists parenthesis integers binary tree preorder traversing way  null node needs represented empty parenthesis pair "()"  need omit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree  easy string tree 
python  straightforward with explanation construct string from binary tree need construct string consists parenthesis integers binary tree preorder traversing way  null node needs represented empty parenthesis pair "()"  need omit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree  easy string tree 
java simple recursion construct string from binary tree need construct string consists parenthesis integers binary tree preorder traversing way  null node needs represented empty parenthesis pair "()"  need omit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree  easy string tree 
[java c++] 1 liner construct string from binary tree need construct string consists parenthesis integers binary tree preorder traversing way  null node needs represented empty parenthesis pair "()"  need omit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree  easy string tree 
python simple solution construct string from binary tree need construct string consists parenthesis integers binary tree preorder traversing way  null node needs represented empty parenthesis pair "()"  need omit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree  easy string tree 
c++ clean solution  answers to follow up find duplicate file in system given list directory info including directory path  files contents directory  need find groups duplicate files file system terms paths  group duplicate files consists least two files exactly content  single directory info string input list following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" means n files (f1 txt  f2 txt     fn txt content f1_content  f2_content     fn_content  respectively) directory root d1 d2     dm  note n >= 1 >= 0  = 0  means directory root directory  output list group duplicate file paths  group  contains file paths files content  file path string following format: "directory_path file_name txt" medium hash table string 
python  straightforward with explanation find duplicate file in system given list directory info including directory path  files contents directory  need find groups duplicate files file system terms paths  group duplicate files consists least two files exactly content  single directory info string input list following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" means n files (f1 txt  f2 txt     fn txt content f1_content  f2_content     fn_content  respectively) directory root d1 d2     dm  note n >= 1 >= 0  = 0  means directory root directory  output list group duplicate file paths  group  contains file paths files content  file path string following format: "directory_path file_name txt" medium hash table string 
java solution  hashmap find duplicate file in system given list directory info including directory path  files contents directory  need find groups duplicate files file system terms paths  group duplicate files consists least two files exactly content  single directory info string input list following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" means n files (f1 txt  f2 txt     fn txt content f1_content  f2_content     fn_content  respectively) directory root d1 d2     dm  note n >= 1 >= 0  = 0  means directory root directory  output list group duplicate file paths  group  contains file paths files content  file path string following format: "directory_path file_name txt" medium hash table string 
straight forward solution with a tiny bit of java8 find duplicate file in system given list directory info including directory path  files contents directory  need find groups duplicate files file system terms paths  group duplicate files consists least two files exactly content  single directory info string input list following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" means n files (f1 txt  f2 txt     fn txt content f1_content  f2_content     fn_content  respectively) directory root d1 d2     dm  note n >= 1 >= 0  = 0  means directory root directory  output list group duplicate file paths  group  contains file paths files content  file path string following format: "directory_path file_name txt" medium hash table string 
follow up questions discussion find duplicate file in system given list directory info including directory path  files contents directory  need find groups duplicate files file system terms paths  group duplicate files consists least two files exactly content  single directory info string input list following format: "root d1 d2     dm f1 txt(f1_content) f2 txt(f2_content)     fn txt(fn_content)" means n files (f1 txt  f2 txt     fn txt content f1_content  f2_content     fn_content  respectively) directory root d1 d2     dm  note n >= 1 >= 0  = 0  means directory root directory  output list group duplicate file paths  group  contains file paths files content  file path string following format: "directory_path file_name txt" medium hash table string 
java o(n^2) time o(1) space valid triangle number given array consists non-negative integers  task count number triplets chosen array make triangles take side lengths triangle  medium array 
java solution  3 pointers valid triangle number given array consists non-negative integers  task count number triplets chosen array make triangles take side lengths triangle  medium array 
o(n^2) solution for c++ & python valid triangle number given array consists non-negative integers  task count number triplets chosen array make triangles take side lengths triangle  medium array 
a similar o(n^2) solution to 3-sum  valid triangle number given array consists non-negative integers  task count number triplets chosen array make triangles take side lengths triangle  medium array 
can this problem  possibly be solved by python? valid triangle number given array consists non-negative integers  task count number triplets chosen array make triangles take side lengths triangle  medium array 
python  straightforward with explanation merge two binary trees given two binary trees imagine put one cover other  nodes two trees overlapped others not  need merge new binary tree  merge rule two nodes overlap  sum node values new value merged node  otherwise  null node used node new tree  easy tree 
java solution  6 lines  tree traversal merge two binary trees given two binary trees imagine put one cover other  nodes two trees overlapped others not  need merge new binary tree  merge rule two nodes overlap  sum node values new value merged node  otherwise  null node used node new tree  easy tree 
short recursive solution w  python & c++ merge two binary trees given two binary trees imagine put one cover other  nodes two trees overlapped others not  need merge new binary tree  merge rule two nodes overlap  sum node values new value merged node  otherwise  null node used node new tree  easy tree 
[java c++] clean code - unique node | shared node - 5 liner merge two binary trees given two binary trees imagine put one cover other  nodes two trees overlapped others not  need merge new binary tree  merge rule two nodes overlap  sum node values new value merged node  otherwise  null node used node new tree  easy tree 
java one recursive solution and two iterative solutions (dfs and bfs) with explanations merge two binary trees given two binary trees imagine put one cover other  nodes two trees overlapped others not  need merge new binary tree  merge rule two nodes overlap  sum node values new value merged node  otherwise  null node used node new tree  easy tree 
my solution not boring movies sql schemax city opened new cinema  many people would like go cinema  cinema also gives poster indicating movies’ ratings descriptions  please write sql query output movies odd numbered id description 'boring'  order result rating  easy 
judge parity using '&' not boring movies sql schemax city opened new cinema  many people would like go cinema  cinema also gives poster indicating movies’ ratings descriptions  please write sql query output movies odd numbered id description 'boring'  order result rating  easy 
my first post of sql questions! : ) not boring movies sql schemax city opened new cinema  many people would like go cinema  cinema also gives poster indicating movies’ ratings descriptions  please write sql query output movies odd numbered id description 'boring'  order result rating  easy 
the problem description could be worded better not boring movies sql schemax city opened new cinema  many people would like go cinema  cinema also gives poster indicating movies’ ratings descriptions  please write sql query output movies odd numbered id description 'boring'  order result rating  easy 
a slightly different way of solving this sql using case not boring movies sql schemax city opened new cinema  many people would like go cinema  cinema also gives poster indicating movies’ ratings descriptions  please write sql query output movies odd numbered id description 'boring'  order result rating  easy 
concise java using array design circular queue design implementation circular queue  circular queue linear data structure operations performed based fifo (first first out) principle last position connected back first position make circle  also called "ring buffer"  one benefits circular queue make use spaces front queue  normal queue  queue becomes full  cannot insert next element even space front queue  using circular queue  use space store new values  implementation support following operations: mycircularqueue(k): constructor  set size queue k  front: get front item queue  queue empty  return -1  rear: get last item queue  queue empty  return -1  enqueue(value): insert element circular queue  return true operation successful  dequeue(): delete element circular queue  return true operation successful  isempty(): checks whether circular queue empty not  isfull(): checks whether circular queue full not  medium design queue 
python short & simple ac doubly linked list solution design circular queue design implementation circular queue  circular queue linear data structure operations performed based fifo (first first out) principle last position connected back first position make circle  also called "ring buffer"  one benefits circular queue make use spaces front queue  normal queue  queue becomes full  cannot insert next element even space front queue  using circular queue  use space store new values  implementation support following operations: mycircularqueue(k): constructor  set size queue k  front: get front item queue  queue empty  return -1  rear: get last item queue  queue empty  return -1  enqueue(value): insert element circular queue  return true operation successful  dequeue(): delete element circular queue  return true operation successful  isempty(): checks whether circular queue empty not  isfull(): checks whether circular queue full not  medium design queue 
straightforward implementation in c++ [20ms] design circular queue design implementation circular queue  circular queue linear data structure operations performed based fifo (first first out) principle last position connected back first position make circle  also called "ring buffer"  one benefits circular queue make use spaces front queue  normal queue  queue becomes full  cannot insert next element even space front queue  using circular queue  use space store new values  implementation support following operations: mycircularqueue(k): constructor  set size queue k  front: get front item queue  queue empty  return -1  rear: get last item queue  queue empty  return -1  enqueue(value): insert element circular queue  return true operation successful  dequeue(): delete element circular queue  return true operation successful  isempty(): checks whether circular queue empty not  isfull(): checks whether circular queue full not  medium design queue 
java solution with explanation design circular queue design implementation circular queue  circular queue linear data structure operations performed based fifo (first first out) principle last position connected back first position make circle  also called "ring buffer"  one benefits circular queue make use spaces front queue  normal queue  queue becomes full  cannot insert next element even space front queue  using circular queue  use space store new values  implementation support following operations: mycircularqueue(k): constructor  set size queue k  front: get front item queue  queue empty  return -1  rear: get last item queue  queue empty  return -1  enqueue(value): insert element circular queue  return true operation successful  dequeue(): delete element circular queue  return true operation successful  isempty(): checks whether circular queue empty not  isfull(): checks whether circular queue full not  medium design queue 
simple java solution using doubly linked list design circular queue design implementation circular queue  circular queue linear data structure operations performed based fifo (first first out) principle last position connected back first position make circle  also called "ring buffer"  one benefits circular queue make use spaces front queue  normal queue  queue becomes full  cannot insert next element even space front queue  using circular queue  use space store new values  implementation support following operations: mycircularqueue(k): constructor  set size queue k  front: get front item queue  queue empty  return -1  rear: get last item queue  queue empty  return -1  enqueue(value): insert element circular queue  return true operation successful  dequeue(): delete element circular queue  return true operation successful  isempty(): checks whether circular queue empty not  isfull(): checks whether circular queue full not  medium design queue 
[c++] [java] 10 line solution - no helper add one row to tree given root binary tree  value v depth d  need add row nodes value v given depth d  root node depth 1  adding rule is: given positive integer depth d  null tree nodes n depth d-1  create two tree nodes value v n's left subtree root right subtree root  n's original left subtree left subtree new left subtree root  original right subtree right subtree new right subtree root  depth 1 means depth d-1 all  create tree node value v new root whole original tree  original tree new root's left subtree  medium tree 
java  three methods  one bfs and two dfs add one row to tree given root binary tree  value v depth d  need add row nodes value v given depth d  root node depth 1  adding rule is: given positive integer depth d  null tree nodes n depth d-1  create two tree nodes value v n's left subtree root right subtree root  n's original left subtree left subtree new left subtree root  original right subtree right subtree new right subtree root  depth 1 means depth d-1 all  create tree node value v new root whole original tree  original tree new root's left subtree  medium tree 
short python bfs add one row to tree given root binary tree  value v depth d  need add row nodes value v given depth d  root node depth 1  adding rule is: given positive integer depth d  null tree nodes n depth d-1  create two tree nodes value v n's left subtree root right subtree root  n's original left subtree left subtree new left subtree root  original right subtree right subtree new right subtree root  depth 1 means depth d-1 all  create tree node value v new root whole original tree  original tree new root's left subtree  medium tree 
simple java solution - o(n) add one row to tree given root binary tree  value v depth d  need add row nodes value v given depth d  root node depth 1  adding rule is: given positive integer depth d  null tree nodes n depth d-1  create two tree nodes value v n's left subtree root right subtree root  n's original left subtree left subtree new left subtree root  original right subtree right subtree new right subtree root  depth 1 means depth d-1 all  create tree node value v new root whole original tree  original tree new root's left subtree  medium tree 
simple c++ solution add one row to tree given root binary tree  value v depth d  need add row nodes value v given depth d  root node depth 1  adding rule is: given positive integer depth d  null tree nodes n depth d-1  create two tree nodes value v n's left subtree root right subtree root  n's original left subtree left subtree new left subtree root  original right subtree right subtree new right subtree root  depth 1 means depth d-1 all  create tree node value v new root whole original tree  original tree new root's left subtree  medium tree 
4 line solution using if statement exchange seats sql schemamary teacher middle school table seat storing students' names corresponding seat ids  column id continuous increment  mary wants change seats adjacent students  write sql query output result mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ sample input  output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: number students odd  need change last one's seat  medium 
using two union operators exchange seats sql schemamary teacher middle school table seat storing students' names corresponding seat ids  column id continuous increment  mary wants change seats adjacent students  write sql query output result mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ sample input  output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: number students odd  need change last one's seat  medium 
a solution without using union and order by exchange seats sql schemamary teacher middle school table seat storing students' names corresponding seat ids  column id continuous increment  mary wants change seats adjacent students  write sql query output result mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ sample input  output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: number students odd  need change last one's seat  medium 
simple case solution exchange seats sql schemamary teacher middle school table seat storing students' names corresponding seat ids  column id continuous increment  mary wants change seats adjacent students  write sql query output result mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ sample input  output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: number students odd  need change last one's seat  medium 
a simple solution exchange seats sql schemamary teacher middle school table seat storing students' names corresponding seat ids  column id continuous increment  mary wants change seats adjacent students  write sql query output result mary? +---------+---------+ | id | student | +---------+---------+ | 1 | abbot | | 2 | doris | | 3 | emerson | | 4 | green | | 5 | jeames | +---------+---------+ sample input  output is: +---------+---------+ | id | student | +---------+---------+ | 1 | doris | | 2 | abbot | | 3 | green | | 4 | emerson | | 5 | jeames | +---------+---------+ note: number students odd  need change last one's seat  medium 
accept solution with xor swap salary sql schemagiven table salary  one below  m=male f=female values  swap f values (i e   change f values vice versa) single update query intermediate temp table  easy 
short and simple swap salary sql schemagiven table salary  one below  m=male f=female values  swap f values (i e   change f values vice versa) single update query intermediate temp table  easy 
simple and short with if swap salary sql schemagiven table salary  one below  m=male f=female values  swap f values (i e   change f values vice versa) single update query intermediate temp table  easy 
solution using ascii code swap salary sql schemagiven table salary  one below  m=male f=female values  swap f values (i e   change f values vice versa) single update query intermediate temp table  easy 
the solution with multiplication and division of ascii codes swap salary sql schemagiven table salary  one below  m=male f=female values  swap f values (i e   change f values vice versa) single update query intermediate temp table  easy 
java o(1) space o(n) time solution beat 100% maximum product of three numbers given integer array  find three numbers whose product maximum output maximum product  easy array math 
java easy ac    maximum product of three numbers given integer array  find three numbers whose product maximum output maximum product  easy array math 
python concise solution  o(n) and 1 line maximum product of three numbers given integer array  find three numbers whose product maximum output maximum product  easy array math 
share my python solution: one pass  o(n) time o(1) space maximum product of three numbers given integer array  find three numbers whose product maximum output maximum product  easy array math 
general solution for any k  maximum product of three numbers given integer array  find three numbers whose product maximum output maximum product  easy array math 
java dp o(nk) solution k inverse pairs array given two integers n k  find many different arrays consist numbers 1 n exactly k inverse pairs  define inverse pair following: ith jth element array  < j a[i] > a[j] inverse pair; otherwise  not  since answer may large  answer modulo 109 + 7  hard dynamic programming 
shared my c++ o(n   k) solution with explanation k inverse pairs array given two integers n k  find many different arrays consist numbers 1 n exactly k inverse pairs  define inverse pair following: ith jth element array  < j a[i] > a[j] inverse pair; otherwise  not  since answer may large  answer modulo 109 + 7  hard dynamic programming 
python  straightforward with explanation k inverse pairs array given two integers n k  find many different arrays consist numbers 1 n exactly k inverse pairs  define inverse pair following: ith jth element array  < j a[i] > a[j] inverse pair; otherwise  not  since answer may large  answer modulo 109 + 7  hard dynamic programming 
python concise solution k inverse pairs array given two integers n k  find many different arrays consist numbers 1 n exactly k inverse pairs  define inverse pair following: ith jth element array  < j a[i] > a[j] inverse pair; otherwise  not  since answer may large  answer modulo 109 + 7  hard dynamic programming 
java dp thank you so much @gardenaaa for your advice  k inverse pairs array given two integers n k  find many different arrays consist numbers 1 n exactly k inverse pairs  define inverse pair following: ith jth element array  < j a[i] > a[j] inverse pair; otherwise  not  since answer may large  answer modulo 109 + 7  hard dynamic programming 
short java code using priorityqueue course schedule iii n different online courses numbered 1 n  course duration(course length) closed dth day  course taken continuously days must finished dth day  start 1st day  given n online courses represented pairs (t d)  task find maximal number courses taken  hard greedy 
python  straightforward with explanation course schedule iii n different online courses numbered 1 n  course duration(course length) closed dth day  course taken continuously days must finished dth day  start 1st day  given n online courses represented pairs (t d)  task find maximal number courses taken  hard greedy 
c++ 13 lines with explanation course schedule iii n different online courses numbered 1 n  course duration(course length) closed dth day  course taken continuously days must finished dth day  start 1st day  given n online courses represented pairs (t d)  task find maximal number courses taken  hard greedy 
c++ short & elegant o(nlogn) time  o(k) space solution course schedule iii n different online courses numbered 1 n  course duration(course length) closed dth day  course taken continuously days must finished dth day  start 1st day  given n online courses represented pairs (t d)  task find maximal number courses taken  hard greedy 
c++ short code using priority queue  o(nlogn) course schedule iii n different online courses numbered 1 n  course duration(course length) closed dth day  course taken continuously days must finished dth day  start 1st day  given n online courses represented pairs (t d)  task find maximal number courses taken  hard greedy 
java code using priorityqueue  similar to merge k array smallest range k lists sorted integers ascending order  find smallest range includes least one number k lists  define range [a b] smaller range [c d] b-a < d-c < c b-a == d-c  hard hash table two pointers string 
python  heap-based solution smallest range k lists sorted integers ascending order  find smallest range includes least one number k lists  define range [a b] smaller range [c d] b-a < d-c < c b-a == d-c  hard hash table two pointers string 
clean c++ priority_queue solution using iterators smallest range k lists sorted integers ascending order  find smallest range includes least one number k lists  define range [a b] smaller range [c d] b-a < d-c < c b-a == d-c  hard hash table two pointers string 
java 8  sliding window smallest range k lists sorted integers ascending order  find smallest range includes least one number k lists  define range [a b] smaller range [c d] b-a < d-c < c b-a == d-c  hard hash table two pointers string 
java solution with maxheap&minheap smallest range k lists sorted integers ascending order  find smallest range includes least one number k lists  define range [a b] smaller range [c d] b-a < d-c < c b-a == d-c  hard hash table two pointers string 
java two pointers solution sum of square numbers given non-negative integer c  task decide whether there're two integers b a2 + b2 = c  easy math 
hashset  java  quick solution  one for loop sum of square numbers given non-negative integer c  task decide whether there're two integers b a2 + b2 = c  easy math 
python  straightforward with explanation sum of square numbers given non-negative integer c  task decide whether there're two integers b a2 + b2 = c  easy math 
fermat sum of square numbers given non-negative integer c  task decide whether there're two integers b a2 + b2 = c  easy math 
c++ very simple o(1) space solution sum of square numbers given non-negative integer c  task decide whether there're two integers b a2 + b2 = c  easy math 
java stack solution o(n) time o(n) space exclusive time of functions given running logs n functions executed nonpreemptive single threaded cpu  find exclusive time functions  function unique id  start 0 n-1  function may called recursively another function  log string format : function_id:start_or_end:timestamp  medium stack 
python  straightforward with explanation exclusive time of functions given running logs n functions executed nonpreemptive single threaded cpu  find exclusive time functions  function unique id  start 0 n-1  function may called recursively another function  log string format : function_id:start_or_end:timestamp  medium stack 
how is function 1 executing 4 units of time? exclusive time of functions given running logs n functions executed nonpreemptive single threaded cpu  find exclusive time functions  function unique id  start 0 n-1  function may called recursively another function  log string format : function_id:start_or_end:timestamp  medium stack 
c++ o(n) stack with explaination exclusive time of functions given running logs n functions executed nonpreemptive single threaded cpu  find exclusive time functions  function unique id  start 0 n-1  function may called recursively another function  log string format : function_id:start_or_end:timestamp  medium stack 
java clean solution with normalized time explained exclusive time of functions given running logs n functions executed nonpreemptive single threaded cpu  find exclusive time functions  function unique id  start 0 n-1  function may called recursively another function  log string format : function_id:start_or_end:timestamp  medium stack 
java bfs solution average of levels in binary tree given non-empty binary tree  return average value nodes level form array  easy tree 
a good problem to practice (bfs + dfs) average of levels in binary tree given non-empty binary tree  return average value nodes level form array  easy tree 
c++ simple and clear bfs solution average of levels in binary tree given non-empty binary tree  return average value nodes level form array  easy tree 
python  straightforward with explanation average of levels in binary tree given non-empty binary tree  return average value nodes level form array  easy tree 
"one-liner" average of levels in binary tree given non-empty binary tree  return average value nodes level form array  easy tree 
very easy to understand java solution beats 95% with explanation shopping offers leetcode store  kinds items sell  item price  however  special offers  special offer consists one different kinds items sale price  given item's price  set special offers  number need buy item  job output lowest price pay exactly certain items given  could make optimal use special offers  special offer represented form array  last number represents price need pay special offer  numbers represents many specific items could get buy offer  could use special offers many times want  medium dynamic programming depth-first search 
concise c++ dfs solution  6ms shopping offers leetcode store  kinds items sell  item price  however  special offers  special offer consists one different kinds items sale price  given item's price  set special offers  number need buy item  job output lowest price pay exactly certain items given  could make optimal use special offers  special offer represented form array  last number represents price need pay special offer  numbers represents many specific items could get buy offer  could use special offers many times want  medium dynamic programming depth-first search 
simple java recursive solution shopping offers leetcode store  kinds items sell  item price  however  special offers  special offer consists one different kinds items sale price  given item's price  set special offers  number need buy item  job output lowest price pay exactly certain items given  could make optimal use special offers  special offer represented form array  last number represents price need pay special offer  numbers represents many specific items could get buy offer  could use special offers many times want  medium dynamic programming depth-first search 
java dfs + dp shopping offers leetcode store  kinds items sell  item price  however  special offers  special offer consists one different kinds items sale price  given item's price  set special offers  number need buy item  job output lowest price pay exactly certain items given  could make optimal use special offers  special offer represented form array  last number represents price need pay special offer  numbers represents many specific items could get buy offer  could use special offers many times want  medium dynamic programming depth-first search 
python dfs with memorization  shopping offers leetcode store  kinds items sell  item price  however  special offers  special offer consists one different kinds items sale price  given item's price  set special offers  number need buy item  job output lowest price pay exactly certain items given  could make optimal use special offers  special offer represented form array  last number represents price need pay special offer  numbers represents many specific items could get buy offer  could use special offers many times want  medium dynamic programming depth-first search 
java o(n) by general solution for all dp problems decode ways ii message containing letters a-z encoded numbers using following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  encoded string also contain character ' '  treated one numbers 1 9  given encoded message containing digits character ' '  return total number ways decode it  also  since answer may large  return output mod 109 + 7  hard dynamic programming 
python  straightforward with explanation decode ways ii message containing letters a-z encoded numbers using following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  encoded string also contain character ' '  treated one numbers 1 9  given encoded message containing digits character ' '  return total number ways decode it  also  since answer may large  return output mod 109 + 7  hard dynamic programming 
java dp  o(n) time and o(1) space decode ways ii message containing letters a-z encoded numbers using following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  encoded string also contain character ' '  treated one numbers 1 9  given encoded message containing digits character ' '  return total number ways decode it  also  since answer may large  return output mod 109 + 7  hard dynamic programming 
c++  dp  o(n) time o(1) space decode ways ii message containing letters a-z encoded numbers using following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  encoded string also contain character ' '  treated one numbers 1 9  given encoded message containing digits character ' '  return total number ways decode it  also  since answer may large  return output mod 109 + 7  hard dynamic programming 
python 6-lines dp solution decode ways ii message containing letters a-z encoded numbers using following mapping way: 'a' -> 1 'b' -> 2     'z' -> 26 beyond that  encoded string also contain character ' '  treated one numbers 1 9  given encoded message containing digits character ' '  return total number ways decode it  also  since answer may large  return output mod 109 + 7  hard dynamic programming 
concise java solution solve the equation solve given equation return value x form string "x=#value"  equation contains '+'  '-' operation  variable x coefficient  solution equation  return "no solution"  infinite solutions equation  return "infinite solutions"  exactly one solution equation  ensure value x integer  medium math 
simple 2-liner (and more) solve the equation solve given equation return value x form string "x=#value"  equation contains '+'  '-' operation  variable x coefficient  solution equation  return "no solution"  infinite solutions equation  return "infinite solutions"  exactly one solution equation  ensure value x integer  medium math 
c++  two pointers  concise solution solve the equation solve given equation return value x form string "x=#value"  equation contains '+'  '-' operation  variable x coefficient  solution equation  return "no solution"  infinite solutions equation  return "infinite solutions"  exactly one solution equation  ensure value x integer  medium math 
python regex solution explained solve the equation solve given equation return value x form string "x=#value"  equation contains '+'  '-' operation  variable x coefficient  solution equation  return "no solution"  infinite solutions equation  return "infinite solutions"  exactly one solution equation  ensure value x integer  medium math 
clear java code with detailed example solve the equation solve given equation return value x form string "x=#value"  equation contains '+'  '-' operation  variable x coefficient  solution equation  return "no solution"  infinite solutions equation  return "infinite solutions"  exactly one solution equation  ensure value x integer  medium math 
c++ 99% ring buffer no edge cases  fb interviewer really loves it  easy to impl in 4mins  cheers! design circular deque design implementation circular double-ended queue (deque)  implementation support following operations: mycirculardeque(k): constructor  set size deque k  insertfront(): adds item front deque  return true operation successful  insertlast(): adds item rear deque  return true operation successful  deletefront(): deletes item front deque  return true operation successful  deletelast(): deletes item rear deque  return true operation successful  getfront(): gets front item deque  deque empty  return -1  getrear(): gets last item deque  deque empty  return -1  isempty(): checks whether deque empty not  isfull(): checks whether deque full not  medium design queue 
java doubly linkedlist  solution  very straightforward design circular deque design implementation circular double-ended queue (deque)  implementation support following operations: mycirculardeque(k): constructor  set size deque k  insertfront(): adds item front deque  return true operation successful  insertlast(): adds item rear deque  return true operation successful  deletefront(): deletes item front deque  return true operation successful  deletelast(): deletes item rear deque  return true operation successful  getfront(): gets front item deque  deque empty  return -1  getrear(): gets last item deque  deque empty  return -1  isempty(): checks whether deque empty not  isfull(): checks whether deque full not  medium design queue 
is the example return value correct  and why circular? design circular deque design implementation circular double-ended queue (deque)  implementation support following operations: mycirculardeque(k): constructor  set size deque k  insertfront(): adds item front deque  return true operation successful  insertlast(): adds item rear deque  return true operation successful  deletefront(): deletes item front deque  return true operation successful  deletelast(): deletes item rear deque  return true operation successful  getfront(): gets front item deque  deque empty  return -1  getrear(): gets last item deque  deque empty  return -1  isempty(): checks whether deque empty not  isfull(): checks whether deque full not  medium design queue 
straightforward w  array in java(corner cases) design circular deque design implementation circular double-ended queue (deque)  implementation support following operations: mycirculardeque(k): constructor  set size deque k  insertfront(): adds item front deque  return true operation successful  insertlast(): adds item rear deque  return true operation successful  deletefront(): deletes item front deque  return true operation successful  deletelast(): deletes item rear deque  return true operation successful  getfront(): gets front item deque  deque empty  return -1  getrear(): gets last item deque  deque empty  return -1  isempty(): checks whether deque empty not  isfull(): checks whether deque full not  medium design queue 
python3  using list  easy to understand design circular deque design implementation circular double-ended queue (deque)  implementation support following operations: mycirculardeque(k): constructor  set size deque k  insertfront(): adds item front deque  return true operation successful  insertlast(): adds item rear deque  return true operation successful  deletefront(): deletes item front deque  return true operation successful  deletelast(): deletes item rear deque  return true operation successful  getfront(): gets front item deque  deque empty  return -1  getrear(): gets last item deque  deque empty  return -1  isempty(): checks whether deque empty not  isfull(): checks whether deque full not  medium design queue 
java solution  sum of sliding window maximum average subarray i given array consisting n integers  find contiguous subarray given length k maximum average value  need output maximum average value  easy array 
python  straightforward with explanation maximum average subarray i given array consisting n integers  find contiguous subarray given length k maximum average value  need output maximum average value  easy array 
2 lines python  2 versions maximum average subarray i given array consisting n integers  find contiguous subarray given length k maximum average value  need output maximum average value  easy array 
c++ simple sliding-window solution maximum average subarray i given array consisting n integers  find contiguous subarray given length k maximum average value  need output maximum average value  easy array 
simple java solution - sliding window maximum average subarray i given array consisting n integers  find contiguous subarray given length k maximum average value  need output maximum average value  easy array 
java o(n) time o(1) space set mismatch set originally contains numbers 1 n  unfortunately  due data error  one numbers set got duplicated another number set  results repetition one number loss another number  given array nums representing data status set error  task firstly find number occurs twice find number missing  return form array  easy hash table math 
[c++] 6 lines solution with explanation set mismatch set originally contains numbers 1 n  unfortunately  due data error  one numbers set got duplicated another number set  results repetition one number loss another number  given array nums representing data status set error  task firstly find number occurs twice find number missing  return form array  easy hash table math 
xor  one pass set mismatch set originally contains numbers 1 n  unfortunately  due data error  one numbers set got duplicated another number set  results repetition one number loss another number  given array nums representing data status set error  task firstly find number occurs twice find number missing  return form array  easy hash table math 
python  straightforward with explanation set mismatch set originally contains numbers 1 n  unfortunately  due data error  one numbers set got duplicated another number set  results repetition one number loss another number  given array nums representing data status set error  task firstly find number occurs twice find number missing  return form array  easy hash table math 
simple java o(n) solution - hashset set mismatch set originally contains numbers 1 n  unfortunately  due data error  one numbers set got duplicated another number set  results repetition one number loss another number  given array nums representing data status set error  task firstly find number occurs twice find number missing  return form array  easy hash table math 
easy dp maximum length of pair chain given n pairs numbers  every pair  first number always smaller second number  now  define pair (c  d) follow another pair (a  b) b < c  chain pairs formed fashion  given set pairs  find length longest chain formed  use given pairs  select pairs order  medium dynamic programming 
4-liner python greedy maximum length of pair chain given n pairs numbers  every pair  first number always smaller second number  now  define pair (c  d) follow another pair (a  b) b < c  chain pairs formed fashion  given set pairs  find length longest chain formed  use given pairs  select pairs order  medium dynamic programming 
java o(nlog(n)) time o(1) space maximum length of pair chain given n pairs numbers  every pair  first number always smaller second number  now  define pair (c  d) follow another pair (a  b) b < c  chain pairs formed fashion  given set pairs  find length longest chain formed  use given pairs  select pairs order  medium dynamic programming 
[c++] clean code maximum length of pair chain given n pairs numbers  every pair  first number always smaller second number  now  define pair (c  d) follow another pair (a  b) b < c  chain pairs formed fashion  given set pairs  find length longest chain formed  use given pairs  select pairs order  medium dynamic programming 
[java] very simple without dp maximum length of pair chain given n pairs numbers  every pair  first number always smaller second number  now  define pair (c  d) follow another pair (a  b) b < c  chain pairs formed fashion  given set pairs  find length longest chain formed  use given pairs  select pairs order  medium dynamic programming 
java solution  8 lines  extendpalindrome palindromic substrings given string  task count many palindromic substrings string  substrings different start indexes end indexes counted different substrings even consist characters  medium string dynamic programming 
very simple java solution with detail explanation palindromic substrings given string  task count many palindromic substrings string  substrings different start indexes end indexes counted different substrings even consist characters  medium string dynamic programming 
java dp solution based on longest palindromic substring palindromic substrings given string  task count many palindromic substrings string  substrings different start indexes end indexes counted different substrings even consist characters  medium string dynamic programming 
python  straightforward with explanation (bonus o(n) solution) palindromic substrings given string  task count many palindromic substrings string  substrings different start indexes end indexes counted different substrings even consist characters  medium string dynamic programming 
[java c++] 6 lines solution - no dp palindromic substrings given string  task count many palindromic substrings string  substrings different start indexes end indexes counted different substrings even consist characters  medium string dynamic programming 
java simple classical trie question solution (beat 96%) replace words english  concept called root  followed words form another longer word - let's call word successor  medium hash table trie 
python  straightforward with explanation (prefix hash  trie solutions) replace words english  concept called root  followed words form another longer word - let's call word successor  medium hash table trie 
java solution  12 lines  hashset replace words english  concept called root  followed words form another longer word - let's call word successor  medium hash table trie 
simple java 8 and trie based solution replace words english  concept called root  followed words form another longer word - let's call word successor  medium hash table trie 
easy python solution  6 lines replace words english  concept called root  followed words form another longer word - let's call word successor  medium hash table trie 
[java c++] very simple greedy solution with explanation dota2 senate world dota2  two parties: radiant dire  dota2 senate consists senators coming two parties  senate wants make decision change dota2 game  voting change round-based procedure  round  senator exercise one two rights: ban one senator's right: senator make another senator lose rights following rounds  announce victory: senator found senators still rights vote party  announce victory make decision change game  given string representing senator's party belonging  character 'r' 'd' represent radiant party dire party respectively  n senators  size given string n  round-based procedure starts first senator last senator given order  procedure last end voting  senators lost rights skipped procedure  suppose every senator smart enough play best strategy party  need predict party finally announce victory make change dota2 game  output radiant dire  medium greedy 
python  straightforward with explanation dota2 senate world dota2  two parties: radiant dire  dota2 senate consists senators coming two parties  senate wants make decision change dota2 game  voting change round-based procedure  round  senator exercise one two rights: ban one senator's right: senator make another senator lose rights following rounds  announce victory: senator found senators still rights vote party  announce victory make decision change game  given string representing senator's party belonging  character 'r' 'd' represent radiant party dire party respectively  n senators  size given string n  round-based procedure starts first senator last senator given order  procedure last end voting  senators lost rights skipped procedure  suppose every senator smart enough play best strategy party  need predict party finally announce victory make change dota2 game  output radiant dire  medium greedy 
java solution  greedy dota2 senate world dota2  two parties: radiant dire  dota2 senate consists senators coming two parties  senate wants make decision change dota2 game  voting change round-based procedure  round  senator exercise one two rights: ban one senator's right: senator make another senator lose rights following rounds  announce victory: senator found senators still rights vote party  announce victory make decision change game  given string representing senator's party belonging  character 'r' 'd' represent radiant party dire party respectively  n senators  size given string n  round-based procedure starts first senator last senator given order  procedure last end voting  senators lost rights skipped procedure  suppose every senator smart enough play best strategy party  need predict party finally announce victory make change dota2 game  output radiant dire  medium greedy 
c++  o(n) solution dota2 senate world dota2  two parties: radiant dire  dota2 senate consists senators coming two parties  senate wants make decision change dota2 game  voting change round-based procedure  round  senator exercise one two rights: ban one senator's right: senator make another senator lose rights following rounds  announce victory: senator found senators still rights vote party  announce victory make decision change game  given string representing senator's party belonging  character 'r' 'd' represent radiant party dire party respectively  n senators  size given string n  round-based procedure starts first senator last senator given order  procedure last end voting  senators lost rights skipped procedure  suppose every senator smart enough play best strategy party  need predict party finally announce victory make change dota2 game  output radiant dire  medium greedy 
confusion about the logic dota2 senate world dota2  two parties: radiant dire  dota2 senate consists senators coming two parties  senate wants make decision change dota2 game  voting change round-based procedure  round  senator exercise one two rights: ban one senator's right: senator make another senator lose rights following rounds  announce victory: senator found senators still rights vote party  announce victory make decision change game  given string representing senator's party belonging  character 'r' 'd' represent radiant party dire party respectively  n senators  size given string n  round-based procedure starts first senator last senator given order  procedure last end voting  senators lost rights skipped procedure  suppose every senator smart enough play best strategy party  need predict party finally announce victory make change dota2 game  output radiant dire  medium greedy 
java dp solution 2 keys keyboard initially notepad one character 'a' present  perform two operations notepad step: copy all: copy characters present notepad (partial copy allowed)  paste: paste characters copied last time  given number n  get exactly n 'a' notepad performing minimum number steps permitted  output minimum number steps get n 'a'  medium dynamic programming 
loop best case log(n)  no dp  no extra space  no recursion  with explanation 2 keys keyboard initially notepad one character 'a' present  perform two operations notepad step: copy all: copy characters present notepad (partial copy allowed)  paste: paste characters copied last time  given number n  get exactly n 'a' notepad performing minimum number steps permitted  output minimum number steps get n 'a'  medium dynamic programming 
very simple java solution with detail explanation 2 keys keyboard initially notepad one character 'a' present  perform two operations notepad step: copy all: copy characters present notepad (partial copy allowed)  paste: paste characters copied last time  given number n  get exactly n 'a' notepad performing minimum number steps permitted  output minimum number steps get n 'a'  medium dynamic programming 
[java c++] clean code with explanation - 4 lines  no dp 2 keys keyboard initially notepad one character 'a' present  perform two operations notepad step: copy all: copy characters present notepad (partial copy allowed)  paste: paste characters copied last time  given number n  get exactly n 'a' notepad performing minimum number steps permitted  output minimum number steps get n 'a'  medium dynamic programming 
java solutions from naive-dp to optimized-dp to non-dp 2 keys keyboard initially notepad one character 'a' present  perform two operations notepad step: copy all: copy characters present notepad (partial copy allowed)  paste: paste characters copied last time  given number n  get exactly n 'a' notepad performing minimum number steps permitted  output minimum number steps get n 'a'  medium dynamic programming 
java concise postorder traversal solution find duplicate subtrees given binary tree  return duplicate subtrees  kind duplicate subtrees  need return root node one them  two trees duplicate structure node values  medium tree 
o(n) time and space  lots of analysis find duplicate subtrees given binary tree  return duplicate subtrees  kind duplicate subtrees  need return root node one them  two trees duplicate structure node values  medium tree 
[c++] [java] clean code find duplicate subtrees given binary tree  return duplicate subtrees  kind duplicate subtrees  need return root node one them  two trees duplicate structure node values  medium tree 
python easy understand solution find duplicate subtrees given binary tree  return duplicate subtrees  kind duplicate subtrees  need return root node one them  two trees duplicate structure node values  medium tree 
verbose java solution  tree traversal find duplicate subtrees given binary tree  return duplicate subtrees  kind duplicate subtrees  need return root node one them  two trees duplicate structure node values  medium tree 
[java c++] three simple methods - choose one you like two sum iv - input is a bst given binary search tree target number  return true exist two elements bst sum equal given target  easy tree 
[c++] clean code - o(n) time o(lg n) space - binarytree iterator two sum iv - input is a bst given binary search tree target number  return true exist two elements bst sum equal given target  easy tree 
java simple ac with time o(n) space o(log n) in average two sum iv - input is a bst given binary search tree target number  return true exist two elements bst sum equal given target  easy tree 
c++ python straight forward solution two sum iv - input is a bst given binary search tree target number  return true exist two elements bst sum equal given target  easy tree 
java code - o(n) time   o(lg(n)) space using dfs + stack two sum iv - input is a bst given binary search tree target number  return true exist two elements bst sum equal given target  easy tree 
c++ o(n) solution maximum binary tree given integer array duplicates  maximum tree building array defined follow: root maximum number array  left subtree maximum tree constructed left part subarray divided maximum number  right subtree maximum tree constructed right part subarray divided maximum number  construct maximum tree given array output root node tree  medium tree 
java worst case o(n) solution maximum binary tree given integer array duplicates  maximum tree building array defined follow: root maximum number array  left subtree maximum tree constructed left part subarray divided maximum number  right subtree maximum tree constructed right part subarray divided maximum number  construct maximum tree given array output root node tree  medium tree 
java solution  recursion maximum binary tree given integer array duplicates  maximum tree building array defined follow: root maximum number array  left subtree maximum tree constructed left part subarray divided maximum number  right subtree maximum tree constructed right part subarray divided maximum number  construct maximum tree given array output root node tree  medium tree 
c++ 9 lines o(n log n) map  plus stack with binary search maximum binary tree given integer array duplicates  maximum tree building array defined follow: root maximum number array  left subtree maximum tree constructed left part subarray divided maximum number  right subtree maximum tree constructed right part subarray divided maximum number  construct maximum tree given array output root node tree  medium tree 
poor quality question maximum binary tree given integer array duplicates  maximum tree building array defined follow: root maximum number array  left subtree maximum tree constructed left part subarray divided maximum number  right subtree maximum tree constructed right part subarray divided maximum number  construct maximum tree given array output root node tree  medium tree 
python one liner robot return to origin robot starting position (0  0)  origin  2d plane  given sequence moves  judge robot ends (0  0) completes moves  move sequence represented string  character moves[i] represents ith move  valid moves r (right)  l (left)  u (up)  (down)  robot returns origin finishes moves  return true  otherwise  return false  note: way robot "facing" irrelevant  "r" always make robot move right once  "l" always make move left  etc  also  assume magnitude robot's movement move  easy string 
[c++] [java] clean code robot return to origin robot starting position (0  0)  origin  2d plane  given sequence moves  judge robot ends (0  0) completes moves  move sequence represented string  character moves[i] represents ith move  valid moves r (right)  l (left)  u (up)  (down)  robot returns origin finishes moves  return true  otherwise  return false  note: way robot "facing" irrelevant  "r" always make robot move right once  "l" always make move left  etc  also  assume magnitude robot's movement move  easy string 
if you can't describe the problem in a right way  please don't make it a problem  robot return to origin robot starting position (0  0)  origin  2d plane  given sequence moves  judge robot ends (0  0) completes moves  move sequence represented string  character moves[i] represents ith move  valid moves r (right)  l (left)  u (up)  (down)  robot returns origin finishes moves  return true  otherwise  return false  note: way robot "facing" irrelevant  "r" always make robot move right once  "l" always make move left  etc  also  assume magnitude robot's movement move  easy string 
2 lines python robot return to origin robot starting position (0  0)  origin  2d plane  given sequence moves  judge robot ends (0  0) completes moves  move sequence represented string  character moves[i] represents ith move  valid moves r (right)  l (left)  u (up)  (down)  robot returns origin finishes moves  return true  otherwise  return false  note: way robot "facing" irrelevant  "r" always make robot move right once  "l" always make move left  etc  also  assume magnitude robot's movement move  easy string 
easy 2 lines java robot return to origin robot starting position (0  0)  origin  2d plane  given sequence moves  judge robot ends (0  0) completes moves  move sequence represented string  character moves[i] represents ith move  valid moves r (right)  l (left)  u (up)  (down)  robot returns origin finishes moves  return true  otherwise  return false  note: way robot "facing" irrelevant  "r" always make robot move right once  "l" always make move left  etc  also  assume magnitude robot's movement move  easy string 
java o(n) time o(n) space split array into consecutive subsequences given integer array sorted ascending order (may contain duplicates)  need split several subsequences  subsequences consist least 3 consecutive integers  return whether make split  medium heap greedy 
java o(n) time & o(1) space solution -- greedily extending shorter subsequence split array into consecutive subsequences given integer array sorted ascending order (may contain duplicates)  need split several subsequences  subsequences consist least 3 consecutive integers  return whether make split  medium heap greedy 
c++ o(n) solution  two pass split array into consecutive subsequences given integer array sorted ascending order (may contain duplicates)  need split several subsequences  subsequences consist least 3 consecutive integers  return whether make split  medium heap greedy 
python esay understand solution split array into consecutive subsequences given integer array sorted ascending order (may contain duplicates)  need split several subsequences  subsequences consist least 3 consecutive integers  return whether make split  medium heap greedy 
simple c++ greedy o(nlogn) solution (with explanation) split array into consecutive subsequences given integer array sorted ascending order (may contain duplicates)  need split several subsequences  subsequences consist least 3 consecutive integers  return whether make split  medium heap greedy 
c++ o(1) space using "game of life" idea image smoother given 2d integer matrix representing gray scale image  need design smoother make gray scale cell becomes average gray scale (rounding down) 8 surrounding cells itself  cell less 8 surrounding cells  use many can  easy array 
very clean solution in java image smoother given 2d integer matrix representing gray scale image  need design smoother make gray scale cell becomes average gray scale (rounding down) 8 surrounding cells itself  cell less 8 surrounding cells  use many can  easy array 
straightforward python solution image smoother given 2d integer matrix representing gray scale image  need design smoother make gray scale cell becomes average gray scale (rounding down) 8 surrounding cells itself  cell less 8 surrounding cells  use many can  easy array 
don't understand the question and sample output image smoother given 2d integer matrix representing gray scale image  need design smoother make gray scale cell becomes average gray scale (rounding down) 8 surrounding cells itself  cell less 8 surrounding cells  use many can  easy array 
python o(m n) image smoother given 2d integer matrix representing gray scale image  need design smoother make gray scale cell becomes average gray scale (rounding down) 8 surrounding cells itself  cell less 8 surrounding cells  use many can  easy array 
[java c++] very simple dfs solution maximum width of binary tree given binary tree  write function get maximum width given tree  width tree maximum width among levels  binary tree structure full binary tree  nodes null  width one level defined length end-nodes (the leftmost right non-null nodes level  null nodes end-nodes also counted length calculation  medium tree 
[c++ java]   [bfs dfs 3liner] clean code  with explanation maximum width of binary tree given binary tree  write function get maximum width given tree  width tree maximum width among levels  binary tree structure full binary tree  nodes null  width one level defined length end-nodes (the leftmost right non-null nodes level  null nodes end-nodes also counted length calculation  medium tree 
java one queue solution with hashmap maximum width of binary tree given binary tree  write function get maximum width given tree  width tree maximum width among levels  binary tree structure full binary tree  nodes null  width one level defined length end-nodes (the leftmost right non-null nodes level  null nodes end-nodes also counted length calculation  medium tree 
java uff0clevel traversal using two queue maximum width of binary tree given binary tree  write function get maximum width given tree  width tree maximum width among levels  binary tree structure full binary tree  nodes null  width one level defined length end-nodes (the leftmost right non-null nodes level  null nodes end-nodes also counted length calculation  medium tree 
python  straightforward bfs and dfs solutions maximum width of binary tree given binary tree  write function get maximum width given tree  width tree maximum width among levels  binary tree structure full binary tree  nodes null  width one level defined length end-nodes (the leftmost right non-null nodes level  null nodes end-nodes also counted length calculation  medium tree 
java o(n^3) dp solution with explanation and simple optimization strange printer strange printer following two special requirements: printer print sequence character time  turn  printer print new characters starting ending places  cover original existing characters  given string consists lower english letters only  job count minimum number turns printer needed order print it  hard dynamic programming depth-first search 
java solution  dp strange printer strange printer following two special requirements: printer print sequence character time  turn  printer print new characters starting ending places  cover original existing characters  given string consists lower english letters only  job count minimum number turns printer needed order print it  hard dynamic programming depth-first search 
python  straightforward dp with explanation strange printer strange printer following two special requirements: printer print sequence character time  turn  printer print new characters starting ending places  cover original existing characters  given string consists lower english letters only  job count minimum number turns printer needed order print it  hard dynamic programming depth-first search 
java o(n^3) short dp solution strange printer strange printer following two special requirements: printer print sequence character time  turn  printer print new characters starting ending places  cover original existing characters  given string consists lower english letters only  job count minimum number turns printer needed order print it  hard dynamic programming depth-first search 
same as remove boxes strange printer strange printer following two special requirements: printer print sequence character time  turn  printer print new characters starting ending places  cover original existing characters  given string consists lower english letters only  job count minimum number turns printer needed order print it  hard dynamic programming depth-first search 
[java c++] simple greedy like solution with explanation non-decreasing array given array n integers  task check could become non-decreasing modifying 1 element  define array non-decreasing array[i] <= array[i + 1] holds every (1 <= < n)  easy array 
python extremely easy to understand non-decreasing array given array n integers  task check could become non-decreasing modifying 1 element  define array non-decreasing array[i] <= array[i + 1] holds every (1 <= < n)  easy array 
[c++] [java] clean code - 6 liner without modifying input non-decreasing array given array n integers  task check could become non-decreasing modifying 1 element  define array non-decreasing array[i] <= array[i + 1] holds every (1 <= < n)  easy array 
the easiest python solution     non-decreasing array given array n integers  task check could become non-decreasing modifying 1 element  define array non-decreasing array[i] <= array[i + 1] holds every (1 <= < n)  easy array 
java solution  7 liner  non-decreasing array given array n integers  task check could become non-decreasing modifying 1 element  define array non-decreasing array[i] <= array[i + 1] holds every (1 <= < n)  easy array 
[c++] [java] clean code 4-liner beautiful arrangement ii given two integers n k  need construct list contains n different positive integers ranging 1 n obeys following requirement: suppose list [a1  a2  a3        an]  list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] exactly k distinct integers  multiple answers  print them  medium array 
python  straightforward with explanation beautiful arrangement ii given two integers n k  need construct list contains n different positive integers ranging 1 n obeys following requirement: suppose list [a1  a2  a3        an]  list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] exactly k distinct integers  multiple answers  print them  medium array 
java  easy to understand with explanation beautiful arrangement ii given two integers n k  need construct list contains n different positive integers ranging 1 n obeys following requirement: suppose list [a1  a2  a3        an]  list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] exactly k distinct integers  multiple answers  print them  medium array 
c++  concise code  o(n) beautiful arrangement ii given two integers n k  need construct list contains n different positive integers ranging 1 n obeys following requirement: suppose list [a1  a2  a3        an]  list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] exactly k distinct integers  multiple answers  print them  medium array 
short+simple with explanation beautiful arrangement ii given two integers n k  need construct list contains n different positive integers ranging 1 n obeys following requirement: suppose list [a1  a2  a3        an]  list [|a1 - a2|  |a2 - a3|  |a3 - a4|        |an-1 - an|] exactly k distinct integers  multiple answers  print them  medium array 
java solution  binary search kth smallest number in multiplication table nearly every one used multiplication table  could find k-th smallest number quickly multiplication table? given height length n   n multiplication table  positive integer k  need return k-th smallest number table  hard binary search 
this name is very miss leading kth smallest number in multiplication table nearly every one used multiplication table  could find k-th smallest number quickly multiplication table? given height length n   n multiplication table  positive integer k  need return k-th smallest number table  hard binary search 
python  straightforward with explanation kth smallest number in multiplication table nearly every one used multiplication table  could find k-th smallest number quickly multiplication table? given height length n   n multiplication table  positive integer k  need return k-th smallest number table  hard binary search 
this problem is found on another online judge kth smallest number in multiplication table nearly every one used multiplication table  could find k-th smallest number quickly multiplication table? given height length n   n multiplication table  positive integer k  need return k-th smallest number table  hard binary search 
solution like kth smallest number in sorted matrix kth smallest number in multiplication table nearly every one used multiplication table  could find k-th smallest number quickly multiplication table? given height length n   n multiplication table  positive integer k  need return k-th smallest number table  hard binary search 
java solution  6 liner trim a binary search tree given binary search tree lowest highest boundaries l r  trim tree elements lies [l  r] (r >= l)  might need change root tree  result return new root trimmed binary search tree  easy tree 
java solution  iteration version trim a binary search tree given binary search tree lowest highest boundaries l r  trim tree elements lies [l  r] (r >= l)  might need change root tree  result return new root trimmed binary search tree  easy tree 
c++  recursion trim a binary search tree given binary search tree lowest highest boundaries l r  trim tree elements lies [l  r] (r >= l)  might need change root tree  result return new root trimmed binary search tree  easy tree 
clear python solution trim a binary search tree given binary search tree lowest highest boundaries l r  trim tree elements lies [l  r] (r >= l)  might need change root tree  result return new root trimmed binary search tree  easy tree 
clean java solution with explanation and video link trim a binary search tree given binary search tree lowest highest boundaries l r  trim tree elements lies [l  r] (r >= l)  might need change root tree  result return new root trimmed binary search tree  easy tree 
java simple solution  o(n) time maximum swap given non-negative integer  could swap two digits get maximum valued number  return maximum valued number could get  medium array math 
c++ one-pass simple & fast solution: 1-3ms  o(n) time maximum swap given non-negative integer  could swap two digits get maximum valued number  return maximum valued number could get  medium array math 
[c++] 3ms  o(n) time  o(n) space  dp solution maximum swap given non-negative integer  could swap two digits get maximum valued number  return maximum valued number could get  medium array math 
simple ac o(n) java solution with ex maximum swap given non-negative integer  could swap two digits get maximum valued number  return maximum valued number could get  medium array math 
python  straightforward with explanation maximum swap given non-negative integer  could swap two digits get maximum valued number  return maximum valued number could get  medium array math 
java divide and conquer solution second minimum node in a binary tree given non-empty special binary tree consisting nodes non-negative value  node tree exactly two zero sub-node  node two sub-nodes  node's value smaller value among two sub-nodes  given binary tree  need output second minimum value set made nodes' value whole tree  second minimum value exists  output -1 instead  easy tree 
c++  dfs recursion second minimum node in a binary tree given non-empty special binary tree consisting nodes non-negative value  node tree exactly two zero sub-node  node two sub-nodes  node's value smaller value among two sub-nodes  given binary tree  need output second minimum value set made nodes' value whole tree  second minimum value exists  output -1 instead  easy tree 
python extremely easy to understand (beats 91%) second minimum node in a binary tree given non-empty special binary tree consisting nodes non-negative value  node tree exactly two zero sub-node  node two sub-nodes  node's value smaller value among two sub-nodes  given binary tree  need output second minimum value set made nodes' value whole tree  second minimum value exists  output -1 instead  easy tree 
java 4 lines second minimum node in a binary tree given non-empty special binary tree consisting nodes non-negative value  node tree exactly two zero sub-node  node two sub-nodes  node's value smaller value among two sub-nodes  given binary tree  need output second minimum value set made nodes' value whole tree  second minimum value exists  output -1 instead  easy tree 
very simple java solution second minimum node in a binary tree given non-empty special binary tree consisting nodes non-negative value  node tree exactly two zero sub-node  node two sub-nodes  node's value smaller value among two sub-nodes  given binary tree  need output second minimum value set made nodes' value whole tree  second minimum value exists  output -1 instead  easy tree 
java o(1) bulb switcher ii room n lights turned initially 4 buttons wall  performing exactly unknown operations towards buttons  need return many different kinds status n lights could be  suppose n lights labeled number [1  2  3      n]  function 4 buttons given below: flip lights  flip lights even numbers  flip lights odd numbers  flip lights (3k + 1) numbers  k = 0  1  2      medium math 
c++  concise code  o(1) bulb switcher ii room n lights turned initially 4 buttons wall  performing exactly unknown operations towards buttons  need return many different kinds status n lights could be  suppose n lights labeled number [1  2  3      n]  function 4 buttons given below: flip lights  flip lights even numbers  flip lights odd numbers  flip lights (3k + 1) numbers  k = 0  1  2      medium math 
short and clean java o(1) solution bulb switcher ii room n lights turned initially 4 buttons wall  performing exactly unknown operations towards buttons  need return many different kinds status n lights could be  suppose n lights labeled number [1  2  3      n]  function 4 buttons given below: flip lights  flip lights even numbers  flip lights odd numbers  flip lights (3k + 1) numbers  k = 0  1  2      medium math 
python  straightforward with explanation bulb switcher ii room n lights turned initially 4 buttons wall  performing exactly unknown operations towards buttons  need return many different kinds status n lights could be  suppose n lights labeled number [1  2  3      n]  function 4 buttons given below: flip lights  flip lights even numbers  flip lights odd numbers  flip lights (3k + 1) numbers  k = 0  1  2      medium math 
easy to understand java bfs solution o(m) bulb switcher ii room n lights turned initially 4 buttons wall  performing exactly unknown operations towards buttons  need return many different kinds status n lights could be  suppose n lights labeled number [1  2  3      n]  function 4 buttons given below: flip lights  flip lights even numbers  flip lights odd numbers  flip lights (3k + 1) numbers  k = 0  1  2      medium math 
[java c++] simple dp solution with explanation number of longest increasing subsequence given unsorted array integers  find number longest increasing subsequence  medium dynamic programming 
c++  dp with explanation  o(n^2) number of longest increasing subsequence given unsorted array integers  find number longest increasing subsequence  medium dynamic programming 
python dp with explanation (beats 88%) number of longest increasing subsequence given unsorted array integers  find number longest increasing subsequence  medium dynamic programming 
9ms [c++] explanation: dp + binary search + prefix sums o(nlogn) time; o(n) space number of longest increasing subsequence given unsorted array integers  find number longest increasing subsequence  medium dynamic programming 
python dp solution with detailed explanation number of longest increasing subsequence given unsorted array integers  find number longest increasing subsequence  medium dynamic programming 
[java c++]clean solution longest continuous increasing subsequence given unsorted array integers  find length longest continuous increasing subsequence (subarray)  easy array 
python simple solution longest continuous increasing subsequence given unsorted array integers  find length longest continuous increasing subsequence (subarray)  easy array 
java code---6 liner longest continuous increasing subsequence given unsorted array integers  find length longest continuous increasing subsequence (subarray)  easy array 
java solution  dp longest continuous increasing subsequence given unsorted array integers  find length longest continuous increasing subsequence (subarray)  easy array 
[c++ java] clean code - 3 liner [2 pointers] longest continuous increasing subsequence given unsorted array integers  find length longest continuous increasing subsequence (subarray)  easy array 
java solution  priorityqueue + bfs cut off trees for golf event asked cut trees forest golf event  forest represented non-negative 2d map  map: 0 represents obstacle can't reached  1 represents ground walked through  place number bigger 1 represents tree walked through  positive number represents tree's height  asked cut trees forest order tree's height - always cut tree lowest height first  cutting  original place tree become grass (value 1)  start point (0  0) output minimum steps need walk cut trees  can't cut trees  output -1 situation  guaranteed two trees height least one tree needs cut off  hard breadth-first search 
very simple python bfs   but why tle?? cut off trees for golf event asked cut trees forest golf event  forest represented non-negative 2d map  map: 0 represents obstacle can't reached  1 represents ground walked through  place number bigger 1 represents tree walked through  positive number represents tree's height  asked cut trees forest order tree's height - always cut tree lowest height first  cutting  original place tree become grass (value 1)  start point (0  0) output minimum steps need walk cut trees  can't cut trees  output -1 situation  guaranteed two trees height least one tree needs cut off  hard breadth-first search 
python solution based on wufangjie's (hadlock's algorithm?) cut off trees for golf event asked cut trees forest golf event  forest represented non-negative 2d map  map: 0 represents obstacle can't reached  1 represents ground walked through  place number bigger 1 represents tree walked through  positive number represents tree's height  asked cut trees forest order tree's height - always cut tree lowest height first  cutting  original place tree become grass (value 1)  start point (0  0) output minimum steps need walk cut trees  can't cut trees  output -1 situation  guaranteed two trees height least one tree needs cut off  hard breadth-first search 
my python solution  inspired by a  algorithm cut off trees for golf event asked cut trees forest golf event  forest represented non-negative 2d map  map: 0 represents obstacle can't reached  1 represents ground walked through  place number bigger 1 represents tree walked through  positive number represents tree's height  asked cut trees forest order tree's height - always cut tree lowest height first  cutting  original place tree become grass (value 1)  start point (0  0) output minimum steps need walk cut trees  can't cut trees  output -1 situation  guaranteed two trees height least one tree needs cut off  hard breadth-first search 
c++  sort + bfs with explanation cut off trees for golf event asked cut trees forest golf event  forest represented non-negative 2d map  map: 0 represents obstacle can't reached  1 represents ground walked through  place number bigger 1 represents tree walked through  positive number represents tree's height  asked cut trees forest order tree's height - always cut tree lowest height first  cutting  original place tree become grass (value 1)  start point (0  0) output minimum steps need walk cut trees  can't cut trees  output -1 situation  guaranteed two trees height least one tree needs cut off  hard breadth-first search 
easy 14 lines java solution  hashmap implement magic dictionary implement magic directory builddict  search methods  method builddict  given list non-repetitive words build dictionary  method search  given word  judge whether modify exactly one character another character word  modified word dictionary built  medium hash table trie 
python  without  26 factor in complexity implement magic dictionary implement magic directory builddict  search methods  method builddict  given list non-repetitive words build dictionary  method search  given word  judge whether modify exactly one character another character word  modified word dictionary built  medium hash table trie 
easiest java with trie  no need to count the number of changes implement magic dictionary implement magic directory builddict  search methods  method builddict  given list non-repetitive words build dictionary  method search  given word  judge whether modify exactly one character another character word  modified word dictionary built  medium hash table trie 
easy java solution implement magic dictionary implement magic directory builddict  search methods  method builddict  given list non-repetitive words build dictionary  method search  given word  judge whether modify exactly one character another character word  modified word dictionary built  medium hash table trie 
python intuitive solution using dictionary implement magic dictionary implement magic directory builddict  search methods  method builddict  given list non-repetitive words build dictionary  method search  given word  judge whether modify exactly one character another character word  modified word dictionary built  medium hash table trie 
java solution  trie map sum pairs implement mapsum class insert  sum methods  method insert  given pair (string  integer)  string represents key integer represents value  key already existed  original key-value pair overridden new one  method sum  given string representing prefix  need return sum pairs' value whose key starts prefix  medium trie 
c++  easy solution  ordered map map sum pairs implement mapsum class insert  sum methods  method insert  given pair (string  integer)  string represents key integer represents value  key already existed  original key-value pair overridden new one  method sum  given string representing prefix  need return sum pairs' value whose key starts prefix  medium trie 
simple java hashmap solution - o(1) sum  and o(len(key)) insert map sum pairs implement mapsum class insert  sum methods  method insert  given pair (string  integer)  string represents key integer represents value  key already existed  original key-value pair overridden new one  method sum  given string representing prefix  need return sum pairs' value whose key starts prefix  medium trie 
python easy and concise 3 lines solution map sum pairs implement mapsum class insert  sum methods  method insert  given pair (string  integer)  string represents key integer represents value  key already existed  original key-value pair overridden new one  method sum  given string representing prefix  need return sum pairs' value whose key starts prefix  medium trie 
python efficient o(k) insert and sum using trie map sum pairs implement mapsum class insert  sum methods  method insert  given pair (string  integer)  string represents key integer represents value  key already existed  original key-value pair overridden new one  method sum  given string representing prefix  need return sum pairs' value whose key starts prefix  medium trie 
short java o(n) time  o(1) space  one pass valid parenthesis string given string containing three types characters: '('  ')' ' '  write function check whether string valid  define validity string rules: left parenthesis '(' must corresponding right parenthesis ')'  right parenthesis ')' must corresponding left parenthesis '('  left parenthesis '(' must go corresponding right parenthesis ')'  ' ' could treated single right parenthesis ')' single left parenthesis '(' empty string  empty string also valid  medium string 
java 12 lines solution  backtracking valid parenthesis string given string containing three types characters: '('  ')' ' '  write function check whether string valid  define validity string rules: left parenthesis '(' must corresponding right parenthesis ')'  right parenthesis ')' must corresponding left parenthesis '('  left parenthesis '(' must go corresponding right parenthesis ')'  ' ' could treated single right parenthesis ')' single left parenthesis '(' empty string  empty string also valid  medium string 
very concise c++ solution with explaination  no dp valid parenthesis string given string containing three types characters: '('  ')' ' '  write function check whether string valid  define validity string rules: left parenthesis '(' must corresponding right parenthesis ')'  right parenthesis ')' must corresponding left parenthesis '('  left parenthesis '(' must go corresponding right parenthesis ')'  ' ' could treated single right parenthesis ')' single left parenthesis '(' empty string  empty string also valid  medium string 
java using 2 stacks   o(n) space and time complexity  valid parenthesis string given string containing three types characters: '('  ')' ' '  write function check whether string valid  define validity string rules: left parenthesis '(' must corresponding right parenthesis ')'  right parenthesis ')' must corresponding left parenthesis '('  left parenthesis '(' must go corresponding right parenthesis ')'  ' ' could treated single right parenthesis ')' single left parenthesis '(' empty string  empty string also valid  medium string 
java  very easy solution  no recursion or dp  valid parenthesis string given string containing three types characters: '('  ')' ' '  write function check whether string valid  define validity string rules: left parenthesis '(' must corresponding right parenthesis ')'  right parenthesis ')' must corresponding left parenthesis '('  left parenthesis '(' must go corresponding right parenthesis ')'  ' ' could treated single right parenthesis ')' single left parenthesis '(' empty string  empty string also valid  medium string 
 ub5a2 ube3b uac01 uac4e ub0c7 uac05 uac38 uae9a ubd5f uc223 uc684 ubd74 ubd5e ub93c uac08 uac0c ub914 ub58c uc60a uba54 ub284 uc22d uceb8 uae36 uae9b uc616 uac0d ub1d0 uca62 uacf4 ub4c7 uac6f uad84 uc615 uc679 ub21e uc1b4 uac43 ub057 uae2c ub549 uadbf uac00 uc300 ub090 uac44 uc224 ubeb4 ub298 uac58 uaf78 uc222 uac42 uac0b uac03 ucad0 uaf14 uc1be uca61 uc1d4 uc1bf ub05b ub91c uac04 ube3a uca6c uc6e8 ub534 uc620 ub91b uac02 ubd6a ub360 ub1a4 ube50 uc60b uadd2 ub282 uac30 uac16 ub1a5 uadbe uac06 uc60c ubf18 ubb30 uac70 uac0e uae37 ub0a4 uacbc 24 game 4 cards containing number 1 9  need judge whether could operated       +  -  (  ) get value 24  hard depth-first search 
[java] easy to understand  backtracking  24 game 4 cards containing number 1 9  need judge whether could operated       +  -  (  ) get value 24  hard depth-first search 
short python 24 game 4 cards containing number 1 9  need judge whether could operated       +  -  (  ) get value 24  hard depth-first search 
c++  concise code 24 game 4 cards containing number 1 9  need judge whether could operated       +  -  (  ) get value 24  hard depth-first search 
小时候真的玩儿过这个游戏 24 game 4 cards containing number 1 9  need judge whether could operated       +  -  (  ) get value 24  hard depth-first search 
java o(n) time o(1) space valid palindrome ii given non-empty string s  may delete one character  judge whether make palindrome  easy string 
easy to understand python solution valid palindrome ii given non-empty string s  may delete one character  judge whether make palindrome  easy string 
java solution  ispalindrome valid palindrome ii given non-empty string s  may delete one character  judge whether make palindrome  easy string 
easy and concise solution [c++ java python]  valid palindrome ii given non-empty string s  may delete one character  judge whether make palindrome  easy string 
[c++ java] clean code - 2 liner - generic for "you may delete at most n character" valid palindrome ii given non-empty string s  may delete one character  judge whether make palindrome  easy string 
straightforward python baseball game baseball game point recorder  given list strings  string one 4 following types: integer (one round's score): directly represents number points get round  "+" (one round's score): represents points get round sum last two valid round's points  "d" (one round's score): represents points get round doubled data last valid round's points  "c" (an operation  round's score): represents last valid round's points get invalid removed  round's operation permanent could impact round round after  need return sum points could get rounds  easy stack 
verbose java solution  linkedlist baseball game baseball game point recorder  given list strings  string one 4 following types: integer (one round's score): directly represents number points get round  "+" (one round's score): represents points get round sum last two valid round's points  "d" (one round's score): represents points get round doubled data last valid round's points  "c" (an operation  round's score): represents last valid round's points get invalid removed  round's operation permanent could impact round round after  need return sum points could get rounds  easy stack 
[c++] clean code baseball game baseball game point recorder  given list strings  string one 4 following types: integer (one round's score): directly represents number points get round  "+" (one round's score): represents points get round sum last two valid round's points  "d" (one round's score): represents points get round doubled data last valid round's points  "c" (an operation  round's score): represents last valid round's points get invalid removed  round's operation permanent could impact round round after  need return sum points could get rounds  easy stack 
simple c++ using vector baseball game baseball game point recorder  given list strings  string one 4 following types: integer (one round's score): directly represents number points get round  "+" (one round's score): represents points get round sum last two valid round's points  "d" (one round's score): represents points get round doubled data last valid round's points  "c" (an operation  round's score): represents last valid round's points get invalid removed  round's operation permanent could impact round round after  need return sum points could get rounds  easy stack 
java very concise and easy to understand using stack baseball game baseball game point recorder  given list strings  string one 4 following types: integer (one round's score): directly represents number points get round  "+" (one round's score): represents points get round sum last two valid round's points  "d" (one round's score): represents points get round doubled data last valid round's points  "c" (an operation  round's score): represents last valid round's points get invalid removed  round's operation permanent could impact round round after  need return sum points could get rounds  easy stack 
beats 97 96% union find java with explanations redundant connection problem  tree undirected graph connected cycles  given input graph started tree n nodes (with distinct values 1  2       n)  one additional edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] u < v  represents undirected edge connecting nodes u v  return edge removed resulting graph tree n nodes  multiple answers  return answer occurs last given 2d-array  answer edge [u  v] format  u < v  medium tree union find graph 
10 line java solution  union find  redundant connection problem  tree undirected graph connected cycles  given input graph started tree n nodes (with distinct values 1  2       n)  one additional edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] u < v  represents undirected edge connecting nodes u v  return edge removed resulting graph tree n nodes  multiple answers  return answer occurs last given 2d-array  answer edge [u  v] format  u < v  medium tree union find graph 
unicode-find (5 short lines) redundant connection problem  tree undirected graph connected cycles  given input graph started tree n nodes (with distinct values 1  2       n)  one additional edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] u < v  represents undirected edge connecting nodes u v  return edge removed resulting graph tree n nodes  multiple answers  return answer occurs last given 2d-array  answer edge [u  v] format  u < v  medium tree union find graph 
why does this(input: [[2 3] [5 2] [1 5] [4 2] [4 1]] output: [4 2] expected: [4 1] ) happens? redundant connection problem  tree undirected graph connected cycles  given input graph started tree n nodes (with distinct values 1  2       n)  one additional edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] u < v  represents undirected edge connecting nodes u v  return edge removed resulting graph tree n nodes  multiple answers  return answer occurs last given 2d-array  answer edge [u  v] format  u < v  medium tree union find graph 
c++ solution  using union find redundant connection problem  tree undirected graph connected cycles  given input graph started tree n nodes (with distinct values 1  2       n)  one additional edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] u < v  represents undirected edge connecting nodes u v  return edge removed resulting graph tree n nodes  multiple answers  return answer occurs last given 2d-array  answer edge [u  v] format  u < v  medium tree union find graph 
c++ java  union find with explanation  o(n) redundant connection ii problem  rooted tree directed graph that  exactly one node (the root) nodes descendants node  plus every node exactly one parent  except root node parents  given input directed graph started rooted tree n nodes (with distinct values 1  2       n)  one additional directed edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] represents directed edge connecting nodes u v  u parent child v  return edge removed resulting graph rooted tree n nodes  multiple answers  return answer occurs last given 2d-array  hard tree depth-first search union find graph 
one pass disjoint set solution with explain redundant connection ii problem  rooted tree directed graph that  exactly one node (the root) nodes descendants node  plus every node exactly one parent  except root node parents  given input directed graph started rooted tree n nodes (with distinct values 1  2       n)  one additional directed edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] represents directed edge connecting nodes u v  u parent child v  return edge removed resulting graph rooted tree n nodes  multiple answers  return answer occurs last given 2d-array  hard tree depth-first search union find graph 
python o(n) concise solution with detailed explanation  passed updated testcases redundant connection ii problem  rooted tree directed graph that  exactly one node (the root) nodes descendants node  plus every node exactly one parent  except root node parents  given input directed graph started rooted tree n nodes (with distinct values 1  2       n)  one additional directed edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] represents directed edge connecting nodes u v  u parent child v  return edge removed resulting graph rooted tree n nodes  multiple answers  return answer occurs last given 2d-array  hard tree depth-first search union find graph 
share my solution  c++ redundant connection ii problem  rooted tree directed graph that  exactly one node (the root) nodes descendants node  plus every node exactly one parent  except root node parents  given input directed graph started rooted tree n nodes (with distinct values 1  2       n)  one additional directed edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] represents directed edge connecting nodes u v  u parent child v  return edge removed resulting graph rooted tree n nodes  multiple answers  return answer occurs last given 2d-array  hard tree depth-first search union find graph 
easiest understanding java solution  using union find o(n)  redundant connection ii problem  rooted tree directed graph that  exactly one node (the root) nodes descendants node  plus every node exactly one parent  except root node parents  given input directed graph started rooted tree n nodes (with distinct values 1  2       n)  one additional directed edge added  added edge two different vertices chosen 1 n  edge already existed  resulting graph given 2d-array edges  element edges pair [u  v] represents directed edge connecting nodes u v  u parent child v  return edge removed resulting graph rooted tree n nodes  multiple answers  return answer occurs last given 2d-array  hard tree depth-first search union find graph 
c++ 4 lines o(m   n) | o(1) and kmp o(m + n) | o(n) repeated string match given two strings b  find minimum number times repeated b substring it  solution  return -1  easy string 
intuitive python 2-liner repeated string match given two strings b  find minimum number times repeated b substring it  solution  return -1  easy string 
java solution - just keep building (oj missing test cases) repeated string match given two strings b  find minimum number times repeated b substring it  solution  return -1  easy string 
share my java solution! repeated string match given two strings b  find minimum number times repeated b substring it  solution  return -1  easy string 
understandable python solution repeated string match given two strings b  find minimum number times repeated b substring it  solution  return -1  easy string 
[java c++] clean code longest univalue path given binary tree  find length longest path node path value  path may may pass root  note: length path two nodes represented number edges them  easy tree recursion 
java solution with global variable longest univalue path given binary tree  find length longest path node path value  path may may pass root  note: length path two nodes represented number edges them  easy tree recursion 
python simple to understand longest univalue path given binary tree  find length longest path node path value  path may may pass root  note: length path two nodes represented number edges them  easy tree recursion 
java solution with explanation longest univalue path given binary tree  find length longest path node path value  path may may pass root  note: length path two nodes represented number edges them  easy tree recursion 
test cases incorrect longest univalue path given binary tree  find length longest path node path value  path may may pass root  note: length path two nodes represented number edges them  easy tree recursion 
my accepted dp solution knight probability in chessboard nxn chessboard  knight starts r-th row c-th column attempts make exactly k moves  rows columns 0 indexed  top-left square (0  0)  bottom-right square (n-1  n-1)  chess knight 8 possible moves make  illustrated below  move two squares cardinal direction  one square orthogonal direction  time knight move  chooses one eight possible moves uniformly random (even piece would go chessboard) moves there  knight continues moving made exactly k moves moved chessboard  return probability knight remains board stopped moving  medium dynamic programming 
my easy understand dp solution knight probability in chessboard nxn chessboard  knight starts r-th row c-th column attempts make exactly k moves  rows columns 0 indexed  top-left square (0  0)  bottom-right square (n-1  n-1)  chess knight 8 possible moves make  illustrated below  move two squares cardinal direction  one square orthogonal direction  time knight move  chooses one eight possible moves uniformly random (even piece would go chessboard) moves there  knight continues moving made exactly k moves moved chessboard  return probability knight remains board stopped moving  medium dynamic programming 
evolve from recursive to dp beats 94% knight probability in chessboard nxn chessboard  knight starts r-th row c-th column attempts make exactly k moves  rows columns 0 indexed  top-left square (0  0)  bottom-right square (n-1  n-1)  chess knight 8 possible moves make  illustrated below  move two squares cardinal direction  one square orthogonal direction  time knight move  chooses one eight possible moves uniformly random (even piece would go chessboard) moves there  knight continues moving made exactly k moves moved chessboard  return probability knight remains board stopped moving  medium dynamic programming 
c++ java  dp  concise solution knight probability in chessboard nxn chessboard  knight starts r-th row c-th column attempts make exactly k moves  rows columns 0 indexed  top-left square (0  0)  bottom-right square (n-1  n-1)  chess knight 8 possible moves make  illustrated below  move two squares cardinal direction  one square orthogonal direction  time knight move  chooses one eight possible moves uniformly random (even piece would go chessboard) moves there  knight continues moving made exactly k moves moved chessboard  return probability knight remains board stopped moving  medium dynamic programming 
simple java dp solution with explanation knight probability in chessboard nxn chessboard  knight starts r-th row c-th column attempts make exactly k moves  rows columns 0 indexed  top-left square (0  0)  bottom-right square (n-1  n-1)  chess knight 8 possible moves make  illustrated below  move two squares cardinal direction  one square orthogonal direction  time knight move  chooses one eight possible moves uniformly random (even piece would go chessboard) moves there  knight continues moving made exactly k moves moved chessboard  return probability knight remains board stopped moving  medium dynamic programming 
c++ java  dp with explanation  o(n) maximum sum of 3 non-overlapping subarrays given array nums positive integers  find three non-overlapping subarrays maximum sum  subarray size k  want maximize sum 3 k entries  return result list indices representing starting position interval (0-indexed)  multiple answers  return lexicographically smallest one  hard array dynamic programming 
python o(n) time  o(1) space  greedy solution  maximum sum of 3 non-overlapping subarrays given array nums positive integers  find three non-overlapping subarrays maximum sum  subarray size k  want maximize sum 3 k entries  return result list indices representing starting position interval (0-indexed)  multiple answers  return lexicographically smallest one  hard array dynamic programming 
clean java dp o(n) solution  easy extend to sum of k non-overlapping subarrays  maximum sum of 3 non-overlapping subarrays given array nums positive integers  find three non-overlapping subarrays maximum sum  subarray size k  want maximize sum 3 k entries  return result list indices representing starting position interval (0-indexed)  multiple answers  return lexicographically smallest one  hard array dynamic programming 
java dp o(n) solution  explanation inline   maximum sum of 3 non-overlapping subarrays given array nums positive integers  find three non-overlapping subarrays maximum sum  subarray size k  want maximize sum 3 k entries  return result list indices representing starting position interval (0-indexed)  multiple answers  return lexicographically smallest one  hard array dynamic programming 
c++ o(n) time o(n) space concise solution maximum sum of 3 non-overlapping subarrays given array nums positive integers  find three non-overlapping subarrays maximum sum  subarray size k  want maximize sum 3 k entries  return result list indices representing starting position interval (0-indexed)  multiple answers  return lexicographically smallest one  hard array dynamic programming 
java hashmap bfs dfs employee importance given data structure employee information  includes employee's unique id  importance value direct subordinates' id  easy hash table depth-first search breadth-first search 
i literally didn't understand the data type of `employees` from the question employee importance given data structure employee information  includes employee's unique id  importance value direct subordinates' id  easy hash table depth-first search breadth-first search 
3-liner python solution (beats 99%) employee importance given data structure employee information  includes employee's unique id  importance value direct subordinates' id  easy hash table depth-first search breadth-first search 
c++ dfs using stl employee importance given data structure employee information  includes employee's unique id  importance value direct subordinates' id  easy hash table depth-first search breadth-first search 
java 5-liner employee importance given data structure employee information  includes employee's unique id  importance value direct subordinates' id  easy hash table depth-first search breadth-first search 
c++ java python  dp + memoization with optimization  29 ms (c++) stickers to spell word given n different types stickers  sticker lowercase english word it  would like spell given target string cutting individual letters collection stickers rearranging them  use sticker want  infinite quantities sticker  minimum number stickers need spell target? task impossible  return -1  hard dynamic programming backtracking 
rewrite of contest winner's solution stickers to spell word given n different types stickers  sticker lowercase english word it  would like spell given target string cutting individual letters collection stickers rearranging them  use sticker want  infinite quantities sticker  minimum number stickers need spell target? task impossible  return -1  hard dynamic programming backtracking 
explaining stefanpochmann's rewrite of contest winner's solution & +java stickers to spell word given n different types stickers  sticker lowercase english word it  would like spell given target string cutting individual letters collection stickers rearranging them  use sticker want  infinite quantities sticker  minimum number stickers need spell target? task impossible  return -1  hard dynamic programming backtracking 
java bfs solution stickers to spell word given n different types stickers  sticker lowercase english word it  would like spell given target string cutting individual letters collection stickers rearranging them  use sticker want  infinite quantities sticker  minimum number stickers need spell target? task impossible  return -1  hard dynamic programming backtracking 
c++ bfs solution stickers to spell word given n different types stickers  sticker lowercase english word it  would like spell given target string cutting individual letters collection stickers rearranging them  use sticker want  infinite quantities sticker  minimum number stickers need spell target? task impossible  return -1  hard dynamic programming backtracking 
my simple java solution using hashmap & priorityqueue - o(nlogk) time & o(n) space top k frequent words given non-empty list words  return k frequent elements  answer sorted frequency highest lowest  two words frequency  word lower alphabetical order comes first  medium hash table heap trie 
java o(n) solution using hashmap  bucketsort and trie - 22ms beat 81% top k frequent words given non-empty list words  return k frequent elements  answer sorted frequency highest lowest  two words frequency  word lower alphabetical order comes first  medium hash table heap trie 
python 3 solution with o(nlogk) and o(n) top k frequent words given non-empty list words  return k frequent elements  answer sorted frequency highest lowest  two words frequency  word lower alphabetical order comes first  medium hash table heap trie 
o(nlog(k)) priority queue c++ code top k frequent words given non-empty list words  return k frequent elements  answer sorted frequency highest lowest  two words frequency  word lower alphabetical order comes first  medium hash table heap trie 
simplest python solution top k frequent words given non-empty list words  return k frequent elements  answer sorted frequency highest lowest  two words frequency  word lower alphabetical order comes first  medium hash table heap trie 
oneliners (c++  java  ruby  python) binary number with alternating bits given positive integer  check whether alternating bits: namely  two adjacent bits always different values  easy bit manipulation 
java super simple explanation with inline example binary number with alternating bits given positive integer  check whether alternating bits: namely  two adjacent bits always different values  easy bit manipulation 
c++  concise code binary number with alternating bits given positive integer  check whether alternating bits: namely  two adjacent bits always different values  easy bit manipulation 
why not give the fu king precise definition of the fuc king "alternating bits"? binary number with alternating bits given positive integer  check whether alternating bits: namely  two adjacent bits always different values  easy bit manipulation 
easy python binary number with alternating bits given positive integer  check whether alternating bits: namely  two adjacent bits always different values  easy bit manipulation 
java o(n) time o(1) space count binary substrings give string s  count number non-empty (contiguous) substrings number 0's 1's  0's 1's substrings grouped consecutively  substrings occur multiple times counted number times occur  easy string 
[python c++ java] easy and concise with explanation count binary substrings give string s  count number non-empty (contiguous) substrings number 0's 1's  0's 1's substrings grouped consecutively  substrings occur multiple times counted number times occur  easy string 
acceptable java solution with explaination count binary substrings give string s  count number non-empty (contiguous) substrings number 0's 1's  0's 1's substrings grouped consecutively  substrings occur multiple times counted number times occur  easy string 
python intuitive approaches with explanation (3-liner) count binary substrings give string s  count number non-empty (contiguous) substrings number 0's 1's  0's 1's substrings grouped consecutively  substrings occur multiple times counted number times occur  easy string 
c++ easy understanding solution count binary substrings give string s  count number non-empty (contiguous) substrings number 0's 1's  0's 1's substrings grouped consecutively  substrings occur multiple times counted number times occur  easy string 
the example for this question is poor degree of an array given non-empty array non-negative integers nums  degree array defined maximum frequency one elements  task find smallest possible length (contiguous) subarray nums  degree nums  easy array 
easy understand java solution (beats 100% solutions) degree of an array given non-empty array non-negative integers nums  degree array defined maximum frequency one elements  task find smallest possible length (contiguous) subarray nums  degree nums  easy array 
straightforward c++ solution  35ms degree of an array given non-empty array non-negative integers nums  degree array defined maximum frequency one elements  task find smallest possible length (contiguous) subarray nums  degree nums  easy array 
[c++ java python] one-pass and o(m) space degree of an array given non-empty array non-negative integers nums  degree array defined maximum frequency one elements  task find smallest possible length (contiguous) subarray nums  degree nums  easy array 
python easy and concise solution degree of an array given non-empty array non-negative integers nums  degree array defined maximum frequency one elements  task find smallest possible length (contiguous) subarray nums  degree nums  easy array 
[java c++]straightforward dfs solution partition to k equal sum subsets given array integers nums positive integer k  find whether possible divide array k non-empty subsets whose sums equal  medium dynamic programming recursion 
easy to understand java solution partition to k equal sum subsets given array integers nums positive integer k  find whether possible divide array k non-empty subsets whose sums equal  medium dynamic programming recursion 
cpp solution with explanation in details partition to k equal sum subsets given array integers nums positive integer k  find whether possible divide array k non-empty subsets whose sums equal  medium dynamic programming recursion 
clear explanation  easy to understand c++ : 4ms beat 100% partition to k equal sum subsets given array integers nums positive integer k  find whether possible divide array k non-empty subsets whose sums equal  medium dynamic programming recursion 
c++ 3ms dfs solution with pruning partition to k equal sum subsets given array integers nums positive integer k  find whether possible divide array k non-empty subsets whose sums equal  medium dynamic programming recursion 
easy understood o(n^2) solution with explanation falling squares infinite number line (x-axis)  drop given squares order given  i-th square dropped (positions[i] = (left  side_length)) square left-most point positions[i][0] sidelength positions[i][1]  square dropped bottom edge parallel number line  higher height currently landed squares  wait square stick dropping next  squares infinitely sticky bottom edge  remain fixed positive length surface touch (either number line another square)  squares dropped adjacent stick together prematurely  return list ans heights  height ans[i] represents current highest height square dropped  dropping squares represented positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
treemap solution and segment tree (java) solution with lazy propagation and coordinates compression falling squares infinite number line (x-axis)  drop given squares order given  i-th square dropped (positions[i] = (left  side_length)) square left-most point positions[i][0] sidelength positions[i][1]  square dropped bottom edge parallel number line  higher height currently landed squares  wait square stick dropping next  squares infinitely sticky bottom edge  remain fixed positive length surface touch (either number line another square)  squares dropped adjacent stick together prematurely  return list ans heights  height ans[i] represents current highest height square dropped  dropping squares represented positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
easy understood treemap solution falling squares infinite number line (x-axis)  drop given squares order given  i-th square dropped (positions[i] = (left  side_length)) square left-most point positions[i][0] sidelength positions[i][1]  square dropped bottom edge parallel number line  higher height currently landed squares  wait square stick dropping next  squares infinitely sticky bottom edge  remain fixed positive length surface touch (either number line another square)  squares dropped adjacent stick together prematurely  return list ans heights  height ans[i] represents current highest height square dropped  dropping squares represented positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
easy and concise python solution (97%) falling squares infinite number line (x-axis)  drop given squares order given  i-th square dropped (positions[i] = (left  side_length)) square left-most point positions[i][0] sidelength positions[i][1]  square dropped bottom edge parallel number line  higher height currently landed squares  wait square stick dropping next  squares infinitely sticky bottom edge  remain fixed positive length surface touch (either number line another square)  squares dropped adjacent stick together prematurely  return list ans heights  height ans[i] represents current highest height square dropped  dropping squares represented positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
java 14ms  beats 99 38% using interval tree falling squares infinite number line (x-axis)  drop given squares order given  i-th square dropped (positions[i] = (left  side_length)) square left-most point positions[i][0] sidelength positions[i][1]  square dropped bottom edge parallel number line  higher height currently landed squares  wait square stick dropping next  squares infinitely sticky bottom edge  remain fixed positive length surface touch (either number line another square)  squares dropped adjacent stick together prematurely  return list ans heights  height ans[i] represents current highest height square dropped  dropping squares represented positions[0]  positions[1]       positions[i]  hard segment tree binary search tree 
java beats 100% concise method using recursion and iteration search in a binary search tree given root node binary search tree (bst) value  need find node bst node's value equals given value  return subtree rooted node  node exist  return null  easy tree 
python 3 lines dfs solution w  a very simple approach search in a binary search tree given root node binary search tree (bst) value  need find node bst node's value equals given value  return subtree rooted node  node exist  return null  easy tree 
concise iterative solution (c++) search in a binary search tree given root node binary search tree (bst) value  need find node bst node's value equals given value  return subtree rooted node  node exist  return null  easy tree 
swift bug search in a binary search tree given root node binary search tree (bst) value  need find node bst node's value equals given value  return subtree rooted node  node exist  return null  easy tree 
beats 100% java code search in a binary search tree given root node binary search tree (bst) value  need find node bst node's value equals given value  return subtree rooted node  node exist  return null  easy tree 
java iterative 100% insert into a binary search tree given root node binary search tree (bst) value inserted tree  insert value bst  return root node bst insertion  guaranteed new value exist original bst  note may exist multiple valid ways insertion  long tree remains bst insertion  return them  medium tree 
c++: very simple insert into a binary search tree given root node binary search tree (bst) value inserted tree  insert value bst  return root node bst insertion  guaranteed new value exist original bst  note may exist multiple valid ways insertion  long tree remains bst insertion  return them  medium tree 
java easy to understand solution insert into a binary search tree given root node binary search tree (bst) value inserted tree  insert value bst  return root node bst insertion  guaranteed new value exist original bst  note may exist multiple valid ways insertion  long tree remains bst insertion  return them  medium tree 
[java] beats 100%   simple and elegant solution insert into a binary search tree given root node binary search tree (bst) value inserted tree  insert value bst  return root node bst insertion  guaranteed new value exist original bst  note may exist multiple valid ways insertion  long tree remains bst insertion  return them  medium tree 
python - 4 line clean recursive solution insert into a binary search tree given root node binary search tree (bst) value inserted tree  insert value bst  return root node bst insertion  guaranteed new value exist original bst  note may exist multiple valid ways insertion  long tree remains bst insertion  return them  medium tree 
python simple heapq solution beats 100 % kth largest element in a stream design class find kth largest element stream  note kth largest element sorted order  kth distinct element  kthlargest class constructor accepts integer k integer array nums  contains initial elements stream  call method kthlargest add  return element representing kth largest element stream  easy heap 
explanation of minheap solution (no code) kth largest element in a stream design class find kth largest element stream  note kth largest element sorted order  kth distinct element  kthlargest class constructor accepts integer k integer array nums  contains initial elements stream  call method kthlargest add  return element representing kth largest element stream  easy heap 
java  priority queue kth largest element in a stream design class find kth largest element stream  note kth largest element sorted order  kth distinct element  kthlargest class constructor accepts integer k integer array nums  contains initial elements stream  call method kthlargest add  return element representing kth largest element stream  easy heap 
o(h) java solution using bst kth largest element in a stream design class find kth largest element stream  note kth largest element sorted order  kth distinct element  kthlargest class constructor accepts integer k integer array nums  contains initial elements stream  call method kthlargest add  return element representing kth largest element stream  easy heap 
minheap solution kth largest element in a stream design class find kth largest element stream  note kth largest element sorted order  kth distinct element  kthlargest class constructor accepts integer k integer array nums  contains initial elements stream  call method kthlargest add  return element representing kth largest element stream  easy heap 
python typical solutions beat 100 % binary search given sorted (in ascending order) integer array nums n elements target value  write function search target nums  target exists  return index  otherwise return -1  easy binary search 
java solution binary search given sorted (in ascending order) integer array nums n elements target value  write function search target nums  target exists  return index  otherwise return -1  easy binary search 
c++ solution binary search given sorted (in ascending order) integer array nums n elements target value  write function search target nums  target exists  return index  otherwise return -1  easy binary search 
python recursive + iterative easy to understand binary search given sorted (in ascending order) integer array nums n elements target value  write function search target nums  target exists  return index  otherwise return -1  easy binary search 
javascript solution binary search given sorted (in ascending order) integer array nums n elements target value  write function search target nums  target exists  return index  otherwise return -1  easy binary search 
beats 100% real java solution (not boolean array) design hashset design hashset without using built-in hash table libraries  specific  design include functions: add(value): insert value hashset  contains(value) : return whether value exists hashset not  remove(value): remove value hashset  value exist hashset  nothing  easy hash table design 
can you guys think before doing? design hashset design hashset without using built-in hash table libraries  specific  design include functions: add(value): insert value hashset  contains(value) : return whether value exists hashset not  remove(value): remove value hashset  value exist hashset  nothing  easy hash table design 
python solution    can we do better than boolean array ? design hashset design hashset without using built-in hash table libraries  specific  design include functions: add(value): insert value hashset  contains(value) : return whether value exists hashset not  remove(value): remove value hashset  value exist hashset  nothing  easy hash table design 
c++ 97 97% without a massive array or using a map  bst design hashset design hashset without using built-in hash table libraries  specific  design include functions: add(value): insert value hashset  contains(value) : return whether value exists hashset not  remove(value): remove value hashset  value exist hashset  nothing  easy hash table design 
description error in "design hashset" design hashset design hashset without using built-in hash table libraries  specific  design include functions: add(value): insert value hashset  contains(value) : return whether value exists hashset not  remove(value): remove value hashset  value exist hashset  nothing  easy hash table design 
java solution design hashmap design hashmap without using built-in hash table libraries  specific  design include functions: put(key  value) : insert (key  value) pair hashmap  value already exists hashmap  update value  get(key): returns value specified key mapped  -1 map contains mapping key  remove(key) : remove mapping value key map contains mapping key  easy hash table design 
java simple solution design hashmap design hashmap without using built-in hash table libraries  specific  design include functions: put(key  value) : insert (key  value) pair hashmap  value already exists hashmap  update value  get(key): returns value specified key mapped  -1 map contains mapping key  remove(key) : remove mapping value key map contains mapping key  easy hash table design 
hash with chaining [python] design hashmap design hashmap without using built-in hash table libraries  specific  design include functions: put(key  value) : insert (key  value) pair hashmap  value already exists hashmap  update value  get(key): returns value specified key mapped  -1 map contains mapping key  remove(key) : remove mapping value key map contains mapping key  easy hash table design 
python straightforward solution  one line for each function design hashmap design hashmap without using built-in hash table libraries  specific  design include functions: put(key  value) : insert (key  value) pair hashmap  value already exists hashmap  update value  get(key): returns value specified key mapped  -1 map contains mapping key  remove(key) : remove mapping value key map contains mapping key  easy hash table design 
javascript solution: 104ms design hashmap design hashmap without using built-in hash table libraries  specific  design include functions: put(key  value) : insert (key  value) pair hashmap  value already exists hashmap  update value  get(key): returns value specified key mapped  -1 map contains mapping key  remove(key) : remove mapping value key map contains mapping key  easy hash table design 
python solution design linked list design implementation linked list  choose use singly linked list doubly linked list  node singly linked list two attributes: val next  val value current node  next pointer reference next node  want use doubly linked list  need one attribute prev indicate previous node linked list  assume nodes linked list 0-indexed  implement functions linked list class: get(index) : get value index-th node linked list  index invalid  return -1  addathead(val) : add node value val first element linked list  insertion  new node first node linked list  addattail(val) : append node value val last element linked list  addatindex(index  val) : add node value val index-th node linked list  index equals length linked list  node appended end linked list  index greater length  node inserted  deleteatindex(index) : delete index-th node linked list  index valid  easy linked list design 
python ac short & simple linked list solution design linked list design implementation linked list  choose use singly linked list doubly linked list  node singly linked list two attributes: val next  val value current node  next pointer reference next node  want use doubly linked list  need one attribute prev indicate previous node linked list  assume nodes linked list 0-indexed  implement functions linked list class: get(index) : get value index-th node linked list  index invalid  return -1  addathead(val) : add node value val first element linked list  insertion  new node first node linked list  addattail(val) : append node value val last element linked list  addatindex(index  val) : add node value val index-th node linked list  index equals length linked list  node appended end linked list  index greater length  node inserted  deleteatindex(index) : delete index-th node linked list  index valid  easy linked list design 
c++ solution -24ms design linked list design implementation linked list  choose use singly linked list doubly linked list  node singly linked list two attributes: val next  val value current node  next pointer reference next node  want use doubly linked list  need one attribute prev indicate previous node linked list  assume nodes linked list 0-indexed  implement functions linked list class: get(index) : get value index-th node linked list  index invalid  return -1  addathead(val) : add node value val first element linked list  insertion  new node first node linked list  addattail(val) : append node value val last element linked list  addatindex(index  val) : add node value val index-th node linked list  index equals length linked list  node appended end linked list  index greater length  node inserted  deleteatindex(index) : delete index-th node linked list  index valid  easy linked list design 
c++ deque design linked list design implementation linked list  choose use singly linked list doubly linked list  node singly linked list two attributes: val next  val value current node  next pointer reference next node  want use doubly linked list  need one attribute prev indicate previous node linked list  assume nodes linked list 0-indexed  implement functions linked list class: get(index) : get value index-th node linked list  index invalid  return -1  addathead(val) : add node value val first element linked list  insertion  new node first node linked list  addattail(val) : append node value val last element linked list  addatindex(index  val) : add node value val index-th node linked list  index equals length linked list  node appended end linked list  index greater length  node inserted  deleteatindex(index) : delete index-th node linked list  index valid  easy linked list design 
c++ simple solution  beats 97 27%! design linked list design implementation linked list  choose use singly linked list doubly linked list  node singly linked list two attributes: val next  val value current node  next pointer reference next node  want use doubly linked list  need one attribute prev indicate previous node linked list  assume nodes linked list 0-indexed  implement functions linked list class: get(index) : get value index-th node linked list  index invalid  return -1  addathead(val) : add node value val first element linked list  insertion  new node first node linked list  addattail(val) : append node value val last element linked list  addatindex(index  val) : add node value val index-th node linked list  index equals length linked list  node appended end linked list  index greater length  node inserted  deleteatindex(index) : delete index-th node linked list  index valid  easy linked list design 
java  no library methods to lower case implement function tolowercase() string parameter str  returns string lowercase  easy string 
easy c++ solution to lower case implement function tolowercase() string parameter str  returns string lowercase  easy string 
python short 1 line ascii & string method solutions to lower case implement function tolowercase() string parameter str  returns string lowercase  easy string 
c solution- 9 lines  0ms (with test cases) to lower case implement function tolowercase() string parameter str  returns string lowercase  easy string 
javascript solution (not using built in method) to lower case implement function tolowercase() string parameter str  returns string lowercase  easy string 
java o(b)   o(1)  hashmap random pick with blacklist given blacklist b containing unique integers [0  n)  write function return uniform random integer [0  n) b  optimize minimizes call system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) include n  see interval notation  hard hash table binary search sort random 
[c++] do not use rand() after c++11 ! random pick with blacklist given blacklist b containing unique integers [0  n)  write function return uniform random integer [0  n) b  optimize minimizes call system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) include n  see interval notation  hard hash table binary search sort random 
simple java solution with binary search random pick with blacklist given blacklist b containing unique integers [0  n)  write function return uniform random integer [0  n) b  optimize minimizes call system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) include n  see interval notation  hard hash table binary search sort random 
super simple python ac w  remapping random pick with blacklist given blacklist b containing unique integers [0  n)  write function return uniform random integer [0  n) b  optimize minimizes call system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) include n  see interval notation  hard hash table binary search sort random 
python ac solution with a very simple approach random pick with blacklist given blacklist b containing unique integers [0  n)  write function return uniform random integer [0  n) b  optimize minimizes call system’s math random()  note: 1 <= n <= 1000000000 0 <= b length < min(100000  n) [0  n) include n  see interval notation  hard hash table binary search sort random 
c++  dp  with explanation minimum ascii delete sum for two strings given two strings s1  s2  find lowest ascii sum deleted characters make two strings equal  medium dynamic programming 
concise dp solution minimum ascii delete sum for two strings given two strings s1  s2  find lowest ascii sum deleted characters make two strings equal  medium dynamic programming 
[java]{dp}(with explanation) minimum ascii delete sum for two strings given two strings s1  s2  find lowest ascii sum deleted characters make two strings equal  medium dynamic programming 
[java c++] clean code minimum ascii delete sum for two strings given two strings s1  s2  find lowest ascii sum deleted characters make two strings equal  medium dynamic programming 
elegant python solution using dp minimum ascii delete sum for two strings given two strings s1  s2  find lowest ascii sum deleted characters make two strings equal  medium dynamic programming 
[java c++] clean code with explanation subarray product less than k given array positive integers nums  count print number (contiguous) subarrays product elements subarray less k  medium array two pointers 
java two pointers o(n) time o(1) space subarray product less than k given array positive integers nums  count print number (contiguous) subarrays product elements subarray less k  medium array two pointers 
c++  concise solution  o(n) subarray product less than k given array positive integers nums  count print number (contiguous) subarrays product elements subarray less k  medium array two pointers 
python solution with detailed explanation subarray product less than k given array positive integers nums  count print number (contiguous) subarrays product elements subarray less k  medium array two pointers 
straightforward solution subarray product less than k given array positive integers nums  count print number (contiguous) subarrays product elements subarray less k  medium array two pointers 
most consistent ways of dealing with the series of stock problems best time to buy and sell stock with transaction fee given array integers prices  i-th element price given stock day i; non-negative integer fee representing transaction fee  may complete many transactions like  need pay transaction fee transaction  may buy 1 share stock time (ie  must sell stock share buy again ) return maximum profit make  medium array dynamic programming greedy 
2 solutions  2 states dp solutions  clear explanation! best time to buy and sell stock with transaction fee given array integers prices  i-th element price given stock day i; non-negative integer fee representing transaction fee  may complete many transactions like  need pay transaction fee transaction  may buy 1 share stock time (ie  must sell stock share buy again ) return maximum profit make  medium array dynamic programming greedy 
c++  concise solution  o(n) time o(1) space best time to buy and sell stock with transaction fee given array integers prices  i-th element price given stock day i; non-negative integer fee representing transaction fee  may complete many transactions like  need pay transaction fee transaction  may buy 1 share stock time (ie  must sell stock share buy again ) return maximum profit make  medium array dynamic programming greedy 
java simple dp solutions  o(n) best time to buy and sell stock with transaction fee given array integers prices  i-th element price given stock day i; non-negative integer fee representing transaction fee  may complete many transactions like  need pay transaction fee transaction  may buy 1 share stock time (ie  must sell stock share buy again ) return maximum profit make  medium array dynamic programming greedy 
java dp solution o(n) to o(1) space best time to buy and sell stock with transaction fee given array integers prices  i-th element price given stock day i; non-negative integer fee representing transaction fee  may complete many transactions like  need pay transaction fee transaction  may buy 1 share stock time (ie  must sell stock share buy again ) return maximum profit make  medium array dynamic programming greedy 
java treemap range module range module module tracks ranges numbers  task design implement following interfaces efficient manner  addrange(int left  int right) adds half-open interval [left  right)  tracking every real number interval  adding interval partially overlaps currently tracked numbers add numbers interval [left  right) already tracked  queryrange(int left  int right) returns true every real number interval [left  right) currently tracked  removerange(int left  int right) stops tracking every real number currently tracked interval [left  right)  hard array segment tree binary search tree 
c++  vector o(n) and map o(logn)  compare two solutions range module range module module tracks ranges numbers  task design implement following interfaces efficient manner  addrange(int left  int right) adds half-open interval [left  right)  tracking every real number interval  adding interval partially overlaps currently tracked numbers add numbers interval [left  right) already tracked  queryrange(int left  int right) returns true every real number interval [left  right) currently tracked  removerange(int left  int right) stops tracking every real number currently tracked interval [left  right)  hard array segment tree binary search tree 
python range module range module module tracks ranges numbers  task design implement following interfaces efficient manner  addrange(int left  int right) adds half-open interval [left  right)  tracking every real number interval  adding interval partially overlaps currently tracked numbers add numbers interval [left  right) already tracked  queryrange(int left  int right) returns true every real number interval [left  right) currently tracked  removerange(int left  int right) stops tracking every real number currently tracked interval [left  right)  hard array segment tree binary search tree 
c++ o(nlogn) based on disjoint intervals data structure range module range module module tracks ranges numbers  task design implement following interfaces efficient manner  addrange(int left  int right) adds half-open interval [left  right)  tracking every real number interval  adding interval partially overlaps currently tracked numbers add numbers interval [left  right) already tracked  queryrange(int left  int right) returns true every real number interval [left  right) currently tracked  removerange(int left  int right) stops tracking every real number currently tracked interval [left  right)  hard array segment tree binary search tree 
clean python solution range module range module module tracks ranges numbers  task design implement following interfaces efficient manner  addrange(int left  int right) adds half-open interval [left  right)  tracking every real number interval  adding interval partially overlaps currently tracked numbers add numbers interval [left  right) already tracked  queryrange(int left  int right) returns true every real number interval [left  right) currently tracked  removerange(int left  int right) stops tracking every real number currently tracked interval [left  right)  hard array segment tree binary search tree 
java  check only the end of array 1-bit and 2-bit characters two special characters  first character represented one bit 0  second character represented two bits (10 11)  given string represented several bits  return whether last character must one-bit character not  given string always end zero  easy array 
java solution  1 or 2 1-bit and 2-bit characters two special characters  first character represented one bit 0  second character represented two bits (10 11)  given string represented several bits  return whether last character must one-bit character not  given string always end zero  easy array 
python solution  easy 1-bit and 2-bit characters two special characters  first character represented one bit 0  second character represented two bits (10 11)  given string represented several bits  return whether last character must one-bit character not  given string always end zero  easy array 
easy to understand c++ solution with modified for loop 1-bit and 2-bit characters two special characters  first character represented one bit 0  second character represented two bits (10 11)  given string represented several bits  return whether last character must one-bit character not  given string always end zero  easy array 
single regular expression - js: es6 1-bit and 2-bit characters two special characters  first character represented one bit 0  second character represented two bits (10 11)  given string represented several bits  return whether last character must one-bit character not  given string always end zero  easy array 
concise java dp: same idea of longest common substring maximum length of repeated subarray given two integer arrays b  return maximum length subarray appears arrays  medium array hash table binary search dynamic programming 
[java c++] clean code - 8 lines maximum length of repeated subarray given two integer arrays b  return maximum length subarray appears arrays  medium array hash table binary search dynamic programming 
java o(mn) time  o(1) space maximum length of repeated subarray given two integer arrays b  return maximum length subarray appears arrays  medium array hash table binary search dynamic programming 
python concise dp maximum length of repeated subarray given two integer arrays b  return maximum length subarray appears arrays  medium array hash table binary search dynamic programming 
simple o(nm) dp solution maximum length of repeated subarray given two integer arrays b  return maximum length subarray appears arrays  medium array hash table binary search dynamic programming 
[java c++] clean code longest word in dictionary given list strings words representing english dictionary  find longest word words built one character time words words  one possible answer  return longest word smallest lexicographical order  answer  return empty string  easy hash table trie 
python elegant and extremely easy to understand longest word in dictionary given list strings words representing english dictionary  find longest word words built one character time words words  one possible answer  return longest word smallest lexicographical order  answer  return empty string  easy hash table trie 
[java 16ms (99%) @ 20180108] trie+dfs: clean  easy  explained and illustrated longest word in dictionary given list strings words representing english dictionary  find longest word words built one character time words words  one possible answer  return longest word smallest lexicographical order  answer  return empty string  easy hash table trie 
java solution with trie + bfs longest word in dictionary given list strings words representing english dictionary  find longest word words built one character time words words  one possible answer  return longest word smallest lexicographical order  answer  return empty string  easy hash table trie 
1-liner longest word in dictionary given list strings words representing english dictionary  find longest word words built one character time words words  one possible answer  return longest word smallest lexicographical order  answer  return empty string  easy hash table trie 
[java c++] union find accounts merge given list accounts  element accounts[i] list strings  first element accounts[i][0] name  rest elements emails representing emails account  now  would like merge accounts  two accounts definitely belong person email common accounts  note even two accounts name  may belong different people people could name  person number accounts initially  accounts definitely name  merging accounts  return accounts following format: first element account name  rest elements emails sorted order  accounts returned order  medium depth-first search union find 
java solution (build graph + dfs search) accounts merge given list accounts  element accounts[i] list strings  first element accounts[i][0] name  rest elements emails representing emails account  now  would like merge accounts  two accounts definitely belong person email common accounts  note even two accounts name  may belong different people people could name  person number accounts initially  accounts definitely name  merging accounts  return accounts following format: first element account name  rest elements emails sorted order  accounts returned order  medium depth-first search union find 
python simple dfs with explanation!!! accounts merge given list accounts  element accounts[i] list strings  first element accounts[i][0] name  rest elements emails representing emails account  now  would like merge accounts  two accounts definitely belong person email common accounts  note even two accounts name  may belong different people people could name  person number accounts initially  accounts definitely name  merging accounts  return accounts following format: first element account name  rest elements emails sorted order  accounts returned order  medium depth-first search union find 
summary for dfs templates accounts merge given list accounts  element accounts[i] list strings  first element accounts[i][0] name  rest elements emails representing emails account  now  would like merge accounts  two accounts definitely belong person email common accounts  note even two accounts name  may belong different people people could name  person number accounts initially  accounts definitely name  merging accounts  return accounts following format: first element account name  rest elements emails sorted order  accounts returned order  medium depth-first search union find 
hashmap plus union found solution using java programming! accounts merge given list accounts  element accounts[i] list strings  first element accounts[i][0] name  rest elements emails representing emails account  now  would like merge accounts  two accounts definitely belong person email common accounts  note even two accounts name  may belong different people people could name  person number accounts initially  accounts definitely name  merging accounts  return accounts following format: first element account name  rest elements emails sorted order  accounts returned order  medium depth-first search union find 
one pass solution in java remove comments given c++ program  remove comments it  program source array source[i] i-th line source code  represents result splitting original source code string newline character  n  c++  two types comments  line comments  block comments  string    denotes line comment  represents rest characters right line ignored  string    denotes block comment  represents characters next (non-overlapping) occurrence    ignored  (here  occurrences happen reading order: line line left right ) clear  string     yet end block comment  ending would overlapping beginning  first effective comment takes precedence others: string    occurs block comment  ignored  similarly  string    occurs line block comment  also ignored  certain line code empty removing comments  must output line: string answer list non-empty  control characters  single quote  double quote characters  medium string 
1-liners remove comments given c++ program  remove comments it  program source array source[i] i-th line source code  represents result splitting original source code string newline character  n  c++  two types comments  line comments  block comments  string    denotes line comment  represents rest characters right line ignored  string    denotes block comment  represents characters next (non-overlapping) occurrence    ignored  (here  occurrences happen reading order: line line left right ) clear  string     yet end block comment  ending would overlapping beginning  first effective comment takes precedence others: string    occurs block comment  ignored  similarly  string    occurs line block comment  also ignored  certain line code empty removing comments  must output line: string answer list non-empty  control characters  single quote  double quote characters  medium string 
simple python one-pass with clear inline explanation!!! remove comments given c++ program  remove comments it  program source array source[i] i-th line source code  represents result splitting original source code string newline character  n  c++  two types comments  line comments  block comments  string    denotes line comment  represents rest characters right line ignored  string    denotes block comment  represents characters next (non-overlapping) occurrence    ignored  (here  occurrences happen reading order: line line left right ) clear  string     yet end block comment  ending would overlapping beginning  first effective comment takes precedence others: string    occurs block comment  ignored  similarly  string    occurs line block comment  also ignored  certain line code empty removing comments  must output line: string answer list non-empty  control characters  single quote  double quote characters  medium string 
c++ o(n) (one pass) remove comments given c++ program  remove comments it  program source array source[i] i-th line source code  represents result splitting original source code string newline character  n  c++  two types comments  line comments  block comments  string    denotes line comment  represents rest characters right line ignored  string    denotes block comment  represents characters next (non-overlapping) occurrence    ignored  (here  occurrences happen reading order: line line left right ) clear  string     yet end block comment  ending would overlapping beginning  first effective comment takes precedence others: string    occurs block comment  ignored  similarly  string    occurs line block comment  also ignored  certain line code empty removing comments  must output line: string answer list non-empty  control characters  single quote  double quote characters  medium string 
just kill me remove comments given c++ program  remove comments it  program source array source[i] i-th line source code  represents result splitting original source code string newline character  n  c++  two types comments  line comments  block comments  string    denotes line comment  represents rest characters right line ignored  string    denotes block comment  represents characters next (non-overlapping) occurrence    ignored  (here  occurrences happen reading order: line line left right ) clear  string     yet end block comment  ending would overlapping beginning  first effective comment takes precedence others: string    occurs block comment  ignored  similarly  string    occurs line block comment  also ignored  certain line code empty removing comments  must output line: string answer list non-empty  control characters  single quote  double quote characters  medium string 
short python o(n) time o(1) space with explanation find pivot index given array integers nums  write method returns "pivot" index array  define pivot index index sum numbers left index equal sum numbers right index  index exists  return -1  multiple pivot indexes  return left-most pivot index  easy array 
this is a very poorly described problem find pivot index given array integers nums  write method returns "pivot" index array  define pivot index index sum numbers left index equal sum numbers right index  index exists  return -1  multiple pivot indexes  return left-most pivot index  easy array 
java 6 liner find pivot index given array integers nums  write method returns "pivot" index array  define pivot index index sum numbers left index equal sum numbers right index  index exists  return -1  multiple pivot indexes  return left-most pivot index  easy array 
[java c++] clean code find pivot index given array integers nums  write method returns "pivot" index array  define pivot index index sum numbers left index equal sum numbers right index  index exists  return -1  multiple pivot indexes  return left-most pivot index  easy array 
easy to understand c++ code  find pivot index given array integers nums  write method returns "pivot" index array  define pivot index index sum numbers left index equal sum numbers right index  index exists  return -1  multiple pivot indexes  return left-most pivot index  easy array 
[java c++] clean code split linked list in parts given (singly) linked list head node root  write function split linked list k consecutive linked list "parts"  length part equal possible: two parts size differing 1  may lead parts null  parts order occurrence input list  parts occurring earlier always size greater equal parts occurring later  return list listnode's representing linked list parts formed  medium linked list 
elegant python with explanation - 45ms split linked list in parts given (singly) linked list head node root  write function split linked list k consecutive linked list "parts"  length part equal possible: two parts size differing 1  may lead parts null  parts order occurrence input list  parts occurring earlier always size greater equal parts occurring later  return list listnode's representing linked list parts formed  medium linked list 
c++ solution o(1) space 9ms split linked list in parts given (singly) linked list head node root  write function split linked list k consecutive linked list "parts"  length part equal possible: two parts size differing 1  may lead parts null  parts order occurrence input list  parts occurring earlier always size greater equal parts occurring later  return list listnode's representing linked list parts formed  medium linked list 
easy to follow python solution split linked list in parts given (singly) linked list head node root  write function split linked list k consecutive linked list "parts"  length part equal possible: two parts size differing 1  may lead parts null  parts order occurrence input list  parts occurring earlier always size greater equal parts occurring later  return list listnode's representing linked list parts formed  medium linked list 
simple pythonic solution  beats 100% split linked list in parts given (singly) linked list head node root  write function split linked list k consecutive linked list "parts"  length part equal possible: two parts size differing 1  may lead parts null  parts order occurrence input list  parts occurring earlier always size greater equal parts occurring later  return list listnode's representing linked list parts formed  medium linked list 
java solution using stack and map number of atoms given chemical formula (given string)  return count atom  atomic element always starts uppercase character  zero lowercase letters  representing name  1 digits representing count element may follow count greater 1  count 1  digits follow  hard hash table stack recursion 
neat python with explanation - 35ms number of atoms given chemical formula (given string)  return count atom  atomic element always starts uppercase character  zero lowercase letters  representing name  1 digits representing count element may follow count greater 1  count 1  digits follow  hard hash table stack recursion 
python    20 lines very readable  simplest and shortest solution    36 ms    beats 100 % number of atoms given chemical formula (given string)  return count atom  atomic element always starts uppercase character  zero lowercase letters  representing name  1 digits representing count element may follow count greater 1  count 1  digits follow  hard hash table stack recursion 
[c++] recursive parser number of atoms given chemical formula (given string)  return count atom  atomic element always starts uppercase character  zero lowercase letters  representing name  1 digits representing count element may follow count greater 1  count 1  digits follow  hard hash table stack recursion 
c++ iterative solution number of atoms given chemical formula (given string)  return count atom  atomic element always starts uppercase character  zero lowercase letters  representing name  1 digits representing count element may follow count greater 1  count 1  digits follow  hard hash table stack recursion 
python elegant 2-liner!!! self dividing numbers self-dividing number number divisible every digit contains  easy math 
[java c++] clean code self dividing numbers self-dividing number number divisible every digit contains  easy math 
one-line python (learn some python tricks that you might not know) self dividing numbers self-dividing number number divisible every digit contains  easy math 
java solution with explanation  no tostring() conversion self dividing numbers self-dividing number number divisible every digit contains  easy math 
my javascript solution self dividing numbers self-dividing number number divisible every digit contains  easy math 
java 8 liner  treemap my calendar i implement mycalendar class store events  new event added adding event cause double booking  class method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  double booking happens two events non-empty intersection (ie   time common events ) call method mycalendar book  return true event added calendar successfully without causing double booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
[java c++] clean code with explanation my calendar i implement mycalendar class store events  new event added adding event cause double booking  class method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  double booking happens two events non-empty intersection (ie   time common events ) call method mycalendar book  return true event added calendar successfully without causing double booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
binary search tree python my calendar i implement mycalendar class store events  new event added adding event cause double booking  class method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  double booking happens two events non-empty intersection (ie   time common events ) call method mycalendar book  return true event added calendar successfully without causing double booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
[java] simple 6 line solution  treemap lowerentry my calendar i implement mycalendar class store events  new event added adding event cause double booking  class method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  double booking happens two events non-empty intersection (ie   time common events ) call method mycalendar book  return true event added calendar successfully without causing double booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
short brute force python solution my calendar i implement mycalendar class store events  new event added adding event cause double booking  class method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  double booking happens two events non-empty intersection (ie   time common events ) call method mycalendar book  return true event added calendar successfully without causing double booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array 
java 96ms dp solution with detailed explanation count different palindromic subsequences given string s  find number different non-empty palindromic subsequences s  return number modulo 10^9 + 7  subsequence string obtained deleting 0 characters s  sequence palindromic equal sequence reversed  two sequences a_1  a_2      b_1  b_2      different a_i != b_i  hard string dynamic programming 
accepted java solution using memoization count different palindromic subsequences given string s  find number different non-empty palindromic subsequences s  return number modulo 10^9 + 7  subsequence string obtained deleting 0 characters s  sequence palindromic equal sequence reversed  two sequences a_1  a_2      b_1  b_2      different a_i != b_i  hard string dynamic programming 
c++ o(n^2) time  o(n) memory with explanation count different palindromic subsequences given string s  find number different non-empty palindromic subsequences s  return number modulo 10^9 + 7  subsequence string obtained deleting 0 characters s  sequence palindromic equal sequence reversed  two sequences a_1  a_2      b_1  b_2      different a_i != b_i  hard string dynamic programming 
n^2 dp python with explanation count different palindromic subsequences given string s  find number different non-empty palindromic subsequences s  return number modulo 10^9 + 7  subsequence string obtained deleting 0 characters s  sequence palindromic equal sequence reversed  two sequences a_1  a_2      b_1  b_2      different a_i != b_i  hard string dynamic programming 
java solution using simple dp  o(n^2) run time and o(n^2) space count different palindromic subsequences given string s  find number different non-empty palindromic subsequences s  return number modulo 10^9 + 7  subsequence string obtained deleting 0 characters s  sequence palindromic equal sequence reversed  two sequences a_1  a_2      b_1  b_2      different a_i != b_i  hard string dynamic programming 
[java c++] clean code with explanation my calendar ii implement mycalendartwo class store events  new event added adding event cause triple booking  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  triple booking happens three events non-empty intersection (ie   time common 3 events ) call method mycalendar book  return true event added calendar successfully without causing triple booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
n^2 python  short and elegant my calendar ii implement mycalendartwo class store events  new event added adding event cause triple booking  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  triple booking happens three events non-empty intersection (ie   time common 3 events ) call method mycalendar book  return true event added calendar successfully without causing triple booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
nlogd java solution using segment tree with lazy propagation -- applicable to the general case of k-booking my calendar ii implement mycalendartwo class store events  new event added adding event cause triple booking  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  triple booking happens three events non-empty intersection (ie   time common 3 events ) call method mycalendar book  return true event added calendar successfully without causing triple booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
simplified winner's solution my calendar ii implement mycalendartwo class store events  new event added adding event cause triple booking  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  triple booking happens three events non-empty intersection (ie   time common 3 events ) call method mycalendar book  return true event added calendar successfully without causing triple booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
simple ac by treemap my calendar ii implement mycalendartwo class store events  new event added adding event cause triple booking  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  triple booking happens three events non-empty intersection (ie   time common 3 events ) call method mycalendar book  return true event added calendar successfully without causing triple booking  otherwise  return false add event calendar  class called like this: mycalendar cal = new mycalendar(); mycalendar book(start  end) medium array binary search tree 
[java c++] clean code my calendar iii implement mycalendarthree class store events  new event always added  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  k-booking happens k events non-empty intersection (ie   time common k events ) call method mycalendar book  return integer k representing largest integer exists k-booking calendar  class called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
question explanation please my calendar iii implement mycalendarthree class store events  new event always added  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  k-booking happens k events non-empty intersection (ie   time common k events ) call method mycalendar book  return integer k representing largest integer exists k-booking calendar  class called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
c++ o(n) method my calendar iii implement mycalendarthree class store events  new event always added  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  k-booking happens k events non-empty intersection (ie   time common k events ) call method mycalendar book  return integer k representing largest integer exists k-booking calendar  class called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
is this a right test case? my calendar iii implement mycalendarthree class store events  new event always added  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  k-booking happens k events non-empty intersection (ie   time common k events ) call method mycalendar book  return integer k representing largest integer exists k-booking calendar  class called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
java solution o(n log(len)) beats 100% segment tree my calendar iii implement mycalendarthree class store events  new event always added  class one method  book(int start  int end)  formally  represents booking half open interval [start  end)  range real numbers x start <= x < end  k-booking happens k events non-empty intersection (ie   time common k events ) call method mycalendar book  return integer k representing largest integer exists k-booking calendar  class called like this: mycalendarthree cal = new mycalendarthree(); mycalendarthree book(start  end) hard segment tree binary search tree 
java 9 liner  dfs flood fill image represented 2-d array integers  integer representing pixel value image (from 0 65535)  given coordinate (sr  sc) representing starting pixel (row column) flood fill  pixel value newcolor  "flood fill" image  perform "flood fill"  consider starting pixel  plus pixels connected 4-directionally starting pixel color starting pixel  plus pixels connected 4-directionally pixels (also color starting pixel)  on  replace color aforementioned pixels newcolor  end  return modified image  easy depth-first search 
easy python dfs (no need for visited)!!! flood fill image represented 2-d array integers  integer representing pixel value image (from 0 65535)  given coordinate (sr  sc) representing starting pixel (row column) flood fill  pixel value newcolor  "flood fill" image  perform "flood fill"  consider starting pixel  plus pixels connected 4-directionally starting pixel color starting pixel  plus pixels connected 4-directionally pixels (also color starting pixel)  on  replace color aforementioned pixels newcolor  end  return modified image  easy depth-first search 
[java c++] clean code flood fill image represented 2-d array integers  integer representing pixel value image (from 0 65535)  given coordinate (sr  sc) representing starting pixel (row column) flood fill  pixel value newcolor  "flood fill" image  perform "flood fill"  consider starting pixel  plus pixels connected 4-directionally starting pixel color starting pixel  plus pixels connected 4-directionally pixels (also color starting pixel)  on  replace color aforementioned pixels newcolor  end  return modified image  easy depth-first search 
c# dfs solution flood fill image represented 2-d array integers  integer representing pixel value image (from 0 65535)  given coordinate (sr  sc) representing starting pixel (row column) flood fill  pixel value newcolor  "flood fill" image  perform "flood fill"  consider starting pixel  plus pixels connected 4-directionally starting pixel color starting pixel  plus pixels connected 4-directionally pixels (also color starting pixel)  on  replace color aforementioned pixels newcolor  end  return modified image  easy depth-first search 
java easy bfs flood fill image represented 2-d array integers  integer representing pixel value image (from 0 65535)  given coordinate (sr  sc) representing starting pixel (row column) flood fill  pixel value newcolor  "flood fill" image  perform "flood fill"  consider starting pixel  plus pixels connected 4-directionally starting pixel color starting pixel  plus pixels connected 4-directionally pixels (also color starting pixel)  on  replace color aforementioned pixels newcolor  end  return modified image  easy depth-first search 
[java c++] clean code asteroid collision given array asteroids integers representing asteroids row  asteroid  absolute value represents size  sign represents direction (positive meaning right  negative meaning left)  asteroid moves speed  find state asteroids collisions  two asteroids meet  smaller one explode  size  explode  two asteroids moving direction never meet  medium stack 
python o(n) stack-based with explanation asteroid collision given array asteroids integers representing asteroids row  asteroid  absolute value represents size  sign represents direction (positive meaning right  negative meaning left)  asteroid moves speed  find state asteroids collisions  two asteroids meet  smaller one explode  size  explode  two asteroids moving direction never meet  medium stack 
java solution  stack asteroid collision given array asteroids integers representing asteroids row  asteroid  absolute value represents size  sign represents direction (positive meaning right  negative meaning left)  asteroid moves speed  find state asteroids collisions  two asteroids meet  smaller one explode  size  explode  two asteroids moving direction never meet  medium stack 
java solution - beat 90% - no extra space  asteroid collision given array asteroids integers representing asteroids row  asteroid  absolute value represents size  sign represents direction (positive meaning right  negative meaning left)  asteroid moves speed  find state asteroids collisions  two asteroids meet  smaller one explode  size  explode  two asteroids moving direction never meet  medium stack 
stack java solution asteroid collision given array asteroids integers representing asteroids row  asteroid  absolute value represents size  sign represents direction (positive meaning right  negative meaning left)  asteroid moves speed  find state asteroids collisions  two asteroids meet  smaller one explode  size  explode  two asteroids moving direction never meet  medium stack 
c++ recursion solution with explaination parse lisp expression given string expression representing lisp-like expression return integer value of  syntax expressions given follows  expression either integer  let-expression  add-expression  mult-expression  assigned variable  expressions always evaluate single integer  (an integer could positive negative ) let-expression takes form (let v1 e1 v2 e2     vn en expr)  let always string "let"  1 pairs alternating variables expressions  meaning first variable v1 assigned value expression e1  second variable v2 assigned value expression e2  sequentially; value let-expression value expression expr  add-expression takes form (add e1 e2) add always string "add"  always two expressions e1  e2  expression evaluates addition evaluation e1 evaluation e2  mult-expression takes form (mult e1 e2) mult always string "mult"  always two expressions e1  e2  expression evaluates multiplication evaluation e1 evaluation e2  purposes question  use smaller subset variable names  variable starts lowercase letter  zero lowercase letters digits  additionally convenience  names "add"  "let"  "mult" protected never used variable names  finally  concept scope  expression variable name evaluated  within context evaluation  innermost scope (in terms parentheses) checked first value variable  outer scopes checked sequentially  guaranteed every expression legal  please see hard string 
i don't think this problem is good one for interview to be honest parse lisp expression given string expression representing lisp-like expression return integer value of  syntax expressions given follows  expression either integer  let-expression  add-expression  mult-expression  assigned variable  expressions always evaluate single integer  (an integer could positive negative ) let-expression takes form (let v1 e1 v2 e2     vn en expr)  let always string "let"  1 pairs alternating variables expressions  meaning first variable v1 assigned value expression e1  second variable v2 assigned value expression e2  sequentially; value let-expression value expression expr  add-expression takes form (add e1 e2) add always string "add"  always two expressions e1  e2  expression evaluates addition evaluation e1 evaluation e2  mult-expression takes form (mult e1 e2) mult always string "mult"  always two expressions e1  e2  expression evaluates multiplication evaluation e1 evaluation e2  purposes question  use smaller subset variable names  variable starts lowercase letter  zero lowercase letters digits  additionally convenience  names "add"  "let"  "mult" protected never used variable names  finally  concept scope  expression variable name evaluated  within context evaluation  innermost scope (in terms parentheses) checked first value variable  outer scopes checked sequentially  guaranteed every expression legal  please see hard string 
python solution using stacks  parse lisp expression given string expression representing lisp-like expression return integer value of  syntax expressions given follows  expression either integer  let-expression  add-expression  mult-expression  assigned variable  expressions always evaluate single integer  (an integer could positive negative ) let-expression takes form (let v1 e1 v2 e2     vn en expr)  let always string "let"  1 pairs alternating variables expressions  meaning first variable v1 assigned value expression e1  second variable v2 assigned value expression e2  sequentially; value let-expression value expression expr  add-expression takes form (add e1 e2) add always string "add"  always two expressions e1  e2  expression evaluates addition evaluation e1 evaluation e2  mult-expression takes form (mult e1 e2) mult always string "mult"  always two expressions e1  e2  expression evaluates multiplication evaluation e1 evaluation e2  purposes question  use smaller subset variable names  variable starts lowercase letter  zero lowercase letters digits  additionally convenience  names "add"  "let"  "mult" protected never used variable names  finally  concept scope  expression variable name evaluated  within context evaluation  innermost scope (in terms parentheses) checked first value variable  outer scopes checked sequentially  guaranteed every expression legal  please see hard string 
a clean java solution parse lisp expression given string expression representing lisp-like expression return integer value of  syntax expressions given follows  expression either integer  let-expression  add-expression  mult-expression  assigned variable  expressions always evaluate single integer  (an integer could positive negative ) let-expression takes form (let v1 e1 v2 e2     vn en expr)  let always string "let"  1 pairs alternating variables expressions  meaning first variable v1 assigned value expression e1  second variable v2 assigned value expression e2  sequentially; value let-expression value expression expr  add-expression takes form (add e1 e2) add always string "add"  always two expressions e1  e2  expression evaluates addition evaluation e1 evaluation e2  mult-expression takes form (mult e1 e2) mult always string "mult"  always two expressions e1  e2  expression evaluates multiplication evaluation e1 evaluation e2  purposes question  use smaller subset variable names  variable starts lowercase letter  zero lowercase letters digits  additionally convenience  names "add"  "let"  "mult" protected never used variable names  finally  concept scope  expression variable name evaluated  within context evaluation  innermost scope (in terms parentheses) checked first value variable  outer scopes checked sequentially  guaranteed every expression legal  please see hard string 
java modularized solution parse lisp expression given string expression representing lisp-like expression return integer value of  syntax expressions given follows  expression either integer  let-expression  add-expression  mult-expression  assigned variable  expressions always evaluate single integer  (an integer could positive negative ) let-expression takes form (let v1 e1 v2 e2     vn en expr)  let always string "let"  1 pairs alternating variables expressions  meaning first variable v1 assigned value expression e1  second variable v2 assigned value expression e2  sequentially; value let-expression value expression expr  add-expression takes form (add e1 e2) add always string "add"  always two expressions e1  e2  expression evaluates addition evaluation e1 evaluation e2  mult-expression takes form (mult e1 e2) mult always string "mult"  always two expressions e1  e2  expression evaluates multiplication evaluation e1 evaluation e2  purposes question  use smaller subset variable names  variable starts lowercase letter  zero lowercase letters digits  additionally convenience  names "add"  "let"  "mult" protected never used variable names  finally  concept scope  expression variable name evaluated  within context evaluation  innermost scope (in terms parentheses) checked first value variable  outer scopes checked sequentially  guaranteed every expression legal  please see hard string 
simple and very short c++ solution monotone increasing digits given non-negative integer n  find largest number less equal n monotone increasing digits  (recall integer monotone increasing digits pair adjacent digits x satisfy x <= y ) medium greedy 
simple python solution w  explanation monotone increasing digits given non-negative integer n  find largest number less equal n monotone increasing digits  (recall integer monotone increasing digits pair adjacent digits x satisfy x <= y ) medium greedy 
simple and very short java solution monotone increasing digits given non-negative integer n  find largest number less equal n monotone increasing digits  (recall integer monotone increasing digits pair adjacent digits x satisfy x <= y ) medium greedy 
easy java monotone increasing digits given non-negative integer n  find largest number less equal n monotone increasing digits  (recall integer monotone increasing digits pair adjacent digits x satisfy x <= y ) medium greedy 
simple java solution with clear explanation  very easy to understand  monotone increasing digits given non-negative integer n  find largest number less equal n monotone increasing digits  (recall integer monotone increasing digits pair adjacent digits x satisfy x <= y ) medium greedy 
[java] easy ac solution with stack daily temperatures given list daily temperatures t  return list that  day input  tells many days would wait warmer temperature  future day possible  put 0 instead  medium hash table stack 
[c++] clean code with explanation: o(n) time and o(1) space (beats 99 13%) daily temperatures given list daily temperatures t  return list that  day input  tells many days would wait warmer temperature  future day possible  put 0 instead  medium hash table stack 
elegant python solution with stack daily temperatures given list daily temperatures t  return list that  day input  tells many days would wait warmer temperature  future day possible  put 0 instead  medium hash table stack 
javascript stack solution with explaination daily temperatures given list daily temperatures t  return list that  day input  tells many days would wait warmer temperature  future day possible  put 0 instead  medium hash table stack 
simple python by hashing the temperatures daily temperatures given list daily temperatures t  return list that  day input  tells many days would wait warmer temperature  future day possible  put 0 instead  medium hash table stack 
[java c++] clean code with explanation delete and earn given array nums integers  perform operations array  operation  pick nums[i] delete earn nums[i] points  after  must delete every element equal nums[i] - 1 nums[i] + 1  start 0 points  return maximum number points earn applying operations  medium dynamic programming 
awesome python 4-liner with explanation - reduce to house robbers question  u0001f31d delete and earn given array nums integers  perform operations array  operation  pick nums[i] delete earn nums[i] points  after  must delete every element equal nums[i] - 1 nums[i] + 1  start 0 points  return maximum number points earn applying operations  medium dynamic programming 
sharing my simple straight forward java o(n) solution -- explanation included delete and earn given array nums integers  perform operations array  operation  pick nums[i] delete earn nums[i] points  after  must delete every element equal nums[i] - 1 nums[i] + 1  start 0 points  return maximum number points earn applying operations  medium dynamic programming 
[java] easy dp solution delete and earn given array nums integers  perform operations array  operation  pick nums[i] delete earn nums[i] points  after  must delete every element equal nums[i] - 1 nums[i] + 1  start 0 points  return maximum number points earn applying operations  medium dynamic programming 
java ------ 4 lines delete and earn given array nums integers  perform operations array  operation  pick nums[i] delete earn nums[i] points  after  must delete every element equal nums[i] - 1 nums[i] + 1  start 0 points  return maximum number points earn applying operations  medium dynamic programming 
step by step guidance of the o(n^3) time and o(n^2) space solution cherry pickup n x n grid representing field cherries  cell one three possible integers  0 means cell empty  pass through; 1 means cell contains cherry  pick pass through; -1 means cell contains thorn blocks way  task collect maximum number cherries possible following rules below: starting position (0  0) reaching (n-1  n-1) moving right valid path cells (cells value 0 1); reaching (n-1  n-1)  returning (0  0) moving left valid path cells; passing path cell containing cherry  pick cell becomes empty cell (0); valid path (0  0) (n-1  n-1)  cherries collected  hard dynamic programming 
annotated c++ dp solution cherry pickup n x n grid representing field cherries  cell one three possible integers  0 means cell empty  pass through; 1 means cell contains cherry  pick pass through; -1 means cell contains thorn blocks way  task collect maximum number cherries possible following rules below: starting position (0  0) reaching (n-1  n-1) moving right valid path cells (cells value 0 1); reaching (n-1  n-1)  returning (0  0) moving left valid path cells; passing path cell containing cherry  pick cell becomes empty cell (0); valid path (0  0) (n-1  n-1)  cherries collected  hard dynamic programming 
c++ dp solution cherry pickup n x n grid representing field cherries  cell one three possible integers  0 means cell empty  pass through; 1 means cell contains cherry  pick pass through; -1 means cell contains thorn blocks way  task collect maximum number cherries possible following rules below: starting position (0  0) reaching (n-1  n-1) moving right valid path cells (cells value 0 1); reaching (n-1  n-1)  returning (0  0) moving left valid path cells; passing path cell containing cherry  pick cell becomes empty cell (0); valid path (0  0) (n-1  n-1)  cherries collected  hard dynamic programming 
java o(n^3) dp solution w  specific explanation cherry pickup n x n grid representing field cherries  cell one three possible integers  0 means cell empty  pass through; 1 means cell contains cherry  pick pass through; -1 means cell contains thorn blocks way  task collect maximum number cherries possible following rules below: starting position (0  0) reaching (n-1  n-1) moving right valid path cells (cells value 0 1); reaching (n-1  n-1)  returning (0  0) moving left valid path cells; passing path cell containing cherry  pick cell becomes empty cell (0); valid path (0  0) (n-1  n-1)  cherries collected  hard dynamic programming 
python clean&commented o(n^3) dp cherry pickup n x n grid representing field cherries  cell one three possible integers  0 means cell empty  pass through; 1 means cell contains cherry  pick pass through; -1 means cell contains thorn blocks way  task collect maximum number cherries possible following rules below: starting position (0  0) reaching (n-1  n-1) moving right valid path cells (cells value 0 1); reaching (n-1  n-1)  returning (0  0) moving left valid path cells; passing path cell containing cherry  pick cell becomes empty cell (0); valid path (0  0) (n-1  n-1)  cherries collected  hard dynamic programming 
[c++] bellman ford network delay time n network nodes  labelled 1 n  given times  list travel times directed edges times[i] = (u  v  w)  u source node  v target node  w time takes signal travel source target  now  send signal certain node k  long take nodes receive signal? impossible  return -1  note: n range [1  100]  k range [1  n]  length times range [1  6000]  edges times[i] = (u  v  w) 1 <= u  v <= n 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
simple java djikstra's (priorityqueue optimized) solution with explanation network delay time n network nodes  labelled 1 n  given times  list travel times directed edges times[i] = (u  v  w)  u source node  v target node  w time takes signal travel source target  now  send signal certain node k  long take nodes receive signal? impossible  return -1  note: n range [1  100]  k range [1  n]  length times range [1  6000]  edges times[i] = (u  v  w) 1 <= u  v <= n 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
oj was testing out of given conditions  network delay time n network nodes  labelled 1 n  given times  list travel times directed edges times[i] = (u  v  w)  u source node  v target node  w time takes signal travel source target  now  send signal certain node k  long take nodes receive signal? impossible  return -1  note: n range [1  100]  k range [1  n]  length times range [1  6000]  edges times[i] = (u  v  w) 1 <= u  v <= n 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
straightforward python dijkstra's  u0001f60c network delay time n network nodes  labelled 1 n  given times  list travel times directed edges times[i] = (u  v  w)  u source node  v target node  w time takes signal travel source target  now  send signal certain node k  long take nodes receive signal? impossible  return -1  note: n range [1  100]  k range [1  n]  length times range [1  6000]  edges times[i] = (u  v  w) 1 <= u  v <= n 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
simple java solution using bfs (similar to dijkstra's shortest path algorithm) with explanation network delay time n network nodes  labelled 1 n  given times  list travel times directed edges times[i] = (u  v  w)  u source node  v target node  w time takes signal travel source target  now  send signal certain node k  long take nodes receive signal? impossible  return -1  note: n range [1  100]  k range [1  n]  length times range [1  6000]  edges times[i] = (u  v  w) 1 <= u  v <= n 1 <= w <= 100  easy heap depth-first search breadth-first search graph 
easy binary search in java - o(log(n)) time find smallest letter greater than target given list sorted characters letters containing lowercase letters  given target letter target  find smallest element list larger given target  letters also wrap around  easy binary search 
python no brainer!  u0001f921 find smallest letter greater than target given list sorted characters letters containing lowercase letters  given target letter target  find smallest element list larger given target  letters also wrap around  easy binary search 
[c++] 2 lines solution using upper_bound find smallest letter greater than target given list sorted characters letters containing lowercase letters  given target letter target  find smallest element list larger given target  letters also wrap around  easy binary search 
java 2 lines o(log n) find smallest letter greater than target given list sorted characters letters containing lowercase letters  given target letter target  find smallest element list larger given target  letters also wrap around  easy binary search 
java binary search find smallest letter greater than target given list sorted characters letters containing lowercase letters  given target letter target  find smallest element list larger given target  letters also wrap around  easy binary search 
three ways to solve this problem in java prefix and suffix search given many words  words[i] weight i  design class wordfilter supports one function  wordfilter f(string prefix  string suffix)  return word given prefix suffix maximum weight  word exists  return -1  hard trie 
python few ways to do it  with explanations!  u0001f389 prefix and suffix search given many words  words[i] weight i  design class wordfilter supports one function  wordfilter f(string prefix  string suffix)  return word given prefix suffix maximum weight  word exists  return -1  hard trie 
java beat 95%  just small modifications in implementing trie  prefix and suffix search given many words  words[i] weight i  design class wordfilter supports one function  wordfilter f(string prefix  string suffix)  return word given prefix suffix maximum weight  word exists  return -1  hard trie 
accepted java code  using trie prefix and suffix search given many words  words[i] weight i  design class wordfilter supports one function  wordfilter f(string prefix  string suffix)  return word given prefix suffix maximum weight  word exists  return -1  hard trie 
c++ solution using two trie  time & memory efficient  prefix and suffix search given many words  words[i] weight i  design class wordfilter supports one function  wordfilter f(string prefix  string suffix)  return word given prefix suffix maximum weight  word exists  return -1  hard trie 
easy to understand c++ using dp with detailed explanation min cost climbing stairs staircase  i-th step non-negative cost cost[i] assigned (0 indexed)  pay cost  either climb one two steps  need find minimum cost reach top floor  either start step index 0  step index 1  easy array dynamic programming 
3 lines java solution - o(1) space min cost climbing stairs staircase  i-th step non-negative cost cost[i] assigned (0 indexed)  pay cost  either climb one two steps  need find minimum cost reach top floor  either start step index 0  step index 1  easy array dynamic programming 
easy to understand - python solution - o(1) space min cost climbing stairs staircase  i-th step non-negative cost cost[i] assigned (0 indexed)  pay cost  either climb one two steps  need find minimum cost reach top floor  either start step index 0  step index 1  easy array dynamic programming 
doubt ?? min cost climbing stairs staircase  i-th step non-negative cost cost[i] assigned (0 indexed)  pay cost  either climb one two steps  need find minimum cost reach top floor  either start step index 0  step index 1  easy array dynamic programming 
simple python solution min cost climbing stairs staircase  i-th step non-negative cost cost[i] assigned (0 indexed)  pay cost  either climb one two steps  need find minimum cost reach top floor  either start step index 0  step index 1  easy array dynamic programming 
python o(n) time and o(1) space without fancy builtins largest number at least twice of others given integer array nums  always exactly one largest element  find whether largest element array least twice much every number array  is  return index largest element  otherwise return -1  easy array 
[java] one pass solution o(n) complexity largest number at least twice of others given integer array nums  always exactly one largest element  find whether largest element array least twice much every number array  is  return index largest element  otherwise return -1  easy array 
one pass o(n) java solution 9ms 100% largest number at least twice of others given integer array nums  always exactly one largest element  find whether largest element array least twice much every number array  is  return index largest element  otherwise return -1  easy array 
my c++ solution largest number at least twice of others given integer array nums  always exactly one largest element  find whether largest element array least twice much every number array  is  return index largest element  otherwise return -1  easy array 
[java]-fetch two largest values  one pass tc-o(n)  sc-o(1) largest number at least twice of others given integer array nums  always exactly one largest element  find whether largest element array least twice much every number array  is  return index largest element  otherwise return -1  easy array 
java 6ms beats 100% prime numbers shortest completing word find minimum length word given dictionary words  letters string licenseplate  word said complete given string licenseplate here  letters ignore case  easy hash table 
java solution using character array shortest completing word find minimum length word given dictionary words  letters string licenseplate  word said complete given string licenseplate here  letters ignore case  easy hash table 
python solutions shortest completing word find minimum length word given dictionary words  letters string licenseplate  word said complete given string licenseplate here  letters ignore case  easy hash table 
java solution 17ms using char array shortest completing word find minimum length word given dictionary words  letters string licenseplate  word said complete given string licenseplate here  letters ignore case  easy hash table 
easy java shortest completing word find minimum length word given dictionary words  letters string licenseplate  word said complete given string licenseplate here  letters ignore case  easy hash table 
funniest output answer i've ever seen on leetcode contain virus virus spreading rapidly  task quarantine infected area installing walls  world modeled 2-d array cells  0 represents uninfected cells  1 represents cells contaminated virus  wall (and one wall) installed two 4-directionally adjacent cells  shared boundary  every night  virus spreads neighboring cells four directions unless blocked wall  resources limited  day  install walls around one region -- affected area (continuous block infected cells) threatens uninfected cells following night  never tie  save day? so  number walls required? not  world becomes fully infected  return number walls used  hard depth-first search 
c++  dfs  12ms contain virus virus spreading rapidly  task quarantine infected area installing walls  world modeled 2-d array cells  0 represents uninfected cells  1 represents cells contaminated virus  wall (and one wall) installed two 4-directionally adjacent cells  shared boundary  every night  virus spreads neighboring cells four directions unless blocked wall  resources limited  day  install walls around one region -- affected area (continuous block infected cells) threatens uninfected cells following night  never tie  save day? so  number walls required? not  world becomes fully infected  return number walls used  hard depth-first search 
my neat java solution using dfs contain virus virus spreading rapidly  task quarantine infected area installing walls  world modeled 2-d array cells  0 represents uninfected cells  1 represents cells contaminated virus  wall (and one wall) installed two 4-directionally adjacent cells  shared boundary  every night  virus spreads neighboring cells four directions unless blocked wall  resources limited  day  install walls around one region -- affected area (continuous block infected cells) threatens uninfected cells following night  never tie  save day? so  number walls required? not  world becomes fully infected  return number walls used  hard depth-first search 
after a region is quarantined  is it still considered continuous with other regions? contain virus virus spreading rapidly  task quarantine infected area installing walls  world modeled 2-d array cells  0 represents uninfected cells  1 represents cells contaminated virus  wall (and one wall) installed two 4-directionally adjacent cells  shared boundary  every night  virus spreads neighboring cells four directions unless blocked wall  resources limited  day  install walls around one region -- affected area (continuous block infected cells) threatens uninfected cells following night  never tie  save day? so  number walls required? not  world becomes fully infected  return number walls used  hard depth-first search 
did the problem logic change during the contest? contain virus virus spreading rapidly  task quarantine infected area installing walls  world modeled 2-d array cells  0 represents uninfected cells  1 represents cells contaminated virus  wall (and one wall) installed two 4-directionally adjacent cells  shared boundary  every night  virus spreads neighboring cells four directions unless blocked wall  resources limited  day  install walls around one region -- affected area (continuous block infected cells) threatens uninfected cells following night  never tie  save day? so  number walls required? not  world becomes fully infected  return number walls used  hard depth-first search 
regular java bfs solution and 2-end bfs solution with improvement open the lock lock front 4 circular wheels  wheel 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  wheels rotate freely wrap around: medium breadth-first search 
bfs solution c++ open the lock lock front 4 circular wheels  wheel 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  wheels rotate freely wrap around: medium breadth-first search 
accepted python java bfs  + how to avoid tle open the lock lock front 4 circular wheels  wheel 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  wheels rotate freely wrap around: medium breadth-first search 
why wrong answer? open the lock lock front 4 circular wheels  wheel 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  wheels rotate freely wrap around: medium breadth-first search 
python 16 lines    simple and readable    bfs solution    beats 94 % open the lock lock front 4 circular wheels  wheel 10 slots: '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  wheels rotate freely wrap around: medium breadth-first search 
short java solution with explanation reach a number standing position 0 infinite number line  goal position target  move  either go left right  n-th move (starting 1)  take n steps  return minimum number steps required reach destination  easy math 
c++ o(1) solution  without loop reach a number standing position 0 infinite number line  goal position target  move  either go left right  n-th move (starting 1)  take n steps  return minimum number steps required reach destination  easy math 
not an easy reach a number standing position 0 infinite number line  goal position target  move  either go left right  n-th move (starting 1)  take n steps  return minimum number steps required reach destination  easy math 
concise python with explanation and example reach a number standing position 0 infinite number line  goal position target  move  either go left right  n-th move (starting 1)  take n steps  return minimum number steps required reach destination  easy math 
learn from other with my explanations  reach a number standing position 0 infinite number line  goal position target  move  either go left right  n-th move (starting 1)  take n steps  return minimum number steps required reach destination  easy math 
java solution - map + backtracking pyramid transition matrix stacking blocks form pyramid  block color one letter string  like `'z'`  every block color `c` place bottom row  placing top left block color `a` right block color `b`  allowed place block `(a  b  c)` allowed triple  start bottom row bottom  represented single string  also start list allowed triples allowed  allowed triple represented string length 3  return true build pyramid way top  otherwise false  medium bit manipulation depth-first search 
counter example to the standard code pyramid transition matrix stacking blocks form pyramid  block color one letter string  like `'z'`  every block color `c` place bottom row  placing top left block color `a` right block color `b`  allowed place block `(a  b  c)` allowed triple  start bottom row bottom  represented single string  also start list allowed triples allowed  allowed triple represented string length 3  return true build pyramid way top  otherwise false  medium bit manipulation depth-first search 
c++ passed counter example  dfs with memoization  6 ms pyramid transition matrix stacking blocks form pyramid  block color one letter string  like `'z'`  every block color `c` place bottom row  placing top left block color `a` right block color `b`  allowed place block `(a  b  c)` allowed triple  start bottom row bottom  represented single string  also start list allowed triples allowed  allowed triple represented string length 3  return true build pyramid way top  otherwise false  medium bit manipulation depth-first search 
easy and concise python solution pyramid transition matrix stacking blocks form pyramid  block color one letter string  like `'z'`  every block color `c` place bottom row  placing top left block color `a` right block color `b`  allowed place block `(a  b  c)` allowed triple  start bottom row bottom  represented single string  also start list allowed triples allowed  allowed triple represented string length 3  return true build pyramid way top  otherwise false  medium bit manipulation depth-first search 
dp o(n^2   m) pyramid transition matrix stacking blocks form pyramid  block color one letter string  like `'z'`  every block color `c` place bottom row  placing top left block color `a` right block color `b`  allowed place block `(a  b  c)` allowed triple  start bottom row bottom  represented single string  also start list allowed triples allowed  allowed triple represented string length 3  return true build pyramid way top  otherwise false  medium bit manipulation depth-first search 
ever wonder why the greedy algorithm works? here is the explanation! set intersection size at least two integer interval [a  b] (for integers < b) set consecutive integers b  including b  find minimum size set every integer interval intervals  intersection size least 2  hard greedy 
java o(nlogn) solution  greedy set intersection size at least two integer interval [a  b] (for integers < b) set consecutive integers b  including b  find minimum size set every integer interval intervals  intersection size least 2  hard greedy 
c++ concise solution  o(nlogn) greedy  39 ms set intersection size at least two integer interval [a  b] (for integers < b) set consecutive integers b  including b  find minimum size set every integer interval intervals  intersection size least 2  hard greedy 
hope you enjoy this problem  : )  o(nlogn) java greedy  easy to understand solution set intersection size at least two integer interval [a  b] (for integers < b) set consecutive integers b  including b  find minimum size set every integer interval intervals  intersection size least 2  hard greedy 
c++ greedy o(nlogn) with explanations set intersection size at least two integer interval [a  b] (for integers < b) set consecutive integers b  including b  find minimum size set every integer interval intervals  intersection size least 2  hard greedy 
easy and concise solution with explanation [c++ java python] special binary string special binary strings binary strings following two properties: number 0's equal number 1's  every prefix binary string least many 1's 0's  given special string s  move consists choosing two consecutive  non-empty  special substrings s  swapping them  (two strings consecutive last character first string exactly one index first character second string ) end number moves  lexicographically largest resulting string possible? hard string recursion 
think of it as valid-parentheses special binary string special binary strings binary strings following two properties: number 0's equal number 1's  every prefix binary string least many 1's 0's  given special string s  move consists choosing two consecutive  non-empty  special substrings s  swapping them  (two strings consecutive last character first string exactly one index first character second string ) end number moves  lexicographically largest resulting string possible? hard string recursion 
what is the definition of "special"? special binary string special binary strings binary strings following two properties: number 0's equal number 1's  every prefix binary string least many 1's 0's  given special string s  move consists choosing two consecutive  non-empty  special substrings s  swapping them  (two strings consecutive last character first string exactly one index first character second string ) end number moves  lexicographically largest resulting string possible? hard string recursion 
logical thinking with clear code special binary string special binary strings binary strings following two properties: number 0's equal number 1's  every prefix binary string least many 1's 0's  given special string s  move consists choosing two consecutive  non-empty  special substrings s  swapping them  (two strings consecutive last character first string exactly one index first character second string ) end number moves  lexicographically largest resulting string possible? hard string recursion 
sharing my simple   easy to understand straight forward java solution special binary string special binary strings binary strings following two properties: number 0's equal number 1's  every prefix binary string least many 1's 0's  given special string s  move consists choosing two consecutive  non-empty  special substrings s  swapping them  (two strings consecutive last character first string exactly one index first character second string ) end number moves  lexicographically largest resulting string possible? hard string recursion 
665772 prime number of set bits in binary representation given two integers l r  find count numbers range [l  r] (inclusive) prime number set bits binary representation  (recall number set bits integer number 1s present written binary  easy bit manipulation 
[java c++] clean code prime number of set bits in binary representation given two integers l r  find count numbers range [l  r] (inclusive) prime number set bits binary representation  (recall number set bits integer number 1s present written binary  easy bit manipulation 
easy o(n) java solution using dp prime number of set bits in binary representation given two integers l r  find count numbers range [l  r] (inclusive) prime number set bits binary representation  (recall number set bits integer number 1s present written binary  easy bit manipulation 
sort easy python prime number of set bits in binary representation given two integers l r  find count numbers range [l  r] (inclusive) prime number set bits binary representation  (recall number set bits integer number 1s present written binary  easy bit manipulation 
python 1 line prime number of set bits in binary representation given two integers l r  find count numbers range [l  r] (inclusive) prime number set bits binary representation  (recall number set bits integer number 1s present written binary  easy bit manipulation 
java 2 pass o(n) time o(1) space  extending end pointer solution partition labels string lowercase letters given  want partition string many parts possible letter appears one part  return list integers representing size parts  medium two pointers greedy 
short easy python partition labels string lowercase letters given  want partition string many parts possible letter appears one part  return list integers representing size parts  medium two pointers greedy 
c++ 6 lines o(n)   o(1) - two simple passes partition labels string lowercase letters given  want partition string many parts possible letter appears one part  return list integers representing size parts  medium two pointers greedy 
easy o(n) java solution using sliding window (two pointers)  comments and explanation given partition labels string lowercase letters given  want partition string many parts possible letter appears one part  return list integers representing size parts  medium two pointers greedy 
java very short and easy solution partition labels string lowercase letters given  want partition string many parts possible letter appears one part  return list integers representing size parts  medium two pointers greedy 
java c++ python o(n^2) solution using only one grid matrix largest plus sign 2d grid (0  0) (n-1  n-1)  every cell contains 1  except cells given list mines 0  largest axis-aligned plus sign 1s contained grid? return order plus sign  none  return 0  "axis-aligned plus sign 1s order k" center grid[x][y] = 1 along 4 arms length k-1 going up  down  left  right  made 1s  demonstrated diagrams below  note could 0s 1s beyond arms plus sign  relevant area plus sign checked 1s  medium dynamic programming 
easy to understand java solution largest plus sign 2d grid (0  0) (n-1  n-1)  every cell contains 1  except cells given list mines 0  largest axis-aligned plus sign 1s contained grid? return order plus sign  none  return 0  "axis-aligned plus sign 1s order k" center grid[x][y] = 1 along 4 arms length k-1 going up  down  left  right  made 1s  demonstrated diagrams below  note could 0s 1s beyond arms plus sign  relevant area plus sign checked 1s  medium dynamic programming 
python 250ms solution largest plus sign 2d grid (0  0) (n-1  n-1)  every cell contains 1  except cells given list mines 0  largest axis-aligned plus sign 1s contained grid? return order plus sign  none  return 0  "axis-aligned plus sign 1s order k" center grid[x][y] = 1 along 4 arms length k-1 going up  down  left  right  made 1s  demonstrated diagrams below  note could 0s 1s beyond arms plus sign  relevant area plus sign checked 1s  medium dynamic programming 
my simple o(n^2) time and o(n^2) space accepted solution 150ms largest plus sign 2d grid (0  0) (n-1  n-1)  every cell contains 1  except cells given list mines 0  largest axis-aligned plus sign 1s contained grid? return order plus sign  none  return 0  "axis-aligned plus sign 1s order k" center grid[x][y] = 1 along 4 arms length k-1 going up  down  left  right  made 1s  demonstrated diagrams below  note could 0s 1s beyond arms plus sign  relevant area plus sign checked 1s  medium dynamic programming 
c++ o(n^3) solution 226ms with explanation  largest plus sign 2d grid (0  0) (n-1  n-1)  every cell contains 1  except cells given list mines 0  largest axis-aligned plus sign 1s contained grid? return order plus sign  none  return 0  "axis-aligned plus sign 1s order k" center grid[x][y] = 1 along 4 arms length k-1 going up  down  left  right  made 1s  demonstrated diagrams below  note could 0s 1s beyond arms plus sign  relevant area plus sign checked 1s  medium dynamic programming 
java c++ o(n) solution using cyclic swapping couples holding hands n couples sit 2n seats arranged row want hold hands  want know minimum number swaps every couple sitting side side  swap consists choosing two people  stand switch seats  people seats represented integer 0 2n-1  couples numbered order  first couple (0  1)  second couple (2  3)  last couple (2n-2  2n-1)  couples' initial seating given row[i] value person initially sitting i-th seat  hard greedy union find graph 
java  union find  easy to understand  5 ms couples holding hands n couples sit 2n seats arranged row want hold hands  want know minimum number swaps every couple sitting side side  swap consists choosing two people  stand switch seats  people seats represented integer 0 2n-1  couples numbered order  first couple (0  1)  second couple (2  3)  last couple (2n-2  2n-1)  couples' initial seating given row[i] value person initially sitting i-th seat  hard greedy union find graph 
java ac o(n) greedy solution  couples holding hands n couples sit 2n seats arranged row want hold hands  want know minimum number swaps every couple sitting side side  swap consists choosing two people  stand switch seats  people seats represented integer 0 2n-1  couples numbered order  first couple (0  1)  second couple (2  3)  last couple (2n-2  2n-1)  couples' initial seating given row[i] value person initially sitting i-th seat  hard greedy union find graph 
na xefve solution accepted (with a proof)    wrong difficulty? couples holding hands n couples sit 2n seats arranged row want hold hands  want know minimum number swaps every couple sitting side side  swap consists choosing two people  stand switch seats  people seats represented integer 0 2n-1  couples numbered order  first couple (0  1)  second couple (2  3)  last couple (2n-2  2n-1)  couples' initial seating given row[i] value person initially sitting i-th seat  hard greedy union find graph 
union find  understand in 60 seconds  beats 99 6% couples holding hands n couples sit 2n seats arranged row want hold hands  want know minimum number swaps every couple sitting side side  swap consists choosing two people  stand switch seats  people seats represented integer 0 2n-1  couples numbered order  first couple (0  1)  second couple (2  3)  last couple (2n-2  2n-1)  couples' initial seating given row[i] value person initially sitting i-th seat  hard greedy union find graph 
java solution  4 liner  toeplitz matrix matrix toeplitz every diagonal top-left bottom-right element  given x n matrix  return true matrix toeplitz  easy array 
python easy and concise solution toeplitz matrix matrix toeplitz every diagonal top-left bottom-right element  given x n matrix  return true matrix toeplitz  easy array 
[c++ java] clean code toeplitz matrix matrix toeplitz every diagonal top-left bottom-right element  given x n matrix  return true matrix toeplitz  easy array 
java answers to the follow-ups (load partial row column one time)  the 3rd one beats 98%  toeplitz matrix matrix toeplitz every diagonal top-left bottom-right element  given x n matrix  return true matrix toeplitz  easy array 
one line easy python solution  using slice  only 1 "for loop"  toeplitz matrix matrix toeplitz every diagonal top-left bottom-right element  given x n matrix  return true matrix toeplitz  easy array 
java solution  priorityqueue reorganize string given string s  check letters rearranged two characters adjacent same  possible  output possible result  possible  return empty string  medium string heap greedy sort 
4 lines python reorganize string given string s  check letters rearranged two characters adjacent same  possible  output possible result  possible  return empty string  medium string heap greedy sort 
c++  greedy sort  o(n) reorganize string given string s  check letters rearranged two characters adjacent same  possible  output possible result  possible  return empty string  medium string heap greedy sort 
simple python solution using priorityqueue reorganize string given string s  check letters rearranged two characters adjacent same  possible  output possible result  possible  return empty string  medium string heap greedy sort 
java solution  99% similar to 358 reorganize string given string s  check letters rearranged two characters adjacent same  possible  output possible result  possible  return empty string  medium string heap greedy sort 
java solution  left max and right min  max chunks to make sorted ii question "max chunks make sorted" except integers given array necessarily distinct  input array could length 2000  elements could 10  8  given array arr integers (not necessarily distinct)  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? hard array 
[c++] 9 lines  15ms max chunks to make sorted ii question "max chunks make sorted" except integers given array necessarily distinct  input array could length 2000  elements could 10  8  given array arr integers (not necessarily distinct)  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? hard array 
python easy and concise solution max chunks to make sorted ii question "max chunks make sorted" except integers given array necessarily distinct  input array could length 2000  elements could 10  8  given array arr integers (not necessarily distinct)  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? hard array 
simple java solution with explanation max chunks to make sorted ii question "max chunks make sorted" except integers given array necessarily distinct  input array could length 2000  elements could 10  8  given array arr integers (not necessarily distinct)  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? hard array 
c++ 7 lines  o (n   log n)   o(n) max chunks to make sorted ii question "max chunks make sorted" except integers given array necessarily distinct  input array could length 2000  elements could 10  8  given array arr integers (not necessarily distinct)  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? hard array 
simple java o(n) solution with detailed explanation max chunks to make sorted given array arr permutation [0  1       arr length - 1]  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? medium array 
java solution  left max and right min  max chunks to make sorted given array arr permutation [0  1       arr length - 1]  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? medium array 
c++ 4 lines o(n)   o(1) max chunks to make sorted given array arr permutation [0  1       arr length - 1]  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? medium array 
[c++] 6 lines  3ms solution max chunks to make sorted given array arr permutation [0  1       arr length - 1]  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? medium array 
java o(n)  beats 100% max chunks to make sorted given array arr permutation [0  1       arr length - 1]  split array number "chunks" (partitions)  individually sort chunk  concatenating them  result equals sorted array  number chunks could made? medium array 
i would give up directly if asked this question in interview basic calculator iv given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1])  return list tokens representing simplified expression  ["-1 a" "14"] expression alternates chunks symbols  space separating chunk symbol  chunk either expression parentheses  variable  non-negative integer  variable string lowercase letters (not including digits ) note variables multiple letters  note variables never leading coefficient unary operator like "2x" "-x"  expressions evaluated usual order: brackets first  multiplication  addition subtraction  hard hash table string stack 
easy :-p basic calculator iv given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1])  return list tokens representing simplified expression  ["-1 a" "14"] expression alternates chunks symbols  space separating chunk symbol  chunk either expression parentheses  variable  non-negative integer  variable string lowercase letters (not including digits ) note variables multiple letters  note variables never leading coefficient unary operator like "2x" "-x"  expressions evaluated usual order: brackets first  multiplication  addition subtraction  hard hash table string stack 
c++  unordered_map + stack  with explanation basic calculator iv given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1])  return list tokens representing simplified expression  ["-1 a" "14"] expression alternates chunks symbols  space separating chunk symbol  chunk either expression parentheses  variable  non-negative integer  variable string lowercase letters (not including digits ) note variables multiple letters  note variables never leading coefficient unary operator like "2x" "-x"  expressions evaluated usual order: brackets first  multiplication  addition subtraction  hard hash table string stack 
java solution  using stack basic calculator iv given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1])  return list tokens representing simplified expression  ["-1 a" "14"] expression alternates chunks symbols  space separating chunk symbol  chunk either expression parentheses  variable  non-negative integer  variable string lowercase letters (not including digits ) note variables multiple letters  note variables never leading coefficient unary operator like "2x" "-x"  expressions evaluated usual order: brackets first  multiplication  addition subtraction  hard hash table string stack 
do it the hard way: real tokenizer & parser basic calculator iv given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1])  return list tokens representing simplified expression  ["-1 a" "14"] expression alternates chunks symbols  space separating chunk symbol  chunk either expression parentheses  variable  non-negative integer  variable string lowercase letters (not including digits ) note variables multiple letters  note variables never leading coefficient unary operator like "2x" "-x"  expressions evaluated usual order: brackets first  multiplication  addition subtraction  hard hash table string stack 
1-liners python java ruby jewels and stones given strings j representing types stones jewels  representing stones have  character type stone have  want know many stones also jewels  letters j guaranteed distinct  characters j letters  letters case sensitive  "a" considered different type stone "a"  easy hash table 
[c++ java python] easy and concise solution o(m+n)  jewels and stones given strings j representing types stones jewels  representing stones have  character type stone have  want know many stones also jewels  letters j guaranteed distinct  characters j letters  letters case sensitive  "a" considered different type stone "a"  easy hash table 
java: o(s+j) time and o(1) space jewels and stones given strings j representing types stones jewels  representing stones have  character type stone have  want know many stones also jewels  letters j guaranteed distinct  characters j letters  letters case sensitive  "a" considered different type stone "a"  easy hash table 
python o(m+n) hash - 公瑾 jewels and stones given strings j representing types stones jewels  representing stones have  character type stone have  want know many stones also jewels  letters j guaranteed distinct  characters j letters  letters case sensitive  "a" considered different type stone "a"  easy hash table 
two-line javascript solution jewels and stones given strings j representing types stones jewels  representing stones have  character type stone have  want know many stones also jewels  letters j guaranteed distinct  characters j letters  letters case sensitive  "a" considered different type stone "a"  easy hash table 
java 19ms 26 clean lines bfs with comment  sliding puzzle 2x3 board  5 tiles represented integers 1 5  empty square represented 0  move consists choosing 0 4-directionally adjacent number swapping it  state board solved board [[1 2 3] [4 5 0]]  given puzzle board  return least number moves required state board solved  impossible state board solved  return -1  hard breadth-first search 
java 8ms bfs with algorithm explained sliding puzzle 2x3 board  5 tiles represented integers 1 5  empty square represented 0  move consists choosing 0 4-directionally adjacent number swapping it  state board solved board [[1 2 3] [4 5 0]]  given puzzle board  return least number moves required state board solved  impossible state board solved  return -1  hard breadth-first search 
c++ 9 lines dfs and bfs sliding puzzle 2x3 board  5 tiles represented integers 1 5  empty square represented 0  move consists choosing 0 4-directionally adjacent number swapping it  state board solved board [[1 2 3] [4 5 0]]  given puzzle board  return least number moves required state board solved  impossible state board solved  return -1  hard breadth-first search 
readable java solution sliding puzzle 2x3 board  5 tiles represented integers 1 5  empty square represented 0  move consists choosing 0 4-directionally adjacent number swapping it  state board solved board [[1 2 3] [4 5 0]]  given puzzle board  return least number moves required state board solved  impossible state board solved  return -1  hard breadth-first search 
java intuitive dfs+backtracking sliding puzzle 2x3 board  5 tiles represented integers 1 5  empty square represented 0  move consists choosing 0 4-directionally adjacent number swapping it  state board solved board [[1 2 3] [4 5 0]]  given puzzle board  return least number moves required state board solved  impossible state board solved  return -1  hard breadth-first search 
my 3 lines c++ solution global and local inversions permutation [0  1       n - 1]  n length a  number (global) inversions number < j 0 <= < j < n a[i] > a[j]  number local inversions number 0 <= < n a[i] > a[i+1]  return true number global inversions equal number local inversions  medium array math 
easy and concise solution [c++ java python] global and local inversions permutation [0  1       n - 1]  n length a  number (global) inversions number < j 0 <= < j < n a[i] > a[j]  number local inversions number 0 <= < n a[i] > a[i+1]  return true number global inversions equal number local inversions  medium array math 
check if we can sort the array with only local inversions global and local inversions permutation [0  1       n - 1]  n length a  number (global) inversions number < j 0 <= < j < n a[i] > a[j]  number local inversions number 0 <= < n a[i] > a[i+1]  return true number global inversions equal number local inversions  medium array math 
java o(n) solution with explanation global and local inversions permutation [0  1       n - 1]  n length a  number (global) inversions number < j 0 <= < j < n a[i] > a[j]  number local inversions number 0 <= < n a[i] > a[i+1]  return true number global inversions equal number local inversions  medium array math 
logical thinking with clear code global and local inversions permutation [0  1       n - 1]  n length a  number (global) inversions number < j 0 <= < j < n a[i] > a[j]  number local inversions number 0 <= < n a[i] > a[i+1]  return true number global inversions equal number local inversions  medium array math 
simple java one pass o(n) solution with explaination swap adjacent in lr string string composed 'l'  'r'  'x' characters  like "rxxlrxrxl"  move consists either replacing one occurrence "xl" "lx"  replacing one occurrence "rx" "xr"  given starting string start ending string end  return true exists sequence moves transform one string other  medium brainteaser 
simple java solution swap adjacent in lr string string composed 'l'  'r'  'x' characters  like "rxxlrxrxl"  move consists either replacing one occurrence "xl" "lx"  replacing one occurrence "rx" "xr"  given starting string start ending string end  return true exists sequence moves transform one string other  medium brainteaser 
python simple solution  3 lines o(n) swap adjacent in lr string string composed 'l'  'r'  'x' characters  like "rxxlrxrxl"  move consists either replacing one occurrence "xl" "lx"  replacing one occurrence "rx" "xr"  given starting string start ending string end  return true exists sequence moves transform one string other  medium brainteaser 
[c++] simple subsequence matching with position constraint  swap adjacent in lr string string composed 'l'  'r'  'x' characters  like "rxxlrxrxl"  move consists either replacing one occurrence "xl" "lx"  replacing one occurrence "rx" "xr"  given starting string start ending string end  return true exists sequence moves transform one string other  medium brainteaser 
c++ with explanation  o(n)  14ms swap adjacent in lr string string composed 'l'  'r'  'x' characters  like "rxxlrxrxl"  move consists either replacing one occurrence "xl" "lx"  replacing one occurrence "rx" "xr"  given starting string start ending string end  return true exists sequence moves transform one string other  medium brainteaser 
easy and concise solution using priorityqueue [python c++] swim in rising water n x n grid  square grid[i][j] represents elevation point (i j)  rain starts fall  time t  depth water everywhere t  swim square another 4-directionally adjacent square elevation squares individually t  swim infinite distance zero time  course  must stay within boundaries grid swim  start top left square (0  0)  least time reach bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
c++ two solutions  binary search+dfs and dijkstra+bfs  o(n^2logn)  11ms swim in rising water n x n grid  square grid[i][j] represents elevation point (i j)  rain starts fall  time t  depth water everywhere t  swim square another 4-directionally adjacent square elevation squares individually t  swim infinite distance zero time  course  must stay within boundaries grid swim  start top left square (0  0)  least time reach bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
java - dfs and union find swim in rising water n x n grid  square grid[i][j] represents elevation point (i j)  rain starts fall  time t  depth water everywhere t  swim square another 4-directionally adjacent square elevation squares individually t  swim infinite distance zero time  course  must stay within boundaries grid swim  start top left square (0  0)  least time reach bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
easy and concise solution using binary search [python c++] swim in rising water n x n grid  square grid[i][j] represents elevation point (i j)  rain starts fall  time t  depth water everywhere t  swim square another 4-directionally adjacent square elevation squares individually t  swim infinite distance zero time  course  must stay within boundaries grid swim  start top left square (0  0)  least time reach bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
o(n^2) solution  union-find  python swim in rising water n x n grid  square grid[i][j] represents elevation point (i j)  rain starts fall  time t  depth water everywhere t  swim square another 4-directionally adjacent square elevation squares individually t  swim infinite distance zero time  course  must stay within boundaries grid swim  start top left square (0  0)  least time reach bottom right square (n-1  n-1)? hard binary search heap depth-first search union find 
my 3 lines c++ recursive solution k-th symbol in grammar first row  write 0  every subsequent row  look previous row replace occurrence 0 01  occurrence 1 10  given row n index k  return k-th indexed symbol row n  (the values k 1-indexed ) (1 indexed)  medium recursion 
[java] one line k-th symbol in grammar first row  write 0  every subsequent row  look previous row replace occurrence 0 01  occurrence 1 10  given row n index k  return k-th indexed symbol row n  (the values k 1-indexed ) (1 indexed)  medium recursion 
python 1-line k-th symbol in grammar first row  write 0  every subsequent row  look previous row replace occurrence 0 01  occurrence 1 10  given row n index k  return k-th indexed symbol row n  (the values k 1-indexed ) (1 indexed)  medium recursion 
[python java c++] easy 1-line solution with detailed explanation k-th symbol in grammar first row  write 0  every subsequent row  look previous row replace occurrence 0 01  occurrence 1 10  given row n index k  return k-th indexed symbol row n  (the values k 1-indexed ) (1 indexed)  medium recursion 
c++ with explanation  three solutions o(n)  o(logn)  and o(loglogn) k-th symbol in grammar first row  write 0  every subsequent row  look previous row replace occurrence 0 01  occurrence 1 10  given row n index k  return k-th indexed symbol row n  (the values k 1-indexed ) (1 indexed)  medium recursion 
easy and concise 2-line solution[python c++ java] reaching points move consists taking point (x  y) transforming either (x  x+y) (x+y  y)  given starting point (sx  sy) target point (tx  ty)  return true sequence moves exists transform point (sx  sy) (tx  ty)  otherwise  return false  hard math 
[c++] simple iterative  reaching points move consists taking point (x  y) transforming either (x  x+y) (x+y  y)  given starting point (sx  sy) target point (tx  ty)  return true sequence moves exists transform point (sx  sy) (tx  ty)  otherwise  return false  hard math 
[java] easy to understand recursion solution reaching points move consists taking point (x  y) transforming either (x  x+y) (x+y  y)  given starting point (sx  sy) target point (tx  ty)  return true sequence moves exists transform point (sx  sy) (tx  ty)  otherwise  return false  hard math 
[java] simple solution with explanation reaching points move consists taking point (x  y) transforming either (x  x+y) (x+y  y)  given starting point (sx  sy) target point (tx  ty)  return true sequence moves exists transform point (sx  sy) (tx  ty)  otherwise  return false  hard math 
c++ simple 6 line solution reaching points move consists taking point (x  y) transforming either (x  x+y) (x+y  y)  given starting point (sx  sy) target point (tx  ty)  return true sequence moves exists transform point (sx  sy) (tx  ty)  otherwise  return false  hard math 
 [c++ java python] easy and concise solution rabbits in forest forest  rabbit color  subset rabbits (possibly them) tell many rabbits color them  answers placed array  return minimum number rabbits could forest  medium hash table math 
my easy java hashmap solution rabbits in forest forest  rabbit color  subset rabbits (possibly them) tell many rabbits color them  answers placed array  return minimum number rabbits could forest  medium hash table math 
java solution with hashmap o(n) and comments rabbits in forest forest  rabbit color  subset rabbits (possibly them) tell many rabbits color them  answers placed array  return minimum number rabbits could forest  medium hash table math 
java simple solution rabbits in forest forest  rabbit color  subset rabbits (possibly them) tell many rabbits color them  answers placed array  return minimum number rabbits could forest  medium hash table math 
 u3010simple python u3011 rabbits in forest forest  rabbit color  subset rabbits (possibly them) tell many rabbits color them  answers placed array  return minimum number rabbits could forest  medium hash table math 
easy and concise solution with explanation [c++ java python] transform to chessboard n x n board contains 0s 1s  move  swap 2 rows other  2 columns other  minimum number moves transform board "chessboard" - board 0s 1s 4-directionally adjacent? task impossible  return -1  hard array math 
key observation on property of chessboard transform to chessboard n x n board contains 0s 1s  move  swap 2 rows other  2 columns other  minimum number moves transform board "chessboard" - board 0s 1s 4-directionally adjacent? task impossible  return -1  hard array math 
short c++ solution  no swaps  9ms  o(n^2) time  o(1) space transform to chessboard n x n board contains 0s 1s  move  swap 2 rows other  2 columns other  minimum number moves transform board "chessboard" - board 0s 1s 4-directionally adjacent? task impossible  return -1  hard array math 
java clear code with detailed explanations transform to chessboard n x n board contains 0s 1s  move  swap 2 rows other  2 columns other  minimum number moves transform board "chessboard" - board 0s 1s 4-directionally adjacent? task impossible  return -1  hard array math 
c++ o(n^2) time solution with explantion transform to chessboard n x n board contains 0s 1s  move  swap 2 rows other  2 columns other  minimum number moves transform board "chessboard" - board 0s 1s 4-directionally adjacent? task impossible  return -1  hard array math 
come on guys  it is obviously the same as problems 530  minimum absolute difference in bst minimum distance between bst nodes given binary search tree (bst) root node root  return minimum difference values two different nodes tree  easy binary search tree 
inorder traversal o(n) time recursion [c++ java python] minimum distance between bst nodes given binary search tree (bst) root node root  return minimum difference values two different nodes tree  easy binary search tree 
problem title is confusing minimum distance between bst nodes given binary search tree (bst) root node root  return minimum difference values two different nodes tree  easy binary search tree 
what the result of [2147483647 -2147483648 null]? minimum distance between bst nodes given binary search tree (bst) root node root  return minimum difference values two different nodes tree  easy binary search tree 
c++ recursive and iterative summary for question 783 & 530  minimum distance between bst nodes given binary search tree (bst) root node root  return minimum difference values two different nodes tree  easy binary search tree 
java easy bfs   dfs solution with explanation letter case permutation given string s  transform every letter individually lowercase uppercase create another string  return list possible strings could create  easy backtracking bit manipulation 
python simple solution (7 lines) letter case permutation given string s  transform every letter individually lowercase uppercase create another string  return list possible strings could create  easy backtracking bit manipulation 
c++ backtrack solution w  trick letter case permutation given string s  transform every letter individually lowercase uppercase create another string  return list possible strings could create  easy backtracking bit manipulation 
easy python 2 line solution letter case permutation given string s  transform every letter individually lowercase uppercase create another string  return list possible strings could create  easy backtracking bit manipulation 
java solution using recursion letter case permutation given string s  transform every letter individually lowercase uppercase create another string  return list possible strings could create  easy backtracking bit manipulation 
java clean dfs solution with explanation is graph bipartite? given undirected graph  return true bipartite  recall graph bipartite split set nodes two independent subsets b every edge graph one node another node b  graph given following form: graph[i] list indexes j edge nodes j exists  node integer 0 graph length - 1  self edges parallel edges: graph[i] contain i  contain element twice  medium depth-first search breadth-first search graph 
java bfs  is graph bipartite? given undirected graph  return true bipartite  recall graph bipartite split set nodes two independent subsets b every edge graph one node another node b  graph given following form: graph[i] list indexes j edge nodes j exists  node integer 0 graph length - 1  self edges parallel edges: graph[i] contain i  contain element twice  medium depth-first search breadth-first search graph 
java short iterative solution is graph bipartite? given undirected graph  return true bipartite  recall graph bipartite split set nodes two independent subsets b every edge graph one node another node b  graph given following form: graph[i] list indexes j edge nodes j exists  node integer 0 graph length - 1  self edges parallel edges: graph[i] contain i  contain element twice  medium depth-first search breadth-first search graph 
why is this even a test case? [[1] [0] [0 1]] is graph bipartite? given undirected graph  return true bipartite  recall graph bipartite split set nodes two independent subsets b every edge graph one node another node b  graph given following form: graph[i] list indexes j edge nodes j exists  node integer 0 graph length - 1  self edges parallel edges: graph[i] contain i  contain element twice  medium depth-first search breadth-first search graph 
easy python solution is graph bipartite? given undirected graph  return true bipartite  recall graph bipartite split set nodes two independent subsets b every edge graph one node another node b  graph given following form: graph[i] list indexes j edge nodes j exists  node integer 0 graph length - 1  self edges parallel edges: graph[i] contain i  contain element twice  medium depth-first search breadth-first search graph 
summary of solutions for problems "reducible" to leetcode 378 k-th smallest prime fraction sorted list contains 1  plus number primes  then  every p < q list  consider fraction p q  k-th smallest fraction considered? return answer array ints  answer[0] = p answer[1] = q  hard binary search heap 
[java] ac o(max(n k)   logn) short easy priorityqueue k-th smallest prime fraction sorted list contains 1  plus number primes  then  every p < q list  consider fraction p q  k-th smallest fraction considered? return answer array ints  answer[0] = p answer[1] = q  hard binary search heap 
c++ 9lines priority queue k-th smallest prime fraction sorted list contains 1  plus number primes  then  every p < q list  consider fraction p q  k-th smallest fraction considered? return answer array ints  answer[0] = p answer[1] = q  hard binary search heap 
o(n) k-th smallest prime fraction sorted list contains 1  plus number primes  then  every p < q list  consider fraction p q  k-th smallest fraction considered? return answer array ints  answer[0] = p answer[1] = q  hard binary search heap 
python solution using binary search k-th smallest prime fraction sorted list contains 1  plus number primes  then  every p < q list  consider fraction p q  k-th smallest fraction considered? return answer array ints  answer[0] = p answer[1] = q  hard binary search heap 
 [java python] priority queue solution cheapest flights within k stops n cities connected flights  fight starts city u arrives v price w  given cities flights  together starting city src destination dst  task find cheapest price src dst k stops  route  output -1  medium dynamic programming heap breadth-first search 
c++ 8 line bellman ford cheapest flights within k stops n cities connected flights  fight starts city u arrives v price w  given cities flights  together starting city src destination dst  task find cheapest price src dst k stops  route  output -1  medium dynamic programming heap breadth-first search 
5 ms ac java solution based on dijkstra's algorithm  cheapest flights within k stops n cities connected flights  fight starts city u arrives v price w  given cities flights  together starting city src destination dst  task find cheapest price src dst k stops  route  output -1  medium dynamic programming heap breadth-first search 
three c++ solutions bfs  dfs  and bf cheapest flights within k stops n cities connected flights  fight starts city u arrives v price w  given cities flights  together starting city src destination dst  task find cheapest price src dst k stops  route  output -1  medium dynamic programming heap breadth-first search 
c++ solution using dynamic programming cheapest flights within k stops n cities connected flights  fight starts city u arrives v price w  given cities flights  together starting city src destination dst  task find cheapest price src dst k stops  route  output -1  medium dynamic programming heap breadth-first search 
java dp solution 9ms rotated digits x good number rotating digit individually 180 degrees  get valid number different x  digit must rotated - cannot choose leave alone  number valid digit remains digit rotation  0  1  8 rotate themselves; 2 5 rotate other; 6 9 rotate other  rest numbers rotate number become invalid  given positive number n  many numbers x 1 n good? easy string 
easily understood java solution rotated digits x good number rotating digit individually 180 degrees  get valid number different x  digit must rotated - cannot choose leave alone  number valid digit remains digit rotation  0  1  8 rotate themselves; 2 5 rotate other; 6 9 rotate other  rest numbers rotate number become invalid  given positive number n  many numbers x 1 n good? easy string 
the question need to be explained clearly rotated digits x good number rotating digit individually 180 degrees  get valid number different x  digit must rotated - cannot choose leave alone  number valid digit remains digit rotation  0  1  8 rotate themselves; 2 5 rotate other; 6 9 rotate other  rest numbers rotate number become invalid  given positive number n  many numbers x 1 n good? easy string 
easy to understand python solution (using string) rotated digits x good number rotating digit individually 180 degrees  get valid number different x  digit must rotated - cannot choose leave alone  number valid digit remains digit rotation  0  1  8 rotate themselves; 2 5 rotate other; 6 9 rotate other  rest numbers rotate number become invalid  given positive number n  many numbers x 1 n good? easy string 
o(log10(n)) easy to understand java solution rotated digits x good number rotating digit individually 180 degrees  get valid number different x  digit must rotated - cannot choose leave alone  number valid digit remains digit rotation  0  1  8 rotate themselves; 2 5 rotate other; 6 9 rotate other  rest numbers rotate number become invalid  given positive number n  many numbers x 1 n good? easy string 
why interception in the middle is not a good idea for ghosts  escape the ghosts playing simplified pacman game  start point (0  0)  destination (target[0]  target[1])  several ghosts map  i-th ghost starts (ghosts[i][0]  ghosts[i][1])  turn  ghosts simultaneously  may  move one 4 cardinal directions: north  east  west  south  going previous point new point 1 unit distance away  escape reach target ghost reaches (for given moves ghosts may take ) reach square (including target) time ghost  count escape  return true possible escape  medium math 
java 5 liner escape the ghosts playing simplified pacman game  start point (0  0)  destination (target[0]  target[1])  several ghosts map  i-th ghost starts (ghosts[i][0]  ghosts[i][1])  turn  ghosts simultaneously  may  move one 4 cardinal directions: north  east  west  south  going previous point new point 1 unit distance away  escape reach target ghost reaches (for given moves ghosts may take ) reach square (including target) time ghost  count escape  return true possible escape  medium math 
short with explanation  python escape the ghosts playing simplified pacman game  start point (0  0)  destination (target[0]  target[1])  several ghosts map  i-th ghost starts (ghosts[i][0]  ghosts[i][1])  turn  ghosts simultaneously  may  move one 4 cardinal directions: north  east  west  south  going previous point new point 1 unit distance away  escape reach target ghost reaches (for given moves ghosts may take ) reach square (including target) time ghost  count escape  return true possible escape  medium math 
test case showing true  but false in output escape the ghosts playing simplified pacman game  start point (0  0)  destination (target[0]  target[1])  several ghosts map  i-th ghost starts (ghosts[i][0]  ghosts[i][1])  turn  ghosts simultaneously  may  move one 4 cardinal directions: north  east  west  south  going previous point new point 1 unit distance away  escape reach target ghost reaches (for given moves ghosts may take ) reach square (including target) time ghost  count escape  return true possible escape  medium math 
[c++ java python] easy and concise solution escape the ghosts playing simplified pacman game  start point (0  0)  destination (target[0]  target[1])  several ghosts map  i-th ghost starts (ghosts[i][0]  ghosts[i][1])  turn  ghosts simultaneously  may  move one 4 cardinal directions: north  east  west  south  going previous point new point 1 unit distance away  escape reach target ghost reaches (for given moves ghosts may take ) reach square (including target) time ghost  count escape  return true possible escape  medium math 
detail and explanation of o(n) solution why dp[n]=2 d[n-1]+dp[n-3] domino and tromino tiling two types tiles: 2x1 domino shape  "l" tromino shape  shapes may rotated  xx <- domino xx <- "l" tromino x given n  many ways tile 2 x n board? return answer modulo 10^9 + 7  (in tiling  every square must covered tile  two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile ) medium dynamic programming 
schematic explanation of two equivalent dp recurrence formula domino and tromino tiling two types tiles: 2x1 domino shape  "l" tromino shape  shapes may rotated  xx <- domino xx <- "l" tromino x given n  many ways tile 2 x n board? return answer modulo 10^9 + 7  (in tiling  every square must covered tile  two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile ) medium dynamic programming 
python recursive dp solution with cache w  explanation domino and tromino tiling two types tiles: 2x1 domino shape  "l" tromino shape  shapes may rotated  xx <- domino xx <- "l" tromino x given n  many ways tile 2 x n board? return answer modulo 10^9 + 7  (in tiling  every square must covered tile  two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile ) medium dynamic programming 
easy to understand o(n) solution with drawing picture explanation! domino and tromino tiling two types tiles: 2x1 domino shape  "l" tromino shape  shapes may rotated  xx <- domino xx <- "l" tromino x given n  many ways tile 2 x n board? return answer modulo 10^9 + 7  (in tiling  every square must covered tile  two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile ) medium dynamic programming 
o(n) time and o(1) space [c++ java python] domino and tromino tiling two types tiles: 2x1 domino shape  "l" tromino shape  shapes may rotated  xx <- domino xx <- "l" tromino x given n  many ways tile 2 x n board? return answer modulo 10^9 + 7  (in tiling  every square must covered tile  two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile ) medium dynamic programming 
java 5 ms 10 line counting solution with comment custom sort string strings composed lowercase letters  s  letter occurs once  sorted custom order previously  want permute characters match order sorted  specifically  x occurs s  x occur returned string  return permutation (as string) satisfies property  medium string 
two lines c++ custom sort string strings composed lowercase letters  s  letter occurs once  sorted custom order previously  want permute characters match order sorted  specifically  x occurs s  x occur returned string  return permutation (as string) satisfies property  medium string 
java bucket sort solution o(n+m) with follow up questions custom sort string strings composed lowercase letters  s  letter occurs once  sorted custom order previously  want permute characters match order sorted  specifically  x occurs s  x occur returned string  return permutation (as string) satisfies property  medium string 
easy python solution custom sort string strings composed lowercase letters  s  letter occurs once  sorted custom order previously  want permute characters match order sorted  specifically  x occurs s  x occur returned string  return permutation (as string) satisfies property  medium string 
python priority queue solution o(nlgn) custom sort string strings composed lowercase letters  s  letter occurs once  sorted custom order previously  want permute characters match order sorted  specifically  x occurs s  x occur returned string  return permutation (as string) satisfies property  medium string 
efficient and simple  go through words in parallel  with explanation number of matching subsequences given string dictionary words words  find number words[i] subsequence s  medium array 
java solution using hashmap and queue number of matching subsequences given string dictionary words words  find number words[i] subsequence s  medium array 
simple python solution number of matching subsequences given string dictionary words words  find number words[i] subsequence s  medium array 
java o(n) solution number of matching subsequences given string dictionary words words  find number words[i] subsequence s  medium array 
c++ 12 line solution with explanation number of matching subsequences given string dictionary words words  find number words[i] subsequence s  medium array 
four binary search solutions based on different ideas preimage size of factorial zeroes function let f(x) number zeroes end x!  (recall x! = 1   2   3         x  convention  0! = 1 ) hard binary search 
binary search python code [40ms] preimage size of factorial zeroes function let f(x) number zeroes end x!  (recall x! = 1   2   3         x  convention  0! = 1 ) hard binary search 
c++  o(logn)  math solution with explanation preimage size of factorial zeroes function let f(x) number zeroes end x!  (recall x! = 1   2   3         x  convention  0! = 1 ) hard binary search 
using binary search java solution preimage size of factorial zeroes function let f(x) number zeroes end x!  (recall x! = 1   2   3         x  convention  0! = 1 ) hard binary search 
python simple binary search solution preimage size of factorial zeroes function let f(x) number zeroes end x!  (recall x! = 1   2   3         x  convention  0! = 1 ) hard binary search 
straightforward java solution with explaination valid tic-tac-toe state tic-tac-toe board given string array board  return true possible reach board position course valid tic-tac-toe game  board 3 x 3 array  consists characters " "  "x"  "o"  " " character represents empty square  rules tic-tac-toe: players take turns placing characters empty squares (" ")  first player always places "x" characters  second player always places "o" characters  "x" "o" characters always placed empty squares  never filled ones  game ends 3 (non-empty) character filling row  column  diagonal  game also ends squares non-empty  moves played game over  medium math recursion 
4 lines python valid tic-tac-toe state tic-tac-toe board given string array board  return true possible reach board position course valid tic-tac-toe game  board 3 x 3 array  consists characters " "  "x"  "o"  " " character represents empty square  rules tic-tac-toe: players take turns placing characters empty squares (" ")  first player always places "x" characters  second player always places "o" characters  "x" "o" characters always placed empty squares  never filled ones  game ends 3 (non-empty) character filling row  column  diagonal  game also ends squares non-empty  moves played game over  medium math recursion 
simple python solution with explanation valid tic-tac-toe state tic-tac-toe board given string array board  return true possible reach board position course valid tic-tac-toe game  board 3 x 3 array  consists characters " "  "x"  "o"  " " character represents empty square  rules tic-tac-toe: players take turns placing characters empty squares (" ")  first player always places "x" characters  second player always places "o" characters  "x" "o" characters always placed empty squares  never filled ones  game ends 3 (non-empty) character filling row  column  diagonal  game also ends squares non-empty  moves played game over  medium math recursion 
java - 20 lines with a cute trick  valid tic-tac-toe state tic-tac-toe board given string array board  return true possible reach board position course valid tic-tac-toe game  board 3 x 3 array  consists characters " "  "x"  "o"  " " character represents empty square  rules tic-tac-toe: players take turns placing characters empty squares (" ")  first player always places "x" characters  second player always places "o" characters  "x" "o" characters always placed empty squares  never filled ones  game ends 3 (non-empty) character filling row  column  diagonal  game also ends squares non-empty  moves played game over  medium math recursion 
easy to understand in c valid tic-tac-toe state tic-tac-toe board given string array board  return true possible reach board position course valid tic-tac-toe game  board 3 x 3 array  consists characters " "  "x"  "o"  " " character represents empty square  rules tic-tac-toe: players take turns placing characters empty squares (" ")  first player always places "x" characters  second player always places "o" characters  "x" "o" characters always placed empty squares  never filled ones  game ends 3 (non-empty) character filling row  column  diagonal  game also ends squares non-empty  moves played game over  medium math recursion 
short java o(n) solution number of subarrays with bounded maximum given array positive integers  two positive integers l r (l <= r)  return number (contiguous  non-empty) subarrays value maximum array element subarray least l r  medium array 
c++  o(n)  <10 lines number of subarrays with bounded maximum given array positive integers  two positive integers l r (l <= r)  return number (contiguous  non-empty) subarrays value maximum array element subarray least l r  medium array 
python   standard dp solution with explanation  number of subarrays with bounded maximum given array positive integers  two positive integers l r (l <= r)  return number (contiguous  non-empty) subarrays value maximum array element subarray least l r  medium array 
c++ o(n) solution with explanations number of subarrays with bounded maximum given array positive integers  two positive integers l r (l <= r)  return number (contiguous  non-empty) subarrays value maximum array element subarray least l r  medium array 
clean & simple o(n) java  number of subarrays with bounded maximum given array positive integers  two positive integers l r (l <= r)  return number (contiguous  non-empty) subarrays value maximum array element subarray least l r  medium array 
c++   java   python 1 line solution rotate string given two strings  b  shift consists taking string moving leftmost character rightmost position  easy 
java 1 line solution rotate string given two strings  b  shift consists taking string moving leftmost character rightmost position  easy 
[c++ java python] 1-line solution rotate string given two strings  b  shift consists taking string moving leftmost character rightmost position  easy 
1 line c++ rotate string given two strings  b  shift consists taking string moving leftmost character rightmost position  easy 
python 3  beats 100% rotate string given two strings  b  shift consists taking string moving leftmost character rightmost position  easy 
java dfs solution all paths from source to target given directed  acyclic graph n nodes  find possible paths node 0 node n-1  return order  graph given follows: nodes 0  1       graph length - 1  graph[i] list nodes j edge (i  j) exists  medium 
easy and concise dfs solution [c++   2-line python] all paths from source to target given directed  acyclic graph n nodes  find possible paths node 0 node n-1  return order  graph given follows: nodes 0  1       graph length - 1  graph[i] list nodes j edge (i  j) exists  medium 
c++ dfs recursive  easy to understand all paths from source to target given directed  acyclic graph n nodes  find possible paths node 0 node n-1  return order  graph given follows: nodes 0  1       graph length - 1  graph[i] list nodes j edge (i  j) exists  medium 
short python iterative dfs all paths from source to target given directed  acyclic graph n nodes  find possible paths node 0 node n-1  return order  graph given follows: nodes 0  1       graph length - 1  graph[i] list nodes j edge (i  j) exists  medium 
javascript solution all paths from source to target given directed  acyclic graph n nodes  find possible paths node 0 node n-1  return order  graph given follows: nodes 0  1       graph length - 1  graph[i] list nodes j edge (i  j) exists  medium 
 [c++ java python] solution with explanation smallest rotation with highest score given array a  may rotate non-negative integer k array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  entries less equal index worth 1 point  hard 
java  o(n)time o(n) space solution smallest rotation with highest score given array a  may rotate non-negative integer k array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  entries less equal index worth 1 point  hard 
easy c++  w  comments - o(n) time smallest rotation with highest score given array a  may rotate non-negative integer k array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  entries less equal index worth 1 point  hard 
two python3 o(n) time and space ac solutions with picture explanation smallest rotation with highest score given array a  may rotate non-negative integer k array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  entries less equal index worth 1 point  hard 
java solution w  comments smallest rotation with highest score given array a  may rotate non-negative integer k array becomes a[k]  a[k+1]  a{k+2]      a[a length - 1]  a[0]  a[1]       a[k-1]  afterward  entries less equal index worth 1 point  hard 
[20ms] c++  easy understand solution champagne tower stack glasses pyramid  first row 1 glass  second row 2 glasses  100th row  glass holds one cup (250ml) champagne  then  champagne poured first glass top  top glass full  excess liquid poured fall equally glass immediately left right it  glasses become full  excess champagne fall equally left right glasses  on  (a glass bottom row excess champagne fall floor ) medium 
[9ms] 5 lines code [ c++ java ] champagne tower stack glasses pyramid  first row 1 glass  second row 2 glasses  100th row  glass holds one cup (250ml) champagne  then  champagne poured first glass top  top glass full  excess liquid poured fall equally glass immediately left right it  glasses become full  excess champagne fall equally left right glasses  on  (a glass bottom row excess champagne fall floor ) medium 
 [c++ java python] o(101) space solution champagne tower stack glasses pyramid  first row 1 glass  second row 2 glasses  100th row  glass holds one cup (250ml) champagne  then  champagne poured first glass top  top glass full  excess liquid poured fall equally glass immediately left right it  glasses become full  excess champagne fall equally left right glasses  on  (a glass bottom row excess champagne fall floor ) medium 
simple c++ solution and explanations champagne tower stack glasses pyramid  first row 1 glass  second row 2 glasses  100th row  glass holds one cup (250ml) champagne  then  champagne poured first glass top  top glass full  excess liquid poured fall equally glass immediately left right it  glasses become full  excess champagne fall equally left right glasses  on  (a glass bottom row excess champagne fall floor ) medium 
simple python dp solution champagne tower stack glasses pyramid  first row 1 glass  second row 2 glasses  100th row  glass holds one cup (250ml) champagne  then  champagne poured first glass top  top glass full  excess liquid poured fall equally glass immediately left right it  glasses become full  excess champagne fall equally left right glasses  on  (a glass bottom row excess champagne fall floor ) medium 
java o(n) dp solution minimum swaps to make sequences increasing two integer sequences b non-zero length  allowed swap elements a[i] b[i]  note elements index position respective sequences  end number swaps  b strictly increasing  (a sequence strictly increasing a[0] < a[1] < a[2] <     < a[a length - 1] ) given b  return minimum number swaps make sequences strictly increasing  guaranteed given input always makes possible  medium dynamic programming 
python 14-line o(1) space o(n) time dp solution minimum swaps to make sequences increasing two integer sequences b non-zero length  allowed swap elements a[i] b[i]  note elements index position respective sequences  end number swaps  b strictly increasing  (a sequence strictly increasing a[0] < a[1] < a[2] <     < a[a length - 1] ) given b  return minimum number swaps make sequences strictly increasing  guaranteed given input always makes possible  medium dynamic programming 
[c++ java python] easy understood dp solution minimum swaps to make sequences increasing two integer sequences b non-zero length  allowed swap elements a[i] b[i]  note elements index position respective sequences  end number swaps  b strictly increasing  (a sequence strictly increasing a[0] < a[1] < a[2] <     < a[a length - 1] ) given b  return minimum number swaps make sequences strictly increasing  guaranteed given input always makes possible  medium dynamic programming 
logical thinking with optimization minimum swaps to make sequences increasing two integer sequences b non-zero length  allowed swap elements a[i] b[i]  note elements index position respective sequences  end number swaps  b strictly increasing  (a sequence strictly increasing a[0] < a[1] < a[2] <     < a[a length - 1] ) given b  return minimum number swaps make sequences strictly increasing  guaranteed given input always makes possible  medium dynamic programming 
java neat and easy to understand dp o(n) solution! minimum swaps to make sequences increasing two integer sequences b non-zero length  allowed swap elements a[i] b[i]  note elements index position respective sequences  end number swaps  b strictly increasing  (a sequence strictly increasing a[0] < a[1] < a[2] <     < a[a length - 1] ) given b  return minimum number swaps make sequences strictly increasing  guaranteed given input always makes possible  medium dynamic programming 
straightforward java solution  easy to understand! find eventual safe states directed graph  start node every turn  walk along directed edge graph  reach node terminal (that is  outgoing directed edges)  stop  now  say starting node eventually safe must eventually walk terminal node  specifically  exists natural number k choice walk  must stopped terminal node less k steps  nodes eventually safe? return array sorted order  directed graph n nodes labels 0  1       n-1  n length graph  graph given following form: graph[i] list labels j (i  j) directed edge graph  medium depth-first search graph 
20-line python concise sol by removing 0 out degree nodes find eventual safe states directed graph  start node every turn  walk along directed edge graph  reach node terminal (that is  outgoing directed edges)  stop  now  say starting node eventually safe must eventually walk terminal node  specifically  exists natural number k choice walk  must stopped terminal node less k steps  nodes eventually safe? return array sorted order  directed graph n nodes labels 0  1       n-1  n length graph  graph given following form: graph[i] list labels j (i  j) directed edge graph  medium depth-first search graph 
python  easy peasy    11 lines very simple and clear solution    192 ms    beats 100 % find eventual safe states directed graph  start node every turn  walk along directed edge graph  reach node terminal (that is  outgoing directed edges)  stop  now  say starting node eventually safe must eventually walk terminal node  specifically  exists natural number k choice walk  must stopped terminal node less k steps  nodes eventually safe? return array sorted order  directed graph n nodes labels 0  1       n-1  n length graph  graph given following form: graph[i] list labels j (i  j) directed edge graph  medium depth-first search graph 
c++  simple topological sorting with dp find eventual safe states directed graph  start node every turn  walk along directed edge graph  reach node terminal (that is  outgoing directed edges)  stop  now  say starting node eventually safe must eventually walk terminal node  specifically  exists natural number k choice walk  must stopped terminal node less k steps  nodes eventually safe? return array sorted order  directed graph n nodes labels 0  1       n-1  n length graph  graph given following form: graph[i] list labels j (i  j) directed edge graph  medium depth-first search graph 
c++ dfs solution with explanation  o(n) find eventual safe states directed graph  start node every turn  walk along directed edge graph  reach node terminal (that is  outgoing directed edges)  stop  now  say starting node eventually safe must eventually walk terminal node  specifically  exists natural number k choice walk  must stopped terminal node less k steps  nodes eventually safe? return array sorted order  directed graph n nodes labels 0  1       n-1  n length graph  graph given following form: graph[i] list labels j (i  j) directed edge graph  medium depth-first search graph 
python solution by reversely adding hits bricks back bricks falling when hit grid 1s 0s; 1s cell represent bricks  brick drop directly connected top grid  least one (4-way) adjacent bricks drop  erasures sequentially  time want erasure location (i  j)  brick (if exists) location disappear  bricks may drop erasure  return array representing number bricks drop erasure sequence  hard union find 
tricky problem that reverses lc305 bricks falling when hit grid 1s 0s; 1s cell represent bricks  brick drop directly connected top grid  least one (4-way) adjacent bricks drop  erasures sequentially  time want erasure location (i  j)  brick (if exists) location disappear  bricks may drop erasure  return array representing number bricks drop erasure sequence  hard union find 
c++ dfs (similar to lc749) bricks falling when hit grid 1s 0s; 1s cell represent bricks  brick drop directly connected top grid  least one (4-way) adjacent bricks drop  erasures sequentially  time want erasure location (i  j)  brick (if exists) location disappear  bricks may drop erasure  return array representing number bricks drop erasure sequence  hard union find 
java solution bricks falling when hit grid 1s 0s; 1s cell represent bricks  brick drop directly connected top grid  least one (4-way) adjacent bricks drop  erasures sequentially  time want erasure location (i  j)  brick (if exists) location disappear  bricks may drop erasure  return array representing number bricks drop erasure sequence  hard union find 
java simple dfs 16ms  reversely add bricks back bricks falling when hit grid 1s 0s; 1s cell represent bricks  brick drop directly connected top grid  least one (4-way) adjacent bricks drop  erasures sequentially  time want erasure location (i  j)  brick (if exists) location disappear  bricks may drop erasure  return array representing number bricks drop erasure sequence  hard union find 
is the description of the problem correct? unique morse code words international morse code defines standard encoding letter mapped series dots dashes  follows: "a" maps " -"  "b" maps "-   "  "c" maps "- - "  on  convenience  full table 26 letters english alphabet given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given list words  word written concatenation morse code letter  easy string 
[c++ java python]  easy and concise solution unique morse code words international morse code defines standard encoding letter mapped series dots dashes  follows: "a" maps " -"  "b" maps "-   "  "c" maps "- - "  on  convenience  full table 26 letters english alphabet given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given list words  word written concatenation morse code letter  easy string 
c++  straightforward unique morse code words international morse code defines standard encoding letter mapped series dots dashes  follows: "a" maps " -"  "b" maps "-   "  "c" maps "- - "  on  convenience  full table 26 letters english alphabet given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given list words  word written concatenation morse code letter  easy string 
accepted java solution unique morse code words international morse code defines standard encoding letter mapped series dots dashes  follows: "a" maps " -"  "b" maps "-   "  "c" maps "- - "  on  convenience  full table 26 letters english alphabet given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given list words  word written concatenation morse code letter  easy string 
easy python solution unique morse code words international morse code defines standard encoding letter mapped series dots dashes  follows: "a" maps " -"  "b" maps "-   "  "c" maps "- - "  on  convenience  full table 26 letters english alphabet given below: [" -" "-   " "- - " "-  " " " "  - " "-- " "    " "  " " ---" "- -" " -  " "--" "- " "---" " -- " "-- -" " - " "   " "-" "  -" "   -" " --" "-  -" "- --" "--  "] now  given list words  word written concatenation morse code letter  easy string 
c++ solution with explanation  early termination (updated for new test case) split array with same average given integer array a  must move every element either list b list c  (b c initially start empty ) return true move  possible average value b equal average value c  b c non-empty  hard math 
dp with bitset over  sum  (fast python ruby  decent c++) split array with same average given integer array a  must move every element either list b list c  (b c initially start empty ) return true move  possible average value b equal average value c  b c non-empty  hard math 
simple python with explanation split array with same average given integer array a  must move every element either list b list c  (b c initially start empty ) return true move  possible average value b equal average value c  b c non-empty  hard math 
java  accepted recursive solution  with explanation split array with same average given integer array a  must move every element either list b list c  (b c initially start empty ) return true move  possible average value b equal average value c  b c non-empty  hard math 
easy and concise solution ［c++ java python］  split array with same average given integer array a  must move every element either list b list c  (b c initially start empty ) return true move  possible average value b equal average value c  b c non-empty  hard math 
the description of the question has to be updated number of lines to write string write letters given string s  left right lines  line maximum width 100 units  writing letter would cause width line exceed 100 units  written next line  given array widths  array widths[0] width 'a'  widths[1] width 'b'       widths[25] width 'z'  answer two questions: many lines least one character s  width used last line? return answer integer list length 2  easy 
easy solution 6-lines [c++ java python]  number of lines to write string write letters given string s  left right lines  line maximum width 100 units  writing letter would cause width line exceed 100 units  written next line  given array widths  array widths[0] width 'a'  widths[1] width 'b'       widths[25] width 'z'  answer two questions: many lines least one character s  width used last line? return answer integer list length 2  easy 
this question is so inane and badly written it should be deleted  number of lines to write string write letters given string s  left right lines  line maximum width 100 units  writing letter would cause width line exceed 100 units  written next line  given array widths  array widths[0] width 'a'  widths[1] width 'b'       widths[25] width 'z'  answer two questions: many lines least one character s  width used last line? return answer integer list length 2  easy 
regex number of lines to write string write letters given string s  left right lines  line maximum width 100 units  writing letter would cause width line exceed 100 units  written next line  given array widths  array widths[0] width 'a'  widths[1] width 'b'       widths[25] width 'z'  answer two questions: many lines least one character s  width used last line? return answer integer list length 2  easy 
c++  straightforward  number of lines to write string write letters given string s  left right lines  line maximum width 100 units  writing letter would cause width line exceed 100 units  written next line  given array widths  array widths[0] width 'a'  widths[1] width 'b'       widths[25] width 'z'  answer two questions: many lines least one character s  width used last line? return answer integer list length 2  easy 
easy and concise solution [c++ java python]  max increase to keep city skyline 2 dimensional array grid  value grid[i][j] represents height building located there  allowed increase height number buildings  amount (the amounts different different buildings)  height 0 considered building well  end  "skyline" viewed four directions grid  i e  top  bottom  left  right  must skyline original grid  city's skyline outer contour rectangles formed buildings viewed distance  see following medium 
what is this question?  max increase to keep city skyline 2 dimensional array grid  value grid[i][j] represents height building located there  allowed increase height number buildings  amount (the amounts different different buildings)  height 0 considered building well  end  "skyline" viewed four directions grid  i e  top  bottom  left  right  must skyline original grid  city's skyline outer contour rectangles formed buildings viewed distance  see following medium 
48ms python3 solution max increase to keep city skyline 2 dimensional array grid  value grid[i][j] represents height building located there  allowed increase height number buildings  amount (the amounts different different buildings)  height 0 considered building well  end  "skyline" viewed four directions grid  i e  top  bottom  left  right  must skyline original grid  city's skyline outer contour rectangles formed buildings viewed distance  see following medium 
c++  straightforward o(m n) time max increase to keep city skyline 2 dimensional array grid  value grid[i][j] represents height building located there  allowed increase height number buildings  amount (the amounts different different buildings)  height 0 considered building well  end  "skyline" viewed four directions grid  i e  top  bottom  left  right  must skyline original grid  city's skyline outer contour rectangles formed buildings viewed distance  see following medium 
simple python solution max increase to keep city skyline 2 dimensional array grid  value grid[i][j] represents height building located there  allowed increase height number buildings  amount (the amounts different different buildings)  height 0 considered building well  end  "skyline" viewed four directions grid  i e  top  bottom  left  right  must skyline original grid  city's skyline outer contour rectangles formed buildings viewed distance  see following medium 
[c++ java python] when n >= 4800  just return 1 soup servings two types soup: type type b  initially n ml type soup  four kinds operations: serve 100 ml soup 0 ml soup b serve 75 ml soup 25 ml soup b serve 50 ml soup 50 ml soup b serve 25 ml soup 75 ml soup b serve soup  give someone longer it  turn  choose four operations equal probability 0 25  remaining volume soup enough complete operation  serve much can  stop longer quantity types soup  note operation 100 ml's soup b used first  return probability soup empty first  plus half probability b become empty time  medium dynamic programming 
straightforward java recursion with memorization soup servings two types soup: type type b  initially n ml type soup  four kinds operations: serve 100 ml soup 0 ml soup b serve 75 ml soup 25 ml soup b serve 50 ml soup 50 ml soup b serve 25 ml soup 75 ml soup b serve soup  give someone longer it  turn  choose four operations equal probability 0 25  remaining volume soup enough complete operation  serve much can  stop longer quantity types soup  note operation 100 ml's soup b used first  return probability soup empty first  plus half probability b become empty time  medium dynamic programming 
easy understand c++ recursive solution soup servings two types soup: type type b  initially n ml type soup  four kinds operations: serve 100 ml soup 0 ml soup b serve 75 ml soup 25 ml soup b serve 50 ml soup 50 ml soup b serve 25 ml soup 75 ml soup b serve soup  give someone longer it  turn  choose four operations equal probability 0 25  remaining volume soup enough complete operation  serve much can  stop longer quantity types soup  note operation 100 ml's soup b used first  return probability soup empty first  plus half probability b become empty time  medium dynamic programming 
python    7 lines clear dp solution    44 ms    beats 97 5 % soup servings two types soup: type type b  initially n ml type soup  four kinds operations: serve 100 ml soup 0 ml soup b serve 75 ml soup 25 ml soup b serve 50 ml soup 50 ml soup b serve 25 ml soup 75 ml soup b serve soup  give someone longer it  turn  choose four operations equal probability 0 25  remaining volume soup enough complete operation  serve much can  stop longer quantity types soup  note operation 100 ml's soup b used first  return probability soup empty first  plus half probability b become empty time  medium dynamic programming 
[java]top down search with hashmap memorized soup servings two types soup: type type b  initially n ml type soup  four kinds operations: serve 100 ml soup 0 ml soup b serve 75 ml soup 25 ml soup b serve 50 ml soup 50 ml soup b serve 25 ml soup 75 ml soup b serve soup  give someone longer it  turn  choose four operations equal probability 0 25  remaining volume soup enough complete operation  serve much can  stop longer quantity types soup  note operation 100 ml's soup b used first  return probability soup empty first  plus half probability b become empty time  medium dynamic programming 
[c++ java python] 2 pointers and 4 pointers expressive words sometimes people repeat letters represent extra feeling  "hello" -> "heeellooo"  "hi" -> "hiiii"  here  groups  adjacent letters character  adjacent characters group different  group extended group length 3 more  "e" "o" would extended first medium string 
short straight-forward c++ solution  two pointers one pass scan expressive words sometimes people repeat letters represent extra feeling  "hello" -> "heeellooo"  "hi" -> "hiiii"  here  groups  adjacent letters character  adjacent characters group different  group extended group length 3 more  "e" "o" would extended first medium string 
some test case have problems? expressive words sometimes people repeat letters represent extra feeling  "hello" -> "heeellooo"  "hi" -> "hiiii"  here  groups  adjacent letters character  adjacent characters group different  group extended group length 3 more  "e" "o" would extended first medium string 
15 lines java code - 2 pointers 1 pass  expressive words sometimes people repeat letters represent extra feeling  "hello" -> "heeellooo"  "hi" -> "hiiii"  here  groups  adjacent letters character  adjacent characters group different  group extended group length 3 more  "e" "o" would extended first medium string 
simple and clear solution with detailed exaplanation expressive words sometimes people repeat letters represent extra feeling  "hello" -> "heeellooo"  "hi" -> "hiiii"  here  groups  adjacent letters character  adjacent characters group different  group extended group length 3 more  "e" "o" would extended first medium string 
why [1 2 3] return true? chalkboard xor game given non-negative integers nums[i] written chalkboard  alice bob take turns erasing exactly one number chalkboard  alice starting first  erasing number causes bitwise xor elements chalkboard become 0  player loses  (also  we'll say bitwise xor one element element itself  bitwise xor elements 0 ) also  player starts turn bitwise xor elements chalkboard equal 0  player wins  return true alice wins game  assuming players play optimally  hard math 
[c++ java python] 3-lines easy solution with complaint and explanation chalkboard xor game given non-negative integers nums[i] written chalkboard  alice bob take turns erasing exactly one number chalkboard  alice starting first  erasing number causes bitwise xor elements chalkboard become 0  player loses  (also  we'll say bitwise xor one element element itself  bitwise xor elements 0 ) also  player starts turn bitwise xor elements chalkboard equal 0  player wins  return true alice wins game  assuming players play optimally  hard math 
[810 chalkboard xor game] c++ ac chalkboard xor game given non-negative integers nums[i] written chalkboard  alice bob take turns erasing exactly one number chalkboard  alice starting first  erasing number causes bitwise xor elements chalkboard become 0  player loses  (also  we'll say bitwise xor one element element itself  bitwise xor elements 0 ) also  player starts turn bitwise xor elements chalkboard equal 0  player wins  return true alice wins game  assuming players play optimally  hard math 
solution based on minimax   but returns false for [1 2 3] so not accepted in oj chalkboard xor game given non-negative integers nums[i] written chalkboard  alice bob take turns erasing exactly one number chalkboard  alice starting first  erasing number causes bitwise xor elements chalkboard become 0  player loses  (also  we'll say bitwise xor one element element itself  bitwise xor elements 0 ) also  player starts turn bitwise xor elements chalkboard equal 0  player wins  return true alice wins game  assuming players play optimally  hard math 
o(n) simple python3 with explanation -- beats 100% chalkboard xor game given non-negative integers nums[i] written chalkboard  alice bob take turns erasing exactly one number chalkboard  alice starting first  erasing number causes bitwise xor elements chalkboard become 0  player loses  (also  we'll say bitwise xor one element element itself  bitwise xor elements 0 ) also  player starts turn bitwise xor elements chalkboard equal 0  player wins  return true alice wins game  assuming players play optimally  hard math 
[c++ java python] easy understood solution subdomain visit count website domain like "discuss leetcode com" consists various subdomains  top level  "com"  next level  "leetcode com"  lowest level  "discuss leetcode com"  visit domain like "discuss leetcode com"  also visit parent domains "leetcode com" "com" implicitly  now  call "count-paired domain" count (representing number visits domain received)  followed space  followed address  easy hash table 
java: do not use string split() to handle the string in this case and the code will run faster subdomain visit count website domain like "discuss leetcode com" consists various subdomains  top level  "com"  next level  "leetcode com"  lowest level  "discuss leetcode com"  visit domain like "discuss leetcode com"  also visit parent domains "leetcode com" "com" implicitly  now  call "count-paired domain" count (representing number visits domain received)  followed space  followed address  easy hash table 
python short & understandable solution [68 ms] subdomain visit count website domain like "discuss leetcode com" consists various subdomains  top level  "com"  next level  "leetcode com"  lowest level  "discuss leetcode com"  visit domain like "discuss leetcode com"  also visit parent domains "leetcode com" "com" implicitly  now  call "count-paired domain" count (representing number visits domain received)  followed space  followed address  easy hash table 
c++ 10 line solution w  explanation subdomain visit count website domain like "discuss leetcode com" consists various subdomains  top level  "com"  next level  "leetcode com"  lowest level  "discuss leetcode com"  visit domain like "discuss leetcode com"  also visit parent domains "leetcode com" "com" implicitly  now  call "count-paired domain" count (representing number visits domain received)  followed space  followed address  easy hash table 
java solution very easy to understand! subdomain visit count website domain like "discuss leetcode com" consists various subdomains  top level  "com"  next level  "leetcode com"  lowest level  "discuss leetcode com"  visit domain like "discuss leetcode com"  also visit parent domains "leetcode com" "com" implicitly  now  call "count-paired domain" count (representing number visits domain received)  followed space  followed address  easy hash table 
[c++ java python] solution with explanation and prove largest triangle area list points plane  return area largest triangle formed 3 points  easy math 
bad problem  solution is brute force largest triangle area list points plane  return area largest triangle formed 3 points  easy math 
simple java - easy understand  largest triangle area list points plane  return area largest triangle formed 3 points  easy math 
[python] another convex hull solution (44ms) to reduce the search space   largest triangle area list points plane  return area largest triangle formed 3 points  easy math 
javascript t(n^3) s(1) largest triangle area list points plane  return area largest triangle formed 3 points  easy math 
[c++ java python] easy understood solution with explanation largest sum of averages partition row numbers k adjacent (non-empty) groups  score sum average group  largest score achieve? note partition must use every number a  scores necessarily integers  medium dynamic programming 
[naive] detailed step by step approach from recursive to dp o(n) solution largest sum of averages partition row numbers k adjacent (non-empty) groups  score sum average group  largest score achieve? note partition must use every number a  scores necessarily integers  medium dynamic programming 
java bottom-up dp with explanation largest sum of averages partition row numbers k adjacent (non-empty) groups  score sum average group  largest score achieve? note partition must use every number a  scores necessarily integers  medium dynamic programming 
c++ dp largest sum of averages partition row numbers k adjacent (non-empty) groups  score sum average group  largest score achieve? note partition must use every number a  scores necessarily integers  medium dynamic programming 
c++ dp simple solution use o(n k) space and o(k n^2) time with detailed explanation largest sum of averages partition row numbers k adjacent (non-empty) groups  score sum average group  largest score achieve? note partition must use every number a  scores necessarily integers  medium dynamic programming 
[c++ java python]  self-explaining solution and 2-lines binary tree pruning given head node root binary tree  additionally every node's value either 0 1  return tree every subtree (of given tree) containing 1 removed  (recall subtree node x x  plus every node descendant x ) medium tree 
3 recursive lines dedicated to python binary tree pruning given head node root binary tree  additionally every node's value either 0 1  return tree every subtree (of given tree) containing 1 removed  (recall subtree node x x  plus every node descendant x ) medium tree 
java 4 lines solution using recursion binary tree pruning given head node root binary tree  additionally every node's value either 0 1  return tree every subtree (of given tree) containing 1 removed  (recall subtree node x x  plus every node descendant x ) medium tree 
clean recursive - python binary tree pruning given head node root binary tree  additionally every node's value either 0 1  return tree every subtree (of given tree) containing 1 removed  (recall subtree node x x  plus every node descendant x ) medium tree 
java backtracking with o(n) time complexity binary tree pruning given head node root binary tree  additionally every node's value either 0 1  return tree every subtree (of given tree) containing 1 removed  (recall subtree node x x  plus every node descendant x ) medium tree 
simple java solution using bfs bus routes list bus routes  routes[i] bus route i-th bus repeats forever  hard breadth-first search 
[c++ java python] bfs solution bus routes list bus routes  routes[i] bus route i-th bus repeats forever  hard breadth-first search 
data invaild? bus routes list bus routes  routes[i] bus route i-th bus repeats forever  hard breadth-first search 
python bfs with explanation bus routes list bus routes  routes[i] bus route i-th bus repeats forever  hard breadth-first search 
python    short & simple & readable & self-explanatory bfs solution    ~170 ms bus routes list bus routes  routes[i] bus route i-th bus repeats forever  hard breadth-first search 
[c++ java python] solution with explanation ambiguous coordinates 2-dimensional coordinates  like "(1  3)" "(2  0 5)"  then  removed commas  decimal points  spaces  ended string s  return list strings representing possibilities original coordinates could been  original representation never extraneous zeroes  never started numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  number represented less digits  also  decimal point within number never occurs without least one digit occuring it  never started numbers like " 1"  final answer list returned order  also note coordinates final answer exactly one space (occurring comma ) medium string 
really clear java code ambiguous coordinates 2-dimensional coordinates  like "(1  3)" "(2  0 5)"  then  removed commas  decimal points  spaces  ended string s  return list strings representing possibilities original coordinates could been  original representation never extraneous zeroes  never started numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  number represented less digits  also  decimal point within number never occurs without least one digit occuring it  never started numbers like " 1"  final answer list returned order  also note coordinates final answer exactly one space (occurring comma ) medium string 
concise c++ solution with comments ambiguous coordinates 2-dimensional coordinates  like "(1  3)" "(2  0 5)"  then  removed commas  decimal points  spaces  ended string s  return list strings representing possibilities original coordinates could been  original representation never extraneous zeroes  never started numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  number represented less digits  also  decimal point within number never occurs without least one digit occuring it  never started numbers like " 1"  final answer list returned order  also note coordinates final answer exactly one space (occurring comma ) medium string 
kotlin solution ambiguous coordinates 2-dimensional coordinates  like "(1  3)" "(2  0 5)"  then  removed commas  decimal points  spaces  ended string s  return list strings representing possibilities original coordinates could been  original representation never extraneous zeroes  never started numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  number represented less digits  also  decimal point within number never occurs without least one digit occuring it  never started numbers like " 1"  final answer list returned order  also note coordinates final answer exactly one space (occurring comma ) medium string 
64ms intuitive python solution that beats 99% ambiguous coordinates 2-dimensional coordinates  like "(1  3)" "(2  0 5)"  then  removed commas  decimal points  spaces  ended string s  return list strings representing possibilities original coordinates could been  original representation never extraneous zeroes  never started numbers like "00"  "0 0"  "0 00"  "1 0"  "001"  "00 01"  number represented less digits  also  decimal point within number never occurs without least one digit occuring it  never started numbers like " 1"  final answer list returned order  also note coordinates final answer exactly one space (occurring comma ) medium string 
[c++ java python] easy and concise solution with explanation linked list components given head  head node linked list containing unique integer values  also given list g  subset values linked list  return number connected components g  two values connected appear consecutively linked list  medium linked list 
can someone explain the test case linked list components given head  head node linked list containing unique integer values  also given list g  subset values linked list  return number connected components g  two values connected appear consecutively linked list  medium linked list 
how is 3  a connected component in this example statement linked list components given head  head node linked list containing unique integer values  also given list g  subset values linked list  return number connected components g  two values connected appear consecutively linked list  medium linked list 
java solution using hashset linked list components given head  head node linked list containing unique integer values  also given list g  subset values linked list  return number connected components g  two values connected appear consecutively linked list  medium linked list 
python using two pointers linked list components given head  head node linked list containing unique integer values  also given list g  subset values linked list  return number connected components g  two values connected appear consecutively linked list  medium linked list 
summary of the bfs and dp solutions with intuitive explanation race car car starts position 0 speed +1 infinite number line  (your car go negative positions ) car drives automatically according sequence instructions (accelerate) r (reverse)  get instruction "a"  car following: position += speed  speed  = 2  get instruction "r"  car following: speed positive speed = -1   otherwise speed = 1  (your position stays same ) hard dynamic programming heap 
[c++ javapython] dp solution race car car starts position 0 speed +1 infinite number line  (your car go negative positions ) car drives automatically according sequence instructions (accelerate) r (reverse)  get instruction "a"  car following: position += speed  speed  = 2  get instruction "r"  car following: speed positive speed = -1   otherwise speed = 1  (your position stays same ) hard dynamic programming heap 
accepted java solution with bfs race car car starts position 0 speed +1 infinite number line  (your car go negative positions ) car drives automatically according sequence instructions (accelerate) r (reverse)  get instruction "a"  car following: position += speed  speed  = 2  get instruction "r"  car following: speed positive speed = -1   otherwise speed = 1  (your position stays same ) hard dynamic programming heap 
accepted plain bfs race car car starts position 0 speed +1 infinite number line  (your car go negative positions ) car drives automatically according sequence instructions (accelerate) r (reverse)  get instruction "a"  car following: position += speed  speed  = 2  get instruction "r"  car following: speed positive speed = -1   otherwise speed = 1  (your position stays same ) hard dynamic programming heap 
straightforward c++ bfs solution with explanation race car car starts position 0 speed +1 infinite number line  (your car go negative positions ) car drives automatically according sequence instructions (accelerate) r (reverse)  get instruction "a"  car following: position += speed  speed  = 2  get instruction "r"  car following: speed positive speed = -1   otherwise speed = 1  (your position stays same ) hard dynamic programming heap 
[c++ java python] easy solution with explanation most common word given paragraph list banned words  return frequent word list banned words  guaranteed least one word banned  answer unique  words list banned words given lowercase  free punctuation  words paragraph case sensitive  answer lowercase  easy string 
last test case is weird most common word given paragraph list banned words  return frequent word list banned words  guaranteed least one word banned  answer unique  words list banned words given lowercase  free punctuation  words paragraph case sensitive  answer lowercase  easy string 
clean 6ms c++ solution most common word given paragraph list banned words  return frequent word list banned words  guaranteed least one word banned  answer unique  words list banned words given lowercase  free punctuation  words paragraph case sensitive  answer lowercase  easy string 
simple java solution most common word given paragraph list banned words  return frequent word list banned words  guaranteed least one word banned  answer unique  words list banned words given lowercase  free punctuation  words paragraph case sensitive  answer lowercase  easy string 
[java] simple solution using hashmaps along with asserts to test most common word given paragraph list banned words  return frequent word list banned words  guaranteed least one word banned  answer unique  words list banned words given lowercase  free punctuation  words paragraph case sensitive  answer lowercase  easy string 
[c++ java python] easy understood solution with explanation short encoding of words given list words  may encode writing reference string list indexes a  medium 
trie solution short encoding of words given list words  may encode writing reference string list indexes a  medium 
simple concept using trie short encoding of words given list words  may encode writing reference string list indexes a  medium 
the problem description should be improved short encoding of words given list words  may encode writing reference string list indexes a  medium 
problem statement is ambiguous: substring vs  suffix short encoding of words given list words  may encode writing reference string list indexes a  medium 
[c++ java python] 2-pass with explanation shortest distance to a character given string character c  return array integers representing shortest distance character c string  easy 
explanation of description without solution shortest distance to a character given string character c  return array integers representing shortest distance character c string  easy 
concise java solution with detailed explanation  easy understand!!! shortest distance to a character given string character c  return array integers representing shortest distance character c string  easy 
java - single pass with trailing pointer (concise) shortest distance to a character given string character c  return array integers representing shortest distance character c string  easy 
python 3 shortest distance to a character given string character c  return array integers representing shortest distance character c string  easy 
problem statement is so confusing! card flipping game table n cards  positive integer printed front back card (possibly different)  flip number cards  choose one card  number x back chosen card front card  number x good  smallest number good? number good  output 0  here  fronts[i] backs[i] represent number front back card i  flip swaps front back numbers  value front back vice versa  medium 
[c++ java python] easy and concise with explanation card flipping game table n cards  positive integer printed front back card (possibly different)  flip number cards  choose one card  number x back chosen card front card  number x good  smallest number good? number good  output 0  here  fronts[i] backs[i] represent number front back card i  flip swaps front back numbers  value front back vice versa  medium 
java solution using hashset (the description in the problem really confuses me   ) card flipping game table n cards  positive integer printed front back card (possibly different)  flip number cards  choose one card  number x back chosen card front card  number x good  smallest number good? number good  output 0  here  fronts[i] backs[i] represent number front back card i  flip swaps front back numbers  value front back vice versa  medium 
python 2 lines card flipping game table n cards  positive integer printed front back card (possibly different)  flip number cards  choose one card  number x back chosen card front card  number x good  smallest number good? number good  output 0  here  fronts[i] backs[i] represent number front back card i  flip swaps front back numbers  value front back vice versa  medium 
simple java solution - 19ms card flipping game table n cards  positive integer printed front back card (possibly different)  flip number cards  choose one card  number x back chosen card front card  number x good  smallest number good? number good  output 0  here  fronts[i] backs[i] represent number front back card i  flip swaps front back numbers  value front back vice versa  medium 
[c++ java python] dp solution binary trees with factors given array unique integers  integer strictly greater 1  make binary tree using integers number may used number times  non-leaf node's value equal product values children  many binary trees make? return answer modulo 10    9 + 7  medium 
concise java solution using hashmap with detailed explanation  easily understand!!! binary trees with factors given array unique integers  integer strictly greater 1  make binary tree using integers number may used number times  non-leaf node's value equal product values children  many binary trees make? return answer modulo 10    9 + 7  medium 
short simple python binary trees with factors given array unique integers  integer strictly greater 1  make binary tree using integers number may used number times  non-leaf node's value equal product values children  many binary trees make? return answer modulo 10    9 + 7  medium 
java accepted solution binary trees with factors given array unique integers  integer strictly greater 1  make binary tree using integers number may used number times  non-leaf node's value equal product values children  many binary trees make? return answer modulo 10    9 + 7  medium 
java easy understanding dp solution with explanation binary trees with factors given array unique integers  integer strictly greater 1  make binary tree using integers number may used number times  non-leaf node's value equal product values children  many binary trees make? return answer modulo 10    9 + 7  medium 
short c++ solution using i o stringstream goat latin sentence given  composed words separated spaces  word consists lowercase uppercase letters only  would like convert sentence "goat latin" (a made-up language similar pig latin ) rules goat latin follows: word begins vowel (a  e  i  o  u)  append "ma" end word  easy string 
java 5 ms solution with time and space complexity explanation goat latin sentence given  composed words separated spaces  word consists lowercase uppercase letters only  would like convert sentence "goat latin" (a made-up language similar pig latin ) rules goat latin follows: word begins vowel (a  e  i  o  u)  append "ma" end word  easy string 
c++  easy to understand  just as we think! goat latin sentence given  composed words separated spaces  word consists lowercase uppercase letters only  would like convert sentence "goat latin" (a made-up language similar pig latin ) rules goat latin follows: word begins vowel (a  e  i  o  u)  append "ma" end word  easy string 
[c++ java python] straight forward solution goat latin sentence given  composed words separated spaces  word consists lowercase uppercase letters only  would like convert sentence "goat latin" (a made-up language similar pig latin ) rules goat latin follows: word begins vowel (a  e  i  o  u)  append "ma" end word  easy string 
concise python solution goat latin sentence given  composed words separated spaces  word consists lowercase uppercase letters only  would like convert sentence "goat latin" (a made-up language similar pig latin ) rules goat latin follows: word begins vowel (a  e  i  o  u)  append "ma" end word  easy string 
age[b] > age[a] and age[b] > 100 && age[a] < 100  isn't the latter redundant? friends of appropriate ages people make friend requests  list ages given ages[i] age ith person  person friend request person b (b != a) following conditions true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  friend request b  note requests b  b necessarily request a  also  people friend request themselves  many total friend requests made? medium array 
10ms concise java  solution  o(n) time and o(1) space friends of appropriate ages people make friend requests  list ages given ages[i] age ith person  person friend request person b (b != a) following conditions true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  friend request b  note requests b  b necessarily request a  also  people friend request themselves  many total friend requests made? medium array 
c++ 5 lines o(n)  sliding sum friends of appropriate ages people make friend requests  list ages given ages[i] age ith person  person friend request person b (b != a) following conditions true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  friend request b  note requests b  b necessarily request a  also  people friend request themselves  many total friend requests made? medium array 
[c++ java python] easy and straight forward friends of appropriate ages people make friend requests  list ages given ages[i] age ith person  person friend request person b (b != a) following conditions true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  friend request b  note requests b  b necessarily request a  also  people friend request themselves  many total friend requests made? medium array 
super clear explanation on both o(nlgn) and o(n) solution step by step friends of appropriate ages people make friend requests  list ages given ages[i] age ith person  person friend request person b (b != a) following conditions true: age[b] <= 0 5   age[a] + 7 age[b] > age[a] age[b] > 100 && age[a] < 100 otherwise  friend request b  note requests b  b necessarily request a  also  people friend request themselves  many total friend requests made? medium array 
[c++ java python] sort and two pointer most profit assigning work jobs: difficulty[i] difficulty ith job  profit[i] profit ith job  workers  worker[i] ability ith worker  means worker complete job difficulty worker[i]  every worker assigned one job  one job completed multiple times  medium two pointers 
java solution with treemap most profit assigning work jobs: difficulty[i] difficulty ith job  profit[i] profit ith job  workers  worker[i] ability ith worker  means worker complete job difficulty worker[i]  every worker assigned one job  one job completed multiple times  medium two pointers 
c++ 4 lines  sort  bucket sort  and bucked sort with two pointers most profit assigning work jobs: difficulty[i] difficulty ith job  profit[i] profit ith job  workers  worker[i] ability ith worker  means worker complete job difficulty worker[i]  every worker assigned one job  one job completed multiple times  medium two pointers 
extremely simple using priority queue most profit assigning work jobs: difficulty[i] difficulty ith job  profit[i] profit ith job  workers  worker[i] ability ith worker  means worker complete job difficulty worker[i]  every worker assigned one job  one job completed multiple times  medium two pointers 
python sort based most profit assigning work jobs: difficulty[i] difficulty ith job  profit[i] profit ith job  workers  worker[i] ability ith worker  means worker complete job difficulty worker[i]  every worker assigned one job  one job completed multiple times  medium two pointers 
c++ o(n m) 15 ms  colorful islands making a large island 2d grid 0s 1s  change one 0 1  after  size largest island? (an island 4-directionally connected group 1s)  hard depth-first search 
[c++ java python] straight forward o(n^2) with explanations making a large island 2d grid 0s 1s  change one 0 1  after  size largest island? (an island 4-directionally connected group 1s)  hard depth-first search 
dfs java ac concise solution making a large island 2d grid 0s 1s  change one 0 1  after  size largest island? (an island 4-directionally connected group 1s)  hard depth-first search 
c++ disjoint set or union find making a large island 2d grid 0s 1s  change one 0 1  after  size largest island? (an island 4-directionally connected group 1s)  hard depth-first search 
extremely simple concept using marker making a large island 2d grid 0s 1s  change one 0 1  after  size largest island? (an island 4-directionally connected group 1s)  hard depth-first search 
one pass o(n)  straight forward unique letter string character unique string occurs exactly it  hard two pointers 
o(n) java solution  dp  clear and easy to understand unique letter string character unique string occurs exactly it  hard two pointers 
simple java 2 pointer unique letter string character unique string occurs exactly it  hard two pointers 
very simple o(n) with prev and next unique letter string character unique string occurs exactly it  hard two pointers 
concise dp o(n) solution unique letter string character unique string occurs exactly it  hard two pointers 
5 lines c++ solution with detailed mathematical explanation  consecutive numbers sum given positive integer n  many ways write sum consecutive positive integers? hard math 
5 line o(n ^ 0 5) java code - math method consecutive numbers sum given positive integer n  many ways write sum consecutive positive integers? hard math 
[c++ java python] 4-lines and o(logn)  count odd factors consecutive numbers sum given positive integer n  many ways write sum consecutive positive integers? hard math 
c++ 2 lines o(sqrt n) consecutive numbers sum given positive integer n  many ways write sum consecutive positive integers? hard math 
c++ solution with strict and detailed proof consecutive numbers sum given positive integer n  many ways write sum consecutive positive integers? hard math 
[c++ java python] straight forward positions of large groups string lowercase letters  letters form consecutive groups character  easy array 
oneline python using regex positions of large groups string lowercase letters  letters form consecutive groups character  easy array 
ambiguous: "the final answer should be in lexicographic order " positions of large groups string lowercase letters  letters form consecutive groups character  easy array 
java solution - two pointers positions of large groups string lowercase letters  letters form consecutive groups character  easy array 
python concise positions of large groups string lowercase letters  letters form consecutive groups character  easy array 
[c++ java python] easy and concise  masking personal information given personal information string s  may represent either email address phone number  would like mask personal information according following rules: 1  email address: define name string length ≥ 2 consisting lowercase letters a-z uppercase letters a-z  email address starts name  followed symbol '@'  followed name  followed dot ' ' followed name  email addresses guaranteed valid format "name1@name2 name3"  mask email  names must converted lowercase letters first last letter first name must replaced 5 asterisks ' '  2  phone number: phone number string consisting digits 0-9 characters set {'+'  '-'  '('  ')'  ' '}  may assume phone number contains 10 13 digits  last 10 digits make local number  digits make country code  note country code optional  want expose last 4 digits mask digits  local number formatted masked "   -   -1111"  1 represents exposed digits  mask phone number country code like "+111 111 111 1111"  write form "+   -   -   -1111"  '+' sign first '-' sign local number exist country code  medium string 
short python solution masking personal information given personal information string s  may represent either email address phone number  would like mask personal information according following rules: 1  email address: define name string length ≥ 2 consisting lowercase letters a-z uppercase letters a-z  email address starts name  followed symbol '@'  followed name  followed dot ' ' followed name  email addresses guaranteed valid format "name1@name2 name3"  mask email  names must converted lowercase letters first last letter first name must replaced 5 asterisks ' '  2  phone number: phone number string consisting digits 0-9 characters set {'+'  '-'  '('  ')'  ' '}  may assume phone number contains 10 13 digits  last 10 digits make local number  digits make country code  note country code optional  want expose last 4 digits mask digits  local number formatted masked "   -   -1111"  1 represents exposed digits  mask phone number country code like "+111 111 111 1111"  write form "+   -   -   -1111"  '+' sign first '-' sign local number exist country code  medium string 
straightforward c++ masking personal information given personal information string s  may represent either email address phone number  would like mask personal information according following rules: 1  email address: define name string length ≥ 2 consisting lowercase letters a-z uppercase letters a-z  email address starts name  followed symbol '@'  followed name  followed dot ' ' followed name  email addresses guaranteed valid format "name1@name2 name3"  mask email  names must converted lowercase letters first last letter first name must replaced 5 asterisks ' '  2  phone number: phone number string consisting digits 0-9 characters set {'+'  '-'  '('  ')'  ' '}  may assume phone number contains 10 13 digits  last 10 digits make local number  digits make country code  note country code optional  want expose last 4 digits mask digits  local number formatted masked "   -   -1111"  1 represents exposed digits  mask phone number country code like "+111 111 111 1111"  write form "+   -   -   -1111"  '+' sign first '-' sign local number exist country code  medium string 
readable java code  masking personal information given personal information string s  may represent either email address phone number  would like mask personal information according following rules: 1  email address: define name string length ≥ 2 consisting lowercase letters a-z uppercase letters a-z  email address starts name  followed symbol '@'  followed name  followed dot ' ' followed name  email addresses guaranteed valid format "name1@name2 name3"  mask email  names must converted lowercase letters first last letter first name must replaced 5 asterisks ' '  2  phone number: phone number string consisting digits 0-9 characters set {'+'  '-'  '('  ')'  ' '}  may assume phone number contains 10 13 digits  last 10 digits make local number  digits make country code  note country code optional  want expose last 4 digits mask digits  local number formatted masked "   -   -1111"  1 represents exposed digits  mask phone number country code like "+111 111 111 1111"  write form "+   -   -   -1111"  '+' sign first '-' sign local number exist country code  medium string 
python with regular expressions masking personal information given personal information string s  may represent either email address phone number  would like mask personal information according following rules: 1  email address: define name string length ≥ 2 consisting lowercase letters a-z uppercase letters a-z  email address starts name  followed symbol '@'  followed name  followed dot ' ' followed name  email addresses guaranteed valid format "name1@name2 name3"  mask email  names must converted lowercase letters first last letter first name must replaced 5 asterisks ' '  2  phone number: phone number string consisting digits 0-9 characters set {'+'  '-'  '('  ')'  ' '}  may assume phone number contains 10 13 digits  last 10 digits make local number  digits make country code  note country code optional  want expose last 4 digits mask digits  local number formatted masked "   -   -1111"  1 represents exposed digits  mask phone number country code like "+111 111 111 1111"  write form "+   -   -   -1111"  '+' sign first '-' sign local number exist country code  medium string 
[c++ java python] reverse and toggle flipping an image given binary matrix a  want flip image horizontally  invert it  return resulting image  flip image horizontally means row image reversed  easy array 
python 1 line flipping an image given binary matrix a  want flip image horizontally  invert it  return resulting image  flip image horizontally means row image reversed  easy array 
one pass in place java solution flipping an image given binary matrix a  want flip image horizontally  invert it  return resulting image  flip image horizontally means row image reversed  easy array 
one-liner javascript solution flipping an image given binary matrix a  want flip image horizontally  invert it  return resulting image  flip image horizontally means row image reversed  easy array 
what are the c parameters?  flipping an image given binary matrix a  want flip image horizontally  invert it  return resulting image  flip image horizontally means row image reversed  easy array 
[c++ java python] replace s from right to left find and replace in string string s  perform replacement operations replace groups letters new ones (not necessarily size)  replacement operation 3 parameters: starting index i  source word x target word y  rule x starts position original string s  replace occurrence x y  not  nothing  medium string 
java 10 line 14ms and 13 line 7ms  codes - both use stringbuilder replace from end  find and replace in string string s  perform replacement operations replace groups letters new ones (not necessarily size)  replacement operation 3 parameters: starting index i  source word x target word y  rule x starts position original string s  replace occurrence x y  not  nothing  medium string 
java o(n) solution find and replace in string string s  perform replacement operations replace groups letters new ones (not necessarily size)  replacement operation 3 parameters: starting index i  source word x target word y  rule x starts position original string s  replace occurrence x y  not  nothing  medium string 
c++ 5 lines  6 ms bucket sort o(n) find and replace in string string s  perform replacement operations replace groups letters new ones (not necessarily size)  replacement operation 3 parameters: starting index i  source word x target word y  rule x starts position original string s  replace occurrence x y  not  nothing  medium string 
short java treemap solution! find and replace in string string s  perform replacement operations replace groups letters new ones (not necessarily size)  replacement operation 3 parameters: starting index i  source word x target word y  rule x starts position original string s  replace occurrence x y  not  nothing  medium string 
[c++ java python] straight forward image overlap two images b given  represented binary  square matrices size  (a binary matrix 0s 1s values ) translate one image however choose (sliding left  right  up  number units)  place top image  after  overlap translation number positions 1 images  (note also translation include kind rotation ) largest possible overlap? medium array 
python easy logic image overlap two images b given  represented binary  square matrices size  (a binary matrix 0s 1s values ) translate one image however choose (sliding left  right  up  number units)  place top image  after  overlap translation number positions 1 images  (note also translation include kind rotation ) largest possible overlap? medium array 
a generic and easy to understand method image overlap two images b given  represented binary  square matrices size  (a binary matrix 0s 1s values ) translate one image however choose (sliding left  right  up  number units)  place top image  after  overlap translation number positions 1 images  (note also translation include kind rotation ) largest possible overlap? medium array 
short and lazy  just expand the graph image overlap two images b given  represented binary  square matrices size  (a binary matrix 0s 1s values ) translate one image however choose (sliding left  right  up  number units)  place top image  after  overlap translation number positions 1 images  (note also translation include kind rotation ) largest possible overlap? medium array 
an interesting solution: let us think about it as "convolution" image overlap two images b given  represented binary  square matrices size  (a binary matrix 0s 1s values ) translate one image however choose (sliding left  right  up  number units)  place top image  after  overlap translation number positions 1 images  (note also translation include kind rotation ) largest possible overlap? medium array 
[c++ java python] 1-line solution  1d to 2d rectangle overlap rectangle represented list [x1  y1  x2  y2]  (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner  two rectangles overlap area intersection positive  clear  two rectangles touch corner edges overlap  given two (axis-aligned) rectangles  return whether overlap  easy math 
c++ solution with easy explanation rectangle overlap rectangle represented list [x1  y1  x2  y2]  (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner  two rectangles overlap area intersection positive  clear  two rectangles touch corner edges overlap  given two (axis-aligned) rectangles  return whether overlap  easy math 
de morgan's law and boolean algebra rectangle overlap rectangle represented list [x1  y1  x2  y2]  (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner  two rectangles overlap area intersection positive  clear  two rectangles touch corner edges overlap  given two (axis-aligned) rectangles  return whether overlap  easy math 
java one line with explanation rectangle overlap rectangle represented list [x1  y1  x2  y2]  (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner  two rectangles overlap area intersection positive  clear  two rectangles touch corner edges overlap  given two (axis-aligned) rectangles  return whether overlap  easy math 
clear java code x 2 rectangle overlap rectangle represented list [x1  y1  x2  y2]  (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner  two rectangles overlap area intersection positive  clear  two rectangles touch corner edges overlap  given two (axis-aligned) rectangles  return whether overlap  easy math 
one pass dp o(n) new 21 game alice plays following game  loosely based card game "21"  alice starts 0 points  draws numbers less k points  draw  gains integer number points randomly range [1  w]  w integer  draw independent outcomes equal probabilities  alice stops drawing numbers gets k points  probability n less points? medium dynamic programming 
please make sure your description is correct before you publish it  otherwise you create a disaster new 21 game alice plays following game  loosely based card game "21"  alice starts 0 points  draws numbers less k points  draw  gains integer number points randomly range [1  w]  w integer  draw independent outcomes equal probabilities  alice stops drawing numbers gets k points  probability n less points? medium dynamic programming 
java o(k + w) dp solution with explanation new 21 game alice plays following game  loosely based card game "21"  alice starts 0 points  draws numbers less k points  draw  gains integer number points randomly range [1  w]  w integer  draw independent outcomes equal probabilities  alice stops drawing numbers gets k points  probability n less points? medium dynamic programming 
my take on how to reach at solution new 21 game alice plays following game  loosely based card game "21"  alice starts 0 points  draws numbers less k points  draw  gains integer number points randomly range [1  w]  w integer  draw independent outcomes equal probabilities  alice stops drawing numbers gets k points  probability n less points? medium dynamic programming 
i think the answer provided isn't correct  we need to consider conditional probability new 21 game alice plays following game  loosely based card game "21"  alice starts 0 points  draws numbers less k points  draw  gains integer number points randomly range [1  w]  w integer  draw independent outcomes equal probabilities  alice stops drawing numbers gets k points  probability n less points? medium dynamic programming 
[c++ java python] two pointers push dominoes n dominoes line  place domino vertically upright  beginning  simultaneously push dominoes either left right  second  domino falling left pushes adjacent domino left  similarly  dominoes falling right push adjacent dominoes standing right  vertical domino dominoes falling sides  stays still due balance forces  purposes question  consider falling domino expends additional force falling already fallen domino  given string "s" representing initial state  s[i] = 'l'  i-th domino pushed left; s[i] = 'r'  i-th domino pushed right; s[i] = ' '  i-th domino pushed  return string representing final state  medium two pointers dynamic programming 
funny idea but passed within time limit (python) push dominoes n dominoes line  place domino vertically upright  beginning  simultaneously push dominoes either left right  second  domino falling left pushes adjacent domino left  similarly  dominoes falling right push adjacent dominoes standing right  vertical domino dominoes falling sides  stays still due balance forces  purposes question  consider falling domino expends additional force falling already fallen domino  given string "s" representing initial state  s[i] = 'l'  i-th domino pushed left; s[i] = 'r'  i-th domino pushed right; s[i] = ' '  i-th domino pushed  return string representing final state  medium two pointers dynamic programming 
java  one pass  in-place  13ms push dominoes n dominoes line  place domino vertically upright  beginning  simultaneously push dominoes either left right  second  domino falling left pushes adjacent domino left  similarly  dominoes falling right push adjacent dominoes standing right  vertical domino dominoes falling sides  stays still due balance forces  purposes question  consider falling domino expends additional force falling already fallen domino  given string "s" representing initial state  s[i] = 'l'  i-th domino pushed left; s[i] = 'r'  i-th domino pushed right; s[i] = ' '  i-th domino pushed  return string representing final state  medium two pointers dynamic programming 
[python] o(n) solution  go through array twice push dominoes n dominoes line  place domino vertically upright  beginning  simultaneously push dominoes either left right  second  domino falling left pushes adjacent domino left  similarly  dominoes falling right push adjacent dominoes standing right  vertical domino dominoes falling sides  stays still due balance forces  purposes question  consider falling domino expends additional force falling already fallen domino  given string "s" representing initial state  s[i] = 'l'  i-th domino pushed left; s[i] = 'r'  i-th domino pushed right; s[i] = ' '  i-th domino pushed  return string representing final state  medium two pointers dynamic programming 
java  one pass  no extra storage  detailed explanation push dominoes n dominoes line  place domino vertically upright  beginning  simultaneously push dominoes either left right  second  domino falling left pushes adjacent domino left  similarly  dominoes falling right push adjacent dominoes standing right  vertical domino dominoes falling sides  stays still due balance forces  purposes question  consider falling domino expends additional force falling already fallen domino  given string "s" representing initial state  s[i] = 'l'  i-th domino pushed left; s[i] = 'r'  i-th domino pushed right; s[i] = ' '  i-th domino pushed  return string representing final state  medium two pointers dynamic programming 
short c++ solution at 220ms  using disjoint set similar string groups two strings x similar swap two letters (in different positions) x  equals y  hard depth-first search union find graph 
simple java solution using dfs similar string groups two strings x similar swap two letters (in different positions) x  equals y  hard depth-first search union find graph 
python  union find solution with tricky  min(o(mn^2)  o(nm^2)) similar string groups two strings x similar swap two letters (in different positions) x  equals y  hard depth-first search union find graph 
simple java with bfs similar string groups two strings x similar swap two letters (in different positions) x  equals y  hard depth-first search union find graph 
simple java 8   python union find  similar string groups two strings x similar swap two letters (in different positions) x  equals y  hard depth-first search union find graph 
python  5 and 43816729 magic squares in grid 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row  column  diagonals sum  given grid integers  many 3 x 3 "magic square" subgrids there? (each subgrid contiguous)  easy array 
one misleading problem magic squares in grid 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row  column  diagonals sum  given grid integers  many 3 x 3 "magic square" subgrids there? (each subgrid contiguous)  easy array 
java 8 ms straightforward & ugly  solution magic squares in grid 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row  column  diagonals sum  given grid integers  many 3 x 3 "magic square" subgrids there? (each subgrid contiguous)  easy array 
why is this test case yielding 0? magic squares in grid 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row  column  diagonals sum  given grid integers  many 3 x 3 "magic square" subgrids there? (each subgrid contiguous)  easy array 
straightforward java solution magic squares in grid 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row  column  diagonals sum  given grid integers  many 3 x 3 "magic square" subgrids there? (each subgrid contiguous)  easy array 
clean code keys and rooms n rooms start room 0  room distinct number 0  1  2       n-1  room may keys access next room  formally  room list keys rooms[i]  key rooms[i][j] integer [0  1       n-1] n = rooms length  key rooms[i][j] = v opens room number v  initially  rooms start locked (except room 0)  walk back forth rooms freely  return true enter every room  medium depth-first search graph 
straight forward keys and rooms n rooms start room 0  room distinct number 0  1  2       n-1  room may keys access next room  formally  room list keys rooms[i]  key rooms[i][j] integer [0  1       n-1] n = rooms length  key rooms[i][j] = v opens room number v  initially  rooms start locked (except room 0)  walk back forth rooms freely  return true enter every room  medium depth-first search graph 
python simple recursive dfs keys and rooms n rooms start room 0  room distinct number 0  1  2       n-1  room may keys access next room  formally  room list keys rooms[i]  key rooms[i][j] integer [0  1       n-1] n = rooms length  key rooms[i][j] = v opens room number v  initially  rooms start locked (except room 0)  walk back forth rooms freely  return true enter every room  medium depth-first search graph 
bfs (9 lines  10ms) and dfs (7 lines  18ms) in c++ w  beginner friendly explanation keys and rooms n rooms start room 0  room distinct number 0  1  2       n-1  room may keys access next room  formally  room list keys rooms[i]  key rooms[i][j] integer [0  1       n-1] n = rooms length  key rooms[i][j] = v opens room number v  initially  rooms start locked (except room 0)  walk back forth rooms freely  return true enter every room  medium depth-first search graph 
java   8 lines keys and rooms n rooms start room 0  room distinct number 0  1  2       n-1  room may keys access next room  formally  room list keys rooms[i]  key rooms[i][j] integer [0  1       n-1] n = rooms length  key rooms[i][j] = v opens room number v  initially  rooms start locked (except room 0)  walk back forth rooms freely  return true enter every room  medium depth-first search graph 
short and fast backtracking solution split array into fibonacci sequence given string digits  = "123456579"  split fibonacci-like sequence [123  456  579]  formally  fibonacci-like sequence list f non-negative integers that: 0 <= f[i] <= 2^31 - 1  (that is  integer fits 32-bit signed integer type); f length >= 3; f[i] + f[i+1] = f[i+2] 0 <= < f length - 2  also  note splitting string pieces  piece must extra leading zeroes  except piece number 0 itself  return fibonacci-like sequence split s  return [] cannot done  medium string backtracking greedy 
well commented c++ backtracking solution split array into fibonacci sequence given string digits  = "123456579"  split fibonacci-like sequence [123  456  579]  formally  fibonacci-like sequence list f non-negative integers that: 0 <= f[i] <= 2^31 - 1  (that is  integer fits 32-bit signed integer type); f length >= 3; f[i] + f[i+1] = f[i+2] 0 <= < f length - 2  also  note splitting string pieces  piece must extra leading zeroes  except piece number 0 itself  return fibonacci-like sequence split s  return [] cannot done  medium string backtracking greedy 
what is wrong with this testcase? split array into fibonacci sequence given string digits  = "123456579"  split fibonacci-like sequence [123  456  579]  formally  fibonacci-like sequence list f non-negative integers that: 0 <= f[i] <= 2^31 - 1  (that is  integer fits 32-bit signed integer type); f length >= 3; f[i] + f[i+1] = f[i+2] 0 <= < f length - 2  also  note splitting string pieces  piece must extra leading zeroes  except piece number 0 itself  return fibonacci-like sequence split s  return [] cannot done  medium string backtracking greedy 
backtracking with memoization split array into fibonacci sequence given string digits  = "123456579"  split fibonacci-like sequence [123  456  579]  formally  fibonacci-like sequence list f non-negative integers that: 0 <= f[i] <= 2^31 - 1  (that is  integer fits 32-bit signed integer type); f length >= 3; f[i] + f[i+1] = f[i+2] 0 <= < f length - 2  also  note splitting string pieces  piece must extra leading zeroes  except piece number 0 itself  return fibonacci-like sequence split s  return [] cannot done  medium string backtracking greedy 
simple java solution using dfs split array into fibonacci sequence given string digits  = "123456579"  split fibonacci-like sequence [123  456  579]  formally  fibonacci-like sequence list f non-negative integers that: 0 <= f[i] <= 2^31 - 1  (that is  integer fits 32-bit signed integer type); f length >= 3; f[i] + f[i+1] = f[i+2] 0 <= < f length - 2  also  note splitting string pieces  piece must extra leading zeroes  except piece number 0 itself  return fibonacci-like sequence split s  return [] cannot done  medium string backtracking greedy 
random guess and minimax guess with comparison guess the word problem interactive problem new leetcode platform  given word list unique words  word 6 letters long  one word list chosen secret  may call master guess(word) guess word  guessed word type string must original list 6 lowercase letters  function returns integer type  representing number exact matches (value position) guess secret word  also  guess given wordlist  return -1 instead  test case  10 guesses guess word  end number calls  made 10 less calls master guess least one guesses secret  pass testcase  besides hard minimax 
optimal minmax solution (+ extra challenging test cases) guess the word problem interactive problem new leetcode platform  given word list unique words  word 6 letters long  one word list chosen secret  may call master guess(word) guess word  guessed word type string must original list 6 lowercase letters  function returns integer type  representing number exact matches (value position) guess secret word  also  guess given wordlist  return -1 instead  test case  10 guesses guess word  end number calls  made 10 less calls master guess least one guesses secret  pass testcase  besides hard minimax 
screencast of leetcode weekly contest 86 guess the word problem interactive problem new leetcode platform  given word list unique words  word 6 letters long  one word list chosen secret  may call master guess(word) guess word  guessed word type string must original list 6 lowercase letters  function returns integer type  representing number exact matches (value position) guess secret word  also  guess given wordlist  return -1 instead  test case  10 guesses guess word  end number calls  made 10 less calls master guess least one guesses secret  pass testcase  besides hard minimax 
c++ elimination histogram  beats minimax guess the word problem interactive problem new leetcode platform  given word list unique words  word 6 letters long  one word list chosen secret  may call master guess(word) guess word  guessed word type string must original list 6 lowercase letters  function returns integer type  representing number exact matches (value position) guess secret word  also  guess given wordlist  return -1 instead  test case  10 guesses guess word  end number calls  made 10 less calls master guess least one guesses secret  pass testcase  besides hard minimax 
python o(n) with maximum overlap heuristic guess the word problem interactive problem new leetcode platform  given word list unique words  word 6 letters long  one word list chosen secret  may call master guess(word) guess word  guessed word type string must original list 6 lowercase letters  function returns integer type  representing number exact matches (value position) guess secret word  also  guess given wordlist  return -1 instead  test case  10 guesses guess word  end number calls  made 10 less calls master guess least one guesses secret  pass testcase  besides hard minimax 
[c++ java python] o(n) time and o(1) space backspace string compare given two strings t  return equal typed empty text editors  # means backspace character  easy two pointers stack 
[java c++] efficient and simple solution without stack etc backspace string compare given two strings t  return equal typed empty text editors  # means backspace character  easy two pointers stack 
java two pointer with explanation - beat 98% backspace string compare given two strings t  return equal typed empty text editors  # means backspace character  easy two pointers stack 
8 lines c++ o(1) space easy to understand backspace string compare given two strings t  return equal typed empty text editors  # means backspace character  easy two pointers stack 
python o(1) space backspace string compare given two strings t  return equal typed empty text editors  # means backspace character  easy two pointers stack 
[c++ java python] 1-pass and o(1) space longest mountain in array let's call (contiguous) subarray b (of a) mountain following properties hold: b length >= 3 exists 0 < < b length - 1 b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note b could subarray a  including entire array a ) given array integers  return length longest mountain  return 0 mountain  medium two pointers 
simple java solution longest mountain in array let's call (contiguous) subarray b (of a) mountain following properties hold: b length >= 3 exists 0 < < b length - 1 b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note b could subarray a  including entire array a ) given array integers  return length longest mountain  return 0 mountain  medium two pointers 
1-pass java two point solution longest mountain in array let's call (contiguous) subarray b (of a) mountain following properties hold: b length >= 3 exists 0 < < b length - 1 b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note b could subarray a  including entire array a ) given array integers  return length longest mountain  return 0 mountain  medium two pointers 
simple o(n) one pass o(1) space java ac solution beats 99 05  longest mountain in array let's call (contiguous) subarray b (of a) mountain following properties hold: b length >= 3 exists 0 < < b length - 1 b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note b could subarray a  including entire array a ) given array integers  return length longest mountain  return 0 mountain  medium two pointers 
easy to understand - find peaks and then find max length mountain o(n) longest mountain in array let's call (contiguous) subarray b (of a) mountain following properties hold: b length >= 3 exists 0 < < b length - 1 b[0] < b[1] <     b[i-1] < b[i] > b[i+1] >     > b[b length - 1] (note b could subarray a  including entire array a ) given array integers  return length longest mountain  return 0 mountain  medium two pointers 
[c++ java python] o(mlogm) complexity hand of straights alice hand cards  given array integers  wants rearrange cards groups group size w  consists w consecutive cards  return true can  medium map 
short and clear python solution + b站讲解 hand of straights alice hand cards  given array integers  wants rearrange cards groups group size w  consists w consecutive cards  return true can  medium map 
simple java solution using priority queue hand of straights alice hand cards  given array integers  wants rearrange cards groups group size w  consists w consecutive cards  return true can  medium map 
short java solution! hand of straights alice hand cards  given array integers  wants rearrange cards groups group size w  consists w consecutive cards  return true can  medium map 
python o(nlgn) simple solution with intuition hand of straights alice hand cards  given array integers  wants rearrange cards groups group size w  consists w consecutive cards  return true can  medium map 
screencast of leetcode weekly contest 87 shortest path visiting all nodes undirected  connected graph n nodes (labeled 0  1  2       n-1) given graph  graph length = n  j != list graph[i] exactly once  nodes j connected  return length shortest path visits every node  may start stop node  may revisit nodes multiple times  may reuse edges  hard dynamic programming breadth-first search 
fast bfs solution (46ms) -- clear  detailed explanation included shortest path visiting all nodes undirected  connected graph n nodes (labeled 0  1  2       n-1) given graph  graph length = n  j != list graph[i] exactly once  nodes j connected  return length shortest path visits every node  may start stop node  may revisit nodes multiple times  may reuse edges  hard dynamic programming breadth-first search 
java dp solution shortest path visiting all nodes undirected  connected graph n nodes (labeled 0  1  2       n-1) given graph  graph length = n  j != list graph[i] exactly once  nodes j connected  return length shortest path visits every node  may start stop node  may revisit nodes multiple times  may reuse edges  hard dynamic programming breadth-first search 
python 8 lines heapq & bfs & deque solutions shortest path visiting all nodes undirected  connected graph n nodes (labeled 0  1  2       n-1) given graph  graph length = n  j != list graph[i] exactly once  nodes j connected  return length shortest path visits every node  may start stop node  may revisit nodes multiple times  may reuse edges  hard dynamic programming breadth-first search 
can't understand the description what's the meaning of the given array[][] shortest path visiting all nodes undirected  connected graph n nodes (labeled 0  1  2       n-1) given graph  graph length = n  j != list graph[i] exactly once  nodes j connected  return length shortest path visits every node  may start stop node  may revisit nodes multiple times  may reuse edges  hard dynamic programming breadth-first search 
[c++ java python] easy understood shifting letters string lowercase letters  integer array shifts  call shift letter  next letter alphabet  (wrapping around 'z' becomes 'a')  medium string 
java clean solution shifting letters string lowercase letters  integer array shifts  call shift letter  next letter alphabet  (wrapping around 'z' becomes 'a')  medium string 
short and concise c++ solution  3 lines shifting letters string lowercase letters  integer array shifts  call shift letter  next letter alphabet  (wrapping around 'z' becomes 'a')  medium string 
c++ 2 lines  o(n) shifting letters string lowercase letters  integer array shifts  call shift letter  next letter alphabet  (wrapping around 'z' becomes 'a')  medium string 
linear one pass solution beats 100% best solution and clean  explanation shifting letters string lowercase letters  integer array shifts  call shift letter  next letter alphabet  (wrapping around 'z' becomes 'a')  medium string 
[c++ java] 1 pass solution maximize distance to closest person row seats  1 represents person sitting seat  0 represents seat empty  least one empty seat  least one person sitting  alex wants sit seat distance closest person maximized  return maximum distance closest person  easy array 
clean   one pass   two pointers   java solution maximize distance to closest person row seats  1 represents person sitting seat  0 represents seat empty  least one empty seat  least one person sitting  alex wants sit seat distance closest person maximized  return maximum distance closest person  easy array 
3 lines c++ one pass maximize distance to closest person row seats  1 represents person sitting seat  0 represents seat empty  least one empty seat  least one person sitting  alex wants sit seat distance closest person maximized  return maximum distance closest person  easy array 
java one pass easy understand maximize distance to closest person row seats  1 represents person sitting seat  0 represents seat empty  least one empty seat  least one person sitting  alex wants sit seat distance closest person maximized  return maximum distance closest person  easy array 
python and c++ solution using two pointers  short and elegant  beats 98% maximize distance to closest person row seats  1 represents person sitting seat  0 represents seat empty  least one empty seat  least one person sitting  alex wants sit seat distance closest person maximized  return maximum distance closest person  easy array 
leetcode weekly contest 88 screencast rectangle area ii given list (axis-aligned) rectangles  rectangle[i] = [x1  y1  x2  y2]   (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner ith rectangle  find total area covered rectangles plane  since answer may large  return modulo 10^9 + 7  hard segment tree 
【top】java solution with detailed explaination  check this one !  rectangle area ii given list (axis-aligned) rectangles  rectangle[i] = [x1  y1  x2  y2]   (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner ith rectangle  find total area covered rectangles plane  since answer may large  return modulo 10^9 + 7  hard segment tree 
[c++ python] discretization and o(nlogn) rectangle area ii given list (axis-aligned) rectangles  rectangle[i] = [x1  y1  x2  y2]   (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner ith rectangle  find total area covered rectangles plane  since answer may large  return modulo 10^9 + 7  hard segment tree 
java treemap solution inspired by skyline and meeting room rectangle area ii given list (axis-aligned) rectangles  rectangle[i] = [x1  y1  x2  y2]   (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner ith rectangle  find total area covered rectangles plane  since answer may large  return modulo 10^9 + 7  hard segment tree 
clean recursive solution [java] rectangle area ii given list (axis-aligned) rectangles  rectangle[i] = [x1  y1  x2  y2]   (x1  y1) coordinates bottom-left corner  (x2  y2) coordinates top-right corner ith rectangle  find total area covered rectangles plane  since answer may large  return modulo 10^9 + 7  hard segment tree 
[c++ java python] concise dfs  loud and rich group n people (labelled 0  1  2       n-1)  person different amounts money  different levels quietness  convenience  we'll call person label x  simply "person x"  we'll say richer[i] = [x  y] person x definitely money person y  note richer may subset valid observations  also  we'll say quiet[x] = q person x quietness q  now  return answer  answer[x] = least quiet person (that is  person smallest value quiet[y])  among people definitely equal money person x  medium depth-first search 
example is confusing loud and rich group n people (labelled 0  1  2       n-1)  person different amounts money  different levels quietness  convenience  we'll call person label x  simply "person x"  we'll say richer[i] = [x  y] person x definitely money person y  note richer may subset valid observations  also  we'll say quiet[x] = q person x quietness q  now  return answer  answer[x] = least quiet person (that is  person smallest value quiet[y])  among people definitely equal money person x  medium depth-first search 
dfs with memory loud and rich group n people (labelled 0  1  2       n-1)  person different amounts money  different levels quietness  convenience  we'll call person label x  simply "person x"  we'll say richer[i] = [x  y] person x definitely money person y  note richer may subset valid observations  also  we'll say quiet[x] = q person x quietness q  now  return answer  answer[x] = least quiet person (that is  person smallest value quiet[y])  among people definitely equal money person x  medium depth-first search 
c++ with topological sorting loud and rich group n people (labelled 0  1  2       n-1)  person different amounts money  different levels quietness  convenience  we'll call person label x  simply "person x"  we'll say richer[i] = [x  y] person x definitely money person y  note richer may subset valid observations  also  we'll say quiet[x] = q person x quietness q  now  return answer  answer[x] = least quiet person (that is  person smallest value quiet[y])  among people definitely equal money person x  medium depth-first search 
java bfs loud and rich group n people (labelled 0  1  2       n-1)  person different amounts money  different levels quietness  convenience  we'll call person label x  simply "person x"  we'll say richer[i] = [x  y] person x definitely money person y  note richer may subset valid observations  also  we'll say quiet[x] = q person x quietness q  now  return answer  answer[x] = least quiet person (that is  person smallest value quiet[y])  among people definitely equal money person x  medium depth-first search 
[c++ java python] better than binary search peak index in a mountain array let's call array mountain following properties hold: a length >= 3 exists 0 < < a length - 1 a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given array definitely mountain  return a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
java o(n) and o(log(n)) code peak index in a mountain array let's call array mountain following properties hold: a length >= 3 exists 0 < < a length - 1 a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given array definitely mountain  return a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
java - basic binary search solution peak index in a mountain array let's call array mountain following properties hold: a length >= 3 exists 0 < < a length - 1 a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given array definitely mountain  return a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
python & javascript 1-liner peak index in a mountain array let's call array mountain following properties hold: a length >= 3 exists 0 < < a length - 1 a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given array definitely mountain  return a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
python3 binary search peak index in a mountain array let's call array mountain following properties hold: a length >= 3 exists 0 < < a length - 1 a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1] given array definitely mountain  return a[0] < a[1] <     a[i-1] < a[i] > a[i+1] >     > a[a length - 1]  easy binary search 
[c++ java python] straight forward car fleet n cars going destination along one lane road  destination target miles away  car constant speed speed[i] (in miles per hour)  initial position position[i] miles towards target along road  car never pass another car ahead it  catch it  drive bumper bumper speed  distance two cars ignored - assumed position  car fleet non-empty set cars driving position speed  note single car also car fleet  car catches car fleet right destination point  still considered one car fleet  many car fleets arrive destination? medium stack 
easy understanding java treemap solution with explanation & comment car fleet n cars going destination along one lane road  destination target miles away  car constant speed speed[i] (in miles per hour)  initial position position[i] miles towards target along road  car never pass another car ahead it  catch it  drive bumper bumper speed  distance two cars ignored - assumed position  car fleet non-empty set cars driving position speed  note single car also car fleet  car catches car fleet right destination point  still considered one car fleet  many car fleets arrive destination? medium stack 
java 10 and 11 liner with comment  both time o(nlog(n)) space o(n) car fleet n cars going destination along one lane road  destination target miles away  car constant speed speed[i] (in miles per hour)  initial position position[i] miles towards target along road  car never pass another car ahead it  catch it  drive bumper bumper speed  distance two cars ignored - assumed position  car fleet non-empty set cars driving position speed  note single car also car fleet  car catches car fleet right destination point  still considered one car fleet  many car fleets arrive destination? medium stack 
solution without map car fleet n cars going destination along one lane road  destination target miles away  car constant speed speed[i] (in miles per hour)  initial position position[i] miles towards target along road  car never pass another car ahead it  catch it  drive bumper bumper speed  distance two cars ignored - assumed position  car fleet non-empty set cars driving position speed  note single car also car fleet  car catches car fleet right destination point  still considered one car fleet  many car fleets arrive destination? medium stack 
java o(n) without sorting car fleet n cars going destination along one lane road  destination target miles away  car constant speed speed[i] (in miles per hour)  initial position position[i] miles towards target along road  car never pass another car ahead it  catch it  drive bumper bumper speed  distance two cars ignored - assumed position  car fleet non-empty set cars driving position speed  note single car also car fleet  car catches car fleet right destination point  still considered one car fleet  many car fleets arrive destination? medium stack 
java bfs 32 ms clean concise explanation whatever k-similar strings strings b k-similar (for non-negative integer k) swap positions two letters exactly k times resulting string equals b  given two anagrams b  return smallest k b k-similar  hard breadth-first search graph 
java backtracking with memorization k-similar strings strings b k-similar (for non-negative integer k) swap positions two letters exactly k times resulting string equals b  given two anagrams b  return smallest k b k-similar  hard breadth-first search graph 
c++ 6ms solution k-similar strings strings b k-similar (for non-negative integer k) swap positions two letters exactly k times resulting string equals b  given two anagrams b  return smallest k b k-similar  hard breadth-first search graph 
c++ bfs solution k-similar strings strings b k-similar (for non-negative integer k) swap positions two letters exactly k times resulting string equals b  given two anagrams b  return smallest k b k-similar  hard breadth-first search graph 
problem statement was wrong k-similar strings strings b k-similar (for non-negative integer k) swap positions two letters exactly k times resulting string equals b  given two anagrams b  return smallest k b k-similar  hard breadth-first search graph 
[java] priorityqueue with customized object  seat: o(logn)  leave o(n) with explanation exam room exam room  n seats single row  numbered 0  1  2       n-1  student enters room  must sit seat maximizes distance closest person  multiple seats  sit seat lowest number  (also  one room  student sits seat number 0 ) return class examroom(int n) exposes two functions: examroom seat() returning int representing seat student sat in  examroom leave(int p) representing student seat number p leaves room  guaranteed calls examroom leave(p) student sitting seat p  medium map 
[c++ java python] straight forward exam room exam room  n seats single row  numbered 0  1  2       n-1  student enters room  must sit seat maximizes distance closest person  multiple seats  sit seat lowest number  (also  one room  student sits seat number 0 ) return class examroom(int n) exposes two functions: examroom seat() returning int representing seat student sat in  examroom leave(int p) representing student seat number p leaves room  guaranteed calls examroom leave(p) student sitting seat p  medium map 
[python] o(log n) time for both seat() and leave() with heapq and dicts - detailed explanation exam room exam room  n seats single row  numbered 0  1  2       n-1  student enters room  must sit seat maximizes distance closest person  multiple seats  sit seat lowest number  (also  one room  student sits seat number 0 ) return class examroom(int n) exposes two functions: examroom seat() returning int representing seat student sat in  examroom leave(int p) representing student seat number p leaves room  guaranteed calls examroom leave(p) student sitting seat p  medium map 
java solution based on treeset exam room exam room  n seats single row  numbered 0  1  2       n-1  student enters room  must sit seat maximizes distance closest person  multiple seats  sit seat lowest number  (also  one room  student sits seat number 0 ) return class examroom(int n) exposes two functions: examroom seat() returning int representing seat student sat in  examroom leave(int p) representing student seat number p leaves room  guaranteed calls examroom leave(p) student sitting seat p  medium map 
c++ o(logn) seat() and o(logn) leave() with stl set and map exam room exam room  n seats single row  numbered 0  1  2       n-1  student enters room  must sit seat maximizes distance closest person  multiple seats  sit seat lowest number  (also  one room  student sits seat number 0 ) return class examroom(int n) exposes two functions: examroom seat() returning int representing seat student sat in  examroom leave(int p) representing student seat number p leaves room  guaranteed calls examroom leave(p) student sitting seat p  medium map 
[c++ java python] concise o(1) space score of parentheses given balanced parentheses string s  compute score string based following rule: () score 1 ab score + b  b balanced parentheses strings  (a) score 2   a  balanced parentheses string  medium string stack 
java solution using stack score of parentheses given balanced parentheses string s  compute score string based following rule: () score 1 ab score + b  b balanced parentheses strings  (a) score 2   a  balanced parentheses string  medium string stack 
1-line python score of parentheses given balanced parentheses string s  compute score string based following rule: () score 1 ab score + b  b balanced parentheses strings  (a) score 2   a  balanced parentheses string  medium string stack 
python & javascript    simple and readable    stack solution score of parentheses given balanced parentheses string s  compute score string based following rule: () score 1 ab score + b  b balanced parentheses strings  (a) score 2   a  balanced parentheses string  medium string stack 
java 8ms 11 lines recursion with explanation score of parentheses given balanced parentheses string s  compute score string based following rule: () score 1 ab score + b  b balanced parentheses strings  (a) score 2   a  balanced parentheses string  medium string stack 
detailed explanation o(nlogn) minimum cost to hire k workers n workers  i-th worker quality[i] minimum wage expectation wage[i]  want hire exactly k workers form paid group  hiring group k workers  must pay according following rules: every worker paid group paid ratio quality compared workers paid group  every worker paid group must paid least minimum wage expectation  return least amount money needed form paid group satisfying conditions  hard heap 
o(nlogn) c++ code using priority queue with explanation minimum cost to hire k workers n workers  i-th worker quality[i] minimum wage expectation wage[i]  want hire exactly k workers form paid group  hiring group k workers  must pay according following rules: every worker paid group paid ratio quality compared workers paid group  every worker paid group must paid least minimum wage expectation  return least amount money needed form paid group satisfying conditions  hard heap 
n log n explanation  no code minimum cost to hire k workers n workers  i-th worker quality[i] minimum wage expectation wage[i]  want hire exactly k workers form paid group  hiring group k workers  must pay according following rules: every worker paid group paid ratio quality compared workers paid group  every worker paid group must paid least minimum wage expectation  return least amount money needed form paid group satisfying conditions  hard heap 
75ms java with explanations minimum cost to hire k workers n workers  i-th worker quality[i] minimum wage expectation wage[i]  want hire exactly k workers form paid group  hiring group k workers  must pay according following rules: every worker paid group paid ratio quality compared workers paid group  every worker paid group must paid least minimum wage expectation  return least amount money needed form paid group satisfying conditions  hard heap 
detailed plain english explanation with very simple readable code  minimum cost to hire k workers n workers  i-th worker quality[i] minimum wage expectation wage[i]  want hire exactly k workers form paid group  hiring group k workers  must pay according following rules: every worker paid group paid ratio quality compared workers paid group  every worker paid group must paid least minimum wage expectation  return least amount money needed form paid group satisfying conditions  hard heap 
java short solution with a sample drawing mirror reflection special square room mirrors four walls  except southwest corner  receptors remaining corners  numbered 0  1  2  square room walls length p  laser ray southwest corner first meets east wall distance q 0th receptor  return number receptor ray meets first  (it guaranteed ray meet receptor eventually ) medium math 
[c++ java python] 1-line without using any package or ✖️➗% mirror reflection special square room mirrors four walls  except southwest corner  receptors remaining corners  numbered 0  1  2  square room walls length p  laser ray southwest corner first meets east wall distance q 0th receptor  return number receptor ray meets first  (it guaranteed ray meet receptor eventually ) medium math 
一看就懂 mirror reflection special square room mirrors four walls  except southwest corner  receptors remaining corners  numbered 0  1  2  square room walls length p  laser ray southwest corner first meets east wall distance q 0th receptor  return number receptor ray meets first  (it guaranteed ray meet receptor eventually ) medium math 
the most straight forward solution pure math only 13ms mirror reflection special square room mirrors four walls  except southwest corner  receptors remaining corners  numbered 0  1  2  square room walls length p  laser ray southwest corner first meets east wall distance q 0th receptor  return number receptor ray meets first  (it guaranteed ray meet receptor eventually ) medium math 
java solution with an easy-to-understand explanation mirror reflection special square room mirrors four walls  except southwest corner  receptors remaining corners  numbered 0  1  2  square room walls length p  laser ray southwest corner first meets east wall distance q 0th receptor  return number receptor ray meets first  (it guaranteed ray meet receptor eventually ) medium math 
easy understood buddy strings given two strings b lowercase letters  return true swap two letters result equals b  easy string 
java o(1) space  o(n) time buddy strings given two strings b lowercase letters  return true swap two letters result equals b  easy string 
clear c++ solution buddy strings given two strings b lowercase letters  return true swap two letters result equals b  easy string 
very simple python solution with detailed explanation [o(n) time  o(1) space with 40 ms runtime] buddy strings given two strings b lowercase letters  return true swap two letters result equals b  easy string 
javascript straightforward buddy strings given two strings b lowercase letters  return true swap two letters result equals b  easy string 
[c++ java python] straight forward lemonade change lemonade stand  lemonade costs $5  customers standing queue buy you  order one time (in order specified bills)  customer buy one lemonade pay either $5  $10  $20 bill  must provide correct change customer  net transaction customer pays $5  note change hand first  return true provide every customer correct change  easy greedy 
python simple & readable lemonade change lemonade stand  lemonade costs $5  customers standing queue buy you  order one time (in order specified bills)  customer buy one lemonade pay either $5  $10  $20 bill  must provide correct change customer  net transaction customer pays $5  note change hand first  return true provide every customer correct change  easy greedy 
java easy undersand lemonade change lemonade stand  lemonade costs $5  customers standing queue buy you  order one time (in order specified bills)  customer buy one lemonade pay either $5  $10  $20 bill  must provide correct change customer  net transaction customer pays $5  note change hand first  return true provide every customer correct change  easy greedy 
easy to understand java solution lemonade change lemonade stand  lemonade costs $5  customers standing queue buy you  order one time (in order specified bills)  customer buy one lemonade pay either $5  $10  $20 bill  must provide correct change customer  net transaction customer pays $5  note change hand first  return true provide every customer correct change  easy greedy 
7ms java solution with readable code and explanation lemonade change lemonade stand  lemonade costs $5  customers standing queue buy you  order one time (in order specified bills)  customer buy one lemonade pay either $5  $10  $20 bill  must provide correct change customer  net transaction customer pays $5  note change hand first  return true provide every customer correct change  easy greedy 
[c++ java python] easy and concise score after flipping matrix two dimensional matrix value 0 1  move consists choosing row column  toggling value row column: changing 0s 1s  1s 0s  making number moves  every row matrix interpreted binary number  score matrix sum numbers  return highest possible score  medium greedy 
[c++ java] from intuition  un-optimized code to optimized code with detailed explanation  score after flipping matrix two dimensional matrix value 0 1  move consists choosing row column  toggling value row column: changing 0s 1s  1s 0s  making number moves  every row matrix interpreted binary number  score matrix sum numbers  return highest possible score  medium greedy 
java  two steps  o(mn) score after flipping matrix two dimensional matrix value 0 1  move consists choosing row column  toggling value row column: changing 0s 1s  1s 0s  making number moves  every row matrix interpreted binary number  score matrix sum numbers  return highest possible score  medium greedy 
python o(n m) greedy solution score after flipping matrix two dimensional matrix value 0 1  move consists choosing row column  toggling value row column: changing 0s 1s  1s 0s  making number moves  every row matrix interpreted binary number  score matrix sum numbers  return highest possible score  medium greedy 
c++ easy understand greedy method with explanation score after flipping matrix two dimensional matrix value 0 1  move consists choosing row column  toggling value row column: changing 0s 1s  1s 0s  making number moves  every row matrix interpreted binary number  score matrix sum numbers  return highest possible score  medium greedy 
[c++ java python] o(n) using deque shortest subarray with sum at least k return length shortest  non-empty  contiguous subarray sum least k  non-empty subarray sum least k  return -1  hard binary search queue 
simple java solution using treemap shortest subarray with sum at least k return length shortest  non-empty  contiguous subarray sum least k  non-empty subarray sum least k  return -1  hard binary search queue 
python simple & readable    ac heapq solution w  detailed explanation  shortest subarray with sum at least k return length shortest  non-empty  contiguous subarray sum least k  non-empty subarray sum least k  return -1  hard binary search queue 
detailed intuition behind deque solution shortest subarray with sum at least k return length shortest  non-empty  contiguous subarray sum least k  non-empty subarray sum least k  return -1  hard binary search queue 
a java deque solution time o(n) space o(n) shortest subarray with sum at least k return length shortest  non-empty  contiguous subarray sum least k  non-empty subarray sum least k  return -1  hard binary search queue 
java bfs solution shortest path to get all keys given 2-dimensional grid  " " empty cell  "#" wall  "@" starting point  ("a"  "b"     ) keys  ("a"  "b"     ) locks  start starting point  one move consists walking one space one 4 cardinal directions  cannot walk outside grid  walk wall  walk key  pick up  can't walk lock unless corresponding key  1 <= k <= 6  exactly one lowercase one uppercase letter first k letters english alphabet grid  means exactly one key lock  one lock key; also letters used represent keys locks chosen order english alphabet  return lowest number moves acquire keys  impossible  return -1  hard heap breadth-first search 
leetcode weekly contest 92 screencast shortest path to get all keys given 2-dimensional grid  " " empty cell  "#" wall  "@" starting point  ("a"  "b"     ) keys  ("a"  "b"     ) locks  start starting point  one move consists walking one space one 4 cardinal directions  cannot walk outside grid  walk wall  walk key  pick up  can't walk lock unless corresponding key  1 <= k <= 6  exactly one lowercase one uppercase letter first k letters english alphabet grid  means exactly one key lock  one lock key; also letters used represent keys locks chosen order english alphabet  return lowest number moves acquire keys  impossible  return -1  hard heap breadth-first search 
o(mn2^k) 500ms python bfs easy to understand solution shortest path to get all keys given 2-dimensional grid  " " empty cell  "#" wall  "@" starting point  ("a"  "b"     ) keys  ("a"  "b"     ) locks  start starting point  one move consists walking one space one 4 cardinal directions  cannot walk outside grid  walk wall  walk key  pick up  can't walk lock unless corresponding key  1 <= k <= 6  exactly one lowercase one uppercase letter first k letters english alphabet grid  means exactly one key lock  one lock key; also letters used represent keys locks chosen order english alphabet  return lowest number moves acquire keys  impossible  return -1  hard heap breadth-first search 
[c++] bfs with current key recorded visited map (12ms) shortest path to get all keys given 2-dimensional grid  " " empty cell  "#" wall  "@" starting point  ("a"  "b"     ) keys  ("a"  "b"     ) locks  start starting point  one move consists walking one space one 4 cardinal directions  cannot walk outside grid  walk wall  walk key  pick up  can't walk lock unless corresponding key  1 <= k <= 6  exactly one lowercase one uppercase letter first k letters english alphabet grid  means exactly one key lock  one lock key; also letters used represent keys locks chosen order english alphabet  return lowest number moves acquire keys  impossible  return -1  hard heap breadth-first search 
python heapq solution w  memoization  shortest path to get all keys given 2-dimensional grid  " " empty cell  "#" wall  "@" starting point  ("a"  "b"     ) keys  ("a"  "b"     ) locks  start starting point  one move consists walking one space one 4 cardinal directions  cannot walk outside grid  walk wall  walk key  pick up  can't walk lock unless corresponding key  1 <= k <= 6  exactly one lowercase one uppercase letter first k letters english alphabet grid  means exactly one key lock  one lock key; also letters used represent keys locks chosen order english alphabet  return lowest number moves acquire keys  impossible  return -1  hard heap breadth-first search 
one pass smallest subtree with all the deepest nodes given binary tree rooted root  depth node shortest distance root  node deepest largest depth possible among node entire tree  subtree node node  plus set descendants node  return node largest depth contains deepest nodes subtree  medium tree 
simple recursive java solution  smallest subtree with all the deepest nodes given binary tree rooted root  depth node shortest distance root  node deepest largest depth possible among node entire tree  subtree node node  plus set descendants node  return node largest depth contains deepest nodes subtree  medium tree 
description of what the problem is asking is unclear smallest subtree with all the deepest nodes given binary tree rooted root  depth node shortest distance root  node deepest largest depth possible among node entire tree  subtree node node  plus set descendants node  return node largest depth contains deepest nodes subtree  medium tree 
short and concise c++ solution using dfs  3~5 lines smallest subtree with all the deepest nodes given binary tree rooted root  depth node shortest distance root  node deepest largest depth possible among node entire tree  subtree node node  plus set descendants node  return node largest depth contains deepest nodes subtree  medium tree 
unclear problem description  smallest subtree with all the deepest nodes given binary tree rooted root  depth node shortest distance root  node deepest largest depth possible among node entire tree  subtree node node  plus set descendants node  return node largest depth contains deepest nodes subtree  medium tree 
search palindrome with even digits prime palindrome find smallest prime palindrome greater equal n  recall number prime divisors 1 itself  greater 1  medium math 
c++ o(1) 0ms prime palindrome find smallest prime palindrome greater equal n  recall number prime divisors 1 itself  greater 1  medium math 
getting one over the system (o(1) solution in java) prime palindrome find smallest prime palindrome greater equal n  recall number prime divisors 1 itself  greater 1  medium math 
faster way to find palindrome  accepted c++ solution  prime palindrome find smallest prime palindrome greater equal n  recall number prime divisors 1 itself  greater 1  medium math 
java solution 6ms prime palindrome find smallest prime palindrome greater equal n  recall number prime divisors 1 itself  greater 1  medium math 
python - 1 liner transpose matrix given matrix a  return transpose a  transpose matrix matrix flipped main diagonal  switching row column indices matrix  easy array 
python self-explanatory 1 line solution transpose matrix given matrix a  return transpose a  transpose matrix matrix flipped main diagonal  switching row column indices matrix  easy array 
[c++ java python] easy understood transpose matrix given matrix a  return transpose a  transpose matrix matrix flipped main diagonal  switching row column indices matrix  easy array 
simple java solution transpose matrix given matrix a  return transpose a  transpose matrix matrix flipped main diagonal  switching row column indices matrix  easy array 
java solution   transpose matrix given matrix a  return transpose a  transpose matrix matrix flipped main diagonal  switching row column indices matrix  easy array 
[c++ java python] dividing by 2 binary gap given positive integer n  find return longest distance two consecutive 1's binary representation n  two consecutive 1's  return 0  easy math 
who can tell me  what does "distance" means? binary gap given positive integer n  find return longest distance two consecutive 1's binary representation n  two consecutive 1's  return 0  easy math 
simple java (10 ms) binary gap given positive integer n  find return longest distance two consecutive 1's binary representation n  two consecutive 1's  return 0  easy math 
python 1-line solution binary gap given positive integer n  find return longest distance two consecutive 1's binary representation n  two consecutive 1's  return 0  easy math 
python simple solution binary gap given positive integer n  find return longest distance two consecutive 1's binary representation n  two consecutive 1's  return 0  easy math 
[c++ java python] straight forward reordered power of 2 starting positive integer n  reorder digits order (including original order) leading digit zero  return true way resulting number power 2  medium math 
java naive backtracking 15 lines reordered power of 2 starting positive integer n  reorder digits order (including original order) leading digit zero  return true way resulting number power 2  medium math 
possibly fastest c++ solution using multiset  0ms runtime  reordered power of 2 starting positive integer n  reorder digits order (including original order) leading digit zero  return true way resulting number power 2  medium math 
one line python beats 70% reordered power of 2 starting positive integer n  reorder digits order (including original order) leading digit zero  return true way resulting number power 2  medium math 
simple java solution based on string sorting reordered power of 2 starting positive integer n  reorder digits order (including original order) leading digit zero  return true way resulting number power 2  medium math 
java greedy 6 lines with explanation advantage shuffle given two arrays b equal size  advantage respect b number indices a[i] > b[i]  return permutation maximizes advantage respect b  medium array greedy 
simple java solution with the idea of 田忌赛马 advantage shuffle given two arrays b equal size  advantage respect b number indices a[i] > b[i]  return permutation maximizes advantage respect b  medium array greedy 
c++ 6 lines greedy  o(n log n) advantage shuffle given two arrays b equal size  advantage respect b number indices a[i] > b[i]  return permutation maximizes advantage respect b  medium array greedy 
[python] greedy solution using sort advantage shuffle given two arrays b equal size  advantage respect b number indices a[i] > b[i]  return permutation maximizes advantage respect b  medium array greedy 
[c++ java] greedy solution using map advantage shuffle given two arrays b equal size  advantage respect b number indices a[i] > b[i]  return permutation maximizes advantage respect b  medium array greedy 
dp o(n^2) and priority queue o(nlogn) minimum number of refueling stops car travels starting position destination target miles east starting position  along way  gas stations  station[i] represents gas station station[i][0] miles east starting position  station[i][1] liters gas  car starts infinite tank gas  initially startfuel liters fuel it  uses 1 liter gas per 1 mile drives  car reaches gas station  may stop refuel  transferring gas station car  least number refueling stops car must make order reach destination? cannot reach destination  return -1  note car reaches gas station 0 fuel left  car still refuel there  car reaches destination 0 fuel left  still considered arrived  hard dynamic programming heap 
simple java solution using priorityqueue o(nlogn) minimum number of refueling stops car travels starting position destination target miles east starting position  along way  gas stations  station[i] represents gas station station[i][0] miles east starting position  station[i][1] liters gas  car starts infinite tank gas  initially startfuel liters fuel it  uses 1 liter gas per 1 mile drives  car reaches gas station  may stop refuel  transferring gas station car  least number refueling stops car must make order reach destination? cannot reach destination  return -1  note car reaches gas station 0 fuel left  car still refuel there  car reaches destination 0 fuel left  still considered arrived  hard dynamic programming heap 
c++ dp solution space complexity from o(n^2) to o(n)  minimum number of refueling stops car travels starting position destination target miles east starting position  along way  gas stations  station[i] represents gas station station[i][0] miles east starting position  station[i][1] liters gas  car starts infinite tank gas  initially startfuel liters fuel it  uses 1 liter gas per 1 mile drives  car reaches gas station  may stop refuel  transferring gas station car  least number refueling stops car must make order reach destination? cannot reach destination  return -1  note car reaches gas station 0 fuel left  car still refuel there  car reaches destination 0 fuel left  still considered arrived  hard dynamic programming heap 
python o(nlogn)  minimum number of refueling stops car travels starting position destination target miles east starting position  along way  gas stations  station[i] represents gas station station[i][0] miles east starting position  station[i][1] liters gas  car starts infinite tank gas  initially startfuel liters fuel it  uses 1 liter gas per 1 mile drives  car reaches gas station  may stop refuel  transferring gas station car  least number refueling stops car must make order reach destination? cannot reach destination  return -1  note car reaches gas station 0 fuel left  car still refuel there  car reaches destination 0 fuel left  still considered arrived  hard dynamic programming heap 
o(n) simple and concise c++ solution using priority_queue  need no comment minimum number of refueling stops car travels starting position destination target miles east starting position  along way  gas stations  station[i] represents gas station station[i][0] miles east starting position  station[i][1] liters gas  car starts infinite tank gas  initially startfuel liters fuel it  uses 1 liter gas per 1 mile drives  car reaches gas station  may stop refuel  transferring gas station car  least number refueling stops car must make order reach destination? cannot reach destination  return -1  note car reaches gas station 0 fuel left  car still refuel there  car reaches destination 0 fuel left  still considered arrived  hard dynamic programming heap 
[c++ java python] o(logn) space leaf-similar trees consider leaves binary tree  left right order  values leaves form leaf value sequence  easy tree depth-first search 
4 line python solution leaf-similar trees consider leaves binary tree  left right order  values leaves form leaf value sequence  easy tree depth-first search 
simple 6 lines java  stringbuilder + traverse with explanation leaf-similar trees consider leaves binary tree  left right order  values leaves form leaf value sequence  easy tree depth-first search 
c++ super easy 0ms short solution  beats 100%! leaf-similar trees consider leaves binary tree  left right order  values leaves form leaf value sequence  easy tree depth-first search 
c++ solution based on hashing leaf-similar trees consider leaves binary tree  left right order  values leaves form leaf value sequence  easy tree depth-first search 
[c++ java python] check pair length of longest fibonacci subsequence sequence x_1  x_2       x_n fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} + 2 <= n given strictly increasing array positive integers forming sequence  find length longest fibonacci-like subsequence a  one exist  return 0  (recall subsequence derived another sequence deleting number elements (including none) a  without changing order remaining elements  medium array dynamic programming 
leetcode weekly contest 94 screencast length of longest fibonacci subsequence sequence x_1  x_2       x_n fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} + 2 <= n given strictly increasing array positive integers forming sequence  find length longest fibonacci-like subsequence a  one exist  return 0  (recall subsequence derived another sequence deleting number elements (including none) a  without changing order remaining elements  medium array dynamic programming 
java clean dp o(n^2) time o(n^2) space length of longest fibonacci subsequence sequence x_1  x_2       x_n fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} + 2 <= n given strictly increasing array positive integers forming sequence  find length longest fibonacci-like subsequence a  one exist  return 0  (recall subsequence derived another sequence deleting number elements (including none) a  without changing order remaining elements  medium array dynamic programming 
c++ dp solution length of longest fibonacci subsequence sequence x_1  x_2       x_n fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} + 2 <= n given strictly increasing array positive integers forming sequence  find length longest fibonacci-like subsequence a  one exist  return 0  (recall subsequence derived another sequence deleting number elements (including none) a  without changing order remaining elements  medium array dynamic programming 
java hashmap straightforward length of longest fibonacci subsequence sequence x_1  x_2       x_n fibonacci-like if: n >= 3 x_i + x_{i+1} = x_{i+2} + 2 <= n given strictly increasing array positive integers forming sequence  find length longest fibonacci-like subsequence a  one exist  return 0  (recall subsequence derived another sequence deleting number elements (including none) a  without changing order remaining elements  medium array dynamic programming 
maximum?! this is crazy! walking robot simulation robot infinite grid starts point (0  0) faces north  robot receive one three possible types commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units grid squares obstacles  i-th obstacle grid point (obstacles[i][0]  obstacles[i][1]) robot would try move onto them  robot stays previous grid square instead (but still continues following rest route ) return square maximum euclidean distance robot origin  easy greedy 
logical thinking with clear code walking robot simulation robot infinite grid starts point (0  0) faces north  robot receive one three possible types commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units grid squares obstacles  i-th obstacle grid point (obstacles[i][0]  obstacles[i][1]) robot would try move onto them  robot stays previous grid square instead (but still continues following rest route ) return square maximum euclidean distance robot origin  easy greedy 
python short & straightforward solution w  explanation & statement is wrong in the question !!! walking robot simulation robot infinite grid starts point (0  0) faces north  robot receive one three possible types commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units grid squares obstacles  i-th obstacle grid point (obstacles[i][0]  obstacles[i][1]) robot would try move onto them  robot stays previous grid square instead (but still continues following rest route ) return square maximum euclidean distance robot origin  easy greedy 
any 1160(x) 1954(o)? walking robot simulation robot infinite grid starts point (0  0) faces north  robot receive one three possible types commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units grid squares obstacles  i-th obstacle grid point (obstacles[i][0]  obstacles[i][1]) robot would try move onto them  robot stays previous grid square instead (but still continues following rest route ) return square maximum euclidean distance robot origin  easy greedy 
obstacle at origin walking robot simulation robot infinite grid starts point (0  0) faces north  robot receive one three possible types commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units grid squares obstacles  i-th obstacle grid point (obstacles[i][0]  obstacles[i][1]) robot would try move onto them  robot stays previous grid square instead (but still continues following rest route ) return square maximum euclidean distance robot origin  easy greedy 
logical thinking with java code  koko eating bananas koko loves eat bananas  n piles bananas  i-th pile piles[i] bananas  guards gone come back h hours  koko decide bananas-per-hour eating speed k  hour  chooses pile bananas  eats k bananas pile  pile less k bananas  eats instead  eat bananas hour  koko likes eat slowly  still wants finish eating bananas guards come back  return minimum integer k eat bananas within h hours  medium binary search 
[c++ java python] binary search koko eating bananas koko loves eat bananas  n piles bananas  i-th pile piles[i] bananas  guards gone come back h hours  koko decide bananas-per-hour eating speed k  hour  chooses pile bananas  eats k bananas pile  pile less k bananas  eats instead  eat bananas hour  koko likes eat slowly  still wants finish eating bananas guards come back  return minimum integer k eat bananas within h hours  medium binary search 
java concise binary search 10 lines with explanation koko eating bananas koko loves eat bananas  n piles bananas  i-th pile piles[i] bananas  guards gone come back h hours  koko decide bananas-per-hour eating speed k  hour  chooses pile bananas  eats k bananas pile  pile less k bananas  eats instead  eat bananas hour  koko likes eat slowly  still wants finish eating bananas guards come back  return minimum integer k eat bananas within h hours  medium binary search 
binary search with optimized runtime koko eating bananas koko loves eat bananas  n piles bananas  i-th pile piles[i] bananas  guards gone come back h hours  koko decide bananas-per-hour eating speed k  hour  chooses pile bananas  eats k bananas pile  pile less k bananas  eats instead  eat bananas hour  koko likes eat slowly  still wants finish eating bananas guards come back  return minimum integer k eat bananas within h hours  medium binary search 
python solution with chinese explanation koko eating bananas koko loves eat bananas  n piles bananas  i-th pile piles[i] bananas  guards gone come back h hours  koko decide bananas-per-hour eating speed k  hour  chooses pile bananas  eats k bananas pile  pile less k bananas  eats instead  eat bananas hour  koko likes eat slowly  still wants finish eating bananas guards come back  return minimum integer k eat bananas within h hours  medium binary search 
[c++ java python] slow and fast pointers middle of the linked list given non-empty  singly linked list head node head  return middle node linked list  two middle nodes  return second middle node  easy linked list 
remember this pattern for problems that require middle finding in a linked list  middle of the linked list given non-empty  singly linked list head node head  return middle node linked list  two middle nodes  return second middle node  easy linked list 
python two pointer  extremely simple  with explaination middle of the linked list given non-empty  singly linked list head node head  return middle node linked list  two middle nodes  return second middle node  easy linked list 
java o(n) time & o(1) space solution without using fast slow pointer middle of the linked list given non-empty  singly linked list head node head  return middle node linked list  two middle nodes  return second middle node  easy linked list 
[java] 5 liner with explanations middle of the linked list given non-empty  singly linked list head node head  return middle node linked list  two middle nodes  return second middle node  easy linked list 
[c++ java python] dp or just return true stone game alex lee play game piles stones  even number piles arranged row  pile positive integer number stones piles[i]  objective game end stones  total number stones odd  ties  alex lee take turns  alex starting first  turn  player takes entire pile stones either beginning end row  continues piles left  point person stones wins  assuming alex lee play optimally  return true alex wins game  medium math dynamic programming 
[java] this is minimax + dp (fully detailed explanation + generalization + easy understand code) stone game alex lee play game piles stones  even number piles arranged row  pile positive integer number stones piles[i]  objective game end stones  total number stones odd  ties  alex lee take turns  alex starting first  turn  player takes entire pile stones either beginning end row  continues piles left  point person stones wins  assuming alex lee play optimally  return true alex wins game  medium math dynamic programming 
alex won't lose stone game alex lee play game piles stones  even number piles arranged row  pile positive integer number stones piles[i]  objective game end stones  total number stones odd  ties  alex lee take turns  alex starting first  turn  player takes entire pile stones either beginning end row  continues piles left  point person stones wins  assuming alex lee play optimally  return true alex wins game  medium math dynamic programming 
python solution using memorization with chinese explanation stone game alex lee play game piles stones  even number piles arranged row  pile positive integer number stones piles[i]  objective game end stones  total number stones odd  ties  alex lee take turns  alex starting first  turn  player takes entire pile stones either beginning end row  continues piles left  point person stones wins  assuming alex lee play optimally  return true alex wins game  medium math dynamic programming 
alex can take all piles with odd (even) indices  thus he always wins stone game alex lee play game piles stones  even number piles arranged row  pile positive integer number stones piles[i]  objective game end stones  total number stones odd  ties  alex lee take turns  alex starting first  turn  player takes entire pile stones either beginning end row  continues piles left  point person stones wins  assuming alex lee play optimally  return true alex wins game  medium math dynamic programming 
[c++ java python] binary search nth magical number positive integer magical divisible either b  return n-th magical number  since answer may large  return modulo 10^9 + 7  hard math binary search 
o(1) mathematical solution without binary or brute force search nth magical number positive integer magical divisible either b  return n-th magical number  since answer may large  return modulo 10^9 + 7  hard math binary search 
python using gcd and lcm  no search needed nth magical number positive integer magical divisible either b  return n-th magical number  since answer may large  return modulo 10^9 + 7  hard math binary search 
python leverage gcd and lcm to search nth magical number positive integer magical divisible either b  return n-th magical number  since answer may large  return modulo 10^9 + 7  hard math binary search 
python simple & readable binary search solution nth magical number positive integer magical divisible either b  return n-th magical number  since answer may large  return modulo 10^9 + 7  hard math binary search 
[c++ java python] dp profitable schemes g people gang  list various crimes could commit  i-th crime generates profit[i] requires group[i] gang members participate  gang member participates one crime  member can't participate another crime  let's call profitable scheme subset crimes generates least p profit  total number gang members participating subset crimes g  many schemes chosen? since answer may large  return modulo 10^9 + 7  hard dynamic programming 
java original 3d to 2d dp solution profitable schemes g people gang  list various crimes could commit  i-th crime generates profit[i] requires group[i] gang members participate  gang member participates one crime  member can't participate another crime  let's call profitable scheme subset crimes generates least p profit  total number gang members participating subset crimes g  many schemes chosen? since answer may large  return modulo 10^9 + 7  hard dynamic programming 
leetcode weekly contest 95 screencast profitable schemes g people gang  list various crimes could commit  i-th crime generates profit[i] requires group[i] gang members participate  gang member participates one crime  member can't participate another crime  let's call profitable scheme subset crimes generates least p profit  total number gang members participating subset crimes g  many schemes chosen? since answer may large  return modulo 10^9 + 7  hard dynamic programming 
c++ o(pgn) top-down dp solution profitable schemes g people gang  list various crimes could commit  i-th crime generates profit[i] requires group[i] gang members participate  gang member participates one crime  member can't participate another crime  let's call profitable scheme subset crimes generates least p profit  total number gang members participating subset crimes g  many schemes chosen? since answer may large  return modulo 10^9 + 7  hard dynamic programming 
simple dp o(pgn) profitable schemes g people gang  list various crimes could commit  i-th crime generates profit[i] requires group[i] gang members participate  gang member participates one crime  member can't participate another crime  let's call profitable scheme subset crimes generates least p profit  total number gang members participating subset crimes g  many schemes chosen? since answer may large  return modulo 10^9 + 7  hard dynamic programming 
[c++ python] o(n) time o(1) space decoded string at index encoded string given  find write decoded string tape  encoded string read one character time following steps taken: character read letter  letter written onto tape  character read digit (say d)  entire current tape repeatedly written d-1 times total  encoded string s  index k  find return k-th letter (1 indexed) decoded string  medium stack 
easy to understand java solution decoded string at index encoded string given  find write decoded string tape  encoded string read one character time following steps taken: character read letter  letter written onto tape  character read digit (say d)  entire current tape repeatedly written d-1 times total  encoded string s  index k  find return k-th letter (1 indexed) decoded string  medium stack 
c++ simple recursion decoded string at index encoded string given  find write decoded string tape  encoded string read one character time following steps taken: character read letter  letter written onto tape  character read digit (say d)  entire current tape repeatedly written d-1 times total  encoded string s  index k  find return k-th letter (1 indexed) decoded string  medium stack 
logical thinking with clear code decoded string at index encoded string given  find write decoded string tape  encoded string read one character time following steps taken: character read letter  letter written onto tape  character read digit (say d)  entire current tape repeatedly written d-1 times total  encoded string s  index k  find return k-th letter (1 indexed) decoded string  medium stack 
15 lines clear code decoded string at index encoded string given  find write decoded string tape  encoded string read one character time following steps taken: character read letter  letter written onto tape  character read digit (say d)  entire current tape repeatedly written d-1 times total  encoded string s  index k  find return k-th letter (1 indexed) decoded string  medium stack 
6 lines [java] o(nlogn) code  sorting + greedy  with greedy algorithm proof   boats to save people i-th person weight people[i]  boat carry maximum weight limit  boat carries 2 people time  provided sum weight people limit  return minimum number boats carry every given person  (it guaranteed person carried boat ) medium two pointers greedy 
[c++ java python] two pointers boats to save people i-th person weight people[i]  boat carry maximum weight limit  boat carries 2 people time  provided sum weight people limit  return minimum number boats carry every given person  (it guaranteed person carried boat ) medium two pointers greedy 
python short 2 pointer solution & some thoughts boats to save people i-th person weight people[i]  boat carry maximum weight limit  boat carries 2 people time  provided sum weight people limit  return minimum number boats carry every given person  (it guaranteed person carried boat ) medium two pointers greedy 
[java] o(n(people)) + o(limit) solution boats to save people i-th person weight people[i]  boat carry maximum weight limit  boat carries 2 people time  provided sum weight people limit  return minimum number boats carry every given person  (it guaranteed person carried boat ) medium two pointers greedy 
what if each boat carries at most k people (instead of 2 people) at the same time boats to save people i-th person weight people[i]  boat carry maximum weight limit  boat carries 2 people time  provided sum weight people limit  return minimum number boats carry every given person  (it guaranteed person carried boat ) medium two pointers greedy 
java dijkstra solution reachable nodes in subdivided graph starting undirected graph (the "original graph") nodes 0 n-1  subdivisions made edges  graph given follows: edges[k] list integer pairs (i  j  n) (i  j) edge original graph  n total number new nodes edge  then  edge (i  j) deleted original graph  n new nodes (x_1  x_2       x_n) added original graph  n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) added original graph  now  start node 0 original graph  move  travel along one edge  return many nodes reach moves  hard heap 
[c++ java python] dijkstra + priority queue reachable nodes in subdivided graph starting undirected graph (the "original graph") nodes 0 n-1  subdivisions made edges  graph given follows: edges[k] list integer pairs (i  j  n) (i  j) edge original graph  n total number new nodes edge  then  edge (i  j) deleted original graph  n new nodes (x_1  x_2       x_n) added original graph  n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) added original graph  now  start node 0 original graph  move  travel along one edge  return many nodes reach moves  hard heap 
god  the description of this problem just confuses me!! reachable nodes in subdivided graph starting undirected graph (the "original graph") nodes 0 n-1  subdivisions made edges  graph given follows: edges[k] list integer pairs (i  j  n) (i  j) edge original graph  n total number new nodes edge  then  edge (i  j) deleted original graph  n new nodes (x_1  x_2       x_n) added original graph  n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) added original graph  now  start node 0 original graph  move  travel along one edge  return many nodes reach moves  hard heap 
logical thinking with clear code reachable nodes in subdivided graph starting undirected graph (the "original graph") nodes 0 n-1  subdivisions made edges  graph given follows: edges[k] list integer pairs (i  j  n) (i  j) edge original graph  n total number new nodes edge  then  edge (i  j) deleted original graph  n new nodes (x_1  x_2       x_n) added original graph  n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) added original graph  now  start node 0 original graph  move  travel along one edge  return many nodes reach moves  hard heap 
indecipherable description reachable nodes in subdivided graph starting undirected graph (the "original graph") nodes 0 n-1  subdivisions made edges  graph given follows: edges[k] list integer pairs (i  j  n) (i  j) edge original graph  n total number new nodes edge  then  edge (i  j) deleted original graph  n new nodes (x_1  x_2       x_n) added original graph  n+1 new edges (i  x_1)  (x_1  x_2)  (x_2  x_3)       (x_{n-1}  x_n)  (x_n  j) added original graph  now  start node 0 original graph  move  travel along one edge  return many nodes reach moves  hard heap 
please change the description of the problem projection area of 3d shapes n   n grid  place 1   1   1 cubes axis-aligned x  y  z axes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  view projection cubes onto xy  yz  zx planes  projection like shadow  maps 3 dimensional figure 2 dimensional plane  here  viewing "shadow" looking cubes top  front  side  return total area three projections  easy math 
i don't even understand the description projection area of 3d shapes n   n grid  place 1   1   1 cubes axis-aligned x  y  z axes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  view projection cubes onto xy  yz  zx planes  projection like shadow  maps 3 dimensional figure 2 dimensional plane  here  viewing "shadow" looking cubes top  front  side  return total area three projections  easy math 
11 line 1 pass [java] code and  explanation of the problem  time o(n ^ 2) space o(1)  projection area of 3d shapes n   n grid  place 1   1   1 cubes axis-aligned x  y  z axes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  view projection cubes onto xy  yz  zx planes  projection like shadow  maps 3 dimensional figure 2 dimensional plane  here  viewing "shadow" looking cubes top  front  side  return total area three projections  easy math 
[c++ java python] straight forward projection area of 3d shapes n   n grid  place 1   1   1 cubes axis-aligned x  y  z axes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  view projection cubes onto xy  yz  zx planes  projection like shadow  maps 3 dimensional figure 2 dimensional plane  here  viewing "shadow" looking cubes top  front  side  return total area three projections  easy math 
it drove me nuts  what the hell is it talking about    projection area of 3d shapes n   n grid  place 1   1   1 cubes axis-aligned x  y  z axes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  view projection cubes onto xy  yz  zx planes  projection like shadow  maps 3 dimensional figure 2 dimensional plane  here  viewing "shadow" looking cubes top  front  side  return total area three projections  easy math 
[c++ java python] easy solution with explanation uncommon words from two sentences given two sentences b  (a sentence string space separated words  word consists lowercase letters ) word uncommon appears exactly one sentences  appear sentence  return list uncommon words  may return list order  easy hash table 
[java] 3 liner and 5 liner  using hashmap and hashsets  respectively   uncommon words from two sentences given two sentences b  (a sentence string space separated words  word consists lowercase letters ) word uncommon appears exactly one sentences  appear sentence  return list uncommon words  may return list order  easy hash table 
c++ 100% with unordered_map uncommon words from two sentences given two sentences b  (a sentence string space separated words  word consists lowercase letters ) word uncommon appears exactly one sentences  appear sentence  return list uncommon words  may return list order  easy hash table 
two c++ solutions uncommon words from two sentences given two sentences b  (a sentence string space separated words  word consists lowercase letters ) word uncommon appears exactly one sentences  appear sentence  return list uncommon words  may return list order  easy hash table 
[c# solution] 2 lines of code  beat 100% submission running time uncommon words from two sentences given two sentences b  (a sentence string space separated words  word consists lowercase letters ) word uncommon appears exactly one sentences  appear sentence  return list uncommon words  may return list order  easy hash table 
[c++ java python] 1 1 2 2 3 3 steps spiral matrix iii 2 dimensional grid r rows c columns  start (r0  c0) facing east  here  north-west corner grid first row column  south-east corner grid last row column  now  walk clockwise spiral shape visit every position grid  whenever would move outside boundary grid  continue walk outside grid (but may return grid boundary later ) eventually  reach r   c spaces grid  return list coordinates representing positions grid order visited  medium math 
java 15 lines concise solution with comments spiral matrix iii 2 dimensional grid r rows c columns  start (r0  c0) facing east  here  north-west corner grid first row column  south-east corner grid last row column  now  walk clockwise spiral shape visit every position grid  whenever would move outside boundary grid  continue walk outside grid (but may return grid boundary later ) eventually  reach r   c spaces grid  return list coordinates representing positions grid order visited  medium math 
[python] sort all coordinates spiral matrix iii 2 dimensional grid r rows c columns  start (r0  c0) facing east  here  north-west corner grid first row column  south-east corner grid last row column  now  walk clockwise spiral shape visit every position grid  whenever would move outside boundary grid  continue walk outside grid (but may return grid boundary later ) eventually  reach r   c spaces grid  return list coordinates representing positions grid order visited  medium math 
simple east to understand java solution  spiral matrix iii 2 dimensional grid r rows c columns  start (r0  c0) facing east  here  north-west corner grid first row column  south-east corner grid last row column  now  walk clockwise spiral shape visit every position grid  whenever would move outside boundary grid  continue walk outside grid (but may return grid boundary later ) eventually  reach r   c spaces grid  return list coordinates representing positions grid order visited  medium math 
java simulation 17 lines with line-by-line explanation spiral matrix iii 2 dimensional grid r rows c columns  start (r0  c0) facing east  here  north-west corner grid first row column  south-east corner grid last row column  now  walk clockwise spiral shape visit every position grid  whenever would move outside boundary grid  continue walk outside grid (but may return grid boundary later ) eventually  reach r   c spaces grid  return list coordinates representing positions grid order visited  medium math 
java dfs solution possible bipartition given set n people (numbered 1  2       n)  would like split everyone two groups size  person may dislike people  go group  formally  dislikes[i] = [a  b]  means allowed put people numbered b group  return true possible split everyone two groups way  medium depth-first search 
java graph  possible bipartition given set n people (numbered 1  2       n)  would like split everyone two groups size  person may dislike people  go group  formally  dislikes[i] = [a  b]  means allowed put people numbered b group  return true possible split everyone two groups way  medium depth-first search 
[python] decide if a graph is bipartite by checking the existence of odd cycles  possible bipartition given set n people (numbered 1  2       n)  would like split everyone two groups size  person may dislike people  go group  formally  dislikes[i] = [a  b]  means allowed put people numbered b group  return true possible split everyone two groups way  medium depth-first search 
python dfs with explanation possible bipartition given set n people (numbered 1  2       n)  would like split everyone two groups size  person may dislike people  go group  formally  dislikes[i] = [a  b]  means allowed put people numbered b group  return true possible split everyone two groups way  medium depth-first search 
graph bipartite problem + dfs possible bipartition given set n people (numbered 1  2       n)  would like split everyone two groups size  person may dislike people  go group  formally  dislikes[i] = [a  b]  means allowed put people numbered b group  return true possible split everyone two groups way  medium depth-first search 
[c++ java python] 2d and 1d dp  o(klogn) super egg drop given k eggs  access building n floors 1 n  egg identical function  egg breaks  cannot drop again  know exists floor f 0 <= f <= n egg dropped floor higher f break  egg dropped floor f break  move  may take egg (if unbroken one) drop floor x (with 1 <= x <= n)  goal know certainty value f is  minimum number moves need know certainty f is  regardless initial value f? hard math binary search dynamic programming 
python dp from kn^2 to knlogn to kn super egg drop given k eggs  access building n floors 1 n  egg identical function  egg breaks  cannot drop again  know exists floor f 0 <= f <= n egg dropped floor higher f break  egg dropped floor f break  move  may take egg (if unbroken one) drop floor x (with 1 <= x <= n)  goal know certainty value f is  minimum number moves need know certainty f is  regardless initial value f? hard math binary search dynamic programming 
java dp solution from o(kn^2) to o(knlogn) super egg drop given k eggs  access building n floors 1 n  egg identical function  egg breaks  cannot drop again  know exists floor f 0 <= f <= n egg dropped floor higher f break  egg dropped floor f break  move  may take egg (if unbroken one) drop floor x (with 1 <= x <= n)  goal know certainty value f is  minimum number moves need know certainty f is  regardless initial value f? hard math binary search dynamic programming 
easy to understand super egg drop given k eggs  access building n floors 1 n  egg identical function  egg breaks  cannot drop again  know exists floor f 0 <= f <= n egg dropped floor higher f break  egg dropped floor f break  move  may take egg (if unbroken one) drop floor x (with 1 <= x <= n)  goal know certainty value f is  minimum number moves need know certainty f is  regardless initial value f? hard math binary search dynamic programming 
leetcode weekly contest 97 screencast super egg drop given k eggs  access building n floors 1 n  egg identical function  egg breaks  cannot drop again  know exists floor f 0 <= f <= n egg dropped floor higher f break  egg dropped floor f break  move  may take egg (if unbroken one) drop floor x (with 1 <= x <= n)  goal know certainty value f is  minimum number moves need know certainty f is  regardless initial value f? hard math binary search dynamic programming 
[c++ java python] straight forward fair candy swap alice bob candy bars different sizes: a[i] size i-th bar candy alice has  b[j] size j-th bar candy bob has  since friends  would like exchange one candy bar exchange  total amount candy  (the total amount candy person sum sizes candy bars have ) return integer array ans ans[0] size candy bar alice must exchange  ans[1] size candy bar bob must exchange  multiple answers  may return one them  guaranteed answer exists  easy array 
java 2 solutions clear explanation with illustration fair candy swap alice bob candy bars different sizes: a[i] size i-th bar candy alice has  b[j] size j-th bar candy bob has  since friends  would like exchange one candy bar exchange  total amount candy  (the total amount candy person sum sizes candy bars have ) return integer array ans ans[0] size candy bar alice must exchange  ans[1] size candy bar bob must exchange  multiple answers  may return one them  guaranteed answer exists  easy array 
python simple and quick solution without loop fair candy swap alice bob candy bars different sizes: a[i] size i-th bar candy alice has  b[j] size j-th bar candy bob has  since friends  would like exchange one candy bar exchange  total amount candy  (the total amount candy person sum sizes candy bars have ) return integer array ans ans[0] size candy bar alice must exchange  ans[1] size candy bar bob must exchange  multiple answers  may return one them  guaranteed answer exists  easy array 
python solution using set (similar to twosum concept) fair candy swap alice bob candy bars different sizes: a[i] size i-th bar candy alice has  b[j] size j-th bar candy bob has  since friends  would like exchange one candy bar exchange  total amount candy  (the total amount candy person sum sizes candy bars have ) return integer array ans ans[0] size candy bar alice must exchange  ans[1] size candy bar bob must exchange  multiple answers  may return one them  guaranteed answer exists  easy array 
python simple solution fair candy swap alice bob candy bars different sizes: a[i] size i-th bar candy alice has  b[j] size j-th bar candy bob has  since friends  would like exchange one candy bar exchange  total amount candy  (the total amount candy person sum sizes candy bars have ) return integer array ans ans[0] size candy bar alice must exchange  ans[1] size candy bar bob must exchange  multiple answers  may return one them  guaranteed answer exists  easy array 
[c++ java python] one pass  real o(n) construct binary tree from preorder and postorder traversal return binary tree matches given preorder postorder traversals  values traversals pre post distinct positive integers  medium tree 
logical thinking with code beats 99 89% construct binary tree from preorder and postorder traversal return binary tree matches given preorder postorder traversals  values traversals pre post distinct positive integers  medium tree 
c++ o(n) recursive solution construct binary tree from preorder and postorder traversal return binary tree matches given preorder postorder traversals  values traversals pre post distinct positive integers  medium tree 
clean java o(n) construct binary tree from preorder and postorder traversal return binary tree matches given preorder postorder traversals  values traversals pre post distinct positive integers  medium tree 
easy python recursive solution with explanation construct binary tree from preorder and postorder traversal return binary tree matches given preorder postorder traversals  values traversals pre post distinct positive integers  medium tree 
[c++ java python] normalise word find and replace pattern list words pattern  want know words words matches pattern  word matches pattern exists permutation letters p replacing every letter x pattern p(x)  get desired word  (recall permutation letters bijection letters letters: every letter maps another letter  two letters map letter ) return list words words match given pattern  may return answer order  medium string 
short python isomorphism solution find and replace pattern list words pattern  want know words words matches pattern  word matches pattern exists permutation letters p replacing every letter x pattern p(x)  get desired word  (recall permutation letters bijection letters letters: every letter maps another letter  two letters map letter ) return list words words match given pattern  may return answer order  medium string 
java 3ms clear code find and replace pattern list words pattern  want know words words matches pattern  word matches pattern exists permutation letters p replacing every letter x pattern p(x)  get desired word  (recall permutation letters bijection letters letters: every letter maps another letter  two letters map letter ) return list words words match given pattern  may return answer order  medium string 
java two maps solution find and replace pattern list words pattern  want know words words matches pattern  word matches pattern exists permutation letters p replacing every letter x pattern p(x)  get desired word  (recall permutation letters bijection letters letters: every letter maps another letter  two letters map letter ) return list words words match given pattern  may return answer order  medium string 
python double-dictionary simplest logics beat 99% find and replace pattern list words pattern  want know words words matches pattern  word matches pattern exists permutation letters p replacing every letter x pattern p(x)  get desired word  (recall permutation letters bijection letters letters: every letter maps another letter  two letters map letter ) return list words words match given pattern  may return answer order  medium string 
[c++ java 1-line python] sort and one pass sum of subsequence widths given array integers a  consider non-empty subsequences a  sequence s  let width difference maximum minimum element s  return sum widths subsequences a  answer may large  return answer modulo 10^9 + 7  hard array math 
leetcode weekly contest 98 screencast sum of subsequence widths given array integers a  consider non-empty subsequences a  sequence s  let width difference maximum minimum element s  return sum widths subsequences a  answer may large  return answer modulo 10^9 + 7  hard array math 
c++ solution  o(n log n) sort + o(n) calculate sum of subsequence widths given array integers a  consider non-empty subsequences a  sequence s  let width difference maximum minimum element s  return sum widths subsequences a  answer may large  return answer modulo 10^9 + 7  hard array math 
pythonic o(nlogn) sorting sum of subsequence widths given array integers a  consider non-empty subsequences a  sequence s  let width difference maximum minimum element s  return sum widths subsequences a  answer may large  return answer modulo 10^9 + 7  hard array math 
o(nlogn) solution sum of subsequence widths given array integers a  consider non-empty subsequences a  sequence s  let width difference maximum minimum element s  return sum widths subsequences a  answer may large  return answer modulo 10^9 + 7  hard array math 
[c++ java 1-line python] minus hidden area surface area of 3d shapes n   n grid  place 1   1   1 cubes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  return total surface area resulting shapes  easy math geometry 
java simple solution surface area of 3d shapes n   n grid  place 1   1   1 cubes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  return total surface area resulting shapes  easy math geometry 
difficulty should be medium not easy surface area of 3d shapes n   n grid  place 1   1   1 cubes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  return total surface area resulting shapes  easy math geometry 
java solution surface area of 3d shapes n   n grid  place 1   1   1 cubes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  return total surface area resulting shapes  easy math geometry 
java solution with explanation surface area of 3d shapes n   n grid  place 1   1   1 cubes  value v = grid[i][j] represents tower v cubes placed top grid cell (i  j)  return total surface area resulting shapes  easy math geometry 
java concise set solution groups of special-equivalent strings given array strings  two strings special-equivalent number moves  == t  move consists choosing two indices j % 2 == j % 2  swapping s[i] s[j]  now  group special-equivalent strings non-empty subset string special-equivalent string s  return number groups special-equivalent strings a  easy string 
misleading description during the contest groups of special-equivalent strings given array strings  two strings special-equivalent number moves  == t  move consists choosing two indices j % 2 == j % 2  swapping s[i] s[j]  now  group special-equivalent strings non-empty subset string special-equivalent string s  return number groups special-equivalent strings a  easy string 
python 1-liner groups of special-equivalent strings given array strings  two strings special-equivalent number moves  == t  move consists choosing two indices j % 2 == j % 2  swapping s[i] s[j]  now  group special-equivalent strings non-empty subset string special-equivalent string s  return number groups special-equivalent strings a  easy string 
python extremely simple solution groups of special-equivalent strings given array strings  two strings special-equivalent number moves  == t  move consists choosing two indices j % 2 == j % 2  swapping s[i] s[j]  now  group special-equivalent strings non-empty subset string special-equivalent string s  return number groups special-equivalent strings a  easy string 
c++ simple solution groups of special-equivalent strings given array strings  two strings special-equivalent number moves  == t  move consists choosing two indices j % 2 == j % 2  swapping s[i] s[j]  now  group special-equivalent strings non-empty subset string special-equivalent string s  return number groups special-equivalent strings a  easy string 
[c++ java python] o(1) maximum frequency stack implement freqstack  class simulates operation stack-like data structure  freqstack two functions: push(int x)  pushes integer x onto stack  pop()  removes returns frequent element stack  tie frequent element  element closest top stack removed returned  hard hash table stack 
python simple priorityqueue maximum frequency stack implement freqstack  class simulates operation stack-like data structure  freqstack two functions: push(int x)  pushes integer x onto stack  pop()  removes returns frequent element stack  tie frequent element  element closest top stack removed returned  hard hash table stack 
java o(1) solution easy understand using bucket sort maximum frequency stack implement freqstack  class simulates operation stack-like data structure  freqstack two functions: push(int x)  pushes integer x onto stack  pop()  removes returns frequent element stack  tie frequent element  element closest top stack removed returned  hard hash table stack 
leetcode weekly contest 99 screencast maximum frequency stack implement freqstack  class simulates operation stack-like data structure  freqstack two functions: push(int x)  pushes integer x onto stack  pop()  removes returns frequent element stack  tie frequent element  element closest top stack removed returned  hard hash table stack 
java priority queue easy understand maximum frequency stack implement freqstack  class simulates operation stack-like data structure  freqstack two functions: push(int x)  pushes integer x onto stack  pop()  removes returns frequent element stack  tie frequent element  element closest top stack removed returned  hard hash table stack 
[c++ java python] one pass o(n) monotonic array array monotonic either monotone increasing monotone decreasing  array monotone increasing <= j  a[i] <= a[j]  array monotone decreasing <= j  a[i] >= a[j]  return true given array monotonic  easy array 
python solution  easy to understand monotonic array array monotonic either monotone increasing monotone decreasing  array monotone increasing <= j  a[i] <= a[j]  array monotone decreasing <= j  a[i] >= a[j]  return true given array monotonic  easy array 
java tricky solution monotonic array array monotonic either monotone increasing monotone decreasing  array monotone increasing <= j  a[i] <= a[j]  array monotone decreasing <= j  a[i] >= a[j]  return true given array monotonic  easy array 
1-liner c++ monotonic array array monotonic either monotone increasing monotone decreasing  array monotone increasing <= j  a[i] <= a[j]  array monotone decreasing <= j  a[i] >= a[j]  return true given array monotonic  easy array 
[java] 1 pass 7 lines straight forward code  monotonic array array monotonic either monotone increasing monotone decreasing  array monotone increasing <= j  a[i] <= a[j]  array monotone decreasing <= j  a[i] >= a[j]  return true given array monotonic  easy array 
[c++ java python] self-explained  5-line  o(n) increasing order search tree given tree  rearrange tree in-order leftmost node tree root tree  every node left child 1 right child  easy tree depth-first search 
can someone explain this test case? increasing order search tree given tree  rearrange tree in-order leftmost node tree root tree  every node left child 1 right child  easy tree depth-first search 
java simple inorder traversal- with explanation increasing order search tree given tree  rearrange tree in-order leftmost node tree root tree  every node left child 1 right child  easy tree depth-first search 
6-line python o(n) solution  increasing order search tree given tree  rearrange tree in-order leftmost node tree root tree  every node left child 1 right child  easy tree depth-first search 
inorder traversal increasing order search tree given tree  rearrange tree in-order leftmost node tree root tree  every node left child 1 right child  easy tree depth-first search 
[c++ java python] o(30n) bitwise ors of subarrays array non-negative integers  every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with <= j)  take bitwise elements b  obtaining result a[i] | a[i+1] |     | a[j]  return number possible results  (results occur counted final answer ) medium dynamic programming bit manipulation 
c++ o(kn) solution bitwise ors of subarrays array non-negative integers  every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with <= j)  take bitwise elements b  obtaining result a[i] | a[i+1] |     | a[j]  return number possible results  (results occur counted final answer ) medium dynamic programming bit manipulation 
[python] dynamic programming solution with indepth explanation of intuition  bitwise ors of subarrays array non-negative integers  every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with <= j)  take bitwise elements b  obtaining result a[i] | a[i+1] |     | a[j]  return number possible results  (results occur counted final answer ) medium dynamic programming bit manipulation 
c++ simplest  fastest ;) (224 ms) bitwise ors of subarrays array non-negative integers  every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with <= j)  take bitwise elements b  obtaining result a[i] | a[i+1] |     | a[j]  return number possible results  (results occur counted final answer ) medium dynamic programming bit manipulation 
the exactly same code can pass now  so sad bitwise ors of subarrays array non-negative integers  every (contiguous) subarray b = [a[i]  a[i+1]       a[j]] (with <= j)  take bitwise elements b  obtaining result a[i] | a[i+1] |     | a[j]  return number possible results  (results occur counted final answer ) medium dynamic programming bit manipulation 
[c++ java python] sort string or rotate string orderly queue string lowercase letters given  then  may make number moves  move  choose one first k letters (starting left)  remove it  place end string  return lexicographically smallest string could number moves  hard math string 
k>1 is bubblesort orderly queue string lowercase letters given  then  may make number moves  move  choose one first k letters (starting left)  remove it  place end string  return lexicographically smallest string could number moves  hard math string 
[c++] solution sort rotate orderly queue string lowercase letters given  then  may make number moves  move  choose one first k letters (starting left)  remove it  place end string  return lexicographically smallest string could number moves  hard math string 
when k > 1 you can reorder any way you like [proof] orderly queue string lowercase letters given  then  may make number moves  move  choose one first k letters (starting left)  remove it  place end string  return lexicographically smallest string could number moves  hard math string 
java simple solution  12 ms orderly queue string lowercase letters given  then  may make number moves  move  choose one first k letters (starting left)  remove it  place end string  return lexicographically smallest string could number moves  hard math string 
java straightforward solution  o(n) time  o(1) space rle iterator write iterator iterates run-length encoded sequence  iterator initialized rleiterator(int[] a)  run-length encoding sequence  specifically  even i  a[i] tells us number times non-negative integer value a[i+1] repeated sequence  iterator supports one function: next(int n)  exhausts next n elements (n >= 1) returns last element exhausted way  element left exhaust  next returns -1 instead  medium array 
[java] straightforward code with comment -- o(n) time and o(1) space rle iterator write iterator iterates run-length encoded sequence  iterator initialized rleiterator(int[] a)  run-length encoding sequence  specifically  even i  a[i] tells us number times non-negative integer value a[i+1] repeated sequence  iterator supports one function: next(int n)  exhausts next n elements (n >= 1) returns last element exhausted way  element left exhaust  next returns -1 instead  medium array 
python simple solution beats 95% python codes - o(n) rle iterator write iterator iterates run-length encoded sequence  iterator initialized rleiterator(int[] a)  run-length encoding sequence  specifically  even i  a[i] tells us number times non-negative integer value a[i+1] repeated sequence  iterator supports one function: next(int n)  exhausts next n elements (n >= 1) returns last element exhausted way  element left exhaust  next returns -1 instead  medium array 
c interface error  rleiterator  rleiteratorcreate(int  a)  missing length for c  rle iterator write iterator iterates run-length encoded sequence  iterator initialized rleiterator(int[] a)  run-length encoding sequence  specifically  even i  a[i] tells us number times non-negative integer value a[i+1] repeated sequence  iterator supports one function: next(int n)  exhausts next n elements (n >= 1) returns last element exhausted way  element left exhaust  next returns -1 instead  medium array 
python3 beats 100% rle iterator write iterator iterates run-length encoded sequence  iterator initialized rleiterator(int[] a)  run-length encoding sequence  specifically  even i  a[i] tells us number times non-negative integer value a[i+1] repeated sequence  iterator supports one function: next(int n)  exhausts next n elements (n >= 1) returns last element exhausted way  element left exhaust  next returns -1 instead  medium array 
[c++ java python] o(1) online stock span write class stockspanner collects daily price quotes stock  returns span stock's price current day  span stock's price today defined maximum number consecutive days (starting today going backwards) price stock less equal today's price  medium stack 
simple c++ solution with stack o(n)  with explanation online stock span write class stockspanner collects daily price quotes stock  returns span stock's price current day  span stock's price today defined maximum number consecutive days (starting today going backwards) price stock less equal today's price  medium stack 
short java solution online stock span write class stockspanner collects daily price quotes stock  returns span stock's price current day  span stock's price today defined maximum number consecutive days (starting today going backwards) price stock less equal today's price  medium stack 
java short solution using list with explanation online stock span write class stockspanner collects daily price quotes stock  returns span stock's price current day  span stock's price today defined maximum number consecutive days (starting today going backwards) price stock less equal today's price  medium stack 
simple python solution with comment online stock span write class stockspanner collects daily price quotes stock  returns span stock's price current day  span stock's price today defined maximum number consecutive days (starting today going backwards) price stock less equal today's price  medium stack 
python o(logn) numbers at most n given digit set sorted set digits d  non-empty subset {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note '0' included ) now  write numbers using digits  using digit many times want  hard math dynamic programming 
c++ o(logn) clear code with explanation numbers at most n given digit set sorted set digits d  non-empty subset {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note '0' included ) now  write numbers using digits  using digit many times want  hard math dynamic programming 
java solution with explanation numbers at most n given digit set sorted set digits d  non-empty subset {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note '0' included ) now  write numbers using digits  using digit many times want  hard math dynamic programming 
my straightforward self-explanatory python solution numbers at most n given digit set sorted set digits d  non-empty subset {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note '0' included ) now  write numbers using digits  using digit many times want  hard math dynamic programming 
simple c++ solution ( 0 ms  o(logn) )  with line by line explanation numbers at most n given digit set sorted set digits d  non-empty subset {'1' '2' '3' '4' '5' '6' '7' '8' '9'}  (note '0' included ) now  write numbers using digits  using digit many times want  hard math dynamic programming 
[c++ java python] dp solution o(n^2)  valid permutations for di sequence given s  length n string characters set {'d'  'i'}  (these letters stand "decreasing" "increasing" ) valid permutation permutation p[0]  p[1]       p[n] integers {0  1       n}  i: s[i] == 'd'  p[i] > p[i+1]  and; s[i] == 'i'  p[i] < p[i+1]  many valid permutations there? since answer may large  return answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
share my o(n^3) => o(n^2) c++ dp solution  including the thoughts of improvement  valid permutations for di sequence given s  length n string characters set {'d'  'i'}  (these letters stand "decreasing" "increasing" ) valid permutation permutation p[0]  p[1]       p[n] integers {0  1       n}  i: s[i] == 'd'  p[i] > p[i+1]  and; s[i] == 'i'  p[i] < p[i+1]  many valid permutations there? since answer may large  return answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
top-down with memo -> bottom-up dp -> n^3 dp -> n^2 dp -> o(n) space valid permutations for di sequence given s  length n string characters set {'d'  'i'}  (these letters stand "decreasing" "increasing" ) valid permutation permutation p[0]  p[1]       p[n] integers {0  1       n}  i: s[i] == 'd'  p[i] > p[i+1]  and; s[i] == 'i'  p[i] < p[i+1]  many valid permutations there? since answer may large  return answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
python o(n^3) o(n) space dp solution with explanation valid permutations for di sequence given s  length n string characters set {'d'  'i'}  (these letters stand "decreasing" "increasing" ) valid permutation permutation p[0]  p[1]       p[n] integers {0  1       n}  i: s[i] == 'd'  p[i] > p[i+1]  and; s[i] == 'i'  p[i] < p[i+1]  many valid permutations there? since answer may large  return answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
[visualization] key to the dp solution: imagine cutting a piece of paper and separating the halves valid permutations for di sequence given s  length n string characters set {'d'  'i'}  (these letters stand "decreasing" "increasing" ) valid permutation permutation p[0]  p[1]       p[n] integers {0  1       n}  i: s[i] == 'd'  p[i] > p[i+1]  and; s[i] == 'i'  p[i] < p[i+1]  many valid permutations there? since answer may large  return answer modulo 10^9 + 7  hard divide and conquer dynamic programming 
another poorly worded question fruit into baskets row trees  i-th tree produces fruit type tree[i]  start tree choice  repeatedly perform following steps: add one piece fruit tree baskets  cannot  stop  move next tree right current tree  tree right  stop  note choice initial choice starting tree: must perform step 1  step 2  back step 1  step 2  stop  two baskets  basket carry quantity fruit  want basket carry one type fruit each  total amount fruit collect procedure? medium two pointers 
problem: longest subarray with 2 elements fruit into baskets row trees  i-th tree produces fruit type tree[i]  start tree choice  repeatedly perform following steps: add one piece fruit tree baskets  cannot  stop  move next tree right current tree  tree right  stop  note choice initial choice starting tree: must perform step 1  step 2  back step 1  step 2  stop  two baskets  basket carry quantity fruit  want basket carry one type fruit each  total amount fruit collect procedure? medium two pointers 
sliding window fruit into baskets row trees  i-th tree produces fruit type tree[i]  start tree choice  repeatedly perform following steps: add one piece fruit tree baskets  cannot  stop  move next tree right current tree  tree right  stop  note choice initial choice starting tree: must perform step 1  step 2  back step 1  step 2  stop  two baskets  basket carry quantity fruit  want basket carry one type fruit each  total amount fruit collect procedure? medium two pointers 
what the fuck?what is meaning?i really cann't understand fruit into baskets row trees  i-th tree produces fruit type tree[i]  start tree choice  repeatedly perform following steps: add one piece fruit tree baskets  cannot  stop  move next tree right current tree  tree right  stop  note choice initial choice starting tree: must perform step 1  step 2  back step 1  step 2  stop  two baskets  basket carry quantity fruit  want basket carry one type fruit each  total amount fruit collect procedure? medium two pointers 
java - longest subarray with atmost 2 distinct elements fruit into baskets row trees  i-th tree produces fruit type tree[i]  start tree choice  repeatedly perform following steps: add one piece fruit tree baskets  cannot  stop  move next tree right current tree  tree right  stop  note choice initial choice starting tree: must perform step 1  step 2  back step 1  step 2  stop  two baskets  basket carry quantity fruit  want basket carry one type fruit each  total amount fruit collect procedure? medium two pointers 
[c++ java] in place swap sort array by parity given array non-negative integers  return array consisting even elements a  followed odd elements a  may return answer array satisfies condition  easy array 
very simple c++ python java o(n) soln (avoid in-place swapping as the input is passed as reference) sort array by parity given array non-negative integers  return array consisting even elements a  followed odd elements a  may return answer array satisfies condition  easy array 
my simple java solution sort array by parity given array non-negative integers  return array consisting even elements a  followed odd elements a  may return answer array satisfies condition  easy array 
python 2 pointer in place swap  beats 99% sort array by parity given array non-negative integers  return array consisting even elements a  followed odd elements a  may return answer array satisfies condition  easy array 
one line javascript   sort array by parity given array non-negative integers  return array consisting even elements a  followed odd elements a  may return answer array satisfies condition  easy array 
java building the next palindrome super palindromes let's say positive integer superpalindrome palindrome  also square palindrome  now  given two positive integers l r (represented strings)  return number superpalindromes inclusive range [l  r]  hard math 
no more this type questions for contest! super palindromes let's say positive integer superpalindrome palindrome  also square palindrome  now  given two positive integers l r (represented strings)  return number superpalindromes inclusive range [l  r]  hard math 
python super easy to understand  10^5 complexity  no cheating super palindromes let's say positive integer superpalindrome palindrome  also square palindrome  now  given two positive integers l r (represented strings)  return number superpalindromes inclusive range [l  r]  hard math 
python ac  bfs  detail explanation super palindromes let's say positive integer superpalindrome palindrome  also square palindrome  now  given two positive integers l r (represented strings)  return number superpalindromes inclusive range [l  r]  hard math 
[c++] straightforward backtracking solution super palindromes let's say positive integer superpalindrome palindrome  also square palindrome  now  given two positive integers l r (represented strings)  return number superpalindromes inclusive range [l  r]  hard math 
[c++ java python] stack solution sum of subarray minimums given array integers a  find sum min(b)  b ranges every (contiguous) subarray a  since answer may large  return answer modulo 10^9 + 7  medium array stack 
stack solution with very  detailed explanation step by step sum of subarray minimums given array integers a  find sum min(b)  b ranges every (contiguous) subarray a  since answer may large  return answer modulo 10^9 + 7  medium array stack 
python simple stack o(n) solution - 10 lines  sum of subarray minimums given array integers a  find sum min(b)  b ranges every (contiguous) subarray a  since answer may large  return answer modulo 10^9 + 7  medium array stack 
java o(n) building preprocessed scope array with explanation sum of subarray minimums given array integers a  find sum min(b)  b ranges every (contiguous) subarray a  since answer may large  return answer modulo 10^9 + 7  medium array stack 
one stack solution sum of subarray minimums given array integers a  find sum min(b)  b ranges every (contiguous) subarray a  since answer may large  return answer modulo 10^9 + 7  medium array stack 
very confusing question! smallest range i given array integers  integer a[i] may choose x -k <= x <= k  add x a[i]  process  array b  return smallest possible difference maximum value b minimum value b  easy 
[c++ java python] check max - min smallest range i given array integers  integer a[i] may choose x -k <= x <= k  add x a[i]  process  array b  return smallest possible difference maximum value b minimum value b  easy 
 [java] simple single pass solution smallest range i given array integers  integer a[i] may choose x -k <= x <= k  add x a[i]  process  array b  return smallest possible difference maximum value b minimum value b  easy 
c++ 1-liner smallest range i given array integers  integer a[i] may choose x -k <= x <= k  add x a[i]  process  array b  return smallest possible difference maximum value b minimum value b  easy 
java easy to understand solution smallest range i given array integers  integer a[i] may choose x -k <= x <= k  add x a[i]  process  array b  return smallest possible difference maximum value b minimum value b  easy 
diagram and bfs snakes and ladders n x n board  numbers 1 n n written boustrophedonically starting bottom left board  alternating direction row  medium 
change to 1d array then bfs snakes and ladders n x n board  numbers 1 n n written boustrophedonically starting bottom left board  alternating direction row  medium 
java concise solution easy to understand snakes and ladders n x n board  numbers 1 n n written boustrophedonically starting bottom left board  alternating direction row  medium 
dude    it is literally 1-6 steps  not an example of 1-n steps when n = 6 snakes and ladders n x n board  numbers 1 n n written boustrophedonically starting bottom left board  alternating direction row  medium 
how does this input gives 2? snakes and ladders n x n board  numbers 1 n n written boustrophedonically starting bottom left board  alternating direction row  medium 
[c++ java python] add 0 or 2   k smallest range ii given array integers  integer a[i] need choose either x = -k x = k  add x a[i] (only once)  process  array b  return smallest possible difference maximum value b minimum value b  medium 
simple c++ solution with explanation smallest range ii given array integers  integer a[i] need choose either x = -k x = k  add x a[i] (only once)  process  array b  return smallest possible difference maximum value b minimum value b  medium 
c++  o(n) time solution! take the challenge! with very  very  detail description and comments smallest range ii given array integers  integer a[i] need choose either x = -k x = k  add x a[i] (only once)  process  array b  return smallest possible difference maximum value b minimum value b  medium 
java solution with the picture to explain it smallest range ii given array integers  integer a[i] need choose either x = -k x = k  add x a[i] (only once)  process  array b  return smallest possible difference maximum value b minimum value b  medium 
java solution very easy to understand - [sliding window] smallest range ii given array integers  integer a[i] need choose either x = -k x = k  add x a[i] (only once)  process  array b  return smallest possible difference maximum value b minimum value b  medium 
[c++ java python] binary search in times online election election  i-th vote cast persons[i] time times[i]  now  would like implement following query function: topvotedcandidate q(int t) return number person leading election time t  votes cast time count towards query  case tie  recent vote (among tied candidates) wins  medium 
anyone else just find this question really confusing? online election election  i-th vote cast persons[i] time times[i]  now  would like implement following query function: topvotedcandidate q(int t) return number person leading election time t  votes cast time count towards query  case tie  recent vote (among tied candidates) wins  medium 
[java] two methods with comment- using treemap and binary search  respectively online election election  i-th vote cast persons[i] time times[i]  now  would like implement following query function: topvotedcandidate q(int t) return number person leading election time t  votes cast time count towards query  case tie  recent vote (among tied candidates) wins  medium 
python readable short bisect solution online election election  i-th vote cast persons[i] time times[i]  now  would like implement following query function: topvotedcandidate q(int t) return number person leading election time t  votes cast time count towards query  case tie  recent vote (among tied candidates) wins  medium 
[java] treemap: o(nlogn) + o(logn)  and binary search: o(n) + o(logn) online election election  i-th vote cast persons[i] time times[i]  now  would like implement following query function: topvotedcandidate q(int t) return number person leading election time t  votes cast time count towards query  case tie  recent vote (among tied candidates) wins  medium 
most of the dfs solutions are wrong  check this case cat and mouse game undirected graph played two players  mouse cat  alternate turns  graph given follows: graph[a] list nodes b ab edge graph  mouse starts node 1 goes first  cat starts node 2 goes second  hole node 0  player's turn  must travel along one edge graph meets are  hard breadth-first search minimax 
perfect wrong dfs dp code explained in detail (revised) cat and mouse game undirected graph played two players  mouse cat  alternate turns  graph given follows: graph[a] list nodes b ab edge graph  mouse starts node 1 goes first  cat starts node 2 goes second  hole node 0  player's turn  must travel along one edge graph meets are  hard breadth-first search minimax 
5ms java solution with brief comment  cat and mouse game undirected graph played two players  mouse cat  alternate turns  graph given follows: graph[a] list nodes b ab edge graph  mouse starts node 1 goes first  cat starts node 2 goes second  hole node 0  player's turn  must travel along one edge graph meets are  hard breadth-first search minimax 
so confusing the last case  can't believe it! cat and mouse game undirected graph played two players  mouse cat  alternate turns  graph given follows: graph[a] list nodes b ab edge graph  mouse starts node 1 goes first  cat starts node 2 goes second  hole node 0  player's turn  must travel along one edge graph meets are  hard breadth-first search minimax 
share my thoughts and code so confused by the last case cat and mouse game undirected graph played two players  mouse cat  alternate turns  graph given follows: graph[a] list nodes b ab edge graph  mouse starts node 1 goes first  cat starts node 2 goes second  hole node 0  player's turn  must travel along one edge graph meets are  hard breadth-first search minimax 
[c++ java python] greatest common divisor x of a kind in a deck of cards deck cards  card integer written it  return true choose x >= 2 possible split entire deck 1 groups cards  where: group exactly x cards  cards group integer  easy array math 
c++ solutions using binary method for gcd and the power of stl  3 lines if you use __gcd x of a kind in a deck of cards deck cards  card integer written it  return true choose x >= 2 possible split entire deck 1 groups cards  where: group exactly x cards  cards group integer  easy array math 
need updated cases - bad code passed [9 29 2018] x of a kind in a deck of cards deck cards  card integer written it  return true choose x >= 2 possible split entire deck 1 groups cards  where: group exactly x cards  cards group integer  easy array math 
map plus gcd solution x of a kind in a deck of cards deck cards  card integer written it  return true choose x >= 2 possible split entire deck 1 groups cards  where: group exactly x cards  cards group integer  easy array math 
java gcd x of a kind in a deck of cards deck cards  card integer written it  return true choose x >= 2 possible split entire deck 1 groups cards  where: group exactly x cards  cards group integer  easy array math 
java  one pass  7 lines partition array into disjoint intervals given array a  partition two (contiguous) subarrays left right that: every element left less equal every element right  left right non-empty  left smallest possible size  return length left partitioning  guaranteed partitioning exists  medium array 
[c++ java python] straight forward partition array into disjoint intervals given array a  partition two (contiguous) subarrays left right that: every element left less equal every element right  left right non-empty  left smallest possible size  return length left partitioning  guaranteed partitioning exists  medium array 
explained - python simple o(n) time o(1) space partition array into disjoint intervals given array a  partition two (contiguous) subarrays left right that: every element left less equal every element right  left right non-empty  left smallest possible size  return length left partitioning  guaranteed partitioning exists  medium array 
java easiest simplest partition array into disjoint intervals given array a  partition two (contiguous) subarrays left right that: every element left less equal every element right  left right non-empty  left smallest possible size  return length left partitioning  guaranteed partitioning exists  medium array 
o(n) one pass solution partition array into disjoint intervals given array a  partition two (contiguous) subarrays left right that: every element left less equal every element right  left right non-empty  left smallest possible size  return length left partitioning  guaranteed partitioning exists  medium array 
[c++ java python] straight forward word subsets given two arrays b words  word string lowercase letters  now  say word b subset word every letter b occurs a  including multiplicity  medium string 
[java] 14 line clean code - count the most frequent char of words in b word subsets given two arrays b words  word string lowercase letters  now  say word b subset word every letter b occurs a  including multiplicity  medium string 
[16ms] fastest solution - prime number subset step in o(1) (detailed explanation) word subsets given two arrays b words  word string lowercase letters  now  say word b subset word every letter b occurs a  including multiplicity  medium string 
my python solution  beats 98 4%  word subsets given two arrays b words  word string lowercase letters  now  say word b subset word every letter b occurs a  including multiplicity  medium string 
cpp easy understand solution o(max(na nb) strlen) word subsets given two arrays b words  word string lowercase letters  now  say word b subset word every letter b occurs a  including multiplicity  medium string 
[c++ java python] two pointers reverse only letters given string s  return "reversed" string characters letter stay place  letters reverse positions  easy 
[java] 5 line clean code - very simple logic reverse only letters given string s  return "reversed" string characters letter stay place  letters reverse positions  easy 
java two pointers reverse only letters given string s  return "reversed" string characters letter stay place  letters reverse positions  easy 
my 2-liner python stack solution  reverse only letters given string s  return "reversed" string characters letter stay place  letters reverse positions  easy 
java 6ms simple solution reverse only letters given string s  return "reversed" string characters letter stay place  letters reverse positions  easy 
[c++ java python] one pass maximum sum circular subarray given circular array c integers represented a  find maximum possible sum non-empty subarray c  here  circular array means end array connects beginning array  (formally  c[i] = a[i] 0 <= < a length  c[i+a length] = c[i] >= 0 ) also  subarray may include element fixed buffer once  (formally  subarray c[i]  c[i+1]       c[j]  exist <= k1  k2 <= j k1 % a length = k2 % a length ) medium 
c++ single pass o(n) linear time o(1) constant space maximum sum circular subarray given circular array c integers represented a  find maximum possible sum non-empty subarray c  here  circular array means end array connects beginning array  (formally  c[i] = a[i] 0 <= < a length  c[i+a length] = c[i] >= 0 ) also  subarray may include element fixed buffer once  (formally  subarray c[i]  c[i+1]       c[j]  exist <= k1  k2 <= j k1 % a length = k2 % a length ) medium 
c++ o(n) solution maximum sum circular subarray given circular array c integers represented a  find maximum possible sum non-empty subarray c  here  circular array means end array connects beginning array  (formally  c[i] = a[i] 0 <= < a length  c[i+a length] = c[i] >= 0 ) also  subarray may include element fixed buffer once  (formally  subarray c[i]  c[i+1]       c[j]  exist <= k1  k2 <= j k1 % a length = k2 % a length ) medium 
java one pass  o(n) with very detailed chinese explanation maximum sum circular subarray given circular array c integers represented a  find maximum possible sum non-empty subarray c  here  circular array means end array connects beginning array  (formally  c[i] = a[i] 0 <= < a length  c[i+a length] = c[i] >= 0 ) also  subarray may include element fixed buffer once  (formally  subarray c[i]  c[i+1]       c[j]  exist <= k1  k2 <= j k1 % a length = k2 % a length ) medium 
short java solution!!! maximum sum circular subarray given circular array c integers represented a  find maximum possible sum non-empty subarray c  here  circular array means end array connects beginning array  (formally  c[i] = a[i] 0 <= < a length  c[i+a length] = c[i] >= 0 ) also  subarray may include element fixed buffer once  (formally  subarray c[i]  c[i+1]       c[j]  exist <= k1  k2 <= j k1 % a length = k2 % a length ) medium 
[c++ java python] o(1) insert complete binary tree inserter complete binary tree binary tree every level  except possibly last  completely filled  nodes far left possible  write data structure cbtinserter initialized complete binary tree supports following operations: cbtinserter(treenode root) initializes data structure given tree head node root; cbtinserter insert(int v) insert treenode tree value node val = v tree remains complete  returns value parent inserted treenode; cbtinserter get_root() return head node tree  medium 
[java] bfs straightforward code  two methods  initialization and insert time o(1)  respectively  complete binary tree inserter complete binary tree binary tree every level  except possibly last  completely filled  nodes far left possible  write data structure cbtinserter initialized complete binary tree supports following operations: cbtinserter(treenode root) initializes data structure given tree head node root; cbtinserter insert(int v) insert treenode tree value node val = v tree remains complete  returns value parent inserted treenode; cbtinserter get_root() return head node tree  medium 
javascript always get a runtime error even do nothing changes to template complete binary tree inserter complete binary tree binary tree every level  except possibly last  completely filled  nodes far left possible  write data structure cbtinserter initialized complete binary tree supports following operations: cbtinserter(treenode root) initializes data structure given tree head node root; cbtinserter insert(int v) insert treenode tree value node val = v tree remains complete  returns value parent inserted treenode; cbtinserter get_root() return head node tree  medium 
java solution: o(1) insert vs  o(1) pre-process trade off complete binary tree inserter complete binary tree binary tree every level  except possibly last  completely filled  nodes far left possible  write data structure cbtinserter initialized complete binary tree supports following operations: cbtinserter(treenode root) initializes data structure given tree head node root; cbtinserter insert(int v) insert treenode tree value node val = v tree remains complete  returns value parent inserted treenode; cbtinserter get_root() return head node tree  medium 
c++ 12 ms using queue complete binary tree inserter complete binary tree binary tree every level  except possibly last  completely filled  nodes far left possible  write data structure cbtinserter initialized complete binary tree supports following operations: cbtinserter(treenode root) initializes data structure given tree head node root; cbtinserter insert(int v) insert treenode tree value node val = v tree remains complete  returns value parent inserted treenode; cbtinserter get_root() return head node tree  medium 
[c++ java python] dp solution number of music playlists music player contains n different songs wants listen l (not necessarily different) songs trip  create playlist that: every song played least song played k songs played return number possible playlists  answer large  return modulo 10^9 + 7  hard 
dp solution that is easy to understand number of music playlists music player contains n different songs wants listen l (not necessarily different) songs trip  create playlist that: every song played least song played k songs played return number possible playlists  answer large  return modulo 10^9 + 7  hard 
[c++] straight forward dp  with explanation number of music playlists music player contains n different songs wants listen l (not necessarily different) songs trip  create playlist that: every song played least song played k songs played return number possible playlists  answer large  return modulo 10^9 + 7  hard 
[python3] a math solution o((n - k)   log(l - k)) number of music playlists music player contains n different songs wants listen l (not necessarily different) songs trip  create playlist that: every song played least song played k songs played return number possible playlists  answer large  return modulo 10^9 + 7  hard 
java dp solution (i think the description of the problem could be clearer) number of music playlists music player contains n different songs wants listen l (not necessarily different) songs trip  create playlist that: every song played least song played k songs played return number possible playlists  answer large  return modulo 10^9 + 7  hard 
[java] two one pass 7 liners - space o(n) and o(1)  respectively minimum add to make parentheses valid given string '(' ')' parentheses  add minimum number parentheses ( '(' ')'  positions ) resulting parentheses string valid  formally  parentheses string valid if: empty string  written ab (a concatenated b)  b valid strings  written (a)  valid string  given parentheses string  return minimum number parentheses must add make resulting string valid  medium 
[c++ java python] straight forward one pass minimum add to make parentheses valid given string '(' ')' parentheses  add minimum number parentheses ( '(' ')'  positions ) resulting parentheses string valid  formally  parentheses string valid if: empty string  written ab (a concatenated b)  b valid strings  written (a)  valid string  given parentheses string  return minimum number parentheses must add make resulting string valid  medium 
python classic valid paranthesis solution minimum add to make parentheses valid given string '(' ')' parentheses  add minimum number parentheses ( '(' ')'  positions ) resulting parentheses string valid  formally  parentheses string valid if: empty string  written ab (a concatenated b)  b valid strings  written (a)  valid string  given parentheses string  return minimum number parentheses must add make resulting string valid  medium 
[java] easy to understand stack solution (8ms)  minimum add to make parentheses valid given string '(' ')' parentheses  add minimum number parentheses ( '(' ')'  positions ) resulting parentheses string valid  formally  parentheses string valid if: empty string  written ab (a concatenated b)  b valid strings  written (a)  valid string  given parentheses string  return minimum number parentheses must add make resulting string valid  medium 
python 3-line mathematically optimal solution with explanation  one-pass o(n) time o(1) space minimum add to make parentheses valid given string '(' ')' parentheses  add minimum number parentheses ( '(' ')'  positions ) resulting parentheses string valid  formally  parentheses string valid if: empty string  written ab (a concatenated b)  b valid strings  written (a)  valid string  given parentheses string  return minimum number parentheses must add make resulting string valid  medium 
java two pointer one pass inplace sort array by parity ii given array non-negative integers  half integers odd  half integers even  sort array whenever a[i] odd  odd; whenever a[i] even  even  may return answer array satisfies condition  easy 
python easy 2-liner sort array by parity ii given array non-negative integers  half integers odd  half integers even  sort array whenever a[i] odd  odd; whenever a[i] even  even  may return answer array satisfies condition  easy 
c++ 5 lines  two pointers + 2-liner bonus sort array by parity ii given array non-negative integers  half integers odd  half integers even  sort array whenever a[i] odd  odd; whenever a[i] even  even  may return answer array satisfies condition  easy 
[java] two pointers inplace o(n) time simple & straightforward sort array by parity ii given array non-negative integers  half integers odd  half integers even  sort array whenever a[i] odd  odd; whenever a[i] even  even  may return answer array satisfies condition  easy 
[java] simple code - swap odd and even indices elements  sort array by parity ii given array non-negative integers  half integers odd  half integers even  sort array whenever a[i] odd  odd; whenever a[i] even  even  may return answer array satisfies condition  easy 
[c++ java python] o(101^2) 3sum with multiplicity given integer array a  integer target  return number tuples i  j  k < j < k a[i] + a[j] + a[k] == target  answer large  return modulo 10^9 + 7  medium 
10 lines super super easy java solution 3sum with multiplicity given integer array a  integer target  return number tuples i  j  k < j < k a[i] + a[j] + a[k] == target  answer large  return modulo 10^9 + 7  medium 
knapsack o(n   target) or straightforward o(n^2) 3sum with multiplicity given integer array a  integer target  return number tuples i  j  k < j < k a[i] + a[j] + a[k] == target  answer large  return modulo 10^9 + 7  medium 
[java] o(n^2) code - sort and match  3sum with multiplicity given integer array a  integer target  return number tuples i  j  k < j < k a[i] + a[j] + a[k] == target  answer large  return modulo 10^9 + 7  medium 
dp  python 3sum with multiplicity given integer array a  integer target  return number tuples i  j  k < j < k a[i] + a[j] + a[k] == target  answer large  return modulo 10^9 + 7  medium 
[python] union found minimize malware spread network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  note node removed initial list infected nodes  may still infected later result malware spread  hard 
python short dfs solution minimize malware spread network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  note node removed initial list infected nodes  may still infected later result malware spread  hard 
how to explain this test case? minimize malware spread network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  note node removed initial list infected nodes  may still infected later result malware spread  hard 
brute force or union find minimize malware spread network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  note node removed initial list infected nodes  may still infected later result malware spread  hard 
c++ union find with explanation minimize malware spread network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  note node removed initial list infected nodes  may still infected later result malware spread  hard 
[c++ java python] two pointers long pressed name friend typing name keyboard  sometimes  typing character c  key might get long pressed  character typed 1 times  examine typed characters keyboard  return true possible friends name  characters (possibly none) long pressed  easy 
java one pass solution 4ms with o(1) extra space long pressed name friend typing name keyboard  sometimes  typing character c  key might get long pressed  character typed 1 times  examine typed characters keyboard  return true possible friends name  characters (possibly none) long pressed  easy 
c++ 2 lines accepted and 5 lines accurate long pressed name friend typing name keyboard  sometimes  typing character c  key might get long pressed  character typed 1 times  examine typed characters keyboard  return true possible friends name  characters (possibly none) long pressed  easy 
java simple solution -3 ms long pressed name friend typing name keyboard  sometimes  typing character c  key might get long pressed  character typed 1 times  examine typed characters keyboard  return true possible friends name  characters (possibly none) long pressed  easy 
short java solution long pressed name friend typing name keyboard  sometimes  typing character c  key might get long pressed  character typed 1 times  examine typed characters keyboard  return true possible friends name  characters (possibly none) long pressed  easy 
prefix-suffix java o(n) one pass solution - space o(1) flip string to monotone increasing string '0's '1's monotone increasing consists number '0's (possibly 0)  followed number '1's (also possibly 0 ) given string '0's '1's  may flip '0' '1' '1' '0'  return minimum number flips make monotone increasing  medium 
c++ java 4 lines o(n) | o(1)  dp flip string to monotone increasing string '0's '1's monotone increasing consists number '0's (possibly 0)  followed number '1's (also possibly 0 ) given string '0's '1's  may flip '0' '1' '1' '0'  return minimum number flips make monotone increasing  medium 
java dp solution o(n) time o(1) space flip string to monotone increasing string '0's '1's monotone increasing consists number '0's (possibly 0)  followed number '1's (also possibly 0 ) given string '0's '1's  may flip '0' '1' '1' '0'  return minimum number flips make monotone increasing  medium 
python o(n) time o(1) space solution with explanation(with extra chinese explanation) flip string to monotone increasing string '0's '1's monotone increasing consists number '0's (possibly 0)  followed number '1's (also possibly 0 ) given string '0's '1's  may flip '0' '1' '1' '0'  return minimum number flips make monotone increasing  medium 
c++ one-pass dp solution  0ms o(n) | o(1)  one line  with explaination  flip string to monotone increasing string '0's '1's monotone increasing consists number '0's (possibly 0)  followed number '1's (also possibly 0 ) given string '0's '1's  may flip '0' '1' '1' '0'  return minimum number flips make monotone increasing  medium 
[c++] o(n) time  o(1) space  12 ms with explanation & comments three equal parts given array 0s 1s  divide array 3 non-empty parts parts represent binary value  possible  return [i  j] i+1 < j  that: a[0]  a[1]       a[i] first part; a[i+1]  a[i+2]       a[j-1] second part  a[j]  a[j+1]       a[a length - 1] third part  three parts equal binary value  possible  return [-1  -1]  note entire part used considering binary value represents  hard math 
java o(n) solution three equal parts given array 0s 1s  divide array 3 non-empty parts parts represent binary value  possible  return [i  j] i+1 < j  that: a[0]  a[1]       a[i] first part; a[i+1]  a[i+2]       a[j-1] second part  a[j]  a[j+1]       a[a length - 1] third part  three parts equal binary value  possible  return [-1  -1]  note entire part used considering binary value represents  hard math 
[c++] o(n) time o(n) space  40ms  14 lines  2 loops  easy understand with explanation three equal parts given array 0s 1s  divide array 3 non-empty parts parts represent binary value  possible  return [i  j] i+1 < j  that: a[0]  a[1]       a[i] first part; a[i+1]  a[i+2]       a[j-1] second part  a[j]  a[j+1]       a[a length - 1] third part  three parts equal binary value  possible  return [-1  -1]  note entire part used considering binary value represents  hard math 
java 50ms with my thinking process three equal parts given array 0s 1s  divide array 3 non-empty parts parts represent binary value  possible  return [i  j] i+1 < j  that: a[0]  a[1]       a[i] first part; a[i+1]  a[i+2]       a[j-1] second part  a[j]  a[j+1]       a[a length - 1] third part  three parts equal binary value  possible  return [-1  -1]  note entire part used considering binary value represents  hard math 
java 10ms solution with o(n) time and o(1)space three equal parts given array 0s 1s  divide array 3 non-empty parts parts represent binary value  possible  return [i  j] i+1 < j  that: a[0]  a[1]       a[i] first part; a[i+1]  a[i+2]       a[j-1] second part  a[j]  a[j+1]       a[a length - 1] third part  three parts equal binary value  possible  return [-1  -1]  note entire part used considering binary value represents  hard math 
python solution with my thinking process (with extra chinese explanation) minimize malware spread ii (this problem minimize malware spread  differences bolded ) network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  completely removing connections node node  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  hard depth-first search union find graph 
分享一个详细中文c++讲解 minimize malware spread ii (this problem minimize malware spread  differences bolded ) network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  completely removing connections node node  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  hard depth-first search union find graph 
short python dfs solution w  short explanation ~290 ms minimize malware spread ii (this problem minimize malware spread  differences bolded ) network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  completely removing connections node node  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  hard depth-first search union find graph 
java (42ms) using union find set and brute force with explaination minimize malware spread ii (this problem minimize malware spread  differences bolded ) network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  completely removing connections node node  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  hard depth-first search union find graph 
java bfs without copy graph minimize malware spread ii (this problem minimize malware spread  differences bolded ) network nodes  node directly connected another node j graph[i][j] = 1  nodes initial initially infected malware  whenever two nodes directly connected least one two nodes infected malware  nodes infected malware  spread malware continue nodes infected manner  suppose m(initial) final number nodes infected malware entire network  spread malware stops  remove one node initial list  completely removing connections node node  return node removed  would minimize m(initial)  multiple nodes could removed minimize m(initial)  return node smallest index  hard depth-first search union find graph 
[java] 7 liner with comment  unique email addresses every email consists local name domain name  separated @ sign  easy string 
python solution unique email addresses every email consists local name domain name  separated @ sign  easy string 
concise c++ unique email addresses every email consists local name domain name  separated @ sign  easy string 
[java] clean o(n maxstringlen) with and without split() unique email addresses every email consists local name domain name  separated @ sign  easy string 
python solution beat 91% unique email addresses every email consists local name domain name  separated @ sign  easy string 
[c++ java python] straight forward binary subarrays with sum array 0s 1s  many non-empty subarrays sum s? medium hash table two pointers 
[java] clean solution 2 sum + prefix sum caching binary subarrays with sum array 0s 1s  many non-empty subarrays sum s? medium hash table two pointers 
java o(n) time o(n) space  counting contiguous zeros binary subarrays with sum array 0s 1s  many non-empty subarrays sum s? medium hash table two pointers 
3 ways to solve this kind of problem  binary subarrays with sum array 0s 1s  many non-empty subarrays sum s? medium hash table two pointers 
python easy & short binary subarrays with sum array 0s 1s  many non-empty subarrays sum s? medium hash table two pointers 
java dp solution  with graph illustrated explanations minimum falling path sum given square array integers a  want minimum sum falling path a  falling path starts element first row  chooses one element row  next row's choice must column different previous row's column one  medium dynamic programming 
c++ java 4 lines dp minimum falling path sum given square array integers a  want minimum sum falling path a  falling path starts element first row  chooses one element row  next row's choice must column different previous row's column one  medium dynamic programming 
[java] two clean dp codes - input modified and not  time o(n ^ 2)  space o(1) & o(n) minimum falling path sum given square array integers a  want minimum sum falling path a  falling path starts element first row  chooses one element row  next row's choice must column different previous row's column one  medium dynamic programming 
c 4ms dp solution with explanation minimum falling path sum given square array integers a  want minimum sum falling path a  falling path starts element first row  chooses one element row  next row's choice must column different previous row's column one  medium dynamic programming 
golang dp solution minimum falling path sum given square array integers a  want minimum sum falling path a  falling path starts element first row  chooses one element row  next row's choice must column different previous row's column one  medium dynamic programming 
[c++ java python] odd + even pattern  o(n) beautiful array fixed n  array beautiful permutation integers 1  2       n  that: every < j  k < k < j a[k]   2 = a[i] + a[j]  given n  return beautiful array a  (it guaranteed one exists ) medium divide and conquer 
leetcode weekly contest 108 screencast (only record 10 mins) beautiful array fixed n  array beautiful permutation integers 1  2       n  that: every < j  k < k < j a[k]   2 = a[i] + a[j]  given n  return beautiful array a  (it guaranteed one exists ) medium divide and conquer 
python 1-line solutions beautiful array fixed n  array beautiful permutation integers 1  2       n  that: every < j  k < k < j a[k]   2 = a[i] + a[j]  given n  return beautiful array a  (it guaranteed one exists ) medium divide and conquer 
[3 solutions] 4 lines in python (divide & conquer) + dp (top-down and bottom-up) beautiful array fixed n  array beautiful permutation integers 1  2       n  that: every < j  k < k < j a[k]   2 = a[i] + a[j]  given n  return beautiful array a  (it guaranteed one exists ) medium divide and conquer 
[javascript] how i understand the solution (with verification of the solution) beautiful array fixed n  array beautiful permutation integers 1  2       n  that: every < j  k < k < j a[k]   2 = a[i] + a[j]  given n  return beautiful array a  (it guaranteed one exists ) medium divide and conquer 
[java] three solutions: treemap   treeset  arraylist; all time o(logn)  number of recent calls write class recentcounter count recent requests  one method: ping(int t)  represents time milliseconds  return number pings made 3000 milliseconds ago now  ping time [t - 3000  t] count  including current ping  guaranteed every call ping uses strictly larger value before  easy queue 
c++ easy and clean solution using queue number of recent calls write class recentcounter count recent requests  one method: ping(int t)  represents time milliseconds  return number pings made 3000 milliseconds ago now  ping time [t - 3000  t] count  including current ping  guaranteed every call ping uses strictly larger value before  easy queue 
python straightforward solution number of recent calls write class recentcounter count recent requests  one method: ping(int t)  represents time milliseconds  return number pings made 3000 milliseconds ago now  ping time [t - 3000  t] count  including current ping  guaranteed every call ping uses strictly larger value before  easy queue 
simple javascript solution (3 lines) number of recent calls write class recentcounter count recent requests  one method: ping(int t)  represents time milliseconds  return number pings made 3000 milliseconds ago now  ping time [t - 3000  t] count  including current ping  guaranteed every call ping uses strictly larger value before  easy queue 
[java] array + binary search  111 ms  o(log(3000)) time  o(logn) space number of recent calls write class recentcounter count recent requests  one method: ping(int t)  represents time milliseconds  return number pings made 3000 milliseconds ago now  ping time [t - 3000  t] count  including current ping  guaranteed every call ping uses strictly larger value before  easy queue 
c++ bfs island expansion + uf bonus shortest bridge given 2d binary array a  two islands  (an island 4-directionally connected group 1s connected 1s ) now  may change 0s 1s connect two islands together form 1 island  return smallest number 0s must flipped  (it guaranteed answer least 1 ) medium depth-first search breadth-first search 
python concise dfs & bfs in 1 solution shortest bridge given 2d binary array a  two islands  (an island 4-directionally connected group 1s connected 1s ) now  may change 0s 1s connect two islands together form 1 island  return smallest number 0s must flipped  (it guaranteed answer least 1 ) medium depth-first search breadth-first search 
java dfs find the island -> bfs expand the island shortest bridge given 2d binary array a  two islands  (an island 4-directionally connected group 1s connected 1s ) now  may change 0s 1s connect two islands together form 1 island  return smallest number 0s must flipped  (it guaranteed answer least 1 ) medium depth-first search breadth-first search 
java dfs+bfs  traverse the 2d array once shortest bridge given 2d binary array a  two islands  (an island 4-directionally connected group 1s connected 1s ) now  may change 0s 1s connect two islands together form 1 island  return smallest number 0s must flipped  (it guaranteed answer least 1 ) medium depth-first search breadth-first search 
java extremely easy to understand with comment (bfs to find answer and dfs to paint the matrix) shortest bridge given 2d binary array a  two islands  (an island 4-directionally connected group 1s connected 1s ) now  may change 0s 1s connect two islands together form 1 island  return smallest number 0s must flipped  (it guaranteed answer least 1 ) medium depth-first search breadth-first search 
o(logn) knight dialer chess knight move indicated chess diagram below:   time  place chess knight numbered key phone pad (indicated above)  knight makes n-1 hops  hop must one key another numbered key  time lands key (including initial placement knight)  presses number key  pressing n digits total  many distinct numbers dial manner? since answer may large  output answer modulo 10^9 + 7  medium dynamic programming 
[java] top down memo dp o(n) knight dialer chess knight move indicated chess diagram below:   time  place chess knight numbered key phone pad (indicated above)  knight makes n-1 hops  hop must one key another numbered key  time lands key (including initial placement knight)  presses number key  pressing n digits total  many distinct numbers dial manner? since answer may large  output answer modulo 10^9 + 7  medium dynamic programming 
o(n) time o(1) space dp solution + google interview question writeup knight dialer chess knight move indicated chess diagram below:   time  place chess knight numbered key phone pad (indicated above)  knight makes n-1 hops  hop must one key another numbered key  time lands key (including initial placement knight)  presses number key  pressing n digits total  many distinct numbers dial manner? since answer may large  output answer modulo 10^9 + 7  medium dynamic programming 
how to solve this problem explained for noobs!!! knight dialer chess knight move indicated chess diagram below:   time  place chess knight numbered key phone pad (indicated above)  knight makes n-1 hops  hop must one key another numbered key  time lands key (including initial placement knight)  presses number key  pressing n digits total  many distinct numbers dial manner? since answer may large  output answer modulo 10^9 + 7  medium dynamic programming 
c++ 5 lines dp knight dialer chess knight move indicated chess diagram below:   time  place chess knight numbered key phone pad (indicated above)  knight makes n-1 hops  hop must one key another numbered key  time lands key (including initial placement knight)  presses number key  pressing n digits total  many distinct numbers dial manner? since answer may large  output answer modulo 10^9 + 7  medium dynamic programming 
[c++] reverse operation  30 ms  better than dfs stamping the sequence want form target string lowercase letters  beginning  sequence target length '?' marks  also stamp lowercase letters  turn  may place stamp sequence  replace every letter sequence corresponding letter stamp  make 10   target length turns  hard string greedy 
c++ simple greedy stamping the sequence want form target string lowercase letters  beginning  sequence target length '?' marks  also stamp lowercase letters  turn  may place stamp sequence  replace every letter sequence corresponding letter stamp  make 10   target length turns  hard string greedy 
python ac greedy simple solution for everyone ~200 ms stamping the sequence want form target string lowercase letters  beginning  sequence target length '?' marks  also stamp lowercase letters  turn  may place stamp sequence  replace every letter sequence corresponding letter stamp  make 10   target length turns  hard string greedy 
useless screencast (only 1 min  for promoting my youtube channel) stamping the sequence want form target string lowercase letters  beginning  sequence target length '?' marks  also stamp lowercase letters  turn  may place stamp sequence  replace every letter sequence corresponding letter stamp  make 10   target length turns  hard string greedy 
python solutions stamping the sequence want form target string lowercase letters  beginning  sequence target length '?' marks  also stamp lowercase letters  turn  may place stamp sequence  replace every letter sequence corresponding letter stamp  make 10   target length turns  hard string greedy 
python 1-liner reorder log files array logs  log space delimited string words  log  first word log alphanumeric identifier  then  either: word identifier consist lowercase letters  or; word identifier consist digits  call two varieties logs letter-logs digit-logs  guaranteed log least one word identifier  reorder logs letter-logs come digit-log  letter-logs ordered lexicographically ignoring identifier  identifier used case ties  digit-logs put original order  return final order logs  easy string 
c++ stable_sort easy to understand reorder log files array logs  log space delimited string words  log  first word log alphanumeric identifier  then  either: word identifier consist lowercase letters  or; word identifier consist digits  call two varieties logs letter-logs digit-logs  guaranteed log least one word identifier  reorder logs letter-logs come digit-log  letter-logs ordered lexicographically ignoring identifier  identifier used case ties  digit-logs put original order  return final order logs  easy string 
java - nothing fancy  15 lines  5ms  all clear  reorder log files array logs  log space delimited string words  log  first word log alphanumeric identifier  then  either: word identifier consist lowercase letters  or; word identifier consist digits  call two varieties logs letter-logs digit-logs  guaranteed log least one word identifier  reorder logs letter-logs come digit-log  letter-logs ordered lexicographically ignoring identifier  identifier used case ties  digit-logs put original order  return final order logs  easy string 
few lines c++ version  8ms reorder log files array logs  log space delimited string words  log  first word log alphanumeric identifier  then  either: word identifier consist lowercase letters  or; word identifier consist digits  call two varieties logs letter-logs digit-logs  guaranteed log least one word identifier  reorder logs letter-logs come digit-log  letter-logs ordered lexicographically ignoring identifier  identifier used case ties  digit-logs put original order  return final order logs  easy string 
c++ stable_sort and lambdas reorder log files array logs  log space delimited string words  log  first word log alphanumeric identifier  then  either: word identifier consist lowercase letters  or; word identifier consist digits  call two varieties logs letter-logs digit-logs  guaranteed log least one word identifier  reorder logs letter-logs come digit-log  letter-logs ordered lexicographically ignoring identifier  identifier used case ties  digit-logs put original order  return final order logs  easy string 
[java] 3 recursive methods with comment  range sum of bst given root node binary search tree  return sum values nodes value l r (inclusive)  binary search tree guaranteed unique values  medium binary search tree 
python 1-liner range sum of bst given root node binary search tree  return sum values nodes value l r (inclusive)  binary search tree guaranteed unique values  medium binary search tree 
jave easy to understand 2ms solution (tree pruning) range sum of bst given root node binary search tree  return sum values nodes value l r (inclusive)  binary search tree guaranteed unique values  medium binary search tree 
medium??? i don't think so range sum of bst given root node binary search tree  return sum values nodes value l r (inclusive)  binary search tree guaranteed unique values  medium binary search tree 
python3 | easy to understand | inorder traversal range sum of bst given root node binary search tree  return sum values nodes value l r (inclusive)  binary search tree guaranteed unique values  medium binary search tree 
java n^2 hashmap minimum area rectangle given set points xy-plane  determine minimum area rectangle formed points  sides parallel x axes  rectangle  return 0  medium hash table 
python o(n^1 5)  80ms minimum area rectangle given set points xy-plane  determine minimum area rectangle formed points  sides parallel x axes  rectangle  return 0  medium hash table 
c++ hash-map + set intersection 56 ms minimum area rectangle given set points xy-plane  determine minimum area rectangle formed points  sides parallel x axes  rectangle  return 0  medium hash table 
simple af java solution  with explanation o(n2) minimum area rectangle given set points xy-plane  determine minimum area rectangle formed points  sides parallel x axes  rectangle  return 0  medium hash table 
python straightforward & concise minimum area rectangle given set points xy-plane  determine minimum area rectangle formed points  sides parallel x axes  rectangle  return 0  medium hash table 
[c++ java python] 4 lines o(n) time  o(1) space distinct subsequences ii given string s  count number distinct  non-empty subsequences   since result may large  return answer modulo 10^9 + 7  hard dynamic programming 
java dp o(n^2) time -> o(n) time -> o(1) space distinct subsequences ii given string s  count number distinct  non-empty subsequences   since result may large  return answer modulo 10^9 + 7  hard dynamic programming 
c++ o(n) | o (n) geeks4geeks improved to o(n) | o(1) distinct subsequences ii given string s  count number distinct  non-empty subsequences   since result may large  return answer modulo 10^9 + 7  hard dynamic programming 
leetcode weekly contest 110 screencast (rank 26) distinct subsequences ii given string s  count number distinct  non-empty subsequences   since result may large  return answer modulo 10^9 + 7  hard dynamic programming 
python solution with chinese explanation showing my thinking process distinct subsequences ii given string s  count number distinct  non-empty subsequences   since result may large  return answer modulo 10^9 + 7  hard dynamic programming 
[c++ java python] climb mountain valid mountain array given array integers  return true valid mountain array  recall mountain array if: a length >= 3 exists 0 < < a length - 1 that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
c++ track peak valid mountain array given array integers  return true valid mountain array  recall mountain array if: a length >= 3 exists 0 < < a length - 1 that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
python 2-liner valid mountain array given array integers  return true valid mountain array  recall mountain array if: a length >= 3 exists 0 < < a length - 1 that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
concise c++ valid mountain array given array integers  return true valid mountain array  recall mountain array if: a length >= 3 exists 0 < < a length - 1 that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
the 'stupid' but fast(3ms) method :) valid mountain array given array integers  return true valid mountain array  recall mountain array if: a length >= 3 exists 0 < < a length - 1 that: a[0] < a[1] <     a[i-1] < a[i] a[i] > a[i+1] >     > a[b length - 1] easy array 
[c++ java python] straight forward di string match given string contains "i" (increase) "d" (decrease)  let n = s length  return permutation [0  1       n] = 0       n-1: s[i] == "i"  a[i] < a[i+1] s[i] == "d"  a[i] > a[i+1] easy math 
c++ 5 lines high-low pointers di string match given string contains "i" (increase) "d" (decrease)  let n = s length  return permutation [0  1       n] = 0       n-1: s[i] == "i"  a[i] < a[i+1] s[i] == "d"  a[i] > a[i+1] easy math 
python 5-liner easy to understand di string match given string contains "i" (increase) "d" (decrease)  let n = s length  return permutation [0  1       n] = 0       n-1: s[i] == "i"  a[i] < a[i+1] s[i] == "d"  a[i] > a[i+1] easy math 
probably the easiest java solution di string match given string contains "i" (increase) "d" (decrease)  let n = s length  return permutation [0  1       n] = 0       n-1: s[i] == "i"  a[i] < a[i+1] s[i] == "d"  a[i] > a[i+1] easy math 
c++ implement  simple and straightforward  beats 99% di string match given string contains "i" (increase) "d" (decrease)  let n = s length  return permutation [0  1       n] = 0       n-1: s[i] == "i"  a[i] < a[i+1] s[i] == "d"  a[i] > a[i+1] easy math 
travelling salesman problem find the shortest superstring given array strings  find smallest string contains string substring  may assume string substring another string a  hard dynamic programming 
leetcode weekly contest 111 screencast (rank 12) find the shortest superstring given array strings  find smallest string contains string substring  may assume string substring another string a  hard dynamic programming 
greedy solution is wrong  if your greedy solution gets ac it only means you are lucky enough  find the shortest superstring given array strings  find smallest string contains string substring  may assume string substring another string a  hard dynamic programming 
is this an interview level problem or not? find the shortest superstring given array strings  find smallest string contains string substring  may assume string substring another string a  hard dynamic programming 
python ac concise solution ~132 ms find the shortest superstring given array strings  find smallest string contains string substring  may assume string substring another string a  hard dynamic programming 
really bad example in the description delete columns to make sorted given array n lowercase letter strings  length  now  may choose set deletion indices  string  delete characters indices  remaining rows strings form columns read north south  easy greedy 
why this problem is medium? delete columns to make sorted given array n lowercase letter strings  length  now  may choose set deletion indices  string  delete characters indices  remaining rows strings form columns read north south  easy greedy 
c++ brute force o(n   m) delete columns to make sorted given array n lowercase letter strings  length  now  may choose set deletion indices  string  delete characters indices  remaining rows strings form columns read north south  easy greedy 
python  count unsorted columns delete columns to make sorted given array n lowercase letter strings  length  now  may choose set deletion indices  string  delete characters indices  remaining rows strings form columns read north south  easy greedy 
python easy 1-liner o(n   m) delete columns to make sorted given array n lowercase letter strings  length  now  may choose set deletion indices  string  delete characters indices  remaining rows strings form columns read north south  easy greedy 
